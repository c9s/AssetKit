#!/usr/bin/env php
<?php
Phar::mapPhar('assetkit.phar');
require 'phar://assetkit.phar/ClassLoader.php';
require 'phar://assetkit.phar/Psr0ClassLoader.php';
require 'phar://assetkit.phar/Psr4ClassLoader.php';
require 'phar://assetkit.phar/MapClassLoader.php';
use Universal\ClassLoader\Psr0ClassLoader;
use Universal\ClassLoader\Psr4ClassLoader;
use Universal\ClassLoader\MapClassLoader;
require 'phar://assetkit.phar/vendor/corneltek/fileutil/src/FileUtil.php';
require 'phar://assetkit.phar/vendor/symfony/polyfill-apcu/bootstrap.php';
$map = new MapClassLoader(array (
  'aCssToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssRulesetStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssRulesetEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssFormatter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssDeclarationToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssAtBlockStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'aCssAtBlockEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssWhitesmithsFormatter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssVariablesMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssVariablesMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssUrlParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssStringParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssSortRulesetPropertiesMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssRulesetStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssRulesetParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssRulesetEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssRulesetDeclarationToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssRemoveLastDelarationSemiColonMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssRemoveEmptyRulesetsMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssRemoveEmptyAtBlocksMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssRemoveCommentsMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssParser' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssOtbsFormatter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssNullToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssMinifier' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssMin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssImportImportsMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssExpressionParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssError' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssConvertRgbColorsMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssConvertNamedColorsMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssConvertLevel3PropertiesMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssConvertLevel3AtKeyframesMinifierFilter' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssConvertHslColorsMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssConvertFontWeightMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssCompressUnitValuesMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssCompressExpressionValuesMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssCompressColorValuesMinifierPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssCommentToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssCommentParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtVariablesStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtVariablesParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtVariablesEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtVariablesDeclarationToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtPageStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtPageParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtPageEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtPageDeclarationToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtMediaStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtMediaParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtMediaEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtKeyframesStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtKeyframesRulesetStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtKeyframesRulesetEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtKeyframesRulesetDeclarationToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtKeyframesParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtKeyframesEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtImportToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtImportParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtFontFaceStartToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtFontFaceParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtFontFaceEndToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtFontFaceDeclarationToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtCharsetToken' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
  'CssAtCharsetParserPlugin' => 'phar://assetkit.phar/vendor/natxet/cssmin/src/CssMin.php',
));
$map->register(false);
$psr4 = new Psr4ClassLoader(array (
  0 => 
  array (
    0 => 'GetOptionKit\\',
    1 => 'phar://assetkit.phar/vendor/corneltek/getoptionkit/src/GetOptionKit/',
  ),
  1 => 
  array (
    0 => 'CodeGen\\',
    1 => 'phar://assetkit.phar/vendor/corneltek/codegen/src/CodeGen/',
  ),
  2 => 
  array (
    0 => 'ClassTemplate\\',
    1 => 'phar://assetkit.phar/vendor/corneltek/class-template/src/ClassTemplate/',
  ),
  3 => 
  array (
    0 => 'Universal\\',
    1 => 'phar://assetkit.phar/vendor/corneltek/universal/src/Universal/',
  ),
  4 => 
  array (
    0 => 'Symfony\\Component\\Finder\\',
    1 => 'phar://assetkit.phar/vendor/symfony/finder/',
  ),
  5 => 
  array (
    0 => 'Symfony\\Component\\ClassLoader\\',
    1 => 'phar://assetkit.phar/vendor/symfony/class-loader/',
  ),
  6 => 
  array (
    0 => 'CLIFramework\\',
    1 => 'phar://assetkit.phar/vendor/corneltek/cliframework/src/',
  ),
  7 => 
  array (
    0 => 'Symfony\\Component\\Yaml\\',
    1 => 'phar://assetkit.phar/vendor/symfony/yaml/',
  ),
  8 => 
  array (
    0 => 'ConfigKit\\',
    1 => 'phar://assetkit.phar/vendor/corneltek/configkit/src/ConfigKit/',
  ),
  9 => 
  array (
    0 => 'Symfony\\Component\\Process\\',
    1 => 'phar://assetkit.phar/vendor/symfony/process/',
  ),
  10 => 
  array (
    0 => 'AssetKit\\',
    1 => 'phar://assetkit.phar/src/AssetKit/',
  ),
));
$psr4->register(false);
$psr0 = new Psr0ClassLoader(array (
  'Twig_' => 
  array (
    0 => 'phar://assetkit.phar/vendor/twig/twig/lib/',
  ),
  'UniversalCache' => 
  array (
    0 => 'phar://assetkit.phar/vendor/corneltek/universal-cache/src',
  ),
  'Doctrine\\Common\\Inflector\\' => 
  array (
    0 => 'phar://assetkit.phar/vendor/doctrine/inflector/lib/',
  ),
  'Pimple' => 
  array (
    0 => 'phar://assetkit.phar/vendor/pimple/pimple/src/',
  ),
));
$psr0->register(false);

$app = new AssetKit\Console();
$app->run($argv);
__HALT_COMPILER(); ?>
<µ  B         assetkit.phar       ClassLoader.phpÕ  AèVÕ  Wéüô¶         Psr0ClassLoader.phps  AèVs  éÅ¶         Psr4ClassLoader.php¬  AèV¬  :L2/¶         MapClassLoader.phpÀ  AèVÀ  ğrH½¶      (   vendor/twig/twig/lib/Twig/Autoloader.phpÕ  AèVÕ  9³y¥¶      -   vendor/twig/twig/lib/Twig/BaseNodeVisitor.php  AèV  £?ºZ¶      .   vendor/twig/twig/lib/Twig/Cache/Filesystem.phpª	  AèVª	  ÂLø¶      (   vendor/twig/twig/lib/Twig/Cache/Null.phpö  AèVö  ÉDø©¶      ,   vendor/twig/twig/lib/Twig/CacheInterface.phpo  AèVo  ÛQÇƒ¶      &   vendor/twig/twig/lib/Twig/Compiler.php  AèV  ßÄÑ¶      /   vendor/twig/twig/lib/Twig/CompilerInterface.php  AèV  p§¶      )   vendor/twig/twig/lib/Twig/Environment.php^­  AèV^­  àØÚ„¶      *   vendor/twig/twig/lib/Twig/Error/Loader.php²  AèV²  H¶@$¶      +   vendor/twig/twig/lib/Twig/Error/Runtime.php‹  AèV‹  }ØÜ¶      *   vendor/twig/twig/lib/Twig/Error/Syntax.phpŠ  AèVŠ  ?½yÿ¶      #   vendor/twig/twig/lib/Twig/Error.php?  AèV?  GR-¶      3   vendor/twig/twig/lib/Twig/ExistsLoaderInterface.php´  AèV´  U‚V¶      .   vendor/twig/twig/lib/Twig/ExpressionParser.phpŒe  AèVŒe  cî|å¶      ,   vendor/twig/twig/lib/Twig/Extension/Core.phpéÏ  AèVéÏ  ´šü¶      -   vendor/twig/twig/lib/Twig/Extension/Debug.phpß  AèVß  Î<)b¶      /   vendor/twig/twig/lib/Twig/Extension/Escaper.php_
  AèV_
  —/§²¶      8   vendor/twig/twig/lib/Twig/Extension/GlobalsInterface.php   AèV   Ê
%]¶      <   vendor/twig/twig/lib/Twig/Extension/InitRuntimeInterface.php  AèV  õ @¶      1   vendor/twig/twig/lib/Twig/Extension/Optimizer.phpN  AèVN  üuí‡¶      0   vendor/twig/twig/lib/Twig/Extension/Profiler.phpñ  AèVñ  ş¨}€¶      /   vendor/twig/twig/lib/Twig/Extension/Sandbox.phpp  AèVp  zß”¶      /   vendor/twig/twig/lib/Twig/Extension/Staging.php=  AèV=  Mˆ¨Ñ¶      4   vendor/twig/twig/lib/Twig/Extension/StringLoader.phpø  AèVø  ^yˆÇ¶      '   vendor/twig/twig/lib/Twig/Extension.php^  AèV^  ZiŠ¶      0   vendor/twig/twig/lib/Twig/ExtensionInterface.php¾  AèV¾  W·d¶      ;   vendor/twig/twig/lib/Twig/FileExtensionEscapingStrategy.php°  AèV°  Ö$+á¶      -   vendor/twig/twig/lib/Twig/Filter/Function.php‘  AèV‘  #£5[¶      +   vendor/twig/twig/lib/Twig/Filter/Method.phpE  AèVE  Äš¶      )   vendor/twig/twig/lib/Twig/Filter/Node.php|  AèV|  ¸•
"¶      $   vendor/twig/twig/lib/Twig/Filter.phpÔ  AèVÔ  ¾éN¶      5   vendor/twig/twig/lib/Twig/FilterCallableInterface.phpÜ  AèVÜ  Xä·Ï¶      -   vendor/twig/twig/lib/Twig/FilterInterface.phpQ  AèVQ  ew-l¶      /   vendor/twig/twig/lib/Twig/Function/Function.php¹  AèV¹  £Äò'¶      -   vendor/twig/twig/lib/Twig/Function/Method.phpm  AèVm  Â²ú[¶      +   vendor/twig/twig/lib/Twig/Function/Node.phpˆ  AèVˆ  …¶      &   vendor/twig/twig/lib/Twig/Function.phpï  AèVï  f“¶      7   vendor/twig/twig/lib/Twig/FunctionCallableInterface.phpâ  AèVâ  œŞ¶      /   vendor/twig/twig/lib/Twig/FunctionInterface.php'  AèV'  ¿R—p¶      #   vendor/twig/twig/lib/Twig/Lexer.php–?  AèV–?  Ë‡†!¶      ,   vendor/twig/twig/lib/Twig/LexerInterface.phpü  AèVü  í0WÏ¶      *   vendor/twig/twig/lib/Twig/Loader/Array.phpU	  AèVU	  ÇtH‰¶      *   vendor/twig/twig/lib/Twig/Loader/Chain.php  AèV  ä¹Á†¶      /   vendor/twig/twig/lib/Twig/Loader/Filesystem.php6  AèV6  ~$È¾¶      +   vendor/twig/twig/lib/Twig/Loader/String.phpç  AèVç  î2ä¶      -   vendor/twig/twig/lib/Twig/LoaderInterface.phpU  AèVU  d¬¶      $   vendor/twig/twig/lib/Twig/Markup.phpü  AèVü  E	ğğ¶      -   vendor/twig/twig/lib/Twig/Node/AutoEscape.phpI  AèVI  Ì¸ûô¶      (   vendor/twig/twig/lib/Twig/Node/Block.phpË  AèVË  é¯Êˆ¶      1   vendor/twig/twig/lib/Twig/Node/BlockReference.php&  AèV&  A#¢¶      '   vendor/twig/twig/lib/Twig/Node/Body.phpQ  AèVQ  µ»¨3¶      0   vendor/twig/twig/lib/Twig/Node/CheckSecurity.phpº  AèVº  áqõ-¶      %   vendor/twig/twig/lib/Twig/Node/Do.phpÚ  AèVÚ  ÄüV´¶      (   vendor/twig/twig/lib/Twig/Node/Embed.php  AèV  Ö¨çÍ¶      3   vendor/twig/twig/lib/Twig/Node/Expression/Array.phpÁ  AèVÁ  œÎÔÏ¶      8   vendor/twig/twig/lib/Twig/Node/Expression/AssignName.phpû  AèVû  ¤{;M¶      8   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Add.php  AèV  „İ(H¶      8   vendor/twig/twig/lib/Twig/Node/Expression/Binary/And.php  AèV  ëÔgP¶      ?   vendor/twig/twig/lib/Twig/Node/Expression/Binary/BitwiseAnd.php¤  AèV¤  ş)I¶      >   vendor/twig/twig/lib/Twig/Node/Expression/Binary/BitwiseOr.php£  AèV£  V¬T¶      ?   vendor/twig/twig/lib/Twig/Node/Expression/Binary/BitwiseXor.php¤  AèV¤  ¾IÛl¶      ;   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Concat.php   AèV   ÒÆeO¶      8   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Div.php  AèV  “	«»¶      =   vendor/twig/twig/lib/Twig/Node/Expression/Binary/EndsWith.php|  AèV|  éÎÕá¶      :   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Equal.php…  AèV…  ¾-¶      =   vendor/twig/twig/lib/Twig/Node/Expression/Binary/FloorDiv.php4  AèV4  •PnR¶      <   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Greater.php†  AèV†  ŠÄ«Š¶      A   vendor/twig/twig/lib/Twig/Node/Expression/Binary/GreaterEqual.phpŒ  AèVŒ  JfÂ¶      7   vendor/twig/twig/lib/Twig/Node/Expression/Binary/In.php—  AèV—  oÁ»¶      9   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Less.phpƒ  AèVƒ  iØ¶      >   vendor/twig/twig/lib/Twig/Node/Expression/Binary/LessEqual.php‰  AèV‰  $_óŸ¶      <   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Matches.php–  AèV–  ühÆP¶      8   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Mod.php  AèV  cã¶      8   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Mul.php  AèV  ù©›]¶      =   vendor/twig/twig/lib/Twig/Node/Expression/Binary/NotEqual.phpˆ  AèVˆ   ãZ­¶      :   vendor/twig/twig/lib/Twig/Node/Expression/Binary/NotIn.phpŸ  AèVŸ  òN€¶      7   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Or.php  AèV  Q¸¶      :   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Power.php  AèV  tÕ˜Û¶      :   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Range.php‘  AèV‘  eq,z¶      ?   vendor/twig/twig/lib/Twig/Node/Expression/Binary/StartsWith.phpq  AèVq  ŸÏÅ*¶      8   vendor/twig/twig/lib/Twig/Node/Expression/Binary/Sub.php  AèV  ü
b¦¶      4   vendor/twig/twig/lib/Twig/Node/Expression/Binary.php—  AèV—  ùÈÕ¶      <   vendor/twig/twig/lib/Twig/Node/Expression/BlockReference.phpı  AèVı  –L¶      2   vendor/twig/twig/lib/Twig/Node/Expression/Call.phpn&  AèVn&  Ùàƒ8¶      9   vendor/twig/twig/lib/Twig/Node/Expression/Conditional.php†  AèV†  %Ù ¶      6   vendor/twig/twig/lib/Twig/Node/Expression/Constant.php-  AèV-  D¬È¶      @   vendor/twig/twig/lib/Twig/Node/Expression/ExtensionReference.phpˆ  AèVˆ  hW¶      <   vendor/twig/twig/lib/Twig/Node/Expression/Filter/Default.php/  AèV/  ­°¸"¶      4   vendor/twig/twig/lib/Twig/Node/Expression/Filter.phpç  AèVç  Í
ÒÁ¶      6   vendor/twig/twig/lib/Twig/Node/Expression/Function.phpl  AèVl  ‚†¶      5   vendor/twig/twig/lib/Twig/Node/Expression/GetAttr.php
	  AèV
	  ËM°¶      8   vendor/twig/twig/lib/Twig/Node/Expression/MethodCall.php³  AèV³  &Pÿ¶      2   vendor/twig/twig/lib/Twig/Node/Expression/Name.phpF  AèVF  Öl¦¶      :   vendor/twig/twig/lib/Twig/Node/Expression/NullCoalesce.php(  AèV(  c†ÏA¶      4   vendor/twig/twig/lib/Twig/Node/Expression/Parent.php]  AèV]  S<J2¶      6   vendor/twig/twig/lib/Twig/Node/Expression/TempName.phpR  AèVR  ­–œ¶      ;   vendor/twig/twig/lib/Twig/Node/Expression/Test/Constant.phpj  AèVj  ­PşÏ¶      :   vendor/twig/twig/lib/Twig/Node/Expression/Test/Defined.php
  AèV
  @5’‘¶      >   vendor/twig/twig/lib/Twig/Node/Expression/Test/Divisibleby.phpì  AèVì  <’¶      7   vendor/twig/twig/lib/Twig/Node/Expression/Test/Even.php|  AèV|  µ^u¶      7   vendor/twig/twig/lib/Twig/Node/Expression/Test/Null.phpj  AèVj  ª†©¶      6   vendor/twig/twig/lib/Twig/Node/Expression/Test/Odd.phpy  AèVy  âæú|¶      9   vendor/twig/twig/lib/Twig/Node/Expression/Test/Sameas.php²  AèV²  ›(“I¶      7   vendor/twig/twig/lib/Twig/Node/Expression/Unary/Neg.php”  AèV”   dà ¶      7   vendor/twig/twig/lib/Twig/Node/Expression/Unary/Not.php”  AèV”  5Aî„¶      7   vendor/twig/twig/lib/Twig/Node/Expression/Unary/Pos.php”  AèV”  `“¶      3   vendor/twig/twig/lib/Twig/Node/Expression/Unary.phpÅ  AèVÅ  Âò~P¶      -   vendor/twig/twig/lib/Twig/Node/Expression.phpŸ  AèVŸ  £ëAW¶      (   vendor/twig/twig/lib/Twig/Node/Flush.phpn  AèVn  Â· ¶      &   vendor/twig/twig/lib/Twig/Node/For.phpa  AèVa  Ì±¶      *   vendor/twig/twig/lib/Twig/Node/ForLoop.phpê  AèVê  Ev…¶      %   vendor/twig/twig/lib/Twig/Node/If.phpN  AèVN  Ñø"å¶      )   vendor/twig/twig/lib/Twig/Node/Import.php(  AèV(  ÀnK\¶      *   vendor/twig/twig/lib/Twig/Node/Include.phps	  AèVs	  ê]Èä¶      (   vendor/twig/twig/lib/Twig/Node/Macro.php?  AèV?  ÊB5’¶      )   vendor/twig/twig/lib/Twig/Node/Module.phpË2  AèVË2  O}@&¶      (   vendor/twig/twig/lib/Twig/Node/Print.php9  AèV9  b»O¶      *   vendor/twig/twig/lib/Twig/Node/Sandbox.php~  AèV~  Ø”¶      1   vendor/twig/twig/lib/Twig/Node/SandboxedPrint.php^  AèV^  âÙv:¶      &   vendor/twig/twig/lib/Twig/Node/Set.php+  AèV+  ¹iÕ"¶      *   vendor/twig/twig/lib/Twig/Node/SetTemp.phpH  AèVH  !­¶İ¶      ,   vendor/twig/twig/lib/Twig/Node/Spaceless.php_  AèV_  64|T¶      '   vendor/twig/twig/lib/Twig/Node/Text.phpû  AèVû  /u~j¶      "   vendor/twig/twig/lib/Twig/Node.phpÆ  AèVÆ  %3ù¶      +   vendor/twig/twig/lib/Twig/NodeInterface.php–  AèV–  KÍâh¶      1   vendor/twig/twig/lib/Twig/NodeOutputInterface.php_  AèV_  İä'¶      +   vendor/twig/twig/lib/Twig/NodeTraverser.php=	  AèV=	  [Aİç¶      1   vendor/twig/twig/lib/Twig/NodeVisitor/Escaper.php5  AèV5   Vg‡¶      3   vendor/twig/twig/lib/Twig/NodeVisitor/Optimizer.phpb#  AèVb#  ®ˆ–“¶      6   vendor/twig/twig/lib/Twig/NodeVisitor/SafeAnalysis.phpï  AèVï  ºy+¶      1   vendor/twig/twig/lib/Twig/NodeVisitor/Sandbox.phpD	  AèVD	  >Âbå¶      2   vendor/twig/twig/lib/Twig/NodeVisitorInterface.php,  AèV,  ÚY¶      $   vendor/twig/twig/lib/Twig/Parser.phpë.  AèVë.  ¦œÂm¶      -   vendor/twig/twig/lib/Twig/ParserInterface.phpà  AèVà  Q	}¶      7   vendor/twig/twig/lib/Twig/Profiler/Dumper/Blackfire.php¨  AèV¨  ÿÒ/d¶      2   vendor/twig/twig/lib/Twig/Profiler/Dumper/Html.phpŸ  AèVŸ  ‡ï¶      2   vendor/twig/twig/lib/Twig/Profiler/Dumper/Text.phpÂ  AèVÂ  b¥£À¶      8   vendor/twig/twig/lib/Twig/Profiler/Node/EnterProfile.phpÇ  AèVÇ  .Ë¶      8   vendor/twig/twig/lib/Twig/Profiler/Node/LeaveProfile.php  AèV  O‡]Z¶      ;   vendor/twig/twig/lib/Twig/Profiler/NodeVisitor/Profiler.php	  AèV	  ñçJ¶      .   vendor/twig/twig/lib/Twig/Profiler/Profile.php\  AèV\  C<É¶      3   vendor/twig/twig/lib/Twig/Sandbox/SecurityError.php€  AèV€  Ô=»ò¶      C   vendor/twig/twig/lib/Twig/Sandbox/SecurityNotAllowedFilterError.php  AèV  š	‹¸¶      E   vendor/twig/twig/lib/Twig/Sandbox/SecurityNotAllowedFunctionError.php  AèV  3ËË¶      @   vendor/twig/twig/lib/Twig/Sandbox/SecurityNotAllowedTagError.phpì  AèVì  ›Ô}¶      4   vendor/twig/twig/lib/Twig/Sandbox/SecurityPolicy.phpÅ  AèVÅ  š›µ¶      =   vendor/twig/twig/lib/Twig/Sandbox/SecurityPolicyInterface.php0  AèV0  {˜×/¶      *   vendor/twig/twig/lib/Twig/SimpleFilter.php
  AèV
  h^µã¶      ,   vendor/twig/twig/lib/Twig/SimpleFunction.php)	  AèV)	   ÿcÿ¶      &   vendor/twig/twig/lib/Twig/Template.php‹O  AèV‹O  ÷»è¶      /   vendor/twig/twig/lib/Twig/TemplateInterface.phpÛ  AèVÛ  òTè‘¶      +   vendor/twig/twig/lib/Twig/Test/Function.phpb  AèVb  Èñ/¶      6   vendor/twig/twig/lib/Twig/Test/IntegrationTestCase.php†  AèV†  ¤ÆÕ¶      )   vendor/twig/twig/lib/Twig/Test/Method.php  AèV  ê¶      '   vendor/twig/twig/lib/Twig/Test/Node.php0  AèV0  $I‹¶      /   vendor/twig/twig/lib/Twig/Test/NodeTestCase.phpY  AèVY  +?:.¶      3   vendor/twig/twig/lib/Twig/TestCallableInterface.php³  AèV³  òÓäÚ¶      +   vendor/twig/twig/lib/Twig/TestInterface.phpı  AèVı  	7äˆ¶      #   vendor/twig/twig/lib/Twig/Token.php–  AèV–  –h×¶      4   vendor/twig/twig/lib/Twig/TokenParser/AutoEscape.php	  AèV	  å4;¶      /   vendor/twig/twig/lib/Twig/TokenParser/Block.php	  AèV	  Õ5Q¶      ,   vendor/twig/twig/lib/Twig/TokenParser/Do.php   AèV   ;¯æ‹¶      /   vendor/twig/twig/lib/Twig/TokenParser/Embed.phpg  AèVg  "á[±¶      1   vendor/twig/twig/lib/Twig/TokenParser/Extends.php  AèV  ÀÔ›¶      0   vendor/twig/twig/lib/Twig/TokenParser/Filter.phpr  AèVr  1ïFÎ¶      /   vendor/twig/twig/lib/Twig/TokenParser/Flush.phpU  AèVU  Ø]‘¶      -   vendor/twig/twig/lib/Twig/TokenParser/For.php  AèV  ¶ĞÁH¶      .   vendor/twig/twig/lib/Twig/TokenParser/From.phpÂ  AèVÂ  U¬R‹¶      ,   vendor/twig/twig/lib/Twig/TokenParser/If.phpb	  AèVb	  vSPy¶      0   vendor/twig/twig/lib/Twig/TokenParser/Import.phpÜ  AèVÜ  òb=Ã¶      1   vendor/twig/twig/lib/Twig/TokenParser/Include.php  AèV  $å€E¶      /   vendor/twig/twig/lib/Twig/TokenParser/Macro.phpº  AèVº  °‚S¶      1   vendor/twig/twig/lib/Twig/TokenParser/Sandbox.phpk  AèVk  ÚS|¶      -   vendor/twig/twig/lib/Twig/TokenParser/Set.phpº  AèVº  yV°¶      3   vendor/twig/twig/lib/Twig/TokenParser/Spaceless.php<  AèV<   ×œ~¶      -   vendor/twig/twig/lib/Twig/TokenParser/Use.php#  AèV#  /9à”¶      )   vendor/twig/twig/lib/Twig/TokenParser.php£  AèV£  LmË´¶      /   vendor/twig/twig/lib/Twig/TokenParserBroker.php`  AèV`  °VÛ¶      8   vendor/twig/twig/lib/Twig/TokenParserBrokerInterface.phpù  AèVù  §kÇ¶      2   vendor/twig/twig/lib/Twig/TokenParserInterface.phpÆ  AèVÆ  Fw	÷¶      )   vendor/twig/twig/lib/Twig/TokenStream.phpq  AèVq  qÃÑÈ¶      7   vendor/twig/twig/lib/Twig/Util/DeprecationCollector.phpK  AèVK  ½ûëe¶      6   vendor/twig/twig/lib/Twig/Util/TemplateDirIterator.phpñ  AèVñ  áo4}¶      *   vendor/corneltek/fileutil/src/FileUtil.phpÖ  AèVÖ  óI¡¶      @   vendor/corneltek/universal-cache/src/UniversalCache/ApcCache.php«  AèV«  ?i*¶      F   vendor/corneltek/universal-cache/src/UniversalCache/CacheInterface.php»  AèV»  &0ÿí¶      G   vendor/corneltek/universal-cache/src/UniversalCache/FileSystemCache.phpâ  AèVâ  ˆRë:¶      E   vendor/corneltek/universal-cache/src/UniversalCache/MemcacheCache.php  AèV  €âG¶      C   vendor/corneltek/universal-cache/src/UniversalCache/MemoryCache.php  AèV  Tç¶      F   vendor/corneltek/universal-cache/src/UniversalCache/UniversalCache.phpt  AèVt  énö¶      ;   vendor/corneltek/getoptionkit/src/GetOptionKit/Argument.php‘
  AèV‘
  š¡¶      F   vendor/corneltek/getoptionkit/src/GetOptionKit/ContinuousOptionKit.phpØ  AèVØ  ÄÅµç¶      I   vendor/corneltek/getoptionkit/src/GetOptionKit/ContinuousOptionParser.phpš  AèVš  vN€¶      S   vendor/corneltek/getoptionkit/src/GetOptionKit/Exception/InvalidOptionException.phpn   AèVn   ı¡K¶      P   vendor/corneltek/getoptionkit/src/GetOptionKit/Exception/NonNumericException.phpW  AèVW  İÂ§î¶      R   vendor/corneltek/getoptionkit/src/GetOptionKit/Exception/RequireValueException.phpl   AèVl   Ø›ç]¶      ?   vendor/corneltek/getoptionkit/src/GetOptionKit/GetOptionKit.php.  AèV.  0„X¶      7   vendor/corneltek/getoptionkit/src/GetOptionKit/Init.phpÀ  AèVÀ  ¼±¯¶      9   vendor/corneltek/getoptionkit/src/GetOptionKit/Option.php\/  AèV\/  Ãş|ß¶      C   vendor/corneltek/getoptionkit/src/GetOptionKit/OptionCollection.phpM  AèVM  ıÂT¸¶      ?   vendor/corneltek/getoptionkit/src/GetOptionKit/OptionParser.php  AèV  1©õ¶      U   vendor/corneltek/getoptionkit/src/GetOptionKit/OptionPrinter/ConsoleOptionPrinter.php¾  AèV¾  °Î”¶      W   vendor/corneltek/getoptionkit/src/GetOptionKit/OptionPrinter/OptionPrinterInterface.phpù   AèVù   ìƒt¶      ?   vendor/corneltek/getoptionkit/src/GetOptionKit/OptionResult.php¦  AèV¦  ş,5¶      A   vendor/corneltek/getoptionkit/src/GetOptionKit/SplClassLoader.phpB  AèVB  üşä;¶      E   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/BaseType.php  AèV  ím À¶      H   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/BooleanType.phpI  AèVI  Û»ß¶      E   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/BoolType.php~   AèV~   C#X1¶      E   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/DateType.php  AèV  Ë¤—x¶      D   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/DirType.php  AèV  »»º9¶      F   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/EmailType.phpú   AèVú   ´"¶      E   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/FileType.phpü   AèVü   îb±å¶      C   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/IpType.php  AèV  ÁcÊ¶      E   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/Ipv4Type.php	  AèV	  ï—b¶      E   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/Ipv6Type.php	  AèV	  «O$¶      G   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/NumberType.phpé   AèVé   ZÛ¶      E   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/PathType.php  AèV  ½ø§¶      F   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/RegexType.phpv  AèVv  ß#h¶      G   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/StringType.phpç   AèVç   Xª¶      D   vendor/corneltek/getoptionkit/src/GetOptionKit/ValueType/UrlType.phpö   AèVö   ‚êD¶      E   vendor/doctrine/inflector/lib/Doctrine/Common/Inflector/Inflector.phpB  AèVB  F:.å¶      2   vendor/corneltek/codegen/src/CodeGen/Annotator.php>  AèV>  SN¶      1   vendor/corneltek/codegen/src/CodeGen/Argument.php•  AèV•  °Ü•¶      5   vendor/corneltek/codegen/src/CodeGen/ArgumentList.phpV  AèVV  iÉ\«¶      .   vendor/corneltek/codegen/src/CodeGen/Block.phpw  AèVw  l…^¶      7   vendor/corneltek/codegen/src/CodeGen/BracketedBlock.phpó  AèVó  z›á¶      3   vendor/corneltek/codegen/src/CodeGen/ClassConst.phpQ  AèVQ  °!åj¶      4   vendor/corneltek/codegen/src/CodeGen/ClassMethod.php  AèV  „±rî¶      2   vendor/corneltek/codegen/src/CodeGen/ClassName.phpâ  AèVâ  rŸ·¥¶      6   vendor/corneltek/codegen/src/CodeGen/ClassProperty.phpÓ  AèVÓ  H,RÒ¶      <   vendor/corneltek/codegen/src/CodeGen/ClassStaticVariable.phpÀ  AèVÀ  Ÿ5Z¶      3   vendor/corneltek/codegen/src/CodeGen/ClassTrait.php^  AèV^  {“5L¶      0   vendor/corneltek/codegen/src/CodeGen/Comment.phpï  AèVï  !n˜¶      5   vendor/corneltek/codegen/src/CodeGen/CommentBlock.php´  AèV´  ïgÙ¶      1   vendor/corneltek/codegen/src/CodeGen/Constant.phpd  AèVd  wäE¶      O   vendor/corneltek/codegen/src/CodeGen/Exception/InvalidArgumentTypeException.phpB  AèVB  Å¶      3   vendor/corneltek/codegen/src/CodeGen/Exportable.phpZ   AèVZ   %'Ùr¶      8   vendor/corneltek/codegen/src/CodeGen/Expr/AssignExpr.phpÙ  AèVÙ  å»¶      6   vendor/corneltek/codegen/src/CodeGen/Expr/CallExpr.phpK  AèVK  ÇöŠ:¶      :   vendor/corneltek/codegen/src/CodeGen/Expr/FunctionCall.phpÔ  AèVÔ  QÂŸ4¶      8   vendor/corneltek/codegen/src/CodeGen/Expr/MethodCall.php8  AèV8  ^^[¶      <   vendor/corneltek/codegen/src/CodeGen/Expr/MethodCallExpr.phpx   AèVx   ^)±ò¶      7   vendor/corneltek/codegen/src/CodeGen/Expr/NewObject.php$  AèV$  (0çÇ¶      ;   vendor/corneltek/codegen/src/CodeGen/Expr/NewObjectExpr.phpJ   AèVJ    Ï¹³¶      <   vendor/corneltek/codegen/src/CodeGen/Expr/ObjectProperty.php  AèV  ¾8óK¶      <   vendor/corneltek/codegen/src/CodeGen/Expr/SelfMethodCall.php&  AèV&  „†?¶      @   vendor/corneltek/codegen/src/CodeGen/Expr/SelfMethodCallExpr.phpk   AèVk   ¡ØÀ¶      >   vendor/corneltek/codegen/src/CodeGen/Expr/StaticMethodCall.php  AèV  K›N¶      F   vendor/corneltek/codegen/src/CodeGen/Frameworks/PHPUnit/Assertions.php  AèV  ğ¶      T   vendor/corneltek/codegen/src/CodeGen/Frameworks/PHPUnit/PHPUnitFrameworkTestCase.phpÉ  AèVÉ  }ºWŒ¶      D   vendor/corneltek/codegen/src/CodeGen/Generator/AppClassGenerator.php·	  AèV·	  Ï‚¶      G   vendor/corneltek/codegen/src/CodeGen/Generator/ArrayAccessGenerator.php°  AèV°   dƒa¶      1   vendor/corneltek/codegen/src/CodeGen/Indenter.phpÁ  AèVÁ  ‡n÷¶      5   vendor/corneltek/codegen/src/CodeGen/LicenseBlock.php{  AèV{  ÓÁ[Ğ¶      -   vendor/corneltek/codegen/src/CodeGen/Line.phpØ  AèVØ  ÷Ÿï¶      ,   vendor/corneltek/codegen/src/CodeGen/Raw.php  AèV  ø®;n¶      3   vendor/corneltek/codegen/src/CodeGen/Renderable.phph   AèVh   zÓ¶      B   vendor/corneltek/codegen/src/CodeGen/Statement/AssignStatement.php  AèV  ¬/P¶      G   vendor/corneltek/codegen/src/CodeGen/Statement/ConditionalStatement.phpr  AèVr  _Y7¶      B   vendor/corneltek/codegen/src/CodeGen/Statement/DefineStatement.php–  AèV–  V-wB¶      B   vendor/corneltek/codegen/src/CodeGen/Statement/ElseIfStatement.php€  AèV€  SW¤´¶      @   vendor/corneltek/codegen/src/CodeGen/Statement/ElseStatement.php  AèV  Nß¶      C   vendor/corneltek/codegen/src/CodeGen/Statement/ForEachStatement.php   AèV   ¢Øu¶      H   vendor/corneltek/codegen/src/CodeGen/Statement/FunctionCallStatement.php>  AèV>  ²X?õ¶      B   vendor/corneltek/codegen/src/CodeGen/Statement/IfElseStatement.phpÈ  AèVÈ  ğçNÔ¶      C   vendor/corneltek/codegen/src/CodeGen/Statement/IfIssetStatement.php  AèV  Ö\¿¶      >   vendor/corneltek/codegen/src/CodeGen/Statement/IfStatement.php  AèV  ª¶      F   vendor/corneltek/codegen/src/CodeGen/Statement/MethodCallStatement.php[  AèV[  ¢t}†¶      H   vendor/corneltek/codegen/src/CodeGen/Statement/RequireClassStatement.php  AèV  &…lp¶      S   vendor/corneltek/codegen/src/CodeGen/Statement/RequireComposerAutoloadStatement.php*  AèV*  §?¶      G   vendor/corneltek/codegen/src/CodeGen/Statement/RequireOnceStatement.php¢  AèV¢  <Jõf¶      C   vendor/corneltek/codegen/src/CodeGen/Statement/RequireStatement.phpæ  AèVæ  RV:¶      <   vendor/corneltek/codegen/src/CodeGen/Statement/Statement.phpÏ  AèVÏ  ë½¦¶      D   vendor/corneltek/codegen/src/CodeGen/Statement/TryCatchStatement.phpÅ  AèVÅ  °z²¶      ?   vendor/corneltek/codegen/src/CodeGen/Statement/UseStatement.phpn  AèVn  -äVm¶      @   vendor/corneltek/codegen/src/CodeGen/Testing/CodeGenTestCase.php“  AèV“  Èìë]¶      1   vendor/corneltek/codegen/src/CodeGen/UseClass.phpe  AèVe  !63¶      2   vendor/corneltek/codegen/src/CodeGen/UserClass.phpĞ%  AèVĞ%  ]àåÏ¶      5   vendor/corneltek/codegen/src/CodeGen/UserFunction.phpd  AèVd  ":]¶      .   vendor/corneltek/codegen/src/CodeGen/Utils.phpî  AèVî  şû÷Á¶      1   vendor/corneltek/codegen/src/CodeGen/Variable.php4  AèV4  ÓIåÔ¶      9   vendor/corneltek/codegen/src/CodeGen/VariableDeflator.php×  AèV×  ¿8)s¶      ?   vendor/corneltek/class-template/src/ClassTemplate/ClassFile.php—  AèV—  \–“¶      D   vendor/corneltek/class-template/src/ClassTemplate/ClassInjection.php¼  AèV¼  Y4„Ÿ¶      :   vendor/corneltek/class-template/src/ClassTemplate/File.php€  AèV€  ïo-¶      G   vendor/corneltek/class-template/src/ClassTemplate/TemplateClassFile.php  AèV  ”3±s¶      J   vendor/corneltek/class-template/src/ClassTemplate/Templates/Class.php.twigh  AèVh  õW´¶      B   vendor/corneltek/class-template/src/ClassTemplate/TemplateView.phpÃ  AèVÃ  ú=ÀÎ¶      G   vendor/corneltek/universal/src/Universal/ClassLoader/ApcClassLoader.php+  AèV+  ˜0à¶      L   vendor/corneltek/universal/src/Universal/ClassLoader/BasePathClassLoader.php_  AèV_  ”ºİ¶      L   vendor/corneltek/universal/src/Universal/ClassLoader/BytecodeClassLoader.phpo   AèVo   ¿8ğ¶      K   vendor/corneltek/universal/src/Universal/ClassLoader/ChainedClassLoader.phpù  AèVù  ı}&¶      D   vendor/corneltek/universal/src/Universal/ClassLoader/ClassLoader.phpÕ  AèVÕ  Wéüô¶      G   vendor/corneltek/universal/src/Universal/ClassLoader/MapClassLoader.phpÀ  AèVÀ  ğrH½¶      E   vendor/corneltek/universal/src/Universal/ClassLoader/PathIncluder.php“  AèV“  =Rd¶      H   vendor/corneltek/universal/src/Universal/ClassLoader/Psr0ClassLoader.phps  AèVs  éÅ¶      H   vendor/corneltek/universal/src/Universal/ClassLoader/Psr4ClassLoader.php¬  AèV¬  :L2/¶      G   vendor/corneltek/universal/src/Universal/ClassLoader/SplClassLoader.php  AèV  CŸ'¶      F   vendor/corneltek/universal/src/Universal/Container/ObjectContainer.phpÄ  AèVÄ  À(Ç„¶      ;   vendor/corneltek/universal/src/Universal/Event/PhpEvent.php¯  AèV¯  Òã.°¶      Q   vendor/corneltek/universal/src/Universal/Exception/InvalidUploadFileException.php   AèV    tô¶      T   vendor/corneltek/universal/src/Universal/Exception/UploadedFileMoveFailException.php•   AèV•   h‘Ó¶      K   vendor/corneltek/universal/src/Universal/Exception/UploadErrorException.phpŒ   AèVŒ   Û*‰¶      F   vendor/corneltek/universal/src/Universal/Exception/UploadException.phpş  AèVş  B¤9Ó¶      A   vendor/corneltek/universal/src/Universal/FileSystem/PathUtils.php’  AèV’  è¶f¶      8   vendor/corneltek/universal/src/Universal/Http/Cookie.php   AèV   Ùïxº¶      @   vendor/corneltek/universal/src/Universal/Http/FilesParameter.php½  AèV½  s‘OÎ¶      =   vendor/corneltek/universal/src/Universal/Http/HttpRequest.phpS"  AèVS"  Kyâ¶      >   vendor/corneltek/universal/src/Universal/Http/HttpResponse.phpÚ  AèVÚ  ršx¶      ;   vendor/corneltek/universal/src/Universal/Http/Parameter.phpñ  AèVñ  #İ¶      ;   vendor/corneltek/universal/src/Universal/Http/PutHandle.php¶  AèV¶  úà¶      @   vendor/corneltek/universal/src/Universal/Http/StreamResponse.php  AèV  ¦ˆ­¶      >   vendor/corneltek/universal/src/Universal/Http/UploadedFile.phpœ)  AèVœ)  }êJ¶      D   vendor/corneltek/universal/src/Universal/Requirement/Requirement.phpË  AèVË  ßò&8¶      -   vendor/pimple/pimple/src/Pimple/Container.php "  AèV "  b„2<¶      <   vendor/pimple/pimple/src/Pimple/ServiceProviderInterface.phpS  AèVS  †¡Ø¶      1   vendor/symfony/finder/Adapter/AbstractAdapter.phpÂ  AèVÂ  ª¼Ñ¶      5   vendor/symfony/finder/Adapter/AbstractFindAdapter.php*  AèV*  *ä˜+¶      2   vendor/symfony/finder/Adapter/AdapterInterface.phpÓ  AèVÓ  mT§A¶      0   vendor/symfony/finder/Adapter/BsdFindAdapter.phpí  AèVí  OÅàH¶      0   vendor/symfony/finder/Adapter/GnuFindAdapter.phpä  AèVä  šf!ó¶      ,   vendor/symfony/finder/Adapter/PhpAdapter.phpq  AèVq  «×¶      "   vendor/symfony/finder/CHANGELOG.md€  AèV€  ÀÑ†j¶      /   vendor/symfony/finder/Comparator/Comparator.php  AèV  ç¶¶      3   vendor/symfony/finder/Comparator/DateComparator.php¹  AèV¹  ¸'e¶      5   vendor/symfony/finder/Comparator/NumberComparator.php
  AèV
  l¯dJ¶      #   vendor/symfony/finder/composer.jsonó  AèVó  ´‚»¶      9   vendor/symfony/finder/Exception/AccessDeniedException.php«  AèV«  ÊcWŞ¶      ;   vendor/symfony/finder/Exception/AdapterFailureException.phpK  AèVK  |^í¯¶      6   vendor/symfony/finder/Exception/ExceptionInterface.phpï  AèVï  €7¶      A   vendor/symfony/finder/Exception/OperationNotPermitedException.phpr  AèVr  c
¯©¶      @   vendor/symfony/finder/Exception/ShellCommandFailureException.php  AèV  ~Ë¶      /   vendor/symfony/finder/Expression/Expression.php¯
  AèV¯
  Ûp{¶      )   vendor/symfony/finder/Expression/Glob.phpD  AèVD  ^÷b¶      *   vendor/symfony/finder/Expression/Regex.php  AèV  ÜFH¶      3   vendor/symfony/finder/Expression/ValueInterface.phpÚ  AèVÚ  vŒV×¶          vendor/symfony/finder/Finder.phpfc  AèVfc  ”‹T¶         vendor/symfony/finder/Glob.phpÙ  AèVÙ  şRœ`¶      7   vendor/symfony/finder/Iterator/CustomFilterIterator.php  AèV  úg3,¶      :   vendor/symfony/finder/Iterator/DateRangeFilterIterator.phpÅ  AèVÅ  §'ıQ¶      ;   vendor/symfony/finder/Iterator/DepthRangeFilterIterator.phpå  AèVå  -,ì¶      A   vendor/symfony/finder/Iterator/ExcludeDirectoryFilterIterator.php	  AèV	  "Î°¶      <   vendor/symfony/finder/Iterator/FilecontentFilterIterator.php¦  AèV¦  rÜ~¶      9   vendor/symfony/finder/Iterator/FilenameFilterIterator.php•  AèV•  ËpÀ¶      4   vendor/symfony/finder/Iterator/FilePathsIterator.phpP  AèVP  è¹ş¶      9   vendor/symfony/finder/Iterator/FileTypeFilterIterator.phpY  AèVY  ™]°%¶      1   vendor/symfony/finder/Iterator/FilterIterator.php?  AèV?  gª->¶      =   vendor/symfony/finder/Iterator/MultiplePcreFilterIterator.php¸  AèV¸  ïq÷Ğ¶      5   vendor/symfony/finder/Iterator/PathFilterIterator.php«  AèV«  Xãî·¶      =   vendor/symfony/finder/Iterator/RecursiveDirectoryIterator.php,  AèV,  ïõ°¶      :   vendor/symfony/finder/Iterator/SizeRangeFilterIterator.php¢  AèV¢  ¤§°¶      3   vendor/symfony/finder/Iterator/SortableIterator.phpã	  AèVã	  ª¶*¶         vendor/symfony/finder/LICENSE)  AèV)  ¹ô¶      &   vendor/symfony/finder/phpunit.xml.dist  AèV  ÃeŸ¶         vendor/symfony/finder/README.mdq  AèVq  n”È;¶      '   vendor/symfony/finder/Shell/Command.phps  AèVs  
”Q+¶      %   vendor/symfony/finder/Shell/Shell.phpK  AèVK  ¹±÷5¶      %   vendor/symfony/finder/SplFileInfo.phpu  AèVu  "Pêü¶      *   vendor/symfony/polyfill-apcu/bootstrap.php9  AèV9  —ùö:¶      .   vendor/symfony/class-loader/ApcClassLoader.phpp  AèVp  ŞˆWD¶      7   vendor/symfony/class-loader/ApcUniversalClassLoader.php  AèV  2»B¶      (   vendor/symfony/class-loader/CHANGELOG.md¨  AèV¨  ±^„ã¶      5   vendor/symfony/class-loader/ClassCollectionLoader.php0  AèV0  <­ı1¶      +   vendor/symfony/class-loader/ClassLoader.phpO  AèVO  (IÏ\¶      1   vendor/symfony/class-loader/ClassMapGenerator.phpİ  AèVİ  â‹ï¶      )   vendor/symfony/class-loader/composer.jsonx  AèVx  {†}»¶      0   vendor/symfony/class-loader/DebugClassLoader.phpÌ  AèVÌ  Ócö¶      9   vendor/symfony/class-loader/DebugUniversalClassLoader.php•	  AèV•	  ğæ«¶      #   vendor/symfony/class-loader/LICENSE)  AèV)  ¹ô¶      .   vendor/symfony/class-loader/MapClassLoader.phpú  AèVú  í 34¶      ,   vendor/symfony/class-loader/phpunit.xml.dist?  AèV?  Œsœ+¶      /   vendor/symfony/class-loader/Psr4ClassLoader.phpm  AèVm  uŠTÀ¶      %   vendor/symfony/class-loader/README.md=	  AèV=	  jv¥¶      4   vendor/symfony/class-loader/UniversalClassLoader.php#  AèV#  ˜Õs¶      3   vendor/symfony/class-loader/WinCacheClassLoader.phpÍ  AèVÍ  ì¦oe¶      1   vendor/symfony/class-loader/XcacheClassLoader.php  AèV  Ù’®¶      1   vendor/corneltek/cliframework/src/Ansi/Colors.phpğ  AèVğ  ÎPµ³¶      8   vendor/corneltek/cliframework/src/Ansi/CursorControl.php  AèV  l˜+Ü¶      1   vendor/corneltek/cliframework/src/Application.php->  AèV->  0½H¶      -   vendor/corneltek/cliframework/src/ArgInfo.php)  AèV)  Áù	¶      1   vendor/corneltek/cliframework/src/ArgInfoList.php2  AèV2  xÄî¶      C   vendor/corneltek/cliframework/src/ArgumentEditor/ArgumentEditor.php  AèV  U~/x¶      H   vendor/corneltek/cliframework/src/Autoload/ComposerAutoloadGenerator.phpz(  AèVz(  ôys¶      ,   vendor/corneltek/cliframework/src/Buffer.php5  AèV5  RX	¶      4   vendor/corneltek/cliframework/src/ChainedCommand.phpÑ  AèVÑ  y0e¶      -   vendor/corneltek/cliframework/src/Chooser.php  AèV  üˆ½¶      <   vendor/corneltek/cliframework/src/Command/ArchiveCommand.phph*  AèVh*  [E_Ï¶      C   vendor/corneltek/cliframework/src/Command/BashCompletionCommand.php`  AèV`  ¬;²o¶      J   vendor/corneltek/cliframework/src/Command/BuildGitHubWikiTopicsCommand.php  AèV  ²S¸Ü¶      <   vendor/corneltek/cliframework/src/Command/CompileCommand.php9  AèV9  ù;nx¶      9   vendor/corneltek/cliframework/src/Command/HelpCommand.phpİ!  AèVİ!  Vc¶      9   vendor/corneltek/cliframework/src/Command/MetaCommand.phpG'  AèVG'  4A¶      B   vendor/corneltek/cliframework/src/Command/ZshCompletionCommand.php]  AèV]  ÿ£è¶      -   vendor/corneltek/cliframework/src/Command.phpŸ  AèVŸ  Aş¶      7   vendor/corneltek/cliframework/src/CommandAutoloader.php  AèV  S@S¶      1   vendor/corneltek/cliframework/src/CommandBase.phpS]  AèVS]  ÖS¶      6   vendor/corneltek/cliframework/src/CommandException.php[   AèV[   ¿*)¶      2   vendor/corneltek/cliframework/src/CommandGroup.php:  AèV:  ˆu÷c¶      6   vendor/corneltek/cliframework/src/CommandInterface.phpi  AèVi  üış¶      3   vendor/corneltek/cliframework/src/CommandLoader.phpE  AèVE  Stİè¶      >   vendor/corneltek/cliframework/src/Completion/BashGenerator.phpL  AèVL  }#0í¶      6   vendor/corneltek/cliframework/src/Completion/Utils.phpˆ  AèVˆ  »•¶      =   vendor/corneltek/cliframework/src/Completion/ZshGenerator.phpMQ  AèVMQ  ˜Â!¶      5   vendor/corneltek/cliframework/src/CompletionUtils.php•  AèV•  ©ñùÓ¶      F   vendor/corneltek/cliframework/src/Component/Progress/ETACalculator.php£  AèV£  Nvª?¶      D   vendor/corneltek/cliframework/src/Component/Progress/ProgressBar.php  AèV  :¯1!¶      I   vendor/corneltek/cliframework/src/Component/Progress/ProgressBarStyle.php;  AèV;  Õ+z¶      I   vendor/corneltek/cliframework/src/Component/Progress/ProgressReporter.php‹   AèV‹   c,V¶      E   vendor/corneltek/cliframework/src/Component/Progress/ProgressStar.php±  AèV±  à®²è¶      N   vendor/corneltek/cliframework/src/Component/Progress/SharpProgressBarStyle.phpY  AèVY  ¯ô)¶      J   vendor/corneltek/cliframework/src/Component/Table/BorderlessTableStyle.phpÑ  AèVÑ  ?Eâ¦¶      C   vendor/corneltek/cliframework/src/Component/Table/CellAttribute.phpf  AèVf  ›P‡¶      G   vendor/corneltek/cliframework/src/Component/Table/CompactTableStyle.phpÎ  AèVÎ  )Û(-¶      H   vendor/corneltek/cliframework/src/Component/Table/CurrencyFormatCell.phpÁ  AèVÁ  $—÷‘¶      D   vendor/corneltek/cliframework/src/Component/Table/DateFormatCell.php‘  AèV‘  ÚdÎ¶      H   vendor/corneltek/cliframework/src/Component/Table/DurationFormatCell.phpS  AèVS  4OjB¶      H   vendor/corneltek/cliframework/src/Component/Table/MarkdownTableStyle.php¨  AèV¨  !¼®¶¶      F   vendor/corneltek/cliframework/src/Component/Table/NumberFormatCell.php   AèV   õCíè¶      G   vendor/corneltek/cliframework/src/Component/Table/PercentFormatCell.phpR  AèVR  È—¼¶      N   vendor/corneltek/cliframework/src/Component/Table/SpellOutNumberFormatCell.phpµ  AèVµ  ‚Ùª·¶      ;   vendor/corneltek/cliframework/src/Component/Table/Table.phpÀ-  AèVÀ-  Íriú¶      @   vendor/corneltek/cliframework/src/Component/Table/TableStyle.phpœ  AèVœ  a…¶      9   vendor/corneltek/cliframework/src/Config/GlobalConfig.phpí  AèVí  <ñf¶      D   vendor/corneltek/cliframework/src/ConsoleInfo/ConsoleInfoFactory.php’  AèV’  ,a{»¶      F   vendor/corneltek/cliframework/src/ConsoleInfo/ConsoleInfoInterface.phpº   AèVº   ìfx¶      @   vendor/corneltek/cliframework/src/ConsoleInfo/EnvConsoleInfo.php}  AèV}  ÆAô€¶      A   vendor/corneltek/cliframework/src/ConsoleInfo/TputConsoleInfo.php^  AèV^  wÃ¶      /   vendor/corneltek/cliframework/src/Corrector.phpÒ  AèVÒ  öEı¶      8   vendor/corneltek/cliframework/src/Debug/ConsoleDebug.phpï  AèVï  ç‚Å|¶      9   vendor/corneltek/cliframework/src/Debug/LineIndicator.php,  AèV,  @§Ø-¶      Q   vendor/corneltek/cliframework/src/Exception/CommandArgumentNotEnoughException.phpù  AèVù  If_¶      D   vendor/corneltek/cliframework/src/Exception/CommandBaseException.php¯  AèV¯  [{Ïû¶      M   vendor/corneltek/cliframework/src/Exception/CommandClassNotFoundException.php{  AèV{  ­¼0¶      H   vendor/corneltek/cliframework/src/Exception/CommandNotFoundException.php  AèV  9{zk¶      P   vendor/corneltek/cliframework/src/Exception/ExecuteMethodNotDefinedException.php…   AèV…   55óĞ¶      B   vendor/corneltek/cliframework/src/Exception/ExtensionException.php¤  AèV¤  3-T¶      O   vendor/corneltek/cliframework/src/Exception/InvalidCommandArgumentException.phpÿ  AèVÿ  bef¶      R   vendor/corneltek/cliframework/src/ExceptionPrinter/DevelopmentExceptionPrinter.phpÏ  AèVÏ  8±mb¶      Q   vendor/corneltek/cliframework/src/ExceptionPrinter/ProductionExceptionPrinter.phpV  AèVV   Ğ¶      D   vendor/corneltek/cliframework/src/Extension/ApplicationExtension.php¶   AèV¶   #ÃÏ ¶      @   vendor/corneltek/cliframework/src/Extension/CommandExtension.phpf  AèVf  ï¢Ù[¶      ?   vendor/corneltek/cliframework/src/Extension/DaemonExtension.phpP  AèVP  ß±Õ¶      9   vendor/corneltek/cliframework/src/Extension/Extension.php[   AèV[   †:X¹¶      =   vendor/corneltek/cliframework/src/Extension/ExtensionBase.php·  AèV·  ¦× n¶      /   vendor/corneltek/cliframework/src/Formatter.php·  AèV·  qSËÁ¶      0   vendor/corneltek/cliframework/src/IO/Console.php[  AèV[  NyÚT¶      3   vendor/corneltek/cliframework/src/IO/EchoWriter.phpd  AèVd  èó¯Ñ¶      1   vendor/corneltek/cliframework/src/IO/NullStty.php:  AèV:  §ÖÇ¶      8   vendor/corneltek/cliframework/src/IO/ReadlineConsole.phpx  AèVx  šHm¹¶      8   vendor/corneltek/cliframework/src/IO/StandardConsole.phpä  AèVä  ³Ü>¶      5   vendor/corneltek/cliframework/src/IO/StreamWriter.php›  AèV›  P6´¶      -   vendor/corneltek/cliframework/src/IO/Stty.phpF  AèVF  èQB¢¶      1   vendor/corneltek/cliframework/src/IO/UnixStty.php€  AèV€  ¨Fˆ¶      /   vendor/corneltek/cliframework/src/IO/Writer.php(  AèV(  yşÁ{¶      :   vendor/corneltek/cliframework/src/LevenshteinCorrector.phpa  AèVa  "\§¶      9   vendor/corneltek/cliframework/src/Logger/ActionLogger.php…  AèV…  Ÿ!ÎQ¶      3   vendor/corneltek/cliframework/src/Logger/Logger.php<   AèV<   Ka•K¶      ,   vendor/corneltek/cliframework/src/Logger.phpÏ  AèVÏ  ªˆèù¶      3   vendor/corneltek/cliframework/src/OptionPrinter.php¼  AèV¼  $êÖ¶      ;   vendor/corneltek/cliframework/src/PharKit/PharGenerator.phpü  AèVü  ÷<¨I¶      5   vendor/corneltek/cliframework/src/PharKit/PharURI.php4  AèV4  )`Å¶      .   vendor/corneltek/cliframework/src/Prompter.phpñ  AèVñ  y@ÅÅ¶      6   vendor/corneltek/cliframework/src/ServiceContainer.phpl  AèVl  ; 5™¶      =   vendor/corneltek/cliframework/src/Testing/CommandTestCase.php8  AèV8  º–*¶      =   vendor/corneltek/cliframework/src/Testing/ConsoleTestCase.phpâ  AèVâ  O×AŒ¶      5   vendor/corneltek/cliframework/src/Topic/BaseTopic.php  AèV  m]è¶      7   vendor/corneltek/cliframework/src/Topic/GitHubTopic.phpP   AèVP   À£¹¼¶      +   vendor/corneltek/cliframework/src/Utils.phpA  AèVA  0VO¶      5   vendor/corneltek/cliframework/src/ValueCollection.php“  AèV“  ‹ö³Ë¶      0   vendor/corneltek/cliframework/src/ValueGroup.phpÆ  AèVÆ  Fáú¶          vendor/symfony/yaml/CHANGELOG.mdT  AèVT  5³H!¶      !   vendor/symfony/yaml/composer.jsoní  AèVí  2wf¶         vendor/symfony/yaml/Dumper.php	  AèV	  l£D¶         vendor/symfony/yaml/Escaper.php   AèV   + oÃ¶      /   vendor/symfony/yaml/Exception/DumpException.phpÇ  AèVÇ  Œ¶      4   vendor/symfony/yaml/Exception/ExceptionInterface.php»  AèV»  Ş^KA¶      0   vendor/symfony/yaml/Exception/ParseException.phpú  AèVú  ˆ©!«¶      2   vendor/symfony/yaml/Exception/RuntimeException.phpå  AèVå  ô_q¦¶         vendor/symfony/yaml/Inline.php—R  AèV—R  Xñ§˜¶         vendor/symfony/yaml/LICENSE)  AèV)  ¹ô¶         vendor/symfony/yaml/Parser.phpöv  AèVöv  XB,]¶      $   vendor/symfony/yaml/phpunit.xml.dist  AèV  ó^¢Á¶         vendor/symfony/yaml/README.mdk  AèVk  ¡´]¶      !   vendor/symfony/yaml/Unescaper.phpH  AèVH  
¥q¯¶         vendor/symfony/yaml/Yaml.phpd  AèVd  H`<¶      5   vendor/corneltek/configkit/src/ConfigKit/Accessor.php?	  AèV?	  ¹ĞÅº¶      ;   vendor/corneltek/configkit/src/ConfigKit/ConfigCompiler.php~  AèV~  ¯@¼é¶      9   vendor/corneltek/configkit/src/ConfigKit/ConfigLoader.php8  AèV8  `	‰¶      #   vendor/natxet/cssmin/src/CssMin.php»t AèV»t .cÃö¶      #   vendor/symfony/process/CHANGELOG.md=  AèV=  ¬y¶      $   vendor/symfony/process/composer.jsonö  AèVö  G` M¶      7   vendor/symfony/process/Exception/ExceptionInterface.php¯  AèV¯  <¶      =   vendor/symfony/process/Exception/InvalidArgumentException.phpğ  AèVğ  Ë…ë¶      3   vendor/symfony/process/Exception/LogicException.phpÒ  AèVÒ  °¨W¶      ;   vendor/symfony/process/Exception/ProcessFailedException.php  AèV  PÁ´5¶      =   vendor/symfony/process/Exception/ProcessTimedOutException.php{  AèV{  Ğİ2»¶      5   vendor/symfony/process/Exception/RuntimeException.phpá  AèVá  >H–™¶      +   vendor/symfony/process/ExecutableFinder.php
  AèV
  ½ş™Ê¶         vendor/symfony/process/LICENSE)  AèV)  ¹ô¶      .   vendor/symfony/process/PhpExecutableFinder.phpç  AèVç  õl(ñ¶      %   vendor/symfony/process/PhpProcess.php}	  AèV}	  ŸÔ¸¶      '   vendor/symfony/process/phpunit.xml.dist  AèV  Ç#€¶      .   vendor/symfony/process/Pipes/AbstractPipes.phpO  AèVO  &v©Ü¶      /   vendor/symfony/process/Pipes/PipesInterface.phpw  AèVw  «X]¶      *   vendor/symfony/process/Pipes/UnixPipes.php¥  AèV¥  øùÓ‚¶      -   vendor/symfony/process/Pipes/WindowsPipes.php  AèV  /†Tó¶      "   vendor/symfony/process/Process.php´  AèV´  Q­×¶      )   vendor/symfony/process/ProcessBuilder.php9  AèV9  Ä`™¶      '   vendor/symfony/process/ProcessUtils.php5  AèV5  ]Z¶          vendor/symfony/process/README.md  AèV  ÃëÔ¶         src/AssetKit/Asset.php…+  AèV…+  jêv¢¶          src/AssetKit/AssetCollection.phpø  AèVø  @/õ¶         src/AssetKit/AssetCompiler.phpú(  AèVú(  <°L ¶      %   src/AssetKit/AssetCompilerFactory.phpf  AèVf  [ÜÏ¶         src/AssetKit/AssetConfig.phpy#  AèVy#  dÅÓ®¶      "   src/AssetKit/AssetEntryStorage.php  AèV  zò¡ì¶         src/AssetKit/AssetLoader.phpô  AèVô  :Ä^š¶         src/AssetKit/AssetRender.phpi  AèVi  *’ü]¶          src/AssetKit/AssetUrlBuilder.php¬  AèV¬  ÇÒô¶         src/AssetKit/CacheFactory.phpÍ  AèVÍ  NAÑ9¶         src/AssetKit/Collection.phpº  AèVº  ãh4a¶      #   src/AssetKit/Command/AddCommand.php  AèV  gñÆb¶      )   src/AssetKit/Command/AddTargetCommand.php7  AèV7  âM¶      $   src/AssetKit/Command/BaseCommand.phpØ  AèVØ  ÜzQ.¶      %   src/AssetKit/Command/CleanCommand.phpŞ  AèVŞ  íu‘3¶      '   src/AssetKit/Command/CompileCommand.phpû  AèVû  B‘'¶      .   src/AssetKit/Command/CreateManifestCommand.phpª  AèVª  Ä¶      $   src/AssetKit/Command/InitCommand.phpå	  AèVå	  jùÄ¶      '   src/AssetKit/Command/InstallCommand.php¸  AèV¸  ¼ıB9¶      $   src/AssetKit/Command/ListCommand.phpP  AèVP  ñ’FÄ¶      *   src/AssetKit/Command/ListTargetCommand.phpø  AèVø  öÈ ¶      &   src/AssetKit/Command/RemoveCommand.phpï  AèVï  ¿{šg¶      ,   src/AssetKit/Command/RemoveTargetCommand.php˜  AèV˜  $t5¶      &   src/AssetKit/Command/TargetCommand.php“  AèV“  $N*¶      &   src/AssetKit/Command/UpdateCommand.php`  AèV`  ^tÅ¶      %   src/AssetKit/Command/WatchCommand.phpŸ  AèVŸ  mı!¶      ,   src/AssetKit/CompilerRunner/CoffeeRunner.phpù
  AèVù
  Õ¤¶      7   src/AssetKit/CompilerRunner/CompilerRunnerInterface.phpË  AèVË  ]üw¶      *   src/AssetKit/CompilerRunner/SassRunner.phpo   AèVo   ã!Öj¶      *   src/AssetKit/CompilerRunner/ScssRunner.php!  AèV!  ‹æS8¶      ,   src/AssetKit/Compressor/CssMinCompressor.phpÏ  AèVÏ  á?_:¶      +   src/AssetKit/Compressor/JsMinCompressor.php×  AèV×  ]¨Q•¶      .   src/AssetKit/Compressor/JsMinExtCompressor.phpf  AèVf  ëŞVŒ¶      .   src/AssetKit/Compressor/JsMinPHPCompressor.phpH  AèVH  &F¾¶      ,   src/AssetKit/Compressor/UglifyCompressor.phpW  AèVW  O¥Î´¶      -   src/AssetKit/Compressor/Yui/CssCompressor.php¦  AèV¦  NPP¶      ,   src/AssetKit/Compressor/Yui/JsCompressor.php¥  AèV¥  	Ğ2Ñ¶         src/AssetKit/Console.phpÇ  AèVÇ  Ë¾Q ¶         src/AssetKit/CssMin.php×ü AèV×ü ıšMj¶         src/AssetKit/Data.phpö  AèVö  ªÂ3¶      7   src/AssetKit/Exception/UndefinedCompressorException.phpl   AèVl   ¼µÆ¶      3   src/AssetKit/Exception/UndefinedFilterException.phph   AèVh   s„Á¶      8   src/AssetKit/Exception/UnknownCollectionKeyException.phpú  AèVú  Ç¶      3   src/AssetKit/Exception/UnknownFragmentException.php
  AèV
  ³Bú¶      2   src/AssetKit/Exception/UnwritableFileException.phpf   AèVf   j"ı¶      .   src/AssetKit/Extension/Twig/AssetExtension.php	  AèV	  {ÌÖH¶      )   src/AssetKit/Extension/Twig/AssetNode.php  AèV  A8©C¶      0   src/AssetKit/Extension/Twig/AssetTokenParser.phpQ  AèVQ  õİÃ¶         src/AssetKit/FileUtil.phpV  AèVV  ï‘Ö¶      "   src/AssetKit/Filter/BaseFilter.php[  AèV[  ²Ü,¶      *   src/AssetKit/Filter/CoffeeScriptFilter.php›  AèV›  Kç”K¶      '   src/AssetKit/Filter/CssImportFilter.phpY  AèVY  m&Ã¶      (   src/AssetKit/Filter/CssRewriteFilter.php  AèV  JŸ¶      "   src/AssetKit/Filter/SassFilter.phpg  AèVg  ÚWİo¶      "   src/AssetKit/Filter/ScssFilter.phpD  AèVD  F¨ñ¶         src/AssetKit/Installer.php§  AèV§  Îíã€¶         src/AssetKit/JSMin.phpá*  AèVá*  ¤ä'¶         src/AssetKit/LinkInstaller.php¶  AèV¶  œ"Œ>¶         src/AssetKit/Process.php
  AèV
  =5îê¶      (   src/AssetKit/ProductionAssetCompiler.php¯?  AèV¯?  yÏ6C¶          src/AssetKit/ResourceUpdater.php5  AèV5  ÑV«[¶         src/AssetKit/Target.phpİ   AèVİ   ´Ig¶         src/AssetKit/TestCase.php  AèV  	4_Í¶         src/AssetKit/Utils.php  AèV  r÷£¶      <?php
/**
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <yoanlin93@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Universal\ClassLoader;

interface ClassLoader { 

    public function register($prepend = false);

    public function unregister();

    public function resolveClass($fullclass);

    public function loadClass($class);

}


<?php
/**
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <yoanlin93@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace Universal\ClassLoader;

class Psr0ClassLoader implements ClassLoader
{

    /**
     * namespace mapping
     *
     * @var array
     */
    protected $namespaces = array();

    public function __construct(array $namespaces = array()) 
    {
        $this->namespaces = $namespaces;
    }

    public function addNamespaces(array $namespaceMaps) 
    {
        $this->namespaces = array_merge($this->namespaces, $namespaceMaps);
    }


    public function addNamespace($ns, $dirs)
    {
        $this->namespaces[$ns] = (array) $dirs;
    }


    /**
     * find class file path
     *
     * @param string $fullclass
     */
    public function resolveClass($fullclass)
    {
        if (($r = strrpos($fullclass,'\\')) !== false) {
            $namespace = substr($fullclass,0,$r);
            $classname = substr($fullclass,$r + 1);
            $subpath = strtr($fullclass, '\\', DIRECTORY_SEPARATOR) . '.php';
            foreach ($this->namespaces as $ns => $dirs) {
                if (strpos($namespace,$ns) === 0) {
                    foreach ((array) $dirs as $dir) {
                        $path = $dir . DIRECTORY_SEPARATOR . $subpath;
                        if (file_exists($path)) {
                            return $path;
                        }
                    }
                }
            }
        }
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            require $file;
            return true;
        }
        return false;
    }

    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * unregister the spl autoloader
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }
}




<?php
/**
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <yoanlin93@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Universal\ClassLoader;
use Universal\ClassLoader\ClassLoader;

class Psr4ClassLoader implements ClassLoader
{
    protected $prefixes = array();

    public function __construct(array $prefixes = array()) 
    {
        $this->prefixes = $prefixes;
    }

    public function addPrefix($prefix, $baseDir, $trim = false)
    {
        if ($trim) {
            $prefix = trim($prefix, '\\') . '\\';
            $baseDir = rtrim($baseDir, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
        }
        $this->prefixes[] = array($prefix, $baseDir);
    }


    public function addPrefixes(array $prefixes, $trim = false)
    {
        foreach ($prefixes as $prefix => $baseDir) {
            $this->addPrefix($prefix, $baseDir, $trim);
        }
    }


    /**
     * find class file path
     *
     * @param string $fullclass
     */
    public function resolveClass($fullclass)
    {
        # echo "Fullclass: " . $fullclass . "\n";
        foreach ($this->prefixes as $prefixMap) {
            list($prefix, $dir) = $prefixMap;
            if (strpos($fullclass, $prefix) === 0) {
                $len = strlen($prefix);
                $classSuffix = substr($fullclass, $len);
                $subpath = str_replace('\\', DIRECTORY_SEPARATOR, $classSuffix) . '.php';
                $classPath = $dir . $subpath;
                if (file_exists($classPath)) {
                    return $classPath;
                }
            }
        }
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            require $file;
            return true;
        }
        return false;
    }



    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

}

<?php
namespace Universal\ClassLoader;


class MapClassLoader
{

    protected $classMap;

    public function __construct(array $map)
    {
        $this->classMap = $map;
    }


    /**
     * find class file path
     *
     * @param string $fullclass
     */
    public function resolveClass($fullclass)
    {
        if (isset($this->classMap[$fullclass])) {
            return $this->classMap[$fullclass];
        }
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            require $file;
            return true;
        }
        return false;
    }


    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }
    
}


<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Autoloader class is deprecated since version 1.21 and will be removed in 2.0. Use Composer instead.', E_USER_DEPRECATED);

/**
 * Autoloads Twig classes.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.21 and will be removed in 2.0. Use Composer instead. 2.0.
 */
class Twig_Autoloader
{
    /**
     * Registers Twig_Autoloader as an SPL autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not.
     */
    public static function register($prepend = false)
    {
        @trigger_error('Using Twig_Autoloader is deprecated since version 1.21. Use Composer instead.', E_USER_DEPRECATED);

        if (PHP_VERSION_ID < 50300) {
            spl_autoload_register(array(__CLASS__, 'autoload'));
        } else {
            spl_autoload_register(array(__CLASS__, 'autoload'), true, $prepend);
        }
    }

    /**
     * Handles autoloading of classes.
     *
     * @param string $class A class name.
     */
    public static function autoload($class)
    {
        if (0 !== strpos($class, 'Twig')) {
            return;
        }

        if (is_file($file = dirname(__FILE__).'/../'.str_replace(array('_', "\0"), array('/', ''), $class).'.php')) {
            require $file;
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Twig_BaseNodeVisitor can be used to make node visitors compatible with Twig 1.x and 2.x.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
abstract class Twig_BaseNodeVisitor implements Twig_NodeVisitorInterface
{
    /**
     * {@inheritdoc}
     */
    final public function enterNode(Twig_NodeInterface $node, Twig_Environment $env)
    {
        if (!$node instanceof Twig_Node) {
            throw new LogicException('Twig_BaseNodeVisitor only supports Twig_Node instances.');
        }

        return $this->doEnterNode($node, $env);
    }

    /**
     * {@inheritdoc}
     */
    final public function leaveNode(Twig_NodeInterface $node, Twig_Environment $env)
    {
        if (!$node instanceof Twig_Node) {
            throw new LogicException('Twig_BaseNodeVisitor only supports Twig_Node instances.');
        }

        return $this->doLeaveNode($node, $env);
    }

    /**
     * Called before child nodes are visited.
     *
     * @param Twig_Node        $node The node to visit
     * @param Twig_Environment $env  The Twig environment instance
     *
     * @return Twig_Node The modified node
     */
    abstract protected function doEnterNode(Twig_Node $node, Twig_Environment $env);

    /**
     * Called after child nodes are visited.
     *
     * @param Twig_Node        $node The node to visit
     * @param Twig_Environment $env  The Twig environment instance
     *
     * @return Twig_Node|false The modified node or false if the node must be removed
     */
    abstract protected function doLeaveNode(Twig_Node $node, Twig_Environment $env);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Implements a cache on the filesystem.
 *
 * @author Andrew Tch <andrew@noop.lv>
 */
class Twig_Cache_Filesystem implements Twig_CacheInterface
{
    const FORCE_BYTECODE_INVALIDATION = 1;

    private $directory;
    private $options;

    /**
     * @param $directory string The root cache directory
     * @param $options   int    A set of options
     */
    public function __construct($directory, $options = 0)
    {
        $this->directory = rtrim($directory, '\/').'/';
        $this->options = $options;
    }

    /**
     * {@inheritdoc}
     */
    public function generateKey($name, $className)
    {
        $hash = hash('sha256', $className);

        return $this->directory.$hash[0].$hash[1].'/'.$hash.'.php';
    }

    /**
     * {@inheritdoc}
     */
    public function load($key)
    {
        @include_once $key;
    }

    /**
     * {@inheritdoc}
     */
    public function write($key, $content)
    {
        $dir = dirname($key);
        if (!is_dir($dir)) {
            if (false === @mkdir($dir, 0777, true) && !is_dir($dir)) {
                throw new RuntimeException(sprintf('Unable to create the cache directory (%s).', $dir));
            }
        } elseif (!is_writable($dir)) {
            throw new RuntimeException(sprintf('Unable to write in the cache directory (%s).', $dir));
        }

        $tmpFile = tempnam($dir, basename($key));
        if (false !== @file_put_contents($tmpFile, $content) && @rename($tmpFile, $key)) {
            @chmod($key, 0666 & ~umask());

            if (self::FORCE_BYTECODE_INVALIDATION == ($this->options & self::FORCE_BYTECODE_INVALIDATION)) {
                // Compile cached file into bytecode cache
                if (function_exists('opcache_invalidate')) {
                    opcache_invalidate($key, true);
                } elseif (function_exists('apc_compile_file')) {
                    apc_compile_file($key);
                }
            }

            return;
        }

        throw new RuntimeException(sprintf('Failed to write cache file "%s".', $key));
    }

    /**
     * {@inheritdoc}
     */
    public function getTimestamp($key)
    {
        if (!file_exists($key)) {
            return 0;
        }

        return (int) @filemtime($key);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Implements a no-cache strategy.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Cache_Null implements Twig_CacheInterface
{
    /**
     * {@inheritdoc}
     */
    public function generateKey($name, $className)
    {
        return '';
    }

    /**
     * {@inheritdoc}
     */
    public function write($key, $content)
    {
    }

    /**
     * {@inheritdoc}
     */
    public function load($key)
    {
    }

    /**
     * {@inheritdoc}
     */
    public function getTimestamp($key)
    {
        return 0;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface implemented by cache classes.
 *
 * It is highly recommended to always store templates on the filesystem to
 * benefit from the PHP opcode cache. This interface is mostly useful if you
 * need to implement a custom strategy for storing templates on the filesystem.
 *
 * @author Andrew Tch <andrew@noop.lv>
 */
interface Twig_CacheInterface
{
    /**
     * Generates a cache key for the given template class name.
     *
     * @param string $name      The template name
     * @param string $className The template class name
     *
     * @return string
     */
    public function generateKey($name, $className);

    /**
     * Writes the compiled template to cache.
     *
     * @param string $key     The cache key
     * @param string $content The template representation as a PHP class
     */
    public function write($key, $content);

    /**
     * Loads a template from the cache.
     *
     * @param string $key The cache key
     */
    public function load($key);

    /**
     * Returns the modification timestamp of a key.
     *
     * @param string $key The cache key
     *
     * @return int
     */
    public function getTimestamp($key);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Compiles a node to PHP code.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Compiler implements Twig_CompilerInterface
{
    protected $lastLine;
    protected $source;
    protected $indentation;
    protected $env;
    protected $debugInfo = array();
    protected $sourceOffset;
    protected $sourceLine;
    protected $filename;

    /**
     * Constructor.
     *
     * @param Twig_Environment $env The twig environment instance
     */
    public function __construct(Twig_Environment $env)
    {
        $this->env = $env;
    }

    public function getFilename()
    {
        return $this->filename;
    }

    /**
     * Returns the environment instance related to this compiler.
     *
     * @return Twig_Environment The environment instance
     */
    public function getEnvironment()
    {
        return $this->env;
    }

    /**
     * Gets the current PHP code after compilation.
     *
     * @return string The PHP code
     */
    public function getSource()
    {
        return $this->source;
    }

    /**
     * Compiles a node.
     *
     * @param Twig_NodeInterface $node        The node to compile
     * @param int                $indentation The current indentation
     *
     * @return Twig_Compiler The current compiler instance
     */
    public function compile(Twig_NodeInterface $node, $indentation = 0)
    {
        $this->lastLine = null;
        $this->source = '';
        $this->debugInfo = array();
        $this->sourceOffset = 0;
        // source code starts at 1 (as we then increment it when we encounter new lines)
        $this->sourceLine = 1;
        $this->indentation = $indentation;

        if ($node instanceof Twig_Node_Module) {
            $this->filename = $node->getAttribute('filename');
        }

        $node->compile($this);

        return $this;
    }

    public function subcompile(Twig_NodeInterface $node, $raw = true)
    {
        if (false === $raw) {
            $this->addIndentation();
        }

        $node->compile($this);

        return $this;
    }

    /**
     * Adds a raw string to the compiled code.
     *
     * @param string $string The string
     *
     * @return Twig_Compiler The current compiler instance
     */
    public function raw($string)
    {
        $this->source .= $string;

        return $this;
    }

    /**
     * Writes a string to the compiled code by adding indentation.
     *
     * @return Twig_Compiler The current compiler instance
     */
    public function write()
    {
        $strings = func_get_args();
        foreach ($strings as $string) {
            $this->addIndentation();
            $this->source .= $string;
        }

        return $this;
    }

    /**
     * Appends an indentation to the current PHP code after compilation.
     *
     * @return Twig_Compiler The current compiler instance
     */
    public function addIndentation()
    {
        $this->source .= str_repeat(' ', $this->indentation * 4);

        return $this;
    }

    /**
     * Adds a quoted string to the compiled code.
     *
     * @param string $value The string
     *
     * @return Twig_Compiler The current compiler instance
     */
    public function string($value)
    {
        $this->source .= sprintf('"%s"', addcslashes($value, "\0\t\"\$\\"));

        return $this;
    }

    /**
     * Returns a PHP representation of a given value.
     *
     * @param mixed $value The value to convert
     *
     * @return Twig_Compiler The current compiler instance
     */
    public function repr($value)
    {
        if (is_int($value) || is_float($value)) {
            if (false !== $locale = setlocale(LC_NUMERIC, 0)) {
                setlocale(LC_NUMERIC, 'C');
            }

            $this->raw($value);

            if (false !== $locale) {
                setlocale(LC_NUMERIC, $locale);
            }
        } elseif (null === $value) {
            $this->raw('null');
        } elseif (is_bool($value)) {
            $this->raw($value ? 'true' : 'false');
        } elseif (is_array($value)) {
            $this->raw('array(');
            $first = true;
            foreach ($value as $key => $v) {
                if (!$first) {
                    $this->raw(', ');
                }
                $first = false;
                $this->repr($key);
                $this->raw(' => ');
                $this->repr($v);
            }
            $this->raw(')');
        } else {
            $this->string($value);
        }

        return $this;
    }

    /**
     * Adds debugging information.
     *
     * @param Twig_NodeInterface $node The related twig node
     *
     * @return Twig_Compiler The current compiler instance
     */
    public function addDebugInfo(Twig_NodeInterface $node)
    {
        if ($node->getLine() != $this->lastLine) {
            $this->write(sprintf("// line %d\n", $node->getLine()));

            // when mbstring.func_overload is set to 2
            // mb_substr_count() replaces substr_count()
            // but they have different signatures!
            if (((int) ini_get('mbstring.func_overload')) & 2) {
                // this is much slower than the "right" version
                $this->sourceLine += mb_substr_count(mb_substr($this->source, $this->sourceOffset), "\n");
            } else {
                $this->sourceLine += substr_count($this->source, "\n", $this->sourceOffset);
            }
            $this->sourceOffset = strlen($this->source);
            $this->debugInfo[$this->sourceLine] = $node->getLine();

            $this->lastLine = $node->getLine();
        }

        return $this;
    }

    public function getDebugInfo()
    {
        ksort($this->debugInfo);

        return $this->debugInfo;
    }

    /**
     * Indents the generated code.
     *
     * @param int $step The number of indentation to add
     *
     * @return Twig_Compiler The current compiler instance
     */
    public function indent($step = 1)
    {
        $this->indentation += $step;

        return $this;
    }

    /**
     * Outdents the generated code.
     *
     * @param int $step The number of indentation to remove
     *
     * @return Twig_Compiler The current compiler instance
     *
     * @throws LogicException When trying to outdent too much so the indentation would become negative
     */
    public function outdent($step = 1)
    {
        // can't outdent by more steps than the current indentation level
        if ($this->indentation < $step) {
            throw new LogicException('Unable to call outdent() as the indentation would become negative');
        }

        $this->indentation -= $step;

        return $this;
    }

    public function getVarName()
    {
        return sprintf('__internal_%s', hash('sha256', uniqid(mt_rand(), true), false));
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface implemented by compiler classes.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 3.0)
 */
interface Twig_CompilerInterface
{
    /**
     * Compiles a node.
     *
     * @param Twig_NodeInterface $node The node to compile
     *
     * @return Twig_CompilerInterface The current compiler instance
     */
    public function compile(Twig_NodeInterface $node);

    /**
     * Gets the current PHP code after compilation.
     *
     * @return string The PHP code
     */
    public function getSource();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Stores the Twig configuration.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Environment
{
    const VERSION = '1.24.0';

    protected $charset;
    protected $loader;
    protected $debug;
    protected $autoReload;
    protected $cache;
    protected $lexer;
    protected $parser;
    protected $compiler;
    protected $baseTemplateClass;
    protected $extensions;
    protected $parsers;
    protected $visitors;
    protected $filters;
    protected $tests;
    protected $functions;
    protected $globals;
    protected $runtimeInitialized = false;
    protected $extensionInitialized = false;
    protected $loadedTemplates;
    protected $strictVariables;
    protected $unaryOperators;
    protected $binaryOperators;
    protected $templateClassPrefix = '__TwigTemplate_';
    protected $functionCallbacks = array();
    protected $filterCallbacks = array();
    protected $staging;

    private $originalCache;
    private $bcWriteCacheFile = false;
    private $bcGetCacheFilename = false;
    private $lastModifiedExtension = 0;

    /**
     * Constructor.
     *
     * Available options:
     *
     *  * debug: When set to true, it automatically set "auto_reload" to true as
     *           well (default to false).
     *
     *  * charset: The charset used by the templates (default to UTF-8).
     *
     *  * base_template_class: The base template class to use for generated
     *                         templates (default to Twig_Template).
     *
     *  * cache: An absolute path where to store the compiled templates,
     *           a Twig_Cache_Interface implementation,
     *           or false to disable compilation cache (default).
     *
     *  * auto_reload: Whether to reload the template if the original source changed.
     *                 If you don't provide the auto_reload option, it will be
     *                 determined automatically based on the debug value.
     *
     *  * strict_variables: Whether to ignore invalid variables in templates
     *                      (default to false).
     *
     *  * autoescape: Whether to enable auto-escaping (default to html):
     *                  * false: disable auto-escaping
     *                  * true: equivalent to html
     *                  * html, js: set the autoescaping to one of the supported strategies
     *                  * filename: set the autoescaping strategy based on the template filename extension
     *                  * PHP callback: a PHP callback that returns an escaping strategy based on the template "filename"
     *
     *  * optimizations: A flag that indicates which optimizations to apply
     *                   (default to -1 which means that all optimizations are enabled;
     *                   set it to 0 to disable).
     *
     * @param Twig_LoaderInterface $loader  A Twig_LoaderInterface instance
     * @param array                $options An array of options
     */
    public function __construct(Twig_LoaderInterface $loader = null, $options = array())
    {
        if (null !== $loader) {
            $this->setLoader($loader);
        } else {
            @trigger_error('Not passing a Twig_LoaderInterface as the first constructor argument of Twig_Environment is deprecated since version 1.21.', E_USER_DEPRECATED);
        }

        $options = array_merge(array(
            'debug' => false,
            'charset' => 'UTF-8',
            'base_template_class' => 'Twig_Template',
            'strict_variables' => false,
            'autoescape' => 'html',
            'cache' => false,
            'auto_reload' => null,
            'optimizations' => -1,
        ), $options);

        $this->debug = (bool) $options['debug'];
        $this->charset = strtoupper($options['charset']);
        $this->baseTemplateClass = $options['base_template_class'];
        $this->autoReload = null === $options['auto_reload'] ? $this->debug : (bool) $options['auto_reload'];
        $this->strictVariables = (bool) $options['strict_variables'];
        $this->setCache($options['cache']);

        $this->addExtension(new Twig_Extension_Core());
        $this->addExtension(new Twig_Extension_Escaper($options['autoescape']));
        $this->addExtension(new Twig_Extension_Optimizer($options['optimizations']));
        $this->staging = new Twig_Extension_Staging();

        // For BC
        if (is_string($this->originalCache)) {
            $r = new ReflectionMethod($this, 'writeCacheFile');
            if ($r->getDeclaringClass()->getName() !== __CLASS__) {
                @trigger_error('The Twig_Environment::writeCacheFile method is deprecated since version 1.22 and will be removed in Twig 2.0.', E_USER_DEPRECATED);

                $this->bcWriteCacheFile = true;
            }

            $r = new ReflectionMethod($this, 'getCacheFilename');
            if ($r->getDeclaringClass()->getName() !== __CLASS__) {
                @trigger_error('The Twig_Environment::getCacheFilename method is deprecated since version 1.22 and will be removed in Twig 2.0.', E_USER_DEPRECATED);

                $this->bcGetCacheFilename = true;
            }
        }
    }

    /**
     * Gets the base template class for compiled templates.
     *
     * @return string The base template class name
     */
    public function getBaseTemplateClass()
    {
        return $this->baseTemplateClass;
    }

    /**
     * Sets the base template class for compiled templates.
     *
     * @param string $class The base template class name
     */
    public function setBaseTemplateClass($class)
    {
        $this->baseTemplateClass = $class;
    }

    /**
     * Enables debugging mode.
     */
    public function enableDebug()
    {
        $this->debug = true;
    }

    /**
     * Disables debugging mode.
     */
    public function disableDebug()
    {
        $this->debug = false;
    }

    /**
     * Checks if debug mode is enabled.
     *
     * @return bool true if debug mode is enabled, false otherwise
     */
    public function isDebug()
    {
        return $this->debug;
    }

    /**
     * Enables the auto_reload option.
     */
    public function enableAutoReload()
    {
        $this->autoReload = true;
    }

    /**
     * Disables the auto_reload option.
     */
    public function disableAutoReload()
    {
        $this->autoReload = false;
    }

    /**
     * Checks if the auto_reload option is enabled.
     *
     * @return bool true if auto_reload is enabled, false otherwise
     */
    public function isAutoReload()
    {
        return $this->autoReload;
    }

    /**
     * Enables the strict_variables option.
     */
    public function enableStrictVariables()
    {
        $this->strictVariables = true;
    }

    /**
     * Disables the strict_variables option.
     */
    public function disableStrictVariables()
    {
        $this->strictVariables = false;
    }

    /**
     * Checks if the strict_variables option is enabled.
     *
     * @return bool true if strict_variables is enabled, false otherwise
     */
    public function isStrictVariables()
    {
        return $this->strictVariables;
    }

    /**
     * Gets the current cache implementation.
     *
     * @param bool $original Whether to return the original cache option or the real cache instance
     *
     * @return Twig_CacheInterface|string|false A Twig_CacheInterface implementation,
     *                                          an absolute path to the compiled templates,
     *                                          or false to disable cache
     */
    public function getCache($original = true)
    {
        return $original ? $this->originalCache : $this->cache;
    }

    /**
     * Sets the current cache implementation.
     *
     * @param Twig_CacheInterface|string|false $cache A Twig_CacheInterface implementation,
     *                                                an absolute path to the compiled templates,
     *                                                or false to disable cache
     */
    public function setCache($cache)
    {
        if (is_string($cache)) {
            $this->originalCache = $cache;
            $this->cache = new Twig_Cache_Filesystem($cache);
        } elseif (false === $cache) {
            $this->originalCache = $cache;
            $this->cache = new Twig_Cache_Null();
        } elseif (null === $cache) {
            @trigger_error('Using "null" as the cache strategy is deprecated since version 1.23 and will be removed in Twig 2.0.', E_USER_DEPRECATED);
            $this->originalCache = false;
            $this->cache = new Twig_Cache_Null();
        } elseif ($cache instanceof Twig_CacheInterface) {
            $this->originalCache = $this->cache = $cache;
        } else {
            throw new LogicException(sprintf('Cache can only be a string, false, or a Twig_CacheInterface implementation.'));
        }
    }

    /**
     * Gets the cache filename for a given template.
     *
     * @param string $name The template name
     *
     * @return string|false The cache file name or false when caching is disabled
     *
     * @deprecated since 1.22 (to be removed in 2.0)
     */
    public function getCacheFilename($name)
    {
        @trigger_error(sprintf('The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.', __METHOD__), E_USER_DEPRECATED);

        $key = $this->cache->generateKey($name, $this->getTemplateClass($name));

        return !$key ? false : $key;
    }

    /**
     * Gets the template class associated with the given string.
     *
     * The generated template class is based on the following parameters:
     *
     *  * The cache key for the given template;
     *  * The currently enabled extensions;
     *  * Whether the Twig C extension is available or not.
     *
     * @param string   $name  The name for which to calculate the template class name
     * @param int|null $index The index if it is an embedded template
     *
     * @return string The template class name
     */
    public function getTemplateClass($name, $index = null)
    {
        $key = $this->getLoader()->getCacheKey($name);
        $key .= json_encode(array_keys($this->extensions));
        $key .= function_exists('twig_template_get_attributes');

        return $this->templateClassPrefix.hash('sha256', $key).(null === $index ? '' : '_'.$index);
    }

    /**
     * Gets the template class prefix.
     *
     * @return string The template class prefix
     *
     * @deprecated since 1.22 (to be removed in 2.0)
     */
    public function getTemplateClassPrefix()
    {
        @trigger_error(sprintf('The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.', __METHOD__), E_USER_DEPRECATED);

        return $this->templateClassPrefix;
    }

    /**
     * Renders a template.
     *
     * @param string $name    The template name
     * @param array  $context An array of parameters to pass to the template
     *
     * @return string The rendered template
     *
     * @throws Twig_Error_Loader  When the template cannot be found
     * @throws Twig_Error_Syntax  When an error occurred during compilation
     * @throws Twig_Error_Runtime When an error occurred during rendering
     */
    public function render($name, array $context = array())
    {
        return $this->loadTemplate($name)->render($context);
    }

    /**
     * Displays a template.
     *
     * @param string $name    The template name
     * @param array  $context An array of parameters to pass to the template
     *
     * @throws Twig_Error_Loader  When the template cannot be found
     * @throws Twig_Error_Syntax  When an error occurred during compilation
     * @throws Twig_Error_Runtime When an error occurred during rendering
     */
    public function display($name, array $context = array())
    {
        $this->loadTemplate($name)->display($context);
    }

    /**
     * Loads a template by name.
     *
     * @param string $name  The template name
     * @param int    $index The index if it is an embedded template
     *
     * @return Twig_TemplateInterface A template instance representing the given template name
     *
     * @throws Twig_Error_Loader When the template cannot be found
     * @throws Twig_Error_Syntax When an error occurred during compilation
     */
    public function loadTemplate($name, $index = null)
    {
        $cls = $this->getTemplateClass($name, $index);

        if (isset($this->loadedTemplates[$cls])) {
            return $this->loadedTemplates[$cls];
        }

        if (!class_exists($cls, false)) {
            if ($this->bcGetCacheFilename) {
                $key = $this->getCacheFilename($name);
            } else {
                $key = $this->cache->generateKey($name, $cls);
            }

            if (!$this->isAutoReload() || $this->isTemplateFresh($name, $this->cache->getTimestamp($key))) {
                $this->cache->load($key);
            }

            if (!class_exists($cls, false)) {
                $content = $this->compileSource($this->getLoader()->getSource($name), $name);
                if ($this->bcWriteCacheFile) {
                    $this->writeCacheFile($key, $content);
                } else {
                    $this->cache->write($key, $content);
                }

                eval('?>'.$content);
            }
        }

        if (!$this->runtimeInitialized) {
            $this->initRuntime();
        }

        return $this->loadedTemplates[$cls] = new $cls($this);
    }

    /**
     * Creates a template from source.
     *
     * This method should not be used as a generic way to load templates.
     *
     * @param string $template The template name
     *
     * @return Twig_Template A template instance representing the given template name
     *
     * @throws Twig_Error_Loader When the template cannot be found
     * @throws Twig_Error_Syntax When an error occurred during compilation
     */
    public function createTemplate($template)
    {
        $name = sprintf('__string_template__%s', hash('sha256', uniqid(mt_rand(), true), false));

        $loader = new Twig_Loader_Chain(array(
            new Twig_Loader_Array(array($name => $template)),
            $current = $this->getLoader(),
        ));

        $this->setLoader($loader);
        try {
            $template = $this->loadTemplate($name);
        } catch (Exception $e) {
            $this->setLoader($current);

            throw $e;
        }
        $this->setLoader($current);

        return $template;
    }

    /**
     * Returns true if the template is still fresh.
     *
     * Besides checking the loader for freshness information,
     * this method also checks if the enabled extensions have
     * not changed.
     *
     * @param string $name The template name
     * @param int    $time The last modification time of the cached template
     *
     * @return bool true if the template is fresh, false otherwise
     */
    public function isTemplateFresh($name, $time)
    {
        if (0 === $this->lastModifiedExtension) {
            foreach ($this->extensions as $extension) {
                $r = new ReflectionObject($extension);
                if (file_exists($r->getFileName()) && ($extensionTime = filemtime($r->getFileName())) > $this->lastModifiedExtension) {
                    $this->lastModifiedExtension = $extensionTime;
                }
            }
        }

        return $this->lastModifiedExtension <= $time && $this->getLoader()->isFresh($name, $time);
    }

    /**
     * Tries to load a template consecutively from an array.
     *
     * Similar to loadTemplate() but it also accepts Twig_TemplateInterface instances and an array
     * of templates where each is tried to be loaded.
     *
     * @param string|Twig_Template|array $names A template or an array of templates to try consecutively
     *
     * @return Twig_Template
     *
     * @throws Twig_Error_Loader When none of the templates can be found
     * @throws Twig_Error_Syntax When an error occurred during compilation
     */
    public function resolveTemplate($names)
    {
        if (!is_array($names)) {
            $names = array($names);
        }

        foreach ($names as $name) {
            if ($name instanceof Twig_Template) {
                return $name;
            }

            try {
                return $this->loadTemplate($name);
            } catch (Twig_Error_Loader $e) {
            }
        }

        if (1 === count($names)) {
            throw $e;
        }

        throw new Twig_Error_Loader(sprintf('Unable to find one of the following templates: "%s".', implode('", "', $names)));
    }

    /**
     * Clears the internal template cache.
     *
     * @deprecated since 1.18.3 (to be removed in 2.0)
     */
    public function clearTemplateCache()
    {
        @trigger_error(sprintf('The %s method is deprecated since version 1.18.3 and will be removed in Twig 2.0.', __METHOD__), E_USER_DEPRECATED);

        $this->loadedTemplates = array();
    }

    /**
     * Clears the template cache files on the filesystem.
     *
     * @deprecated since 1.22 (to be removed in 2.0)
     */
    public function clearCacheFiles()
    {
        @trigger_error(sprintf('The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.', __METHOD__), E_USER_DEPRECATED);

        if (is_string($this->originalCache)) {
            foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->originalCache), RecursiveIteratorIterator::LEAVES_ONLY) as $file) {
                if ($file->isFile()) {
                    @unlink($file->getPathname());
                }
            }
        }
    }

    /**
     * Gets the Lexer instance.
     *
     * @return Twig_LexerInterface A Twig_LexerInterface instance
     */
    public function getLexer()
    {
        if (null === $this->lexer) {
            $this->lexer = new Twig_Lexer($this);
        }

        return $this->lexer;
    }

    /**
     * Sets the Lexer instance.
     *
     * @param Twig_LexerInterface $lexer A Twig_LexerInterface instance
     */
    public function setLexer(Twig_LexerInterface $lexer)
    {
        $this->lexer = $lexer;
    }

    /**
     * Tokenizes a source code.
     *
     * @param string $source The template source code
     * @param string $name   The template name
     *
     * @return Twig_TokenStream A Twig_TokenStream instance
     *
     * @throws Twig_Error_Syntax When the code is syntactically wrong
     */
    public function tokenize($source, $name = null)
    {
        return $this->getLexer()->tokenize($source, $name);
    }

    /**
     * Gets the Parser instance.
     *
     * @return Twig_ParserInterface A Twig_ParserInterface instance
     */
    public function getParser()
    {
        if (null === $this->parser) {
            $this->parser = new Twig_Parser($this);
        }

        return $this->parser;
    }

    /**
     * Sets the Parser instance.
     *
     * @param Twig_ParserInterface $parser A Twig_ParserInterface instance
     */
    public function setParser(Twig_ParserInterface $parser)
    {
        $this->parser = $parser;
    }

    /**
     * Converts a token stream to a node tree.
     *
     * @param Twig_TokenStream $stream A token stream instance
     *
     * @return Twig_Node_Module A node tree
     *
     * @throws Twig_Error_Syntax When the token stream is syntactically or semantically wrong
     */
    public function parse(Twig_TokenStream $stream)
    {
        return $this->getParser()->parse($stream);
    }

    /**
     * Gets the Compiler instance.
     *
     * @return Twig_CompilerInterface A Twig_CompilerInterface instance
     */
    public function getCompiler()
    {
        if (null === $this->compiler) {
            $this->compiler = new Twig_Compiler($this);
        }

        return $this->compiler;
    }

    /**
     * Sets the Compiler instance.
     *
     * @param Twig_CompilerInterface $compiler A Twig_CompilerInterface instance
     */
    public function setCompiler(Twig_CompilerInterface $compiler)
    {
        $this->compiler = $compiler;
    }

    /**
     * Compiles a node and returns the PHP code.
     *
     * @param Twig_NodeInterface $node A Twig_NodeInterface instance
     *
     * @return string The compiled PHP source code
     */
    public function compile(Twig_NodeInterface $node)
    {
        return $this->getCompiler()->compile($node)->getSource();
    }

    /**
     * Compiles a template source code.
     *
     * @param string $source The template source code
     * @param string $name   The template name
     *
     * @return string The compiled PHP source code
     *
     * @throws Twig_Error_Syntax When there was an error during tokenizing, parsing or compiling
     */
    public function compileSource($source, $name = null)
    {
        try {
            $compiled = $this->compile($this->parse($this->tokenize($source, $name)), $source);

            if (isset($source[0])) {
                $compiled .= '/* '.str_replace(array('*/', "\r\n", "\r", "\n"), array('*//* ', "\n", "\n", "*/\n/* "), $source)."*/\n";
            }

            return $compiled;
        } catch (Twig_Error $e) {
            $e->setTemplateFile($name);
            throw $e;
        } catch (Exception $e) {
            throw new Twig_Error_Syntax(sprintf('An exception has been thrown during the compilation of a template ("%s").', $e->getMessage()), -1, $name, $e);
        }
    }

    /**
     * Sets the Loader instance.
     *
     * @param Twig_LoaderInterface $loader A Twig_LoaderInterface instance
     */
    public function setLoader(Twig_LoaderInterface $loader)
    {
        $this->loader = $loader;
    }

    /**
     * Gets the Loader instance.
     *
     * @return Twig_LoaderInterface A Twig_LoaderInterface instance
     */
    public function getLoader()
    {
        if (null === $this->loader) {
            throw new LogicException('You must set a loader first.');
        }

        return $this->loader;
    }

    /**
     * Sets the default template charset.
     *
     * @param string $charset The default charset
     */
    public function setCharset($charset)
    {
        $this->charset = strtoupper($charset);
    }

    /**
     * Gets the default template charset.
     *
     * @return string The default charset
     */
    public function getCharset()
    {
        return $this->charset;
    }

    /**
     * Initializes the runtime environment.
     *
     * @deprecated since 1.23 (to be removed in 2.0)
     */
    public function initRuntime()
    {
        $this->runtimeInitialized = true;

        foreach ($this->getExtensions() as $name => $extension) {
            if (!$extension instanceof Twig_Extension_InitRuntimeInterface) {
                $m = new ReflectionMethod($extension, 'initRuntime');

                if ('Twig_Extension' !== $m->getDeclaringClass()->getName()) {
                    @trigger_error(sprintf('Defining the initRuntime() method in the "%s" extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).', $name), E_USER_DEPRECATED);
                }
            }

            $extension->initRuntime($this);
        }
    }

    /**
     * Returns true if the given extension is registered.
     *
     * @param string $name The extension name
     *
     * @return bool Whether the extension is registered or not
     */
    public function hasExtension($name)
    {
        return isset($this->extensions[$name]);
    }

    /**
     * Gets an extension by name.
     *
     * @param string $name The extension name
     *
     * @return Twig_ExtensionInterface A Twig_ExtensionInterface instance
     */
    public function getExtension($name)
    {
        if (!isset($this->extensions[$name])) {
            throw new Twig_Error_Runtime(sprintf('The "%s" extension is not enabled.', $name));
        }

        return $this->extensions[$name];
    }

    /**
     * Registers an extension.
     *
     * @param Twig_ExtensionInterface $extension A Twig_ExtensionInterface instance
     */
    public function addExtension(Twig_ExtensionInterface $extension)
    {
        $name = $extension->getName();

        if ($this->extensionInitialized) {
            throw new LogicException(sprintf('Unable to register extension "%s" as extensions have already been initialized.', $name));
        }

        if (isset($this->extensions[$name])) {
            @trigger_error(sprintf('The possibility to register the same extension twice ("%s") is deprecated since version 1.23 and will be removed in Twig 2.0. Use proper PHP inheritance instead.', $name), E_USER_DEPRECATED);
        }

        $this->lastModifiedExtension = 0;

        $this->extensions[$name] = $extension;
    }

    /**
     * Removes an extension by name.
     *
     * This method is deprecated and you should not use it.
     *
     * @param string $name The extension name
     *
     * @deprecated since 1.12 (to be removed in 2.0)
     */
    public function removeExtension($name)
    {
        @trigger_error(sprintf('The %s method is deprecated since version 1.12 and will be removed in Twig 2.0.', __METHOD__), E_USER_DEPRECATED);

        if ($this->extensionInitialized) {
            throw new LogicException(sprintf('Unable to remove extension "%s" as extensions have already been initialized.', $name));
        }

        unset($this->extensions[$name]);
    }

    /**
     * Registers an array of extensions.
     *
     * @param array $extensions An array of extensions
     */
    public function setExtensions(array $extensions)
    {
        foreach ($extensions as $extension) {
            $this->addExtension($extension);
        }
    }

    /**
     * Returns all registered extensions.
     *
     * @return array An array of extensions
     */
    public function getExtensions()
    {
        return $this->extensions;
    }

    /**
     * Registers a Token Parser.
     *
     * @param Twig_TokenParserInterface $parser A Twig_TokenParserInterface instance
     */
    public function addTokenParser(Twig_TokenParserInterface $parser)
    {
        if ($this->extensionInitialized) {
            throw new LogicException('Unable to add a token parser as extensions have already been initialized.');
        }

        $this->staging->addTokenParser($parser);
    }

    /**
     * Gets the registered Token Parsers.
     *
     * @return Twig_TokenParserBrokerInterface A broker containing token parsers
     */
    public function getTokenParsers()
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        return $this->parsers;
    }

    /**
     * Gets registered tags.
     *
     * Be warned that this method cannot return tags defined by Twig_TokenParserBrokerInterface classes.
     *
     * @return Twig_TokenParserInterface[] An array of Twig_TokenParserInterface instances
     */
    public function getTags()
    {
        $tags = array();
        foreach ($this->getTokenParsers()->getParsers() as $parser) {
            if ($parser instanceof Twig_TokenParserInterface) {
                $tags[$parser->getTag()] = $parser;
            }
        }

        return $tags;
    }

    /**
     * Registers a Node Visitor.
     *
     * @param Twig_NodeVisitorInterface $visitor A Twig_NodeVisitorInterface instance
     */
    public function addNodeVisitor(Twig_NodeVisitorInterface $visitor)
    {
        if ($this->extensionInitialized) {
            throw new LogicException('Unable to add a node visitor as extensions have already been initialized.');
        }

        $this->staging->addNodeVisitor($visitor);
    }

    /**
     * Gets the registered Node Visitors.
     *
     * @return Twig_NodeVisitorInterface[] An array of Twig_NodeVisitorInterface instances
     */
    public function getNodeVisitors()
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        return $this->visitors;
    }

    /**
     * Registers a Filter.
     *
     * @param string|Twig_SimpleFilter               $name   The filter name or a Twig_SimpleFilter instance
     * @param Twig_FilterInterface|Twig_SimpleFilter $filter A Twig_FilterInterface instance or a Twig_SimpleFilter instance
     */
    public function addFilter($name, $filter = null)
    {
        if (!$name instanceof Twig_SimpleFilter && !($filter instanceof Twig_SimpleFilter || $filter instanceof Twig_FilterInterface)) {
            throw new LogicException('A filter must be an instance of Twig_FilterInterface or Twig_SimpleFilter');
        }

        if ($name instanceof Twig_SimpleFilter) {
            $filter = $name;
            $name = $filter->getName();
        } else {
            @trigger_error(sprintf('Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleFilter" instead when defining filter "%s".', __METHOD__, $name), E_USER_DEPRECATED);
        }

        if ($this->extensionInitialized) {
            throw new LogicException(sprintf('Unable to add filter "%s" as extensions have already been initialized.', $name));
        }

        $this->staging->addFilter($name, $filter);
    }

    /**
     * Get a filter by name.
     *
     * Subclasses may override this method and load filters differently;
     * so no list of filters is available.
     *
     * @param string $name The filter name
     *
     * @return Twig_Filter|false A Twig_Filter instance or false if the filter does not exist
     */
    public function getFilter($name)
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        if (isset($this->filters[$name])) {
            return $this->filters[$name];
        }

        foreach ($this->filters as $pattern => $filter) {
            $pattern = str_replace('\\*', '(.*?)', preg_quote($pattern, '#'), $count);

            if ($count) {
                if (preg_match('#^'.$pattern.'$#', $name, $matches)) {
                    array_shift($matches);
                    $filter->setArguments($matches);

                    return $filter;
                }
            }
        }

        foreach ($this->filterCallbacks as $callback) {
            if (false !== $filter = call_user_func($callback, $name)) {
                return $filter;
            }
        }

        return false;
    }

    public function registerUndefinedFilterCallback($callable)
    {
        $this->filterCallbacks[] = $callable;
    }

    /**
     * Gets the registered Filters.
     *
     * Be warned that this method cannot return filters defined with registerUndefinedFilterCallback.
     *
     * @return Twig_FilterInterface[] An array of Twig_FilterInterface instances
     *
     * @see registerUndefinedFilterCallback
     */
    public function getFilters()
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        return $this->filters;
    }

    /**
     * Registers a Test.
     *
     * @param string|Twig_SimpleTest             $name The test name or a Twig_SimpleTest instance
     * @param Twig_TestInterface|Twig_SimpleTest $test A Twig_TestInterface instance or a Twig_SimpleTest instance
     */
    public function addTest($name, $test = null)
    {
        if (!$name instanceof Twig_SimpleTest && !($test instanceof Twig_SimpleTest || $test instanceof Twig_TestInterface)) {
            throw new LogicException('A test must be an instance of Twig_TestInterface or Twig_SimpleTest');
        }

        if ($name instanceof Twig_SimpleTest) {
            $test = $name;
            $name = $test->getName();
        } else {
            @trigger_error(sprintf('Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleTest" instead when defining test "%s".', __METHOD__, $name), E_USER_DEPRECATED);
        }

        if ($this->extensionInitialized) {
            throw new LogicException(sprintf('Unable to add test "%s" as extensions have already been initialized.', $name));
        }

        $this->staging->addTest($name, $test);
    }

    /**
     * Gets the registered Tests.
     *
     * @return Twig_TestInterface[] An array of Twig_TestInterface instances
     */
    public function getTests()
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        return $this->tests;
    }

    /**
     * Gets a test by name.
     *
     * @param string $name The test name
     *
     * @return Twig_Test|false A Twig_Test instance or false if the test does not exist
     */
    public function getTest($name)
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        if (isset($this->tests[$name])) {
            return $this->tests[$name];
        }

        return false;
    }

    /**
     * Registers a Function.
     *
     * @param string|Twig_SimpleFunction                 $name     The function name or a Twig_SimpleFunction instance
     * @param Twig_FunctionInterface|Twig_SimpleFunction $function A Twig_FunctionInterface instance or a Twig_SimpleFunction instance
     */
    public function addFunction($name, $function = null)
    {
        if (!$name instanceof Twig_SimpleFunction && !($function instanceof Twig_SimpleFunction || $function instanceof Twig_FunctionInterface)) {
            throw new LogicException('A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction');
        }

        if ($name instanceof Twig_SimpleFunction) {
            $function = $name;
            $name = $function->getName();
        } else {
            @trigger_error(sprintf('Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleFunction" instead when defining function "%s".', __METHOD__, $name), E_USER_DEPRECATED);
        }

        if ($this->extensionInitialized) {
            throw new LogicException(sprintf('Unable to add function "%s" as extensions have already been initialized.', $name));
        }

        $this->staging->addFunction($name, $function);
    }

    /**
     * Get a function by name.
     *
     * Subclasses may override this method and load functions differently;
     * so no list of functions is available.
     *
     * @param string $name function name
     *
     * @return Twig_Function|false A Twig_Function instance or false if the function does not exist
     */
    public function getFunction($name)
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        if (isset($this->functions[$name])) {
            return $this->functions[$name];
        }

        foreach ($this->functions as $pattern => $function) {
            $pattern = str_replace('\\*', '(.*?)', preg_quote($pattern, '#'), $count);

            if ($count) {
                if (preg_match('#^'.$pattern.'$#', $name, $matches)) {
                    array_shift($matches);
                    $function->setArguments($matches);

                    return $function;
                }
            }
        }

        foreach ($this->functionCallbacks as $callback) {
            if (false !== $function = call_user_func($callback, $name)) {
                return $function;
            }
        }

        return false;
    }

    public function registerUndefinedFunctionCallback($callable)
    {
        $this->functionCallbacks[] = $callable;
    }

    /**
     * Gets registered functions.
     *
     * Be warned that this method cannot return functions defined with registerUndefinedFunctionCallback.
     *
     * @return Twig_FunctionInterface[] An array of Twig_FunctionInterface instances
     *
     * @see registerUndefinedFunctionCallback
     */
    public function getFunctions()
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        return $this->functions;
    }

    /**
     * Registers a Global.
     *
     * New globals can be added before compiling or rendering a template;
     * but after, you can only update existing globals.
     *
     * @param string $name  The global name
     * @param mixed  $value The global value
     */
    public function addGlobal($name, $value)
    {
        if ($this->extensionInitialized || $this->runtimeInitialized) {
            if (null === $this->globals) {
                $this->globals = $this->initGlobals();
            }

            if (!array_key_exists($name, $this->globals)) {
                // The deprecation notice must be turned into the following exception in Twig 2.0
                @trigger_error(sprintf('Registering global variable "%s" at runtime or when the extensions have already been initialized is deprecated since version 1.21.', $name), E_USER_DEPRECATED);
                //throw new LogicException(sprintf('Unable to add global "%s" as the runtime or the extensions have already been initialized.', $name));
            }
        }

        if ($this->extensionInitialized || $this->runtimeInitialized) {
            // update the value
            $this->globals[$name] = $value;
        } else {
            $this->staging->addGlobal($name, $value);
        }
    }

    /**
     * Gets the registered Globals.
     *
     * @return array An array of globals
     */
    public function getGlobals()
    {
        if (!$this->runtimeInitialized && !$this->extensionInitialized) {
            return $this->initGlobals();
        }

        if (null === $this->globals) {
            $this->globals = $this->initGlobals();
        }

        return $this->globals;
    }

    /**
     * Merges a context with the defined globals.
     *
     * @param array $context An array representing the context
     *
     * @return array The context merged with the globals
     */
    public function mergeGlobals(array $context)
    {
        // we don't use array_merge as the context being generally
        // bigger than globals, this code is faster.
        foreach ($this->getGlobals() as $key => $value) {
            if (!array_key_exists($key, $context)) {
                $context[$key] = $value;
            }
        }

        return $context;
    }

    /**
     * Gets the registered unary Operators.
     *
     * @return array An array of unary operators
     */
    public function getUnaryOperators()
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        return $this->unaryOperators;
    }

    /**
     * Gets the registered binary Operators.
     *
     * @return array An array of binary operators
     */
    public function getBinaryOperators()
    {
        if (!$this->extensionInitialized) {
            $this->initExtensions();
        }

        return $this->binaryOperators;
    }

    /**
     * @deprecated since 1.23 (to be removed in 2.0)
     */
    public function computeAlternatives($name, $items)
    {
        @trigger_error(sprintf('The %s method is deprecated since version 1.23 and will be removed in Twig 2.0.', __METHOD__), E_USER_DEPRECATED);

        return Twig_Error_Syntax::computeAlternatives($name, $items);
    }

    protected function initGlobals()
    {
        $globals = array();
        foreach ($this->extensions as $name => $extension) {
            if (!$extension instanceof Twig_Extension_GlobalsInterface) {
                $m = new ReflectionMethod($extension, 'getGlobals');

                if ('Twig_Extension' !== $m->getDeclaringClass()->getName()) {
                    @trigger_error(sprintf('Defining the getGlobals() method in the "%s" extension without explicitly implementing Twig_Extension_GlobalsInterface is deprecated since version 1.23.', $name), E_USER_DEPRECATED);
                }
            }

            $extGlob = $extension->getGlobals();
            if (!is_array($extGlob)) {
                throw new UnexpectedValueException(sprintf('"%s::getGlobals()" must return an array of globals.', get_class($extension)));
            }

            $globals[] = $extGlob;
        }

        $globals[] = $this->staging->getGlobals();

        return call_user_func_array('array_merge', $globals);
    }

    protected function initExtensions()
    {
        if ($this->extensionInitialized) {
            return;
        }

        $this->extensionInitialized = true;
        $this->parsers = new Twig_TokenParserBroker(array(), array(), false);
        $this->filters = array();
        $this->functions = array();
        $this->tests = array();
        $this->visitors = array();
        $this->unaryOperators = array();
        $this->binaryOperators = array();

        foreach ($this->extensions as $extension) {
            $this->initExtension($extension);
        }
        $this->initExtension($this->staging);
    }

    protected function initExtension(Twig_ExtensionInterface $extension)
    {
        // filters
        foreach ($extension->getFilters() as $name => $filter) {
            if ($filter instanceof Twig_SimpleFilter) {
                $name = $filter->getName();
            } else {
                @trigger_error(sprintf('Using an instance of "%s" for filter "%s" is deprecated since version 1.21. Use Twig_SimpleFilter instead.', get_class($filter), $name), E_USER_DEPRECATED);
            }

            $this->filters[$name] = $filter;
        }

        // functions
        foreach ($extension->getFunctions() as $name => $function) {
            if ($function instanceof Twig_SimpleFunction) {
                $name = $function->getName();
            } else {
                @trigger_error(sprintf('Using an instance of "%s" for function "%s" is deprecated since version 1.21. Use Twig_SimpleFunction instead.', get_class($function), $name), E_USER_DEPRECATED);
            }

            $this->functions[$name] = $function;
        }

        // tests
        foreach ($extension->getTests() as $name => $test) {
            if ($test instanceof Twig_SimpleTest) {
                $name = $test->getName();
            } else {
                @trigger_error(sprintf('Using an instance of "%s" for test "%s" is deprecated since version 1.21. Use Twig_SimpleTest instead.', get_class($test), $name), E_USER_DEPRECATED);
            }

            $this->tests[$name] = $test;
        }

        // token parsers
        foreach ($extension->getTokenParsers() as $parser) {
            if ($parser instanceof Twig_TokenParserInterface) {
                $this->parsers->addTokenParser($parser);
            } elseif ($parser instanceof Twig_TokenParserBrokerInterface) {
                @trigger_error('Registering a Twig_TokenParserBrokerInterface instance is deprecated since version 1.21.', E_USER_DEPRECATED);

                $this->parsers->addTokenParserBroker($parser);
            } else {
                throw new LogicException('getTokenParsers() must return an array of Twig_TokenParserInterface or Twig_TokenParserBrokerInterface instances');
            }
        }

        // node visitors
        foreach ($extension->getNodeVisitors() as $visitor) {
            $this->visitors[] = $visitor;
        }

        // operators
        if ($operators = $extension->getOperators()) {
            if (2 !== count($operators)) {
                throw new InvalidArgumentException(sprintf('"%s::getOperators()" does not return a valid operators array.', get_class($extension)));
            }

            $this->unaryOperators = array_merge($this->unaryOperators, $operators[0]);
            $this->binaryOperators = array_merge($this->binaryOperators, $operators[1]);
        }
    }

    /**
     * @deprecated since 1.22 (to be removed in 2.0)
     */
    protected function writeCacheFile($file, $content)
    {
        $this->cache->write($file, $content);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Exception thrown when an error occurs during template loading.
 *
 * Automatic template information guessing is always turned off as
 * if a template cannot be loaded, there is nothing to guess.
 * However, when a template is loaded from another one, then, we need
 * to find the current context and this is automatically done by
 * Twig_Template::displayWithErrorHandling().
 *
 * This strategy makes Twig_Environment::resolveTemplate() much faster.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Error_Loader extends Twig_Error
{
    public function __construct($message, $lineno = -1, $filename = null, Exception $previous = null)
    {
        parent::__construct($message, false, false, $previous);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Exception thrown when an error occurs at runtime.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Error_Runtime extends Twig_Error
{
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Exception thrown when a syntax error occurs during lexing or parsing of a template.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Error_Syntax extends Twig_Error
{
    /**
     * Tweaks the error message to include suggestions.
     *
     * @param string $name  The original name of the item that does not exist
     * @param array  $items An array of possible items
     */
    public function addSuggestions($name, array $items)
    {
        if (!$alternatives = self::computeAlternatives($name, $items)) {
            return;
        }

        $this->appendMessage(sprintf(' Did you mean "%s"?', implode('", "', $alternatives)));
    }

    /**
     * @internal
     *
     * To be merged with the addSuggestions() method in 2.0.
     */
    public static function computeAlternatives($name, $items)
    {
        $alternatives = array();
        foreach ($items as $item) {
            $lev = levenshtein($name, $item);
            if ($lev <= strlen($name) / 3 || false !== strpos($item, $name)) {
                $alternatives[$item] = $lev;
            }
        }
        asort($alternatives);

        return array_keys($alternatives);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Twig base exception.
 *
 * This exception class and its children must only be used when
 * an error occurs during the loading of a template, when a syntax error
 * is detected in a template, or when rendering a template. Other
 * errors must use regular PHP exception classes (like when the template
 * cache directory is not writable for instance).
 *
 * To help debugging template issues, this class tracks the original template
 * name and line where the error occurred.
 *
 * Whenever possible, you must set these information (original template name
 * and line number) yourself by passing them to the constructor. If some or all
 * these information are not available from where you throw the exception, then
 * this class will guess them automatically (when the line number is set to -1
 * and/or the filename is set to null). As this is a costly operation, this
 * can be disabled by passing false for both the filename and the line number
 * when creating a new instance of this class.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Error extends Exception
{
    protected $lineno;
    protected $filename;
    protected $rawMessage;
    protected $previous;

    /**
     * Constructor.
     *
     * Set both the line number and the filename to false to
     * disable automatic guessing of the original template name
     * and line number.
     *
     * Set the line number to -1 to enable its automatic guessing.
     * Set the filename to null to enable its automatic guessing.
     *
     * By default, automatic guessing is enabled.
     *
     * @param string    $message  The error message
     * @param int       $lineno   The template line where the error occurred
     * @param string    $filename The template file name where the error occurred
     * @param Exception $previous The previous exception
     */
    public function __construct($message, $lineno = -1, $filename = null, Exception $previous = null)
    {
        if (PHP_VERSION_ID < 50300) {
            $this->previous = $previous;
            parent::__construct('');
        } else {
            parent::__construct('', 0, $previous);
        }

        $this->lineno = $lineno;
        $this->filename = $filename;

        if (-1 === $this->lineno || null === $this->filename) {
            $this->guessTemplateInfo();
        }

        $this->rawMessage = $message;

        $this->updateRepr();
    }

    /**
     * Gets the raw message.
     *
     * @return string The raw message
     */
    public function getRawMessage()
    {
        return $this->rawMessage;
    }

    /**
     * Gets the filename where the error occurred.
     *
     * @return string The filename
     */
    public function getTemplateFile()
    {
        return $this->filename;
    }

    /**
     * Sets the filename where the error occurred.
     *
     * @param string $filename The filename
     */
    public function setTemplateFile($filename)
    {
        $this->filename = $filename;

        $this->updateRepr();
    }

    /**
     * Gets the template line where the error occurred.
     *
     * @return int The template line
     */
    public function getTemplateLine()
    {
        return $this->lineno;
    }

    /**
     * Sets the template line where the error occurred.
     *
     * @param int $lineno The template line
     */
    public function setTemplateLine($lineno)
    {
        $this->lineno = $lineno;

        $this->updateRepr();
    }

    public function guess()
    {
        $this->guessTemplateInfo();
        $this->updateRepr();
    }

    /**
     * For PHP < 5.3.0, provides access to the getPrevious() method.
     *
     * @param string $method    The method name
     * @param array  $arguments The parameters to be passed to the method
     *
     * @return Exception The previous exception or null
     *
     * @throws BadMethodCallException
     */
    public function __call($method, $arguments)
    {
        if ('getprevious' == strtolower($method)) {
            return $this->previous;
        }

        throw new BadMethodCallException(sprintf('Method "Twig_Error::%s()" does not exist.', $method));
    }

    public function appendMessage($rawMessage)
    {
        $this->rawMessage .= $rawMessage;
        $this->updateRepr();
    }

    /**
     * @internal
     */
    protected function updateRepr()
    {
        $this->message = $this->rawMessage;

        $dot = false;
        if ('.' === substr($this->message, -1)) {
            $this->message = substr($this->message, 0, -1);
            $dot = true;
        }

        $questionMark = false;
        if ('?' === substr($this->message, -1)) {
            $this->message = substr($this->message, 0, -1);
            $questionMark = true;
        }

        if ($this->filename) {
            if (is_string($this->filename) || (is_object($this->filename) && method_exists($this->filename, '__toString'))) {
                $filename = sprintf('"%s"', $this->filename);
            } else {
                $filename = json_encode($this->filename);
            }
            $this->message .= sprintf(' in %s', $filename);
        }

        if ($this->lineno && $this->lineno >= 0) {
            $this->message .= sprintf(' at line %d', $this->lineno);
        }

        if ($dot) {
            $this->message .= '.';
        }

        if ($questionMark) {
            $this->message .= '?';
        }
    }

    /**
     * @internal
     */
    protected function guessTemplateInfo()
    {
        $template = null;
        $templateClass = null;

        if (PHP_VERSION_ID >= 50306) {
            $backtrace = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT);
        } else {
            $backtrace = debug_backtrace();
        }

        foreach ($backtrace as $trace) {
            if (isset($trace['object']) && $trace['object'] instanceof Twig_Template && 'Twig_Template' !== get_class($trace['object'])) {
                $currentClass = get_class($trace['object']);
                $isEmbedContainer = 0 === strpos($templateClass, $currentClass);
                if (null === $this->filename || ($this->filename == $trace['object']->getTemplateName() && !$isEmbedContainer)) {
                    $template = $trace['object'];
                    $templateClass = get_class($trace['object']);
                }
            }
        }

        // update template filename
        if (null !== $template && null === $this->filename) {
            $this->filename = $template->getTemplateName();
        }

        if (null === $template || $this->lineno > -1) {
            return;
        }

        $r = new ReflectionObject($template);
        $file = $r->getFileName();

        // hhvm has a bug where eval'ed files comes out as the current directory
        if (is_dir($file)) {
            $file = '';
        }

        $exceptions = array($e = $this);
        while (($e instanceof self || method_exists($e, 'getPrevious')) && $e = $e->getPrevious()) {
            $exceptions[] = $e;
        }

        while ($e = array_pop($exceptions)) {
            $traces = $e->getTrace();
            array_unshift($traces, array('file' => $e->getFile(), 'line' => $e->getLine()));

            while ($trace = array_shift($traces)) {
                if (!isset($trace['file']) || !isset($trace['line']) || $file != $trace['file']) {
                    continue;
                }

                foreach ($template->getDebugInfo() as $codeLine => $templateLine) {
                    if ($codeLine <= $trace['line']) {
                        // update template line
                        $this->lineno = $templateLine;

                        return;
                    }
                }
            }
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Adds an exists() method for loaders.
 *
 * @author Florin Patan <florinpatan@gmail.com>
 *
 * @deprecated since 1.12 (to be removed in 3.0)
 */
interface Twig_ExistsLoaderInterface
{
    /**
     * Check if we have the source code of a template, given its name.
     *
     * @param string $name The name of the template to check if we can load
     *
     * @return bool If the template source code is handled by this loader or not
     */
    public function exists($name);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Parses expressions.
 *
 * This parser implements a "Precedence climbing" algorithm.
 *
 * @see http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm
 * @see http://en.wikipedia.org/wiki/Operator-precedence_parser
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_ExpressionParser
{
    const OPERATOR_LEFT = 1;
    const OPERATOR_RIGHT = 2;

    protected $parser;
    protected $unaryOperators;
    protected $binaryOperators;

    public function __construct(Twig_Parser $parser, array $unaryOperators, array $binaryOperators)
    {
        $this->parser = $parser;
        $this->unaryOperators = $unaryOperators;
        $this->binaryOperators = $binaryOperators;
    }

    public function parseExpression($precedence = 0)
    {
        $expr = $this->getPrimary();
        $token = $this->parser->getCurrentToken();
        while ($this->isBinary($token) && $this->binaryOperators[$token->getValue()]['precedence'] >= $precedence) {
            $op = $this->binaryOperators[$token->getValue()];
            $this->parser->getStream()->next();

            if (isset($op['callable'])) {
                $expr = call_user_func($op['callable'], $this->parser, $expr);
            } else {
                $expr1 = $this->parseExpression(self::OPERATOR_LEFT === $op['associativity'] ? $op['precedence'] + 1 : $op['precedence']);
                $class = $op['class'];
                $expr = new $class($expr, $expr1, $token->getLine());
            }

            $token = $this->parser->getCurrentToken();
        }

        if (0 === $precedence) {
            return $this->parseConditionalExpression($expr);
        }

        return $expr;
    }

    protected function getPrimary()
    {
        $token = $this->parser->getCurrentToken();

        if ($this->isUnary($token)) {
            $operator = $this->unaryOperators[$token->getValue()];
            $this->parser->getStream()->next();
            $expr = $this->parseExpression($operator['precedence']);
            $class = $operator['class'];

            return $this->parsePostfixExpression(new $class($expr, $token->getLine()));
        } elseif ($token->test(Twig_Token::PUNCTUATION_TYPE, '(')) {
            $this->parser->getStream()->next();
            $expr = $this->parseExpression();
            $this->parser->getStream()->expect(Twig_Token::PUNCTUATION_TYPE, ')', 'An opened parenthesis is not properly closed');

            return $this->parsePostfixExpression($expr);
        }

        return $this->parsePrimaryExpression();
    }

    protected function parseConditionalExpression($expr)
    {
        while ($this->parser->getStream()->nextIf(Twig_Token::PUNCTUATION_TYPE, '?')) {
            if (!$this->parser->getStream()->nextIf(Twig_Token::PUNCTUATION_TYPE, ':')) {
                $expr2 = $this->parseExpression();
                if ($this->parser->getStream()->nextIf(Twig_Token::PUNCTUATION_TYPE, ':')) {
                    $expr3 = $this->parseExpression();
                } else {
                    $expr3 = new Twig_Node_Expression_Constant('', $this->parser->getCurrentToken()->getLine());
                }
            } else {
                $expr2 = $expr;
                $expr3 = $this->parseExpression();
            }

            $expr = new Twig_Node_Expression_Conditional($expr, $expr2, $expr3, $this->parser->getCurrentToken()->getLine());
        }

        return $expr;
    }

    protected function isUnary(Twig_Token $token)
    {
        return $token->test(Twig_Token::OPERATOR_TYPE) && isset($this->unaryOperators[$token->getValue()]);
    }

    protected function isBinary(Twig_Token $token)
    {
        return $token->test(Twig_Token::OPERATOR_TYPE) && isset($this->binaryOperators[$token->getValue()]);
    }

    public function parsePrimaryExpression()
    {
        $token = $this->parser->getCurrentToken();
        switch ($token->getType()) {
            case Twig_Token::NAME_TYPE:
                $this->parser->getStream()->next();
                switch ($token->getValue()) {
                    case 'true':
                    case 'TRUE':
                        $node = new Twig_Node_Expression_Constant(true, $token->getLine());
                        break;

                    case 'false':
                    case 'FALSE':
                        $node = new Twig_Node_Expression_Constant(false, $token->getLine());
                        break;

                    case 'none':
                    case 'NONE':
                    case 'null':
                    case 'NULL':
                        $node = new Twig_Node_Expression_Constant(null, $token->getLine());
                        break;

                    default:
                        if ('(' === $this->parser->getCurrentToken()->getValue()) {
                            $node = $this->getFunctionNode($token->getValue(), $token->getLine());
                        } else {
                            $node = new Twig_Node_Expression_Name($token->getValue(), $token->getLine());
                        }
                }
                break;

            case Twig_Token::NUMBER_TYPE:
                $this->parser->getStream()->next();
                $node = new Twig_Node_Expression_Constant($token->getValue(), $token->getLine());
                break;

            case Twig_Token::STRING_TYPE:
            case Twig_Token::INTERPOLATION_START_TYPE:
                $node = $this->parseStringExpression();
                break;

            case Twig_Token::OPERATOR_TYPE:
                if (preg_match(Twig_Lexer::REGEX_NAME, $token->getValue(), $matches) && $matches[0] == $token->getValue()) {
                    // in this context, string operators are variable names
                    $this->parser->getStream()->next();
                    $node = new Twig_Node_Expression_Name($token->getValue(), $token->getLine());
                    break;
                } elseif (isset($this->unaryOperators[$token->getValue()])) {
                    $class = $this->unaryOperators[$token->getValue()]['class'];

                    $ref = new ReflectionClass($class);
                    $negClass = 'Twig_Node_Expression_Unary_Neg';
                    $posClass = 'Twig_Node_Expression_Unary_Pos';
                    if (!(in_array($ref->getName(), array($negClass, $posClass)) || $ref->isSubclassOf($negClass) || $ref->isSubclassOf($posClass))) {
                        throw new Twig_Error_Syntax(sprintf('Unexpected unary operator "%s".', $token->getValue()), $token->getLine(), $this->parser->getFilename());
                    }

                    $this->parser->getStream()->next();
                    $expr = $this->parsePrimaryExpression();

                    $node = new $class($expr, $token->getLine());
                    break;
                }

            default:
                if ($token->test(Twig_Token::PUNCTUATION_TYPE, '[')) {
                    $node = $this->parseArrayExpression();
                } elseif ($token->test(Twig_Token::PUNCTUATION_TYPE, '{')) {
                    $node = $this->parseHashExpression();
                } else {
                    throw new Twig_Error_Syntax(sprintf('Unexpected token "%s" of value "%s".', Twig_Token::typeToEnglish($token->getType()), $token->getValue()), $token->getLine(), $this->parser->getFilename());
                }
        }

        return $this->parsePostfixExpression($node);
    }

    public function parseStringExpression()
    {
        $stream = $this->parser->getStream();

        $nodes = array();
        // a string cannot be followed by another string in a single expression
        $nextCanBeString = true;
        while (true) {
            if ($nextCanBeString && $token = $stream->nextIf(Twig_Token::STRING_TYPE)) {
                $nodes[] = new Twig_Node_Expression_Constant($token->getValue(), $token->getLine());
                $nextCanBeString = false;
            } elseif ($stream->nextIf(Twig_Token::INTERPOLATION_START_TYPE)) {
                $nodes[] = $this->parseExpression();
                $stream->expect(Twig_Token::INTERPOLATION_END_TYPE);
                $nextCanBeString = true;
            } else {
                break;
            }
        }

        $expr = array_shift($nodes);
        foreach ($nodes as $node) {
            $expr = new Twig_Node_Expression_Binary_Concat($expr, $node, $node->getLine());
        }

        return $expr;
    }

    public function parseArrayExpression()
    {
        $stream = $this->parser->getStream();
        $stream->expect(Twig_Token::PUNCTUATION_TYPE, '[', 'An array element was expected');

        $node = new Twig_Node_Expression_Array(array(), $stream->getCurrent()->getLine());
        $first = true;
        while (!$stream->test(Twig_Token::PUNCTUATION_TYPE, ']')) {
            if (!$first) {
                $stream->expect(Twig_Token::PUNCTUATION_TYPE, ',', 'An array element must be followed by a comma');

                // trailing ,?
                if ($stream->test(Twig_Token::PUNCTUATION_TYPE, ']')) {
                    break;
                }
            }
            $first = false;

            $node->addElement($this->parseExpression());
        }
        $stream->expect(Twig_Token::PUNCTUATION_TYPE, ']', 'An opened array is not properly closed');

        return $node;
    }

    public function parseHashExpression()
    {
        $stream = $this->parser->getStream();
        $stream->expect(Twig_Token::PUNCTUATION_TYPE, '{', 'A hash element was expected');

        $node = new Twig_Node_Expression_Array(array(), $stream->getCurrent()->getLine());
        $first = true;
        while (!$stream->test(Twig_Token::PUNCTUATION_TYPE, '}')) {
            if (!$first) {
                $stream->expect(Twig_Token::PUNCTUATION_TYPE, ',', 'A hash value must be followed by a comma');

                // trailing ,?
                if ($stream->test(Twig_Token::PUNCTUATION_TYPE, '}')) {
                    break;
                }
            }
            $first = false;

            // a hash key can be:
            //
            //  * a number -- 12
            //  * a string -- 'a'
            //  * a name, which is equivalent to a string -- a
            //  * an expression, which must be enclosed in parentheses -- (1 + 2)
            if (($token = $stream->nextIf(Twig_Token::STRING_TYPE)) || ($token = $stream->nextIf(Twig_Token::NAME_TYPE)) || $token = $stream->nextIf(Twig_Token::NUMBER_TYPE)) {
                $key = new Twig_Node_Expression_Constant($token->getValue(), $token->getLine());
            } elseif ($stream->test(Twig_Token::PUNCTUATION_TYPE, '(')) {
                $key = $this->parseExpression();
            } else {
                $current = $stream->getCurrent();

                throw new Twig_Error_Syntax(sprintf('A hash key must be a quoted string, a number, a name, or an expression enclosed in parentheses (unexpected token "%s" of value "%s".', Twig_Token::typeToEnglish($current->getType()), $current->getValue()), $current->getLine(), $this->parser->getFilename());
            }

            $stream->expect(Twig_Token::PUNCTUATION_TYPE, ':', 'A hash key must be followed by a colon (:)');
            $value = $this->parseExpression();

            $node->addElement($value, $key);
        }
        $stream->expect(Twig_Token::PUNCTUATION_TYPE, '}', 'An opened hash is not properly closed');

        return $node;
    }

    public function parsePostfixExpression($node)
    {
        while (true) {
            $token = $this->parser->getCurrentToken();
            if ($token->getType() == Twig_Token::PUNCTUATION_TYPE) {
                if ('.' == $token->getValue() || '[' == $token->getValue()) {
                    $node = $this->parseSubscriptExpression($node);
                } elseif ('|' == $token->getValue()) {
                    $node = $this->parseFilterExpression($node);
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        return $node;
    }

    public function getFunctionNode($name, $line)
    {
        switch ($name) {
            case 'parent':
                $this->parseArguments();
                if (!count($this->parser->getBlockStack())) {
                    throw new Twig_Error_Syntax('Calling "parent" outside a block is forbidden.', $line, $this->parser->getFilename());
                }

                if (!$this->parser->getParent() && !$this->parser->hasTraits()) {
                    throw new Twig_Error_Syntax('Calling "parent" on a template that does not extend nor "use" another template is forbidden.', $line, $this->parser->getFilename());
                }

                return new Twig_Node_Expression_Parent($this->parser->peekBlockStack(), $line);
            case 'block':
                return new Twig_Node_Expression_BlockReference($this->parseArguments()->getNode(0), false, $line);
            case 'attribute':
                $args = $this->parseArguments();
                if (count($args) < 2) {
                    throw new Twig_Error_Syntax('The "attribute" function takes at least two arguments (the variable and the attributes).', $line, $this->parser->getFilename());
                }

                return new Twig_Node_Expression_GetAttr($args->getNode(0), $args->getNode(1), count($args) > 2 ? $args->getNode(2) : null, Twig_Template::ANY_CALL, $line);
            default:
                if (null !== $alias = $this->parser->getImportedSymbol('function', $name)) {
                    $arguments = new Twig_Node_Expression_Array(array(), $line);
                    foreach ($this->parseArguments() as $n) {
                        $arguments->addElement($n);
                    }

                    $node = new Twig_Node_Expression_MethodCall($alias['node'], $alias['name'], $arguments, $line);
                    $node->setAttribute('safe', true);

                    return $node;
                }

                $args = $this->parseArguments(true);
                $class = $this->getFunctionNodeClass($name, $line);

                return new $class($name, $args, $line);
        }
    }

    public function parseSubscriptExpression($node)
    {
        $stream = $this->parser->getStream();
        $token = $stream->next();
        $lineno = $token->getLine();
        $arguments = new Twig_Node_Expression_Array(array(), $lineno);
        $type = Twig_Template::ANY_CALL;
        if ($token->getValue() == '.') {
            $token = $stream->next();
            if (
                $token->getType() == Twig_Token::NAME_TYPE
                ||
                $token->getType() == Twig_Token::NUMBER_TYPE
                ||
                ($token->getType() == Twig_Token::OPERATOR_TYPE && preg_match(Twig_Lexer::REGEX_NAME, $token->getValue()))
            ) {
                $arg = new Twig_Node_Expression_Constant($token->getValue(), $lineno);

                if ($stream->test(Twig_Token::PUNCTUATION_TYPE, '(')) {
                    $type = Twig_Template::METHOD_CALL;
                    foreach ($this->parseArguments() as $n) {
                        $arguments->addElement($n);
                    }
                }
            } else {
                throw new Twig_Error_Syntax('Expected name or number', $lineno, $this->parser->getFilename());
            }

            if ($node instanceof Twig_Node_Expression_Name && null !== $this->parser->getImportedSymbol('template', $node->getAttribute('name'))) {
                if (!$arg instanceof Twig_Node_Expression_Constant) {
                    throw new Twig_Error_Syntax(sprintf('Dynamic macro names are not supported (called on "%s").', $node->getAttribute('name')), $token->getLine(), $this->parser->getFilename());
                }

                $name = $arg->getAttribute('value');

                if ($this->parser->isReservedMacroName($name)) {
                    throw new Twig_Error_Syntax(sprintf('"%s" cannot be called as macro as it is a reserved keyword.', $name), $token->getLine(), $this->parser->getFilename());
                }

                $node = new Twig_Node_Expression_MethodCall($node, 'get'.$name, $arguments, $lineno);
                $node->setAttribute('safe', true);

                return $node;
            }
        } else {
            $type = Twig_Template::ARRAY_CALL;

            // slice?
            $slice = false;
            if ($stream->test(Twig_Token::PUNCTUATION_TYPE, ':')) {
                $slice = true;
                $arg = new Twig_Node_Expression_Constant(0, $token->getLine());
            } else {
                $arg = $this->parseExpression();
            }

            if ($stream->nextIf(Twig_Token::PUNCTUATION_TYPE, ':')) {
                $slice = true;
            }

            if ($slice) {
                if ($stream->test(Twig_Token::PUNCTUATION_TYPE, ']')) {
                    $length = new Twig_Node_Expression_Constant(null, $token->getLine());
                } else {
                    $length = $this->parseExpression();
                }

                $class = $this->getFilterNodeClass('slice', $token->getLine());
                $arguments = new Twig_Node(array($arg, $length));
                $filter = new $class($node, new Twig_Node_Expression_Constant('slice', $token->getLine()), $arguments, $token->getLine());

                $stream->expect(Twig_Token::PUNCTUATION_TYPE, ']');

                return $filter;
            }

            $stream->expect(Twig_Token::PUNCTUATION_TYPE, ']');
        }

        return new Twig_Node_Expression_GetAttr($node, $arg, $arguments, $type, $lineno);
    }

    public function parseFilterExpression($node)
    {
        $this->parser->getStream()->next();

        return $this->parseFilterExpressionRaw($node);
    }

    public function parseFilterExpressionRaw($node, $tag = null)
    {
        while (true) {
            $token = $this->parser->getStream()->expect(Twig_Token::NAME_TYPE);

            $name = new Twig_Node_Expression_Constant($token->getValue(), $token->getLine());
            if (!$this->parser->getStream()->test(Twig_Token::PUNCTUATION_TYPE, '(')) {
                $arguments = new Twig_Node();
            } else {
                $arguments = $this->parseArguments(true);
            }

            $class = $this->getFilterNodeClass($name->getAttribute('value'), $token->getLine());

            $node = new $class($node, $name, $arguments, $token->getLine(), $tag);

            if (!$this->parser->getStream()->test(Twig_Token::PUNCTUATION_TYPE, '|')) {
                break;
            }

            $this->parser->getStream()->next();
        }

        return $node;
    }

    /**
     * Parses arguments.
     *
     * @param bool $namedArguments Whether to allow named arguments or not
     * @param bool $definition     Whether we are parsing arguments for a function definition
     *
     * @return Twig_Node
     *
     * @throws Twig_Error_Syntax
     */
    public function parseArguments($namedArguments = false, $definition = false)
    {
        $args = array();
        $stream = $this->parser->getStream();

        $stream->expect(Twig_Token::PUNCTUATION_TYPE, '(', 'A list of arguments must begin with an opening parenthesis');
        while (!$stream->test(Twig_Token::PUNCTUATION_TYPE, ')')) {
            if (!empty($args)) {
                $stream->expect(Twig_Token::PUNCTUATION_TYPE, ',', 'Arguments must be separated by a comma');
            }

            if ($definition) {
                $token = $stream->expect(Twig_Token::NAME_TYPE, null, 'An argument must be a name');
                $value = new Twig_Node_Expression_Name($token->getValue(), $this->parser->getCurrentToken()->getLine());
            } else {
                $value = $this->parseExpression();
            }

            $name = null;
            if ($namedArguments && $token = $stream->nextIf(Twig_Token::OPERATOR_TYPE, '=')) {
                if (!$value instanceof Twig_Node_Expression_Name) {
                    throw new Twig_Error_Syntax(sprintf('A parameter name must be a string, "%s" given.', get_class($value)), $token->getLine(), $this->parser->getFilename());
                }
                $name = $value->getAttribute('name');

                if ($definition) {
                    $value = $this->parsePrimaryExpression();

                    if (!$this->checkConstantExpression($value)) {
                        throw new Twig_Error_Syntax(sprintf('A default value for an argument must be a constant (a boolean, a string, a number, or an array).'), $token->getLine(), $this->parser->getFilename());
                    }
                } else {
                    $value = $this->parseExpression();
                }
            }

            if ($definition) {
                if (null === $name) {
                    $name = $value->getAttribute('name');
                    $value = new Twig_Node_Expression_Constant(null, $this->parser->getCurrentToken()->getLine());
                }
                $args[$name] = $value;
            } else {
                if (null === $name) {
                    $args[] = $value;
                } else {
                    $args[$name] = $value;
                }
            }
        }
        $stream->expect(Twig_Token::PUNCTUATION_TYPE, ')', 'A list of arguments must be closed by a parenthesis');

        return new Twig_Node($args);
    }

    public function parseAssignmentExpression()
    {
        $targets = array();
        while (true) {
            $token = $this->parser->getStream()->expect(Twig_Token::NAME_TYPE, null, 'Only variables can be assigned to');
            if (in_array($token->getValue(), array('true', 'false', 'none'))) {
                throw new Twig_Error_Syntax(sprintf('You cannot assign a value to "%s".', $token->getValue()), $token->getLine(), $this->parser->getFilename());
            }
            $targets[] = new Twig_Node_Expression_AssignName($token->getValue(), $token->getLine());

            if (!$this->parser->getStream()->nextIf(Twig_Token::PUNCTUATION_TYPE, ',')) {
                break;
            }
        }

        return new Twig_Node($targets);
    }

    public function parseMultitargetExpression()
    {
        $targets = array();
        while (true) {
            $targets[] = $this->parseExpression();
            if (!$this->parser->getStream()->nextIf(Twig_Token::PUNCTUATION_TYPE, ',')) {
                break;
            }
        }

        return new Twig_Node($targets);
    }

    protected function getFunctionNodeClass($name, $line)
    {
        $env = $this->parser->getEnvironment();

        if (false === $function = $env->getFunction($name)) {
            $e = new Twig_Error_Syntax(sprintf('Unknown "%s" function.', $name), $line, $this->parser->getFilename());
            $e->addSuggestions($name, array_keys($env->getFunctions()));

            throw $e;
        }

        if ($function instanceof Twig_SimpleFunction && $function->isDeprecated()) {
            $message = sprintf('Twig Function "%s" is deprecated', $function->getName());
            if (!is_bool($function->getDeprecatedVersion())) {
                $message .= sprintf(' since version %s', $function->getDeprecatedVersion());
            }
            if ($function->getAlternative()) {
                $message .= sprintf('. Use "%s" instead', $function->getAlternative());
            }
            $message .= sprintf(' in %s at line %d.', $this->parser->getFilename(), $line);

            @trigger_error($message, E_USER_DEPRECATED);
        }

        if ($function instanceof Twig_SimpleFunction) {
            return $function->getNodeClass();
        }

        return $function instanceof Twig_Function_Node ? $function->getClass() : 'Twig_Node_Expression_Function';
    }

    protected function getFilterNodeClass($name, $line)
    {
        $env = $this->parser->getEnvironment();

        if (false === $filter = $env->getFilter($name)) {
            $e = new Twig_Error_Syntax(sprintf('Unknown "%s" filter.', $name), $line, $this->parser->getFilename());
            $e->addSuggestions($name, array_keys($env->getFilters()));

            throw $e;
        }

        if ($filter instanceof Twig_SimpleFilter && $filter->isDeprecated()) {
            $message = sprintf('Twig Filter "%s" is deprecated', $filter->getName());
            if (!is_bool($filter->getDeprecatedVersion())) {
                $message .= sprintf(' since version %s', $filter->getDeprecatedVersion());
            }
            if ($filter->getAlternative()) {
                $message .= sprintf('. Use "%s" instead', $filter->getAlternative());
            }
            $message .= sprintf(' in %s at line %d.', $this->parser->getFilename(), $line);

            @trigger_error($message, E_USER_DEPRECATED);
        }

        if ($filter instanceof Twig_SimpleFilter) {
            return $filter->getNodeClass();
        }

        return $filter instanceof Twig_Filter_Node ? $filter->getClass() : 'Twig_Node_Expression_Filter';
    }

    // checks that the node only contains "constant" elements
    protected function checkConstantExpression(Twig_NodeInterface $node)
    {
        if (!($node instanceof Twig_Node_Expression_Constant || $node instanceof Twig_Node_Expression_Array
            || $node instanceof Twig_Node_Expression_Unary_Neg || $node instanceof Twig_Node_Expression_Unary_Pos
        )) {
            return false;
        }

        foreach ($node as $n) {
            if (!$this->checkConstantExpression($n)) {
                return false;
            }
        }

        return true;
    }
}
<?php

if (!defined('ENT_SUBSTITUTE')) {
    // use 0 as hhvm does not support several flags yet
    define('ENT_SUBSTITUTE', 0);
}

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Extension_Core extends Twig_Extension
{
    protected $dateFormats = array('F j, Y H:i', '%d days');
    protected $numberFormat = array(0, '.', ',');
    protected $timezone = null;
    protected $escapers = array();

    /**
     * Defines a new escaper to be used via the escape filter.
     *
     * @param string   $strategy The strategy name that should be used as a strategy in the escape call
     * @param callable $callable A valid PHP callable
     */
    public function setEscaper($strategy, $callable)
    {
        $this->escapers[$strategy] = $callable;
    }

    /**
     * Gets all defined escapers.
     *
     * @return array An array of escapers
     */
    public function getEscapers()
    {
        return $this->escapers;
    }

    /**
     * Sets the default format to be used by the date filter.
     *
     * @param string $format             The default date format string
     * @param string $dateIntervalFormat The default date interval format string
     */
    public function setDateFormat($format = null, $dateIntervalFormat = null)
    {
        if (null !== $format) {
            $this->dateFormats[0] = $format;
        }

        if (null !== $dateIntervalFormat) {
            $this->dateFormats[1] = $dateIntervalFormat;
        }
    }

    /**
     * Gets the default format to be used by the date filter.
     *
     * @return array The default date format string and the default date interval format string
     */
    public function getDateFormat()
    {
        return $this->dateFormats;
    }

    /**
     * Sets the default timezone to be used by the date filter.
     *
     * @param DateTimeZone|string $timezone The default timezone string or a DateTimeZone object
     */
    public function setTimezone($timezone)
    {
        $this->timezone = $timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone);
    }

    /**
     * Gets the default timezone to be used by the date filter.
     *
     * @return DateTimeZone The default timezone currently in use
     */
    public function getTimezone()
    {
        if (null === $this->timezone) {
            $this->timezone = new DateTimeZone(date_default_timezone_get());
        }

        return $this->timezone;
    }

    /**
     * Sets the default format to be used by the number_format filter.
     *
     * @param int    $decimal      The number of decimal places to use.
     * @param string $decimalPoint The character(s) to use for the decimal point.
     * @param string $thousandSep  The character(s) to use for the thousands separator.
     */
    public function setNumberFormat($decimal, $decimalPoint, $thousandSep)
    {
        $this->numberFormat = array($decimal, $decimalPoint, $thousandSep);
    }

    /**
     * Get the default format used by the number_format filter.
     *
     * @return array The arguments for number_format()
     */
    public function getNumberFormat()
    {
        return $this->numberFormat;
    }

    public function getTokenParsers()
    {
        return array(
            new Twig_TokenParser_For(),
            new Twig_TokenParser_If(),
            new Twig_TokenParser_Extends(),
            new Twig_TokenParser_Include(),
            new Twig_TokenParser_Block(),
            new Twig_TokenParser_Use(),
            new Twig_TokenParser_Filter(),
            new Twig_TokenParser_Macro(),
            new Twig_TokenParser_Import(),
            new Twig_TokenParser_From(),
            new Twig_TokenParser_Set(),
            new Twig_TokenParser_Spaceless(),
            new Twig_TokenParser_Flush(),
            new Twig_TokenParser_Do(),
            new Twig_TokenParser_Embed(),
        );
    }

    public function getFilters()
    {
        $filters = array(
            // formatting filters
            new Twig_SimpleFilter('date', 'twig_date_format_filter', array('needs_environment' => true)),
            new Twig_SimpleFilter('date_modify', 'twig_date_modify_filter', array('needs_environment' => true)),
            new Twig_SimpleFilter('format', 'sprintf'),
            new Twig_SimpleFilter('replace', 'twig_replace_filter'),
            new Twig_SimpleFilter('number_format', 'twig_number_format_filter', array('needs_environment' => true)),
            new Twig_SimpleFilter('abs', 'abs'),
            new Twig_SimpleFilter('round', 'twig_round'),

            // encoding
            new Twig_SimpleFilter('url_encode', 'twig_urlencode_filter'),
            new Twig_SimpleFilter('json_encode', 'twig_jsonencode_filter'),
            new Twig_SimpleFilter('convert_encoding', 'twig_convert_encoding'),

            // string filters
            new Twig_SimpleFilter('title', 'twig_title_string_filter', array('needs_environment' => true)),
            new Twig_SimpleFilter('capitalize', 'twig_capitalize_string_filter', array('needs_environment' => true)),
            new Twig_SimpleFilter('upper', 'strtoupper'),
            new Twig_SimpleFilter('lower', 'strtolower'),
            new Twig_SimpleFilter('striptags', 'strip_tags'),
            new Twig_SimpleFilter('trim', 'trim'),
            new Twig_SimpleFilter('nl2br', 'nl2br', array('pre_escape' => 'html', 'is_safe' => array('html'))),

            // array helpers
            new Twig_SimpleFilter('join', 'twig_join_filter'),
            new Twig_SimpleFilter('split', 'twig_split_filter', array('needs_environment' => true)),
            new Twig_SimpleFilter('sort', 'twig_sort_filter'),
            new Twig_SimpleFilter('merge', 'twig_array_merge'),
            new Twig_SimpleFilter('batch', 'twig_array_batch'),

            // string/array filters
            new Twig_SimpleFilter('reverse', 'twig_reverse_filter', array('needs_environment' => true)),
            new Twig_SimpleFilter('length', 'twig_length_filter', array('needs_environment' => true)),
            new Twig_SimpleFilter('slice', 'twig_slice', array('needs_environment' => true)),
            new Twig_SimpleFilter('first', 'twig_first', array('needs_environment' => true)),
            new Twig_SimpleFilter('last', 'twig_last', array('needs_environment' => true)),

            // iteration and runtime
            new Twig_SimpleFilter('default', '_twig_default_filter', array('node_class' => 'Twig_Node_Expression_Filter_Default')),
            new Twig_SimpleFilter('keys', 'twig_get_array_keys_filter'),

            // escaping
            new Twig_SimpleFilter('escape', 'twig_escape_filter', array('needs_environment' => true, 'is_safe_callback' => 'twig_escape_filter_is_safe')),
            new Twig_SimpleFilter('e', 'twig_escape_filter', array('needs_environment' => true, 'is_safe_callback' => 'twig_escape_filter_is_safe')),
        );

        if (function_exists('mb_get_info')) {
            $filters[] = new Twig_SimpleFilter('upper', 'twig_upper_filter', array('needs_environment' => true));
            $filters[] = new Twig_SimpleFilter('lower', 'twig_lower_filter', array('needs_environment' => true));
        }

        return $filters;
    }

    public function getFunctions()
    {
        return array(
            new Twig_SimpleFunction('max', 'max'),
            new Twig_SimpleFunction('min', 'min'),
            new Twig_SimpleFunction('range', 'range'),
            new Twig_SimpleFunction('constant', 'twig_constant'),
            new Twig_SimpleFunction('cycle', 'twig_cycle'),
            new Twig_SimpleFunction('random', 'twig_random', array('needs_environment' => true)),
            new Twig_SimpleFunction('date', 'twig_date_converter', array('needs_environment' => true)),
            new Twig_SimpleFunction('include', 'twig_include', array('needs_environment' => true, 'needs_context' => true, 'is_safe' => array('all'))),
            new Twig_SimpleFunction('source', 'twig_source', array('needs_environment' => true, 'is_safe' => array('all'))),
        );
    }

    public function getTests()
    {
        return array(
            new Twig_SimpleTest('even', null, array('node_class' => 'Twig_Node_Expression_Test_Even')),
            new Twig_SimpleTest('odd', null, array('node_class' => 'Twig_Node_Expression_Test_Odd')),
            new Twig_SimpleTest('defined', null, array('node_class' => 'Twig_Node_Expression_Test_Defined')),
            new Twig_SimpleTest('sameas', null, array('node_class' => 'Twig_Node_Expression_Test_Sameas', 'deprecated' => '1.21', 'alternative' => 'same as')),
            new Twig_SimpleTest('same as', null, array('node_class' => 'Twig_Node_Expression_Test_Sameas')),
            new Twig_SimpleTest('none', null, array('node_class' => 'Twig_Node_Expression_Test_Null')),
            new Twig_SimpleTest('null', null, array('node_class' => 'Twig_Node_Expression_Test_Null')),
            new Twig_SimpleTest('divisibleby', null, array('node_class' => 'Twig_Node_Expression_Test_Divisibleby', 'deprecated' => '1.21', 'alternative' => 'divisible by')),
            new Twig_SimpleTest('divisible by', null, array('node_class' => 'Twig_Node_Expression_Test_Divisibleby')),
            new Twig_SimpleTest('constant', null, array('node_class' => 'Twig_Node_Expression_Test_Constant')),
            new Twig_SimpleTest('empty', 'twig_test_empty'),
            new Twig_SimpleTest('iterable', 'twig_test_iterable'),
        );
    }

    public function getOperators()
    {
        return array(
            array(
                'not' => array('precedence' => 50, 'class' => 'Twig_Node_Expression_Unary_Not'),
                '-' => array('precedence' => 500, 'class' => 'Twig_Node_Expression_Unary_Neg'),
                '+' => array('precedence' => 500, 'class' => 'Twig_Node_Expression_Unary_Pos'),
            ),
            array(
                'or' => array('precedence' => 10, 'class' => 'Twig_Node_Expression_Binary_Or', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'and' => array('precedence' => 15, 'class' => 'Twig_Node_Expression_Binary_And', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'b-or' => array('precedence' => 16, 'class' => 'Twig_Node_Expression_Binary_BitwiseOr', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'b-xor' => array('precedence' => 17, 'class' => 'Twig_Node_Expression_Binary_BitwiseXor', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'b-and' => array('precedence' => 18, 'class' => 'Twig_Node_Expression_Binary_BitwiseAnd', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '==' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_Equal', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '!=' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_NotEqual', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '<' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_Less', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '>' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_Greater', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '>=' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_GreaterEqual', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '<=' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_LessEqual', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'not in' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_NotIn', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'in' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_In', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'matches' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_Matches', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'starts with' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_StartsWith', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'ends with' => array('precedence' => 20, 'class' => 'Twig_Node_Expression_Binary_EndsWith', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '..' => array('precedence' => 25, 'class' => 'Twig_Node_Expression_Binary_Range', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '+' => array('precedence' => 30, 'class' => 'Twig_Node_Expression_Binary_Add', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '-' => array('precedence' => 30, 'class' => 'Twig_Node_Expression_Binary_Sub', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '~' => array('precedence' => 40, 'class' => 'Twig_Node_Expression_Binary_Concat', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '*' => array('precedence' => 60, 'class' => 'Twig_Node_Expression_Binary_Mul', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '/' => array('precedence' => 60, 'class' => 'Twig_Node_Expression_Binary_Div', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '//' => array('precedence' => 60, 'class' => 'Twig_Node_Expression_Binary_FloorDiv', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '%' => array('precedence' => 60, 'class' => 'Twig_Node_Expression_Binary_Mod', 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'is' => array('precedence' => 100, 'callable' => array($this, 'parseTestExpression'), 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                'is not' => array('precedence' => 100, 'callable' => array($this, 'parseNotTestExpression'), 'associativity' => Twig_ExpressionParser::OPERATOR_LEFT),
                '**' => array('precedence' => 200, 'class' => 'Twig_Node_Expression_Binary_Power', 'associativity' => Twig_ExpressionParser::OPERATOR_RIGHT),
                '??' => array('precedence' => 300, 'class' => 'Twig_Node_Expression_NullCoalesce', 'associativity' => Twig_ExpressionParser::OPERATOR_RIGHT),
            ),
        );
    }

    public function parseNotTestExpression(Twig_Parser $parser, Twig_NodeInterface $node)
    {
        return new Twig_Node_Expression_Unary_Not($this->parseTestExpression($parser, $node), $parser->getCurrentToken()->getLine());
    }

    public function parseTestExpression(Twig_Parser $parser, Twig_NodeInterface $node)
    {
        $stream = $parser->getStream();
        list($name, $test) = $this->getTest($parser, $node->getLine());

        if ($test instanceof Twig_SimpleTest && $test->isDeprecated()) {
            $message = sprintf('Twig Test "%s" is deprecated', $name);
            if (!is_bool($test->getDeprecatedVersion())) {
                $message .= sprintf(' since version %s', $test->getDeprecatedVersion());
            }
            if ($test->getAlternative()) {
                $message .= sprintf('. Use "%s" instead', $test->getAlternative());
            }
            $message .= sprintf(' in %s at line %d.', $stream->getFilename(), $stream->getCurrent()->getLine());

            @trigger_error($message, E_USER_DEPRECATED);
        }

        $class = $this->getTestNodeClass($parser, $test);
        $arguments = null;
        if ($stream->test(Twig_Token::PUNCTUATION_TYPE, '(')) {
            $arguments = $parser->getExpressionParser()->parseArguments(true);
        }

        return new $class($node, $name, $arguments, $parser->getCurrentToken()->getLine());
    }

    protected function getTest(Twig_Parser $parser, $line)
    {
        $stream = $parser->getStream();
        $name = $stream->expect(Twig_Token::NAME_TYPE)->getValue();
        $env = $parser->getEnvironment();

        if ($test = $env->getTest($name)) {
            return array($name, $test);
        }

        if ($stream->test(Twig_Token::NAME_TYPE)) {
            // try 2-words tests
            $name = $name.' '.$parser->getCurrentToken()->getValue();

            if ($test = $env->getTest($name)) {
                $parser->getStream()->next();

                return array($name, $test);
            }
        }

        $e = new Twig_Error_Syntax(sprintf('Unknown "%s" test.', $name), $line, $parser->getFilename());
        $e->addSuggestions($name, array_keys($env->getTests()));

        throw $e;
    }

    protected function getTestNodeClass(Twig_Parser $parser, $test)
    {
        if ($test instanceof Twig_SimpleTest) {
            return $test->getNodeClass();
        }

        return $test instanceof Twig_Test_Node ? $test->getClass() : 'Twig_Node_Expression_Test';
    }

    public function getName()
    {
        return 'core';
    }
}

/**
 * Cycles over a value.
 *
 * @param ArrayAccess|array $values   An array or an ArrayAccess instance
 * @param int               $position The cycle position
 *
 * @return string The next value in the cycle
 */
function twig_cycle($values, $position)
{
    if (!is_array($values) && !$values instanceof ArrayAccess) {
        return $values;
    }

    return $values[$position % count($values)];
}

/**
 * Returns a random value depending on the supplied parameter type:
 * - a random item from a Traversable or array
 * - a random character from a string
 * - a random integer between 0 and the integer parameter.
 *
 * @param Twig_Environment             $env    A Twig_Environment instance
 * @param Traversable|array|int|string $values The values to pick a random item from
 *
 * @throws Twig_Error_Runtime When $values is an empty array (does not apply to an empty string which is returned as is).
 *
 * @return mixed A random value from the given sequence
 */
function twig_random(Twig_Environment $env, $values = null)
{
    if (null === $values) {
        return mt_rand();
    }

    if (is_int($values) || is_float($values)) {
        return $values < 0 ? mt_rand($values, 0) : mt_rand(0, $values);
    }

    if ($values instanceof Traversable) {
        $values = iterator_to_array($values);
    } elseif (is_string($values)) {
        if ('' === $values) {
            return '';
        }
        if (null !== $charset = $env->getCharset()) {
            if ('UTF-8' !== $charset) {
                $values = twig_convert_encoding($values, 'UTF-8', $charset);
            }

            // unicode version of str_split()
            // split at all positions, but not after the start and not before the end
            $values = preg_split('/(?<!^)(?!$)/u', $values);

            if ('UTF-8' !== $charset) {
                foreach ($values as $i => $value) {
                    $values[$i] = twig_convert_encoding($value, $charset, 'UTF-8');
                }
            }
        } else {
            return $values[mt_rand(0, strlen($values) - 1)];
        }
    }

    if (!is_array($values)) {
        return $values;
    }

    if (0 === count($values)) {
        throw new Twig_Error_Runtime('The random function cannot pick from an empty array.');
    }

    return $values[array_rand($values, 1)];
}

/**
 * Converts a date to the given format.
 *
 * <pre>
 *   {{ post.published_at|date("m/d/Y") }}
 * </pre>
 *
 * @param Twig_Environment                               $env      A Twig_Environment instance
 * @param DateTime|DateTimeInterface|DateInterval|string $date     A date
 * @param string|null                                    $format   The target format, null to use the default
 * @param DateTimeZone|string|null|false                 $timezone The target timezone, null to use the default, false to leave unchanged
 *
 * @return string The formatted date
 */
function twig_date_format_filter(Twig_Environment $env, $date, $format = null, $timezone = null)
{
    if (null === $format) {
        $formats = $env->getExtension('core')->getDateFormat();
        $format = $date instanceof DateInterval ? $formats[1] : $formats[0];
    }

    if ($date instanceof DateInterval) {
        return $date->format($format);
    }

    return twig_date_converter($env, $date, $timezone)->format($format);
}

/**
 * Returns a new date object modified.
 *
 * <pre>
 *   {{ post.published_at|date_modify("-1day")|date("m/d/Y") }}
 * </pre>
 *
 * @param Twig_Environment $env      A Twig_Environment instance
 * @param DateTime|string  $date     A date
 * @param string           $modifier A modifier string
 *
 * @return DateTime A new date object
 */
function twig_date_modify_filter(Twig_Environment $env, $date, $modifier)
{
    $date = twig_date_converter($env, $date, false);
    $resultDate = $date->modify($modifier);

    // This is a hack to ensure PHP 5.2 support and support for DateTimeImmutable
    // DateTime::modify does not return the modified DateTime object < 5.3.0
    // and DateTimeImmutable does not modify $date.
    return null === $resultDate ? $date : $resultDate;
}

/**
 * Converts an input to a DateTime instance.
 *
 * <pre>
 *    {% if date(user.created_at) < date('+2days') %}
 *      {# do something #}
 *    {% endif %}
 * </pre>
 *
 * @param Twig_Environment                       $env      A Twig_Environment instance
 * @param DateTime|DateTimeInterface|string|null $date     A date
 * @param DateTimeZone|string|null|false         $timezone The target timezone, null to use the default, false to leave unchanged
 *
 * @return DateTime A DateTime instance
 */
function twig_date_converter(Twig_Environment $env, $date = null, $timezone = null)
{
    // determine the timezone
    if (false !== $timezone) {
        if (null === $timezone) {
            $timezone = $env->getExtension('core')->getTimezone();
        } elseif (!$timezone instanceof DateTimeZone) {
            $timezone = new DateTimeZone($timezone);
        }
    }

    // immutable dates
    if ($date instanceof DateTimeImmutable) {
        return false !== $timezone ? $date->setTimezone($timezone) : $date;
    }

    if ($date instanceof DateTime || $date instanceof DateTimeInterface) {
        $date = clone $date;
        if (false !== $timezone) {
            $date->setTimezone($timezone);
        }

        return $date;
    }

    if (null === $date || 'now' === $date) {
        return new DateTime($date, false !== $timezone ? $timezone : $env->getExtension('core')->getTimezone());
    }

    $asString = (string) $date;
    if (ctype_digit($asString) || (!empty($asString) && '-' === $asString[0] && ctype_digit(substr($asString, 1)))) {
        $date = new DateTime('@'.$date);
    } else {
        $date = new DateTime($date, $env->getExtension('core')->getTimezone());
    }

    if (false !== $timezone) {
        $date->setTimezone($timezone);
    }

    return $date;
}

/**
 * Replaces strings within a string.
 *
 * @param string            $str  String to replace in
 * @param array|Traversable $from Replace values
 * @param string|null       $to   Replace to, deprecated (@see http://php.net/manual/en/function.strtr.php)
 *
 * @return string
 */
function twig_replace_filter($str, $from, $to = null)
{
    if ($from instanceof Traversable) {
        $from = iterator_to_array($from);
    } elseif (is_string($from) && is_string($to)) {
        @trigger_error('Using "replace" with character by character replacement is deprecated since version 1.22 and will be removed in Twig 2.0', E_USER_DEPRECATED);

        return strtr($str, $from, $to);
    } elseif (!is_array($from)) {
        throw new Twig_Error_Runtime(sprintf('The "replace" filter expects an array or "Traversable" as replace values, got "%s".',is_object($from) ? get_class($from) : gettype($from)));
    }

    return strtr($str, $from);
}

/**
 * Rounds a number.
 *
 * @param int|float $value     The value to round
 * @param int|float $precision The rounding precision
 * @param string    $method    The method to use for rounding
 *
 * @return int|float The rounded number
 */
function twig_round($value, $precision = 0, $method = 'common')
{
    if ('common' == $method) {
        return round($value, $precision);
    }

    if ('ceil' != $method && 'floor' != $method) {
        throw new Twig_Error_Runtime('The round filter only supports the "common", "ceil", and "floor" methods.');
    }

    return $method($value * pow(10, $precision)) / pow(10, $precision);
}

/**
 * Number format filter.
 *
 * All of the formatting options can be left null, in that case the defaults will
 * be used.  Supplying any of the parameters will override the defaults set in the
 * environment object.
 *
 * @param Twig_Environment $env          A Twig_Environment instance
 * @param mixed            $number       A float/int/string of the number to format
 * @param int              $decimal      The number of decimal points to display.
 * @param string           $decimalPoint The character(s) to use for the decimal point.
 * @param string           $thousandSep  The character(s) to use for the thousands separator.
 *
 * @return string The formatted number
 */
function twig_number_format_filter(Twig_Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null)
{
    $defaults = $env->getExtension('core')->getNumberFormat();
    if (null === $decimal) {
        $decimal = $defaults[0];
    }

    if (null === $decimalPoint) {
        $decimalPoint = $defaults[1];
    }

    if (null === $thousandSep) {
        $thousandSep = $defaults[2];
    }

    return number_format((float) $number, $decimal, $decimalPoint, $thousandSep);
}

/**
 * URL encodes (RFC 3986) a string as a path segment or an array as a query string.
 *
 * @param string|array $url A URL or an array of query parameters
 *
 * @return string The URL encoded value
 */
function twig_urlencode_filter($url)
{
    if (is_array($url)) {
        if (defined('PHP_QUERY_RFC3986')) {
            return http_build_query($url, '', '&', PHP_QUERY_RFC3986);
        }

        return http_build_query($url, '', '&');
    }

    return rawurlencode($url);
}

if (PHP_VERSION_ID < 50300) {
    /**
     * JSON encodes a variable.
     *
     * @param mixed $value   The value to encode.
     * @param int   $options Not used on PHP 5.2.x
     *
     * @return mixed The JSON encoded value
     */
    function twig_jsonencode_filter($value, $options = 0)
    {
        if ($value instanceof Twig_Markup) {
            $value = (string) $value;
        } elseif (is_array($value)) {
            array_walk_recursive($value, '_twig_markup2string');
        }

        return json_encode($value);
    }
} else {
    /**
     * JSON encodes a variable.
     *
     * @param mixed $value   The value to encode.
     * @param int   $options Bitmask consisting of JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP, JSON_HEX_APOS, JSON_NUMERIC_CHECK, JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT
     *
     * @return mixed The JSON encoded value
     */
    function twig_jsonencode_filter($value, $options = 0)
    {
        if ($value instanceof Twig_Markup) {
            $value = (string) $value;
        } elseif (is_array($value)) {
            array_walk_recursive($value, '_twig_markup2string');
        }

        return json_encode($value, $options);
    }
}

function _twig_markup2string(&$value)
{
    if ($value instanceof Twig_Markup) {
        $value = (string) $value;
    }
}

/**
 * Merges an array with another one.
 *
 * <pre>
 *  {% set items = { 'apple': 'fruit', 'orange': 'fruit' } %}
 *
 *  {% set items = items|merge({ 'peugeot': 'car' }) %}
 *
 *  {# items now contains { 'apple': 'fruit', 'orange': 'fruit', 'peugeot': 'car' } #}
 * </pre>
 *
 * @param array|Traversable $arr1 An array
 * @param array|Traversable $arr2 An array
 *
 * @return array The merged array
 */
function twig_array_merge($arr1, $arr2)
{
    if ($arr1 instanceof Traversable) {
        $arr1 = iterator_to_array($arr1);
    } elseif (!is_array($arr1)) {
        throw new Twig_Error_Runtime(sprintf('The merge filter only works with arrays or "Traversable", got "%s" as first argument.', gettype($arr1)));
    }

    if ($arr2 instanceof Traversable) {
        $arr2 = iterator_to_array($arr2);
    } elseif (!is_array($arr2)) {
        throw new Twig_Error_Runtime(sprintf('The merge filter only works with arrays or "Traversable", got "%s" as second argument.', gettype($arr2)));
    }

    return array_merge($arr1, $arr2);
}

/**
 * Slices a variable.
 *
 * @param Twig_Environment $env          A Twig_Environment instance
 * @param mixed            $item         A variable
 * @param int              $start        Start of the slice
 * @param int              $length       Size of the slice
 * @param bool             $preserveKeys Whether to preserve key or not (when the input is an array)
 *
 * @return mixed The sliced variable
 */
function twig_slice(Twig_Environment $env, $item, $start, $length = null, $preserveKeys = false)
{
    if ($item instanceof Traversable) {
        if ($item instanceof IteratorAggregate) {
            $item = $item->getIterator();
        }

        if ($start >= 0 && $length >= 0 && $item instanceof Iterator) {
            try {
                return iterator_to_array(new LimitIterator($item, $start, $length === null ? -1 : $length), $preserveKeys);
            } catch (OutOfBoundsException $exception) {
                return array();
            }
        }

        $item = iterator_to_array($item, $preserveKeys);
    }

    if (is_array($item)) {
        return array_slice($item, $start, $length, $preserveKeys);
    }

    $item = (string) $item;

    if (function_exists('mb_get_info') && null !== $charset = $env->getCharset()) {
        return (string) mb_substr($item, $start, null === $length ? mb_strlen($item, $charset) - $start : $length, $charset);
    }

    return (string) (null === $length ? substr($item, $start) : substr($item, $start, $length));
}

/**
 * Returns the first element of the item.
 *
 * @param Twig_Environment $env  A Twig_Environment instance
 * @param mixed            $item A variable
 *
 * @return mixed The first element of the item
 */
function twig_first(Twig_Environment $env, $item)
{
    $elements = twig_slice($env, $item, 0, 1, false);

    return is_string($elements) ? $elements : current($elements);
}

/**
 * Returns the last element of the item.
 *
 * @param Twig_Environment $env  A Twig_Environment instance
 * @param mixed            $item A variable
 *
 * @return mixed The last element of the item
 */
function twig_last(Twig_Environment $env, $item)
{
    $elements = twig_slice($env, $item, -1, 1, false);

    return is_string($elements) ? $elements : current($elements);
}

/**
 * Joins the values to a string.
 *
 * The separator between elements is an empty string per default, you can define it with the optional parameter.
 *
 * <pre>
 *  {{ [1, 2, 3]|join('|') }}
 *  {# returns 1|2|3 #}
 *
 *  {{ [1, 2, 3]|join }}
 *  {# returns 123 #}
 * </pre>
 *
 * @param array  $value An array
 * @param string $glue  The separator
 *
 * @return string The concatenated string
 */
function twig_join_filter($value, $glue = '')
{
    if ($value instanceof Traversable) {
        $value = iterator_to_array($value, false);
    }

    return implode($glue, (array) $value);
}

/**
 * Splits the string into an array.
 *
 * <pre>
 *  {{ "one,two,three"|split(',') }}
 *  {# returns [one, two, three] #}
 *
 *  {{ "one,two,three,four,five"|split(',', 3) }}
 *  {# returns [one, two, "three,four,five"] #}
 *
 *  {{ "123"|split('') }}
 *  {# returns [1, 2, 3] #}
 *
 *  {{ "aabbcc"|split('', 2) }}
 *  {# returns [aa, bb, cc] #}
 * </pre>
 *
 * @param Twig_Environment $env       A Twig_Environment instance
 * @param string           $value     A string
 * @param string           $delimiter The delimiter
 * @param int              $limit     The limit
 *
 * @return array The split string as an array
 */
function twig_split_filter(Twig_Environment $env, $value, $delimiter, $limit = null)
{
    if (!empty($delimiter)) {
        return null === $limit ? explode($delimiter, $value) : explode($delimiter, $value, $limit);
    }

    if (!function_exists('mb_get_info') || null === $charset = $env->getCharset()) {
        return str_split($value, null === $limit ? 1 : $limit);
    }

    if ($limit <= 1) {
        return preg_split('/(?<!^)(?!$)/u', $value);
    }

    $length = mb_strlen($value, $charset);
    if ($length < $limit) {
        return array($value);
    }

    $r = array();
    for ($i = 0; $i < $length; $i += $limit) {
        $r[] = mb_substr($value, $i, $limit, $charset);
    }

    return $r;
}

// The '_default' filter is used internally to avoid using the ternary operator
// which costs a lot for big contexts (before PHP 5.4). So, on average,
// a function call is cheaper.
/**
 * @internal
 */
function _twig_default_filter($value, $default = '')
{
    if (twig_test_empty($value)) {
        return $default;
    }

    return $value;
}

/**
 * Returns the keys for the given array.
 *
 * It is useful when you want to iterate over the keys of an array:
 *
 * <pre>
 *  {% for key in array|keys %}
 *      {# ... #}
 *  {% endfor %}
 * </pre>
 *
 * @param array $array An array
 *
 * @return array The keys
 */
function twig_get_array_keys_filter($array)
{
    if ($array instanceof Traversable) {
        return array_keys(iterator_to_array($array));
    }

    if (!is_array($array)) {
        return array();
    }

    return array_keys($array);
}

/**
 * Reverses a variable.
 *
 * @param Twig_Environment         $env          A Twig_Environment instance
 * @param array|Traversable|string $item         An array, a Traversable instance, or a string
 * @param bool                     $preserveKeys Whether to preserve key or not
 *
 * @return mixed The reversed input
 */
function twig_reverse_filter(Twig_Environment $env, $item, $preserveKeys = false)
{
    if ($item instanceof Traversable) {
        return array_reverse(iterator_to_array($item), $preserveKeys);
    }

    if (is_array($item)) {
        return array_reverse($item, $preserveKeys);
    }

    if (null !== $charset = $env->getCharset()) {
        $string = (string) $item;

        if ('UTF-8' !== $charset) {
            $item = twig_convert_encoding($string, 'UTF-8', $charset);
        }

        preg_match_all('/./us', $item, $matches);

        $string = implode('', array_reverse($matches[0]));

        if ('UTF-8' !== $charset) {
            $string = twig_convert_encoding($string, $charset, 'UTF-8');
        }

        return $string;
    }

    return strrev((string) $item);
}

/**
 * Sorts an array.
 *
 * @param array|Traversable $array
 *
 * @return array
 */
function twig_sort_filter($array)
{
    if ($array instanceof Traversable) {
        $array = iterator_to_array($array);
    } elseif (!is_array($array)) {
        throw new Twig_Error_Runtime(sprintf('The sort filter only works with arrays or "Traversable", got "%s".', gettype($array)));
    }

    asort($array);

    return $array;
}

/**
 * @internal
 */
function twig_in_filter($value, $compare)
{
    if (is_array($compare)) {
        return in_array($value, $compare, is_object($value) || is_resource($value));
    } elseif (is_string($compare) && (is_string($value) || is_int($value) || is_float($value))) {
        return '' === $value || false !== strpos($compare, (string) $value);
    } elseif ($compare instanceof Traversable) {
        return in_array($value, iterator_to_array($compare, false), is_object($value) || is_resource($value));
    }

    return false;
}

/**
 * Escapes a string.
 *
 * @param Twig_Environment $env        A Twig_Environment instance
 * @param string           $string     The value to be escaped
 * @param string           $strategy   The escaping strategy
 * @param string           $charset    The charset
 * @param bool             $autoescape Whether the function is called by the auto-escaping feature (true) or by the developer (false)
 *
 * @return string
 */
function twig_escape_filter(Twig_Environment $env, $string, $strategy = 'html', $charset = null, $autoescape = false)
{
    if ($autoescape && $string instanceof Twig_Markup) {
        return $string;
    }

    if (!is_string($string)) {
        if (is_object($string) && method_exists($string, '__toString')) {
            $string = (string) $string;
        } elseif (in_array($strategy, array('html', 'js', 'css', 'html_attr', 'url'))) {
            return $string;
        }
    }

    if (null === $charset) {
        $charset = $env->getCharset();
    }

    switch ($strategy) {
        case 'html':
            // see http://php.net/htmlspecialchars

            // Using a static variable to avoid initializing the array
            // each time the function is called. Moving the declaration on the
            // top of the function slow downs other escaping strategies.
            static $htmlspecialcharsCharsets;

            if (null === $htmlspecialcharsCharsets) {
                if (defined('HHVM_VERSION')) {
                    $htmlspecialcharsCharsets = array('utf-8' => true, 'UTF-8' => true);
                } else {
                    $htmlspecialcharsCharsets = array(
                        'ISO-8859-1' => true, 'ISO8859-1' => true,
                        'ISO-8859-15' => true, 'ISO8859-15' => true,
                        'utf-8' => true, 'UTF-8' => true,
                        'CP866' => true, 'IBM866' => true, '866' => true,
                        'CP1251' => true, 'WINDOWS-1251' => true, 'WIN-1251' => true,
                        '1251' => true,
                        'CP1252' => true, 'WINDOWS-1252' => true, '1252' => true,
                        'KOI8-R' => true, 'KOI8-RU' => true, 'KOI8R' => true,
                        'BIG5' => true, '950' => true,
                        'GB2312' => true, '936' => true,
                        'BIG5-HKSCS' => true,
                        'SHIFT_JIS' => true, 'SJIS' => true, '932' => true,
                        'EUC-JP' => true, 'EUCJP' => true,
                        'ISO8859-5' => true, 'ISO-8859-5' => true, 'MACROMAN' => true,
                    );
                }
            }

            if (isset($htmlspecialcharsCharsets[$charset])) {
                return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
            }

            if (isset($htmlspecialcharsCharsets[strtoupper($charset)])) {
                // cache the lowercase variant for future iterations
                $htmlspecialcharsCharsets[$charset] = true;

                return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
            }

            $string = twig_convert_encoding($string, 'UTF-8', $charset);
            $string = htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');

            return twig_convert_encoding($string, $charset, 'UTF-8');

        case 'js':
            // escape all non-alphanumeric characters
            // into their \xHH or \uHHHH representations
            if ('UTF-8' !== $charset) {
                $string = twig_convert_encoding($string, 'UTF-8', $charset);
            }

            if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) {
                throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.');
            }

            $string = preg_replace_callback('#[^a-zA-Z0-9,\._]#Su', '_twig_escape_js_callback', $string);

            if ('UTF-8' !== $charset) {
                $string = twig_convert_encoding($string, $charset, 'UTF-8');
            }

            return $string;

        case 'css':
            if ('UTF-8' !== $charset) {
                $string = twig_convert_encoding($string, 'UTF-8', $charset);
            }

            if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) {
                throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.');
            }

            $string = preg_replace_callback('#[^a-zA-Z0-9]#Su', '_twig_escape_css_callback', $string);

            if ('UTF-8' !== $charset) {
                $string = twig_convert_encoding($string, $charset, 'UTF-8');
            }

            return $string;

        case 'html_attr':
            if ('UTF-8' !== $charset) {
                $string = twig_convert_encoding($string, 'UTF-8', $charset);
            }

            if (0 == strlen($string) ? false : (1 == preg_match('/^./su', $string) ? false : true)) {
                throw new Twig_Error_Runtime('The string to escape is not a valid UTF-8 string.');
            }

            $string = preg_replace_callback('#[^a-zA-Z0-9,\.\-_]#Su', '_twig_escape_html_attr_callback', $string);

            if ('UTF-8' !== $charset) {
                $string = twig_convert_encoding($string, $charset, 'UTF-8');
            }

            return $string;

        case 'url':
            if (PHP_VERSION_ID < 50300) {
                return str_replace('%7E', '~', rawurlencode($string));
            }

            return rawurlencode($string);

        default:
            static $escapers;

            if (null === $escapers) {
                $escapers = $env->getExtension('core')->getEscapers();
            }

            if (isset($escapers[$strategy])) {
                return call_user_func($escapers[$strategy], $env, $string, $charset);
            }

            $validStrategies = implode(', ', array_merge(array('html', 'js', 'url', 'css', 'html_attr'), array_keys($escapers)));

            throw new Twig_Error_Runtime(sprintf('Invalid escaping strategy "%s" (valid ones: %s).', $strategy, $validStrategies));
    }
}

/**
 * @internal
 */
function twig_escape_filter_is_safe(Twig_Node $filterArgs)
{
    foreach ($filterArgs as $arg) {
        if ($arg instanceof Twig_Node_Expression_Constant) {
            return array($arg->getAttribute('value'));
        }

        return array();
    }

    return array('html');
}

if (function_exists('mb_convert_encoding')) {
    function twig_convert_encoding($string, $to, $from)
    {
        return mb_convert_encoding($string, $to, $from);
    }
} elseif (function_exists('iconv')) {
    function twig_convert_encoding($string, $to, $from)
    {
        return iconv($from, $to, $string);
    }
} else {
    function twig_convert_encoding($string, $to, $from)
    {
        throw new Twig_Error_Runtime('No suitable convert encoding function (use UTF-8 as your encoding or install the iconv or mbstring extension).');
    }
}

function _twig_escape_js_callback($matches)
{
    $char = $matches[0];

    // \xHH
    if (!isset($char[1])) {
        return '\\x'.strtoupper(substr('00'.bin2hex($char), -2));
    }

    // \uHHHH
    $char = twig_convert_encoding($char, 'UTF-16BE', 'UTF-8');

    return '\\u'.strtoupper(substr('0000'.bin2hex($char), -4));
}

function _twig_escape_css_callback($matches)
{
    $char = $matches[0];

    // \xHH
    if (!isset($char[1])) {
        $hex = ltrim(strtoupper(bin2hex($char)), '0');
        if (0 === strlen($hex)) {
            $hex = '0';
        }

        return '\\'.$hex.' ';
    }

    // \uHHHH
    $char = twig_convert_encoding($char, 'UTF-16BE', 'UTF-8');

    return '\\'.ltrim(strtoupper(bin2hex($char)), '0').' ';
}

/**
 * This function is adapted from code coming from Zend Framework.
 *
 * @copyright Copyright (c) 2005-2012 Zend Technologies USA Inc. (http://www.zend.com)
 * @license   http://framework.zend.com/license/new-bsd New BSD License
 */
function _twig_escape_html_attr_callback($matches)
{
    /*
     * While HTML supports far more named entities, the lowest common denominator
     * has become HTML5's XML Serialisation which is restricted to the those named
     * entities that XML supports. Using HTML entities would result in this error:
     *     XML Parsing Error: undefined entity
     */
    static $entityMap = array(
        34 => 'quot', /* quotation mark */
        38 => 'amp',  /* ampersand */
        60 => 'lt',   /* less-than sign */
        62 => 'gt',   /* greater-than sign */
    );

    $chr = $matches[0];
    $ord = ord($chr);

    /*
     * The following replaces characters undefined in HTML with the
     * hex entity for the Unicode replacement character.
     */
    if (($ord <= 0x1f && $chr != "\t" && $chr != "\n" && $chr != "\r") || ($ord >= 0x7f && $ord <= 0x9f)) {
        return '&#xFFFD;';
    }

    /*
     * Check if the current character to escape has a name entity we should
     * replace it with while grabbing the hex value of the character.
     */
    if (strlen($chr) == 1) {
        $hex = strtoupper(substr('00'.bin2hex($chr), -2));
    } else {
        $chr = twig_convert_encoding($chr, 'UTF-16BE', 'UTF-8');
        $hex = strtoupper(substr('0000'.bin2hex($chr), -4));
    }

    $int = hexdec($hex);
    if (array_key_exists($int, $entityMap)) {
        return sprintf('&%s;', $entityMap[$int]);
    }

    /*
     * Per OWASP recommendations, we'll use hex entities for any other
     * characters where a named entity does not exist.
     */
    return sprintf('&#x%s;', $hex);
}

// add multibyte extensions if possible
if (function_exists('mb_get_info')) {
    /**
     * Returns the length of a variable.
     *
     * @param Twig_Environment $env   A Twig_Environment instance
     * @param mixed            $thing A variable
     *
     * @return int The length of the value
     */
    function twig_length_filter(Twig_Environment $env, $thing)
    {
        return is_scalar($thing) ? mb_strlen($thing, $env->getCharset()) : count($thing);
    }

    /**
     * Converts a string to uppercase.
     *
     * @param Twig_Environment $env    A Twig_Environment instance
     * @param string           $string A string
     *
     * @return string The uppercased string
     */
    function twig_upper_filter(Twig_Environment $env, $string)
    {
        if (null !== $charset = $env->getCharset()) {
            return mb_strtoupper($string, $charset);
        }

        return strtoupper($string);
    }

    /**
     * Converts a string to lowercase.
     *
     * @param Twig_Environment $env    A Twig_Environment instance
     * @param string           $string A string
     *
     * @return string The lowercased string
     */
    function twig_lower_filter(Twig_Environment $env, $string)
    {
        if (null !== $charset = $env->getCharset()) {
            return mb_strtolower($string, $charset);
        }

        return strtolower($string);
    }

    /**
     * Returns a titlecased string.
     *
     * @param Twig_Environment $env    A Twig_Environment instance
     * @param string           $string A string
     *
     * @return string The titlecased string
     */
    function twig_title_string_filter(Twig_Environment $env, $string)
    {
        if (null !== $charset = $env->getCharset()) {
            return mb_convert_case($string, MB_CASE_TITLE, $charset);
        }

        return ucwords(strtolower($string));
    }

    /**
     * Returns a capitalized string.
     *
     * @param Twig_Environment $env    A Twig_Environment instance
     * @param string           $string A string
     *
     * @return string The capitalized string
     */
    function twig_capitalize_string_filter(Twig_Environment $env, $string)
    {
        if (null !== $charset = $env->getCharset()) {
            return mb_strtoupper(mb_substr($string, 0, 1, $charset), $charset).mb_strtolower(mb_substr($string, 1, mb_strlen($string, $charset), $charset), $charset);
        }

        return ucfirst(strtolower($string));
    }
}
// and byte fallback
else {
    /**
     * Returns the length of a variable.
     *
     * @param Twig_Environment $env   A Twig_Environment instance
     * @param mixed            $thing A variable
     *
     * @return int The length of the value
     */
    function twig_length_filter(Twig_Environment $env, $thing)
    {
        return is_scalar($thing) ? strlen($thing) : count($thing);
    }

    /**
     * Returns a titlecased string.
     *
     * @param Twig_Environment $env    A Twig_Environment instance
     * @param string           $string A string
     *
     * @return string The titlecased string
     */
    function twig_title_string_filter(Twig_Environment $env, $string)
    {
        return ucwords(strtolower($string));
    }

    /**
     * Returns a capitalized string.
     *
     * @param Twig_Environment $env    A Twig_Environment instance
     * @param string           $string A string
     *
     * @return string The capitalized string
     */
    function twig_capitalize_string_filter(Twig_Environment $env, $string)
    {
        return ucfirst(strtolower($string));
    }
}

/**
 * @internal
 */
function twig_ensure_traversable($seq)
{
    if ($seq instanceof Traversable || is_array($seq)) {
        return $seq;
    }

    return array();
}

/**
 * Checks if a variable is empty.
 *
 * <pre>
 * {# evaluates to true if the foo variable is null, false, or the empty string #}
 * {% if foo is empty %}
 *     {# ... #}
 * {% endif %}
 * </pre>
 *
 * @param mixed $value A variable
 *
 * @return bool true if the value is empty, false otherwise
 */
function twig_test_empty($value)
{
    if ($value instanceof Countable) {
        return 0 == count($value);
    }

    return '' === $value || false === $value || null === $value || array() === $value;
}

/**
 * Checks if a variable is traversable.
 *
 * <pre>
 * {# evaluates to true if the foo variable is an array or a traversable object #}
 * {% if foo is traversable %}
 *     {# ... #}
 * {% endif %}
 * </pre>
 *
 * @param mixed $value A variable
 *
 * @return bool true if the value is traversable
 */
function twig_test_iterable($value)
{
    return $value instanceof Traversable || is_array($value);
}

/**
 * Renders a template.
 *
 * @param Twig_Environment $env
 * @param array            $context
 * @param string|array     $template      The template to render or an array of templates to try consecutively
 * @param array            $variables     The variables to pass to the template
 * @param bool             $withContext
 * @param bool             $ignoreMissing Whether to ignore missing templates or not
 * @param bool             $sandboxed     Whether to sandbox the template or not
 *
 * @return string The rendered template
 */
function twig_include(Twig_Environment $env, $context, $template, $variables = array(), $withContext = true, $ignoreMissing = false, $sandboxed = false)
{
    $alreadySandboxed = false;
    $sandbox = null;
    if ($withContext) {
        $variables = array_merge($context, $variables);
    }

    if ($isSandboxed = $sandboxed && $env->hasExtension('sandbox')) {
        $sandbox = $env->getExtension('sandbox');
        if (!$alreadySandboxed = $sandbox->isSandboxed()) {
            $sandbox->enableSandbox();
        }
    }

    $result = null;
    try {
        $result = $env->resolveTemplate($template)->render($variables);
    } catch (Twig_Error_Loader $e) {
        if (!$ignoreMissing) {
            if ($isSandboxed && !$alreadySandboxed) {
                $sandbox->disableSandbox();
            }

            throw $e;
        }
    }

    if ($isSandboxed && !$alreadySandboxed) {
        $sandbox->disableSandbox();
    }

    return $result;
}

/**
 * Returns a template content without rendering it.
 *
 * @param Twig_Environment $env
 * @param string           $name          The template name
 * @param bool             $ignoreMissing Whether to ignore missing templates or not
 *
 * @return string The template source
 */
function twig_source(Twig_Environment $env, $name, $ignoreMissing = false)
{
    try {
        return $env->getLoader()->getSource($name);
    } catch (Twig_Error_Loader $e) {
        if (!$ignoreMissing) {
            throw $e;
        }
    }
}

/**
 * Provides the ability to get constants from instances as well as class/global constants.
 *
 * @param string      $constant The name of the constant
 * @param null|object $object   The object to get the constant from
 *
 * @return string
 */
function twig_constant($constant, $object = null)
{
    if (null !== $object) {
        $constant = get_class($object).'::'.$constant;
    }

    return constant($constant);
}

/**
 * Batches item.
 *
 * @param array $items An array of items
 * @param int   $size  The size of the batch
 * @param mixed $fill  A value used to fill missing items
 *
 * @return array
 */
function twig_array_batch($items, $size, $fill = null)
{
    if ($items instanceof Traversable) {
        $items = iterator_to_array($items, false);
    }

    $size = ceil($size);

    $result = array_chunk($items, $size, true);

    if (null !== $fill && !empty($result)) {
        $last = count($result) - 1;
        if ($fillCount = $size - count($result[$last])) {
            $result[$last] = array_merge(
                $result[$last],
                array_fill(0, $fillCount, $fill)
            );
        }
    }

    return $result;
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Extension_Debug extends Twig_Extension
{
    public function getFunctions()
    {
        // dump is safe if var_dump is overridden by xdebug
        $isDumpOutputHtmlSafe = extension_loaded('xdebug')
            // false means that it was not set (and the default is on) or it explicitly enabled
            && (false === ini_get('xdebug.overload_var_dump') || ini_get('xdebug.overload_var_dump'))
            // false means that it was not set (and the default is on) or it explicitly enabled
            // xdebug.overload_var_dump produces HTML only when html_errors is also enabled
            && (false === ini_get('html_errors') || ini_get('html_errors'))
            || 'cli' === php_sapi_name()
        ;

        return array(
            new Twig_SimpleFunction('dump', 'twig_var_dump', array('is_safe' => $isDumpOutputHtmlSafe ? array('html') : array(), 'needs_context' => true, 'needs_environment' => true)),
        );
    }

    public function getName()
    {
        return 'debug';
    }
}

function twig_var_dump(Twig_Environment $env, $context)
{
    if (!$env->isDebug()) {
        return;
    }

    ob_start();

    $count = func_num_args();
    if (2 === $count) {
        $vars = array();
        foreach ($context as $key => $value) {
            if (!$value instanceof Twig_Template) {
                $vars[$key] = $value;
            }
        }

        var_dump($vars);
    } else {
        for ($i = 2; $i < $count; ++$i) {
            var_dump(func_get_arg($i));
        }
    }

    return ob_get_clean();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Extension_Escaper extends Twig_Extension
{
    protected $defaultStrategy;

    /**
     * Constructor.
     *
     * @param string|false|callable $defaultStrategy An escaping strategy
     *
     * @see setDefaultStrategy()
     */
    public function __construct($defaultStrategy = 'html')
    {
        $this->setDefaultStrategy($defaultStrategy);
    }

    public function getTokenParsers()
    {
        return array(new Twig_TokenParser_AutoEscape());
    }

    public function getNodeVisitors()
    {
        return array(new Twig_NodeVisitor_Escaper());
    }

    public function getFilters()
    {
        return array(
            new Twig_SimpleFilter('raw', 'twig_raw_filter', array('is_safe' => array('all'))),
        );
    }

    /**
     * Sets the default strategy to use when not defined by the user.
     *
     * The strategy can be a valid PHP callback that takes the template
     * "filename" as an argument and returns the strategy to use.
     *
     * @param string|false|callable $defaultStrategy An escaping strategy
     */
    public function setDefaultStrategy($defaultStrategy)
    {
        // for BC
        if (true === $defaultStrategy) {
            @trigger_error('Using "true" as the default strategy is deprecated since version 1.21. Use "html" instead.', E_USER_DEPRECATED);

            $defaultStrategy = 'html';
        }

        if ('filename' === $defaultStrategy) {
            $defaultStrategy = array('Twig_FileExtensionEscapingStrategy', 'guess');
        }

        $this->defaultStrategy = $defaultStrategy;
    }

    /**
     * Gets the default strategy to use when not defined by the user.
     *
     * @param string $filename The template "filename"
     *
     * @return string|false The default strategy to use for the template
     */
    public function getDefaultStrategy($filename)
    {
        // disable string callables to avoid calling a function named html or js,
        // or any other upcoming escaping strategy
        if (!is_string($this->defaultStrategy) && false !== $this->defaultStrategy) {
            return call_user_func($this->defaultStrategy, $filename);
        }

        return $this->defaultStrategy;
    }

    public function getName()
    {
        return 'escaper';
    }
}

/**
 * Marks a variable as being safe.
 *
 * @param string $string A PHP variable
 *
 * @return string
 */
function twig_raw_filter($string)
{
    return $string;
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Enables usage of the deprecated Twig_Extension::getGlobals() method.
 *
 * Explicitly implement this interface if you really need to implement the
 * deprecated getGlobals() method in your extensions.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface Twig_Extension_GlobalsInterface
{
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Enables usage of the deprecated Twig_Extension::initRuntime() method.
 *
 * Explicitly implement this interface if you really need to implement the
 * deprecated initRuntime() method in your extensions.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface Twig_Extension_InitRuntimeInterface
{
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Extension_Optimizer extends Twig_Extension
{
    protected $optimizers;

    public function __construct($optimizers = -1)
    {
        $this->optimizers = $optimizers;
    }

    public function getNodeVisitors()
    {
        return array(new Twig_NodeVisitor_Optimizer($this->optimizers));
    }

    public function getName()
    {
        return 'optimizer';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

class Twig_Extension_Profiler extends Twig_Extension
{
    private $actives = array();

    public function __construct(Twig_Profiler_Profile $profile)
    {
        $this->actives[] = $profile;
    }

    public function enter(Twig_Profiler_Profile $profile)
    {
        $this->actives[0]->addProfile($profile);
        array_unshift($this->actives, $profile);
    }

    public function leave(Twig_Profiler_Profile $profile)
    {
        $profile->leave();
        array_shift($this->actives);

        if (1 === count($this->actives)) {
            $this->actives[0]->leave();
        }
    }

    public function getNodeVisitors()
    {
        return array(new Twig_Profiler_NodeVisitor_Profiler($this->getName()));
    }

    public function getName()
    {
        return 'profiler';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Extension_Sandbox extends Twig_Extension
{
    protected $sandboxedGlobally;
    protected $sandboxed;
    protected $policy;

    public function __construct(Twig_Sandbox_SecurityPolicyInterface $policy, $sandboxed = false)
    {
        $this->policy = $policy;
        $this->sandboxedGlobally = $sandboxed;
    }

    public function getTokenParsers()
    {
        return array(new Twig_TokenParser_Sandbox());
    }

    public function getNodeVisitors()
    {
        return array(new Twig_NodeVisitor_Sandbox());
    }

    public function enableSandbox()
    {
        $this->sandboxed = true;
    }

    public function disableSandbox()
    {
        $this->sandboxed = false;
    }

    public function isSandboxed()
    {
        return $this->sandboxedGlobally || $this->sandboxed;
    }

    public function isSandboxedGlobally()
    {
        return $this->sandboxedGlobally;
    }

    public function setSecurityPolicy(Twig_Sandbox_SecurityPolicyInterface $policy)
    {
        $this->policy = $policy;
    }

    public function getSecurityPolicy()
    {
        return $this->policy;
    }

    public function checkSecurity($tags, $filters, $functions)
    {
        if ($this->isSandboxed()) {
            $this->policy->checkSecurity($tags, $filters, $functions);
        }
    }

    public function checkMethodAllowed($obj, $method)
    {
        if ($this->isSandboxed()) {
            $this->policy->checkMethodAllowed($obj, $method);
        }
    }

    public function checkPropertyAllowed($obj, $method)
    {
        if ($this->isSandboxed()) {
            $this->policy->checkPropertyAllowed($obj, $method);
        }
    }

    public function ensureToStringAllowed($obj)
    {
        if ($this->isSandboxed() && is_object($obj)) {
            $this->policy->checkMethodAllowed($obj, '__toString');
        }

        return $obj;
    }

    public function getName()
    {
        return 'sandbox';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Internal class.
 *
 * This class is used by Twig_Environment as a staging area and must not be used directly.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @internal
 */
class Twig_Extension_Staging extends Twig_Extension
{
    protected $functions = array();
    protected $filters = array();
    protected $visitors = array();
    protected $tokenParsers = array();
    protected $globals = array();
    protected $tests = array();

    public function addFunction($name, $function)
    {
        $this->functions[$name] = $function;
    }

    public function getFunctions()
    {
        return $this->functions;
    }

    public function addFilter($name, $filter)
    {
        $this->filters[$name] = $filter;
    }

    public function getFilters()
    {
        return $this->filters;
    }

    public function addNodeVisitor(Twig_NodeVisitorInterface $visitor)
    {
        $this->visitors[] = $visitor;
    }

    public function getNodeVisitors()
    {
        return $this->visitors;
    }

    public function addTokenParser(Twig_TokenParserInterface $parser)
    {
        $this->tokenParsers[] = $parser;
    }

    public function getTokenParsers()
    {
        return $this->tokenParsers;
    }

    public function addGlobal($name, $value)
    {
        $this->globals[$name] = $value;
    }

    public function getGlobals()
    {
        return $this->globals;
    }

    public function addTest($name, $test)
    {
        $this->tests[$name] = $test;
    }

    public function getTests()
    {
        return $this->tests;
    }

    public function getName()
    {
        return 'staging';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Extension_StringLoader extends Twig_Extension
{
    public function getFunctions()
    {
        return array(
            new Twig_SimpleFunction('template_from_string', 'twig_template_from_string', array('needs_environment' => true)),
        );
    }

    public function getName()
    {
        return 'string_loader';
    }
}

/**
 * Loads a template from a string.
 *
 * <pre>
 * {{ include(template_from_string("Hello {{ name }}")) }}
 * </pre>
 *
 * @param Twig_Environment $env      A Twig_Environment instance
 * @param string           $template A template as a string or object implementing __toString()
 *
 * @return Twig_Template A Twig_Template instance
 */
function twig_template_from_string(Twig_Environment $env, $template)
{
    return $env->createTemplate((string) $template);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
abstract class Twig_Extension implements Twig_ExtensionInterface
{
    /**
     * {@inheritdoc}
     *
     * @deprecated since 1.23 (to be removed in 2.0), implement Twig_Extension_InitRuntimeInterface instead
     */
    public function initRuntime(Twig_Environment $environment)
    {
    }

    /**
     * {@inheritdoc}
     */
    public function getTokenParsers()
    {
        return array();
    }

    /**
     * {@inheritdoc}
     */
    public function getNodeVisitors()
    {
        return array();
    }

    /**
     * {@inheritdoc}
     */
    public function getFilters()
    {
        return array();
    }

    /**
     * {@inheritdoc}
     */
    public function getTests()
    {
        return array();
    }

    /**
     * {@inheritdoc}
     */
    public function getFunctions()
    {
        return array();
    }

    /**
     * {@inheritdoc}
     */
    public function getOperators()
    {
        return array();
    }

    /**
     * {@inheritdoc}
     *
     * @deprecated since 1.23 (to be removed in 2.0), implement Twig_Extension_GlobalsInterface instead
     */
    public function getGlobals()
    {
        return array();
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface implemented by extension classes.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface Twig_ExtensionInterface
{
    /**
     * Initializes the runtime environment.
     *
     * This is where you can load some file that contains filter functions for instance.
     *
     * @param Twig_Environment $environment The current Twig_Environment instance
     *
     * @deprecated since 1.23 (to be removed in 2.0), implement Twig_Extension_InitRuntimeInterface instead
     */
    public function initRuntime(Twig_Environment $environment);

    /**
     * Returns the token parser instances to add to the existing list.
     *
     * @return Twig_TokenParserInterface[]
     */
    public function getTokenParsers();

    /**
     * Returns the node visitor instances to add to the existing list.
     *
     * @return Twig_NodeVisitorInterface[] An array of Twig_NodeVisitorInterface instances
     */
    public function getNodeVisitors();

    /**
     * Returns a list of filters to add to the existing list.
     *
     * @return Twig_SimpleFilter[]
     */
    public function getFilters();

    /**
     * Returns a list of tests to add to the existing list.
     *
     * @return Twig_SimpleTest[]
     */
    public function getTests();

    /**
     * Returns a list of functions to add to the existing list.
     *
     * @return Twig_SimpleFunction[]
     */
    public function getFunctions();

    /**
     * Returns a list of operators to add to the existing list.
     *
     * @return array An array of operators
     */
    public function getOperators();

    /**
     * Returns a list of global variables to add to the existing list.
     *
     * @return array An array of global variables
     *
     * @deprecated since 1.23 (to be removed in 2.0), implement Twig_Extension_GlobalsInterface instead
     */
    public function getGlobals();

    /**
     * Returns the name of the extension.
     *
     * @return string The extension name
     */
    public function getName();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Default autoescaping strategy based on file names.
 *
 * This strategy sets the HTML as the default autoescaping strategy,
 * but changes it based on the filename.
 *
 * Note that there is no runtime performance impact as the
 * default autoescaping strategy is set at compilation time.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_FileExtensionEscapingStrategy
{
    /**
     * Guesses the best autoescaping strategy based on the file name.
     *
     * @param string $filename The template file name
     *
     * @return string|false The escaping strategy name to use or false to disable
     */
    public static function guess($filename)
    {
        if (in_array(substr($filename, -1), array('/', '\\'))) {
            return 'html'; // return html for directories
        }

        if ('.twig' === substr($filename, -5)) {
            $filename = substr($filename, 0, -5);
        }

        $extension = pathinfo($filename, PATHINFO_EXTENSION);

        switch ($extension) {
            case 'js':
                return 'js';

            case 'css':
                return 'css';

            case 'txt':
                return false;

            default:
                return 'html';
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Filter_Function class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleFilter instead.', E_USER_DEPRECATED);

/**
 * Represents a function template filter.
 *
 * Use Twig_SimpleFilter instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Filter_Function extends Twig_Filter
{
    protected $function;

    public function __construct($function, array $options = array())
    {
        $options['callable'] = $function;

        parent::__construct($options);

        $this->function = $function;
    }

    public function compile()
    {
        return $this->function;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Filter_Method class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleFilter instead.', E_USER_DEPRECATED);

/**
 * Represents a method template filter.
 *
 * Use Twig_SimpleFilter instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Filter_Method extends Twig_Filter
{
    protected $extension;
    protected $method;

    public function __construct(Twig_ExtensionInterface $extension, $method, array $options = array())
    {
        $options['callable'] = array($extension, $method);

        parent::__construct($options);

        $this->extension = $extension;
        $this->method = $method;
    }

    public function compile()
    {
        return sprintf('$this->env->getExtension(\'%s\')->%s', $this->extension->getName(), $this->method);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Filter_Node class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleFilter instead.', E_USER_DEPRECATED);

/**
 * Represents a template filter as a node.
 *
 * Use Twig_SimpleFilter instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Filter_Node extends Twig_Filter
{
    protected $class;

    public function __construct($class, array $options = array())
    {
        parent::__construct($options);

        $this->class = $class;
    }

    public function getClass()
    {
        return $this->class;
    }

    public function compile()
    {
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Filter class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleFilter instead.', E_USER_DEPRECATED);

/**
 * Represents a template filter.
 *
 * Use Twig_SimpleFilter instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
abstract class Twig_Filter implements Twig_FilterInterface, Twig_FilterCallableInterface
{
    protected $options;
    protected $arguments = array();

    public function __construct(array $options = array())
    {
        $this->options = array_merge(array(
            'needs_environment' => false,
            'needs_context' => false,
            'pre_escape' => null,
            'preserves_safety' => null,
            'callable' => null,
        ), $options);
    }

    public function setArguments($arguments)
    {
        $this->arguments = $arguments;
    }

    public function getArguments()
    {
        return $this->arguments;
    }

    public function needsEnvironment()
    {
        return $this->options['needs_environment'];
    }

    public function needsContext()
    {
        return $this->options['needs_context'];
    }

    public function getSafe(Twig_Node $filterArgs)
    {
        if (isset($this->options['is_safe'])) {
            return $this->options['is_safe'];
        }

        if (isset($this->options['is_safe_callback'])) {
            return call_user_func($this->options['is_safe_callback'], $filterArgs);
        }
    }

    public function getPreservesSafety()
    {
        return $this->options['preserves_safety'];
    }

    public function getPreEscape()
    {
        return $this->options['pre_escape'];
    }

    public function getCallable()
    {
        return $this->options['callable'];
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a callable template filter.
 *
 * Use Twig_SimpleFilter instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
interface Twig_FilterCallableInterface
{
    public function getCallable();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a template filter.
 *
 * Use Twig_SimpleFilter instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
interface Twig_FilterInterface
{
    /**
     * Compiles a filter.
     *
     * @return string The PHP code for the filter
     */
    public function compile();

    public function needsEnvironment();

    public function needsContext();

    public function getSafe(Twig_Node $filterArgs);

    public function getPreservesSafety();

    public function getPreEscape();

    public function setArguments($arguments);

    public function getArguments();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2010 Arnaud Le Blanc
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Function_Function class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleFunction instead.', E_USER_DEPRECATED);

/**
 * Represents a function template function.
 *
 * Use Twig_SimpleFunction instead.
 *
 * @author Arnaud Le Blanc <arnaud.lb@gmail.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Function_Function extends Twig_Function
{
    protected $function;

    public function __construct($function, array $options = array())
    {
        $options['callable'] = $function;

        parent::__construct($options);

        $this->function = $function;
    }

    public function compile()
    {
        return $this->function;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2010 Arnaud Le Blanc
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Function_Method class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleFunction instead.', E_USER_DEPRECATED);

/**
 * Represents a method template function.
 *
 * Use Twig_SimpleFunction instead.
 *
 * @author Arnaud Le Blanc <arnaud.lb@gmail.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Function_Method extends Twig_Function
{
    protected $extension;
    protected $method;

    public function __construct(Twig_ExtensionInterface $extension, $method, array $options = array())
    {
        $options['callable'] = array($extension, $method);

        parent::__construct($options);

        $this->extension = $extension;
        $this->method = $method;
    }

    public function compile()
    {
        return sprintf('$this->env->getExtension(\'%s\')->%s', $this->extension->getName(), $this->method);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Function_Node class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleFunction instead.', E_USER_DEPRECATED);

/**
 * Represents a template function as a node.
 *
 * Use Twig_SimpleFunction instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Function_Node extends Twig_Function
{
    protected $class;

    public function __construct($class, array $options = array())
    {
        parent::__construct($options);

        $this->class = $class;
    }

    public function getClass()
    {
        return $this->class;
    }

    public function compile()
    {
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Function class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleFunction instead.', E_USER_DEPRECATED);

/**
 * Represents a template function.
 *
 * Use Twig_SimpleFunction instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
abstract class Twig_Function implements Twig_FunctionInterface, Twig_FunctionCallableInterface
{
    protected $options;
    protected $arguments = array();

    public function __construct(array $options = array())
    {
        $this->options = array_merge(array(
            'needs_environment' => false,
            'needs_context' => false,
            'callable' => null,
        ), $options);
    }

    public function setArguments($arguments)
    {
        $this->arguments = $arguments;
    }

    public function getArguments()
    {
        return $this->arguments;
    }

    public function needsEnvironment()
    {
        return $this->options['needs_environment'];
    }

    public function needsContext()
    {
        return $this->options['needs_context'];
    }

    public function getSafe(Twig_Node $functionArgs)
    {
        if (isset($this->options['is_safe'])) {
            return $this->options['is_safe'];
        }

        if (isset($this->options['is_safe_callback'])) {
            return call_user_func($this->options['is_safe_callback'], $functionArgs);
        }

        return array();
    }

    public function getCallable()
    {
        return $this->options['callable'];
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a callable template function.
 *
 * Use Twig_SimpleFunction instead.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
interface Twig_FunctionCallableInterface
{
    public function getCallable();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 * (c) 2010 Arnaud Le Blanc
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a template function.
 *
 * Use Twig_SimpleFunction instead.
 *
 * @author Arnaud Le Blanc <arnaud.lb@gmail.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
interface Twig_FunctionInterface
{
    /**
     * Compiles a function.
     *
     * @return string The PHP code for the function
     */
    public function compile();

    public function needsEnvironment();

    public function needsContext();

    public function getSafe(Twig_Node $filterArgs);

    public function setArguments($arguments);

    public function getArguments();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Lexes a template string.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Lexer implements Twig_LexerInterface
{
    protected $tokens;
    protected $code;
    protected $cursor;
    protected $lineno;
    protected $end;
    protected $state;
    protected $states;
    protected $brackets;
    protected $env;
    protected $filename;
    protected $options;
    protected $regexes;
    protected $position;
    protected $positions;
    protected $currentVarBlockLine;

    const STATE_DATA = 0;
    const STATE_BLOCK = 1;
    const STATE_VAR = 2;
    const STATE_STRING = 3;
    const STATE_INTERPOLATION = 4;

    const REGEX_NAME = '/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/A';
    const REGEX_NUMBER = '/[0-9]+(?:\.[0-9]+)?/A';
    const REGEX_STRING = '/"([^#"\\\\]*(?:\\\\.[^#"\\\\]*)*)"|\'([^\'\\\\]*(?:\\\\.[^\'\\\\]*)*)\'/As';
    const REGEX_DQ_STRING_DELIM = '/"/A';
    const REGEX_DQ_STRING_PART = '/[^#"\\\\]*(?:(?:\\\\.|#(?!\{))[^#"\\\\]*)*/As';
    const PUNCTUATION = '()[]{}?:.,|';

    public function __construct(Twig_Environment $env, array $options = array())
    {
        $this->env = $env;

        $this->options = array_merge(array(
            'tag_comment' => array('{#', '#}'),
            'tag_block' => array('{%', '%}'),
            'tag_variable' => array('{{', '}}'),
            'whitespace_trim' => '-',
            'interpolation' => array('#{', '}'),
        ), $options);

        $this->regexes = array(
            'lex_var' => '/\s*'.preg_quote($this->options['whitespace_trim'].$this->options['tag_variable'][1], '/').'\s*|\s*'.preg_quote($this->options['tag_variable'][1], '/').'/A',
            'lex_block' => '/\s*(?:'.preg_quote($this->options['whitespace_trim'].$this->options['tag_block'][1], '/').'\s*|\s*'.preg_quote($this->options['tag_block'][1], '/').')\n?/A',
            'lex_raw_data' => '/('.preg_quote($this->options['tag_block'][0].$this->options['whitespace_trim'], '/').'|'.preg_quote($this->options['tag_block'][0], '/').')\s*(?:end%s)\s*(?:'.preg_quote($this->options['whitespace_trim'].$this->options['tag_block'][1], '/').'\s*|\s*'.preg_quote($this->options['tag_block'][1], '/').')/s',
            'operator' => $this->getOperatorRegex(),
            'lex_comment' => '/(?:'.preg_quote($this->options['whitespace_trim'], '/').preg_quote($this->options['tag_comment'][1], '/').'\s*|'.preg_quote($this->options['tag_comment'][1], '/').')\n?/s',
            'lex_block_raw' => '/\s*(raw|verbatim)\s*(?:'.preg_quote($this->options['whitespace_trim'].$this->options['tag_block'][1], '/').'\s*|\s*'.preg_quote($this->options['tag_block'][1], '/').')/As',
            'lex_block_line' => '/\s*line\s+(\d+)\s*'.preg_quote($this->options['tag_block'][1], '/').'/As',
            'lex_tokens_start' => '/('.preg_quote($this->options['tag_variable'][0], '/').'|'.preg_quote($this->options['tag_block'][0], '/').'|'.preg_quote($this->options['tag_comment'][0], '/').')('.preg_quote($this->options['whitespace_trim'], '/').')?/s',
            'interpolation_start' => '/'.preg_quote($this->options['interpolation'][0], '/').'\s*/A',
            'interpolation_end' => '/\s*'.preg_quote($this->options['interpolation'][1], '/').'/A',
        );
    }

    /**
     * {@inheritdoc}
     */
    public function tokenize($code, $filename = null)
    {
        if (function_exists('mb_internal_encoding') && ((int) ini_get('mbstring.func_overload')) & 2) {
            $mbEncoding = mb_internal_encoding();
            mb_internal_encoding('ASCII');
        } else {
            $mbEncoding = null;
        }

        $this->code = str_replace(array("\r\n", "\r"), "\n", $code);
        $this->filename = $filename;
        $this->cursor = 0;
        $this->lineno = 1;
        $this->end = strlen($this->code);
        $this->tokens = array();
        $this->state = self::STATE_DATA;
        $this->states = array();
        $this->brackets = array();
        $this->position = -1;

        // find all token starts in one go
        preg_match_all($this->regexes['lex_tokens_start'], $this->code, $matches, PREG_OFFSET_CAPTURE);
        $this->positions = $matches;

        while ($this->cursor < $this->end) {
            // dispatch to the lexing functions depending
            // on the current state
            switch ($this->state) {
                case self::STATE_DATA:
                    $this->lexData();
                    break;

                case self::STATE_BLOCK:
                    $this->lexBlock();
                    break;

                case self::STATE_VAR:
                    $this->lexVar();
                    break;

                case self::STATE_STRING:
                    $this->lexString();
                    break;

                case self::STATE_INTERPOLATION:
                    $this->lexInterpolation();
                    break;
            }
        }

        $this->pushToken(Twig_Token::EOF_TYPE);

        if (!empty($this->brackets)) {
            list($expect, $lineno) = array_pop($this->brackets);
            throw new Twig_Error_Syntax(sprintf('Unclosed "%s".', $expect), $lineno, $this->filename);
        }

        if ($mbEncoding) {
            mb_internal_encoding($mbEncoding);
        }

        return new Twig_TokenStream($this->tokens, $this->filename);
    }

    protected function lexData()
    {
        // if no matches are left we return the rest of the template as simple text token
        if ($this->position == count($this->positions[0]) - 1) {
            $this->pushToken(Twig_Token::TEXT_TYPE, substr($this->code, $this->cursor));
            $this->cursor = $this->end;

            return;
        }

        // Find the first token after the current cursor
        $position = $this->positions[0][++$this->position];
        while ($position[1] < $this->cursor) {
            if ($this->position == count($this->positions[0]) - 1) {
                return;
            }
            $position = $this->positions[0][++$this->position];
        }

        // push the template text first
        $text = $textContent = substr($this->code, $this->cursor, $position[1] - $this->cursor);
        if (isset($this->positions[2][$this->position][0])) {
            $text = rtrim($text);
        }
        $this->pushToken(Twig_Token::TEXT_TYPE, $text);
        $this->moveCursor($textContent.$position[0]);

        switch ($this->positions[1][$this->position][0]) {
            case $this->options['tag_comment'][0]:
                $this->lexComment();
                break;

            case $this->options['tag_block'][0]:
                // raw data?
                if (preg_match($this->regexes['lex_block_raw'], $this->code, $match, null, $this->cursor)) {
                    $this->moveCursor($match[0]);
                    $this->lexRawData($match[1]);
                // {% line \d+ %}
                } elseif (preg_match($this->regexes['lex_block_line'], $this->code, $match, null, $this->cursor)) {
                    $this->moveCursor($match[0]);
                    $this->lineno = (int) $match[1];
                } else {
                    $this->pushToken(Twig_Token::BLOCK_START_TYPE);
                    $this->pushState(self::STATE_BLOCK);
                    $this->currentVarBlockLine = $this->lineno;
                }
                break;

            case $this->options['tag_variable'][0]:
                $this->pushToken(Twig_Token::VAR_START_TYPE);
                $this->pushState(self::STATE_VAR);
                $this->currentVarBlockLine = $this->lineno;
                break;
        }
    }

    protected function lexBlock()
    {
        if (empty($this->brackets) && preg_match($this->regexes['lex_block'], $this->code, $match, null, $this->cursor)) {
            $this->pushToken(Twig_Token::BLOCK_END_TYPE);
            $this->moveCursor($match[0]);
            $this->popState();
        } else {
            $this->lexExpression();
        }
    }

    protected function lexVar()
    {
        if (empty($this->brackets) && preg_match($this->regexes['lex_var'], $this->code, $match, null, $this->cursor)) {
            $this->pushToken(Twig_Token::VAR_END_TYPE);
            $this->moveCursor($match[0]);
            $this->popState();
        } else {
            $this->lexExpression();
        }
    }

    protected function lexExpression()
    {
        // whitespace
        if (preg_match('/\s+/A', $this->code, $match, null, $this->cursor)) {
            $this->moveCursor($match[0]);

            if ($this->cursor >= $this->end) {
                throw new Twig_Error_Syntax(sprintf('Unclosed "%s".', $this->state === self::STATE_BLOCK ? 'block' : 'variable'), $this->currentVarBlockLine, $this->filename);
            }
        }

        // operators
        if (preg_match($this->regexes['operator'], $this->code, $match, null, $this->cursor)) {
            $this->pushToken(Twig_Token::OPERATOR_TYPE, preg_replace('/\s+/', ' ', $match[0]));
            $this->moveCursor($match[0]);
        }
        // names
        elseif (preg_match(self::REGEX_NAME, $this->code, $match, null, $this->cursor)) {
            $this->pushToken(Twig_Token::NAME_TYPE, $match[0]);
            $this->moveCursor($match[0]);
        }
        // numbers
        elseif (preg_match(self::REGEX_NUMBER, $this->code, $match, null, $this->cursor)) {
            $number = (float) $match[0];  // floats
            if (ctype_digit($match[0]) && $number <= PHP_INT_MAX) {
                $number = (int) $match[0]; // integers lower than the maximum
            }
            $this->pushToken(Twig_Token::NUMBER_TYPE, $number);
            $this->moveCursor($match[0]);
        }
        // punctuation
        elseif (false !== strpos(self::PUNCTUATION, $this->code[$this->cursor])) {
            // opening bracket
            if (false !== strpos('([{', $this->code[$this->cursor])) {
                $this->brackets[] = array($this->code[$this->cursor], $this->lineno);
            }
            // closing bracket
            elseif (false !== strpos(')]}', $this->code[$this->cursor])) {
                if (empty($this->brackets)) {
                    throw new Twig_Error_Syntax(sprintf('Unexpected "%s".', $this->code[$this->cursor]), $this->lineno, $this->filename);
                }

                list($expect, $lineno) = array_pop($this->brackets);
                if ($this->code[$this->cursor] != strtr($expect, '([{', ')]}')) {
                    throw new Twig_Error_Syntax(sprintf('Unclosed "%s".', $expect), $lineno, $this->filename);
                }
            }

            $this->pushToken(Twig_Token::PUNCTUATION_TYPE, $this->code[$this->cursor]);
            ++$this->cursor;
        }
        // strings
        elseif (preg_match(self::REGEX_STRING, $this->code, $match, null, $this->cursor)) {
            $this->pushToken(Twig_Token::STRING_TYPE, stripcslashes(substr($match[0], 1, -1)));
            $this->moveCursor($match[0]);
        }
        // opening double quoted string
        elseif (preg_match(self::REGEX_DQ_STRING_DELIM, $this->code, $match, null, $this->cursor)) {
            $this->brackets[] = array('"', $this->lineno);
            $this->pushState(self::STATE_STRING);
            $this->moveCursor($match[0]);
        }
        // unlexable
        else {
            throw new Twig_Error_Syntax(sprintf('Unexpected character "%s".', $this->code[$this->cursor]), $this->lineno, $this->filename);
        }
    }

    protected function lexRawData($tag)
    {
        if ('raw' === $tag) {
            @trigger_error(sprintf('Twig Tag "raw" is deprecated since version 1.21. Use "verbatim" instead in %s at line %d.', $this->filename, $this->lineno), E_USER_DEPRECATED);
        }

        if (!preg_match(str_replace('%s', $tag, $this->regexes['lex_raw_data']), $this->code, $match, PREG_OFFSET_CAPTURE, $this->cursor)) {
            throw new Twig_Error_Syntax(sprintf('Unexpected end of file: Unclosed "%s" block.', $tag), $this->lineno, $this->filename);
        }

        $text = substr($this->code, $this->cursor, $match[0][1] - $this->cursor);
        $this->moveCursor($text.$match[0][0]);

        if (false !== strpos($match[1][0], $this->options['whitespace_trim'])) {
            $text = rtrim($text);
        }

        $this->pushToken(Twig_Token::TEXT_TYPE, $text);
    }

    protected function lexComment()
    {
        if (!preg_match($this->regexes['lex_comment'], $this->code, $match, PREG_OFFSET_CAPTURE, $this->cursor)) {
            throw new Twig_Error_Syntax('Unclosed comment.', $this->lineno, $this->filename);
        }

        $this->moveCursor(substr($this->code, $this->cursor, $match[0][1] - $this->cursor).$match[0][0]);
    }

    protected function lexString()
    {
        if (preg_match($this->regexes['interpolation_start'], $this->code, $match, null, $this->cursor)) {
            $this->brackets[] = array($this->options['interpolation'][0], $this->lineno);
            $this->pushToken(Twig_Token::INTERPOLATION_START_TYPE);
            $this->moveCursor($match[0]);
            $this->pushState(self::STATE_INTERPOLATION);
        } elseif (preg_match(self::REGEX_DQ_STRING_PART, $this->code, $match, null, $this->cursor) && strlen($match[0]) > 0) {
            $this->pushToken(Twig_Token::STRING_TYPE, stripcslashes($match[0]));
            $this->moveCursor($match[0]);
        } elseif (preg_match(self::REGEX_DQ_STRING_DELIM, $this->code, $match, null, $this->cursor)) {
            list($expect, $lineno) = array_pop($this->brackets);
            if ($this->code[$this->cursor] != '"') {
                throw new Twig_Error_Syntax(sprintf('Unclosed "%s".', $expect), $lineno, $this->filename);
            }

            $this->popState();
            ++$this->cursor;
        }
    }

    protected function lexInterpolation()
    {
        $bracket = end($this->brackets);
        if ($this->options['interpolation'][0] === $bracket[0] && preg_match($this->regexes['interpolation_end'], $this->code, $match, null, $this->cursor)) {
            array_pop($this->brackets);
            $this->pushToken(Twig_Token::INTERPOLATION_END_TYPE);
            $this->moveCursor($match[0]);
            $this->popState();
        } else {
            $this->lexExpression();
        }
    }

    protected function pushToken($type, $value = '')
    {
        // do not push empty text tokens
        if (Twig_Token::TEXT_TYPE === $type && '' === $value) {
            return;
        }

        $this->tokens[] = new Twig_Token($type, $value, $this->lineno);
    }

    protected function moveCursor($text)
    {
        $this->cursor += strlen($text);
        $this->lineno += substr_count($text, "\n");
    }

    protected function getOperatorRegex()
    {
        $operators = array_merge(
            array('='),
            array_keys($this->env->getUnaryOperators()),
            array_keys($this->env->getBinaryOperators())
        );

        $operators = array_combine($operators, array_map('strlen', $operators));
        arsort($operators);

        $regex = array();
        foreach ($operators as $operator => $length) {
            // an operator that ends with a character must be followed by
            // a whitespace or a parenthesis
            if (ctype_alpha($operator[$length - 1])) {
                $r = preg_quote($operator, '/').'(?=[\s()])';
            } else {
                $r = preg_quote($operator, '/');
            }

            // an operator with a space can be any amount of whitespaces
            $r = preg_replace('/\s+/', '\s+', $r);

            $regex[] = $r;
        }

        return '/'.implode('|', $regex).'/A';
    }

    protected function pushState($state)
    {
        $this->states[] = $this->state;
        $this->state = $state;
    }

    protected function popState()
    {
        if (0 === count($this->states)) {
            throw new Exception('Cannot pop state without a previous state');
        }

        $this->state = array_pop($this->states);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface implemented by lexer classes.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 3.0)
 */
interface Twig_LexerInterface
{
    /**
     * Tokenizes a source code.
     *
     * @param string $code     The source code
     * @param string $filename A unique identifier for the source code
     *
     * @return Twig_TokenStream A token stream instance
     *
     * @throws Twig_Error_Syntax When the code is syntactically wrong
     */
    public function tokenize($code, $filename = null);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Loads a template from an array.
 *
 * When using this loader with a cache mechanism, you should know that a new cache
 * key is generated each time a template content "changes" (the cache key being the
 * source code of the template). If you don't want to see your cache grows out of
 * control, you need to take care of clearing the old cache file by yourself.
 *
 * This loader should only be used for unit testing.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Loader_Array implements Twig_LoaderInterface, Twig_ExistsLoaderInterface
{
    protected $templates = array();

    /**
     * Constructor.
     *
     * @param array $templates An array of templates (keys are the names, and values are the source code)
     */
    public function __construct(array $templates)
    {
        $this->templates = $templates;
    }

    /**
     * Adds or overrides a template.
     *
     * @param string $name     The template name
     * @param string $template The template source
     */
    public function setTemplate($name, $template)
    {
        $this->templates[(string) $name] = $template;
    }

    /**
     * {@inheritdoc}
     */
    public function getSource($name)
    {
        $name = (string) $name;
        if (!isset($this->templates[$name])) {
            throw new Twig_Error_Loader(sprintf('Template "%s" is not defined.', $name));
        }

        return $this->templates[$name];
    }

    /**
     * {@inheritdoc}
     */
    public function exists($name)
    {
        return isset($this->templates[(string) $name]);
    }

    /**
     * {@inheritdoc}
     */
    public function getCacheKey($name)
    {
        $name = (string) $name;
        if (!isset($this->templates[$name])) {
            throw new Twig_Error_Loader(sprintf('Template "%s" is not defined.', $name));
        }

        return $this->templates[$name];
    }

    /**
     * {@inheritdoc}
     */
    public function isFresh($name, $time)
    {
        $name = (string) $name;
        if (!isset($this->templates[$name])) {
            throw new Twig_Error_Loader(sprintf('Template "%s" is not defined.', $name));
        }

        return true;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Loads templates from other loaders.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Loader_Chain implements Twig_LoaderInterface, Twig_ExistsLoaderInterface
{
    private $hasSourceCache = array();
    protected $loaders = array();

    /**
     * Constructor.
     *
     * @param Twig_LoaderInterface[] $loaders An array of loader instances
     */
    public function __construct(array $loaders = array())
    {
        foreach ($loaders as $loader) {
            $this->addLoader($loader);
        }
    }

    /**
     * Adds a loader instance.
     *
     * @param Twig_LoaderInterface $loader A Loader instance
     */
    public function addLoader(Twig_LoaderInterface $loader)
    {
        $this->loaders[] = $loader;
        $this->hasSourceCache = array();
    }

    /**
     * {@inheritdoc}
     */
    public function getSource($name)
    {
        $exceptions = array();
        foreach ($this->loaders as $loader) {
            if ($loader instanceof Twig_ExistsLoaderInterface && !$loader->exists($name)) {
                continue;
            }

            try {
                return $loader->getSource($name);
            } catch (Twig_Error_Loader $e) {
                $exceptions[] = $e->getMessage();
            }
        }

        throw new Twig_Error_Loader(sprintf('Template "%s" is not defined%s.', $name, $exceptions ? ' ('.implode(', ', $exceptions).')' : ''));
    }

    /**
     * {@inheritdoc}
     */
    public function exists($name)
    {
        $name = (string) $name;

        if (isset($this->hasSourceCache[$name])) {
            return $this->hasSourceCache[$name];
        }

        foreach ($this->loaders as $loader) {
            if ($loader instanceof Twig_ExistsLoaderInterface) {
                if ($loader->exists($name)) {
                    return $this->hasSourceCache[$name] = true;
                }

                continue;
            }

            try {
                $loader->getSource($name);

                return $this->hasSourceCache[$name] = true;
            } catch (Twig_Error_Loader $e) {
            }
        }

        return $this->hasSourceCache[$name] = false;
    }

    /**
     * {@inheritdoc}
     */
    public function getCacheKey($name)
    {
        $exceptions = array();
        foreach ($this->loaders as $loader) {
            if ($loader instanceof Twig_ExistsLoaderInterface && !$loader->exists($name)) {
                continue;
            }

            try {
                return $loader->getCacheKey($name);
            } catch (Twig_Error_Loader $e) {
                $exceptions[] = get_class($loader).': '.$e->getMessage();
            }
        }

        throw new Twig_Error_Loader(sprintf('Template "%s" is not defined%s.', $name, $exceptions ? ' ('.implode(', ', $exceptions).')' : ''));
    }

    /**
     * {@inheritdoc}
     */
    public function isFresh($name, $time)
    {
        $exceptions = array();
        foreach ($this->loaders as $loader) {
            if ($loader instanceof Twig_ExistsLoaderInterface && !$loader->exists($name)) {
                continue;
            }

            try {
                return $loader->isFresh($name, $time);
            } catch (Twig_Error_Loader $e) {
                $exceptions[] = get_class($loader).': '.$e->getMessage();
            }
        }

        throw new Twig_Error_Loader(sprintf('Template "%s" is not defined%s.', $name, $exceptions ? ' ('.implode(', ', $exceptions).')' : ''));
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Loads template from the filesystem.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Loader_Filesystem implements Twig_LoaderInterface, Twig_ExistsLoaderInterface
{
    /** Identifier of the main namespace. */
    const MAIN_NAMESPACE = '__main__';

    protected $paths = array();
    protected $cache = array();
    protected $errorCache = array();

    /**
     * Constructor.
     *
     * @param string|array $paths A path or an array of paths where to look for templates
     */
    public function __construct($paths = array())
    {
        if ($paths) {
            $this->setPaths($paths);
        }
    }

    /**
     * Returns the paths to the templates.
     *
     * @param string $namespace A path namespace
     *
     * @return array The array of paths where to look for templates
     */
    public function getPaths($namespace = self::MAIN_NAMESPACE)
    {
        return isset($this->paths[$namespace]) ? $this->paths[$namespace] : array();
    }

    /**
     * Returns the path namespaces.
     *
     * The main namespace is always defined.
     *
     * @return array The array of defined namespaces
     */
    public function getNamespaces()
    {
        return array_keys($this->paths);
    }

    /**
     * Sets the paths where templates are stored.
     *
     * @param string|array $paths     A path or an array of paths where to look for templates
     * @param string       $namespace A path namespace
     */
    public function setPaths($paths, $namespace = self::MAIN_NAMESPACE)
    {
        if (!is_array($paths)) {
            $paths = array($paths);
        }

        $this->paths[$namespace] = array();
        foreach ($paths as $path) {
            $this->addPath($path, $namespace);
        }
    }

    /**
     * Adds a path where templates are stored.
     *
     * @param string $path      A path where to look for templates
     * @param string $namespace A path name
     *
     * @throws Twig_Error_Loader
     */
    public function addPath($path, $namespace = self::MAIN_NAMESPACE)
    {
        // invalidate the cache
        $this->cache = $this->errorCache = array();

        if (!is_dir($path)) {
            throw new Twig_Error_Loader(sprintf('The "%s" directory does not exist.', $path));
        }

        $this->paths[$namespace][] = rtrim($path, '/\\');
    }

    /**
     * Prepends a path where templates are stored.
     *
     * @param string $path      A path where to look for templates
     * @param string $namespace A path name
     *
     * @throws Twig_Error_Loader
     */
    public function prependPath($path, $namespace = self::MAIN_NAMESPACE)
    {
        // invalidate the cache
        $this->cache = $this->errorCache = array();

        if (!is_dir($path)) {
            throw new Twig_Error_Loader(sprintf('The "%s" directory does not exist.', $path));
        }

        $path = rtrim($path, '/\\');

        if (!isset($this->paths[$namespace])) {
            $this->paths[$namespace][] = $path;
        } else {
            array_unshift($this->paths[$namespace], $path);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getSource($name)
    {
        return file_get_contents($this->findTemplate($name));
    }

    /**
     * {@inheritdoc}
     */
    public function getCacheKey($name)
    {
        return $this->findTemplate($name);
    }

    /**
     * {@inheritdoc}
     */
    public function exists($name)
    {
        $name = $this->normalizeName($name);

        if (isset($this->cache[$name])) {
            return true;
        }

        try {
            return false !== $this->findTemplate($name, false);
        } catch (Twig_Error_Loader $exception) {
            return false;
        }
    }

    /**
     * {@inheritdoc}
     */
    public function isFresh($name, $time)
    {
        return filemtime($this->findTemplate($name)) <= $time;
    }

    protected function findTemplate($name)
    {
        $throw = func_num_args() > 1 ? func_get_arg(1) : true;
        $name = $this->normalizeName($name);

        if (isset($this->cache[$name])) {
            return $this->cache[$name];
        }

        if (isset($this->errorCache[$name])) {
            if (!$throw) {
                return false;
            }

            throw new Twig_Error_Loader($this->errorCache[$name]);
        }

        $this->validateName($name);

        list($namespace, $shortname) = $this->parseName($name);

        if (!isset($this->paths[$namespace])) {
            $this->errorCache[$name] = sprintf('There are no registered paths for namespace "%s".', $namespace);

            if (!$throw) {
                return false;
            }

            throw new Twig_Error_Loader($this->errorCache[$name]);
        }

        foreach ($this->paths[$namespace] as $path) {
            if (is_file($path.'/'.$shortname)) {
                if (false !== $realpath = realpath($path.'/'.$shortname)) {
                    return $this->cache[$name] = $realpath;
                }

                return $this->cache[$name] = $path.'/'.$shortname;
            }
        }

        $this->errorCache[$name] = sprintf('Unable to find template "%s" (looked into: %s).', $name, implode(', ', $this->paths[$namespace]));

        if (!$throw) {
            return false;
        }

        throw new Twig_Error_Loader($this->errorCache[$name]);
    }

    protected function parseName($name, $default = self::MAIN_NAMESPACE)
    {
        if (isset($name[0]) && '@' == $name[0]) {
            if (false === $pos = strpos($name, '/')) {
                throw new Twig_Error_Loader(sprintf('Malformed namespaced template name "%s" (expecting "@namespace/template_name").', $name));
            }

            $namespace = substr($name, 1, $pos - 1);
            $shortname = substr($name, $pos + 1);

            return array($namespace, $shortname);
        }

        return array($default, $name);
    }

    protected function normalizeName($name)
    {
        return preg_replace('#/{2,}#', '/', str_replace('\\', '/', (string) $name));
    }

    protected function validateName($name)
    {
        if (false !== strpos($name, "\0")) {
            throw new Twig_Error_Loader('A template name cannot contain NUL bytes.');
        }

        $name = ltrim($name, '/');
        $parts = explode('/', $name);
        $level = 0;
        foreach ($parts as $part) {
            if ('..' === $part) {
                --$level;
            } elseif ('.' !== $part) {
                ++$level;
            }

            if ($level < 0) {
                throw new Twig_Error_Loader(sprintf('Looks like you try to load a template outside configured directories (%s).', $name));
            }
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Loader_String class is deprecated since version 1.18.1 and will be removed in 2.0. Use Twig_Loader_Array instead or Twig_Environment::createTemplate().', E_USER_DEPRECATED);

/**
 * Loads a template from a string.
 *
 * This loader should NEVER be used. It only exists for Twig internal purposes.
 *
 * When using this loader with a cache mechanism, you should know that a new cache
 * key is generated each time a template content "changes" (the cache key being the
 * source code of the template). If you don't want to see your cache grows out of
 * control, you need to take care of clearing the old cache file by yourself.
 *
 * @deprecated since 1.18.1 (to be removed in 2.0)
 *
 * @internal
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Loader_String implements Twig_LoaderInterface, Twig_ExistsLoaderInterface
{
    /**
     * {@inheritdoc}
     */
    public function getSource($name)
    {
        return $name;
    }

    /**
     * {@inheritdoc}
     */
    public function exists($name)
    {
        return true;
    }

    /**
     * {@inheritdoc}
     */
    public function getCacheKey($name)
    {
        return $name;
    }

    /**
     * {@inheritdoc}
     */
    public function isFresh($name, $time)
    {
        return true;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface all loaders must implement.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface Twig_LoaderInterface
{
    /**
     * Gets the source code of a template, given its name.
     *
     * @param string $name The name of the template to load
     *
     * @return string The template source code
     *
     * @throws Twig_Error_Loader When $name is not found
     */
    public function getSource($name);

    /**
     * Gets the cache key to use for the cache for a given template name.
     *
     * @param string $name The name of the template to load
     *
     * @return string The cache key
     *
     * @throws Twig_Error_Loader When $name is not found
     */
    public function getCacheKey($name);

    /**
     * Returns true if the template is still fresh.
     *
     * @param string $name The template name
     * @param int    $time Timestamp of the last modification time of the
     *                     cached template
     *
     * @return bool true if the template is fresh, false otherwise
     *
     * @throws Twig_Error_Loader When $name is not found
     */
    public function isFresh($name, $time);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Marks a content as safe.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Markup implements Countable
{
    protected $content;
    protected $charset;

    public function __construct($content, $charset)
    {
        $this->content = (string) $content;
        $this->charset = $charset;
    }

    public function __toString()
    {
        return $this->content;
    }

    public function count()
    {
        return function_exists('mb_get_info') ? mb_strlen($this->content, $this->charset) : strlen($this->content);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents an autoescape node.
 *
 * The value is the escaping strategy (can be html, js, ...)
 *
 * The true value is equivalent to html.
 *
 * If autoescaping is disabled, then the value is false.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_AutoEscape extends Twig_Node
{
    public function __construct($value, Twig_NodeInterface $body, $lineno, $tag = 'autoescape')
    {
        parent::__construct(array('body' => $body), array('value' => $value), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->subcompile($this->getNode('body'));
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a block node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Block extends Twig_Node
{
    public function __construct($name, Twig_NodeInterface $body, $lineno, $tag = null)
    {
        parent::__construct(array('body' => $body), array('name' => $name), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write(sprintf("public function block_%s(\$context, array \$blocks = array())\n", $this->getAttribute('name')), "{\n")
            ->indent()
        ;

        $compiler
            ->subcompile($this->getNode('body'))
            ->outdent()
            ->write("}\n\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a block call node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_BlockReference extends Twig_Node implements Twig_NodeOutputInterface
{
    public function __construct($name, $lineno, $tag = null)
    {
        parent::__construct(array(), array('name' => $name), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write(sprintf("\$this->displayBlock('%s', \$context, \$blocks);\n", $this->getAttribute('name')))
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a body node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Body extends Twig_Node
{
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_CheckSecurity extends Twig_Node
{
    protected $usedFilters;
    protected $usedTags;
    protected $usedFunctions;

    public function __construct(array $usedFilters, array $usedTags, array $usedFunctions)
    {
        $this->usedFilters = $usedFilters;
        $this->usedTags = $usedTags;
        $this->usedFunctions = $usedFunctions;

        parent::__construct();
    }

    public function compile(Twig_Compiler $compiler)
    {
        $tags = $filters = $functions = array();
        foreach (array('tags', 'filters', 'functions') as $type) {
            foreach ($this->{'used'.ucfirst($type)} as $name => $node) {
                if ($node instanceof Twig_Node) {
                    ${$type}[$name] = $node->getLine();
                } else {
                    ${$type}[$node] = null;
                }
            }
        }

        $compiler
            ->write('$tags = ')->repr(array_filter($tags))->raw(";\n")
            ->write('$filters = ')->repr(array_filter($filters))->raw(";\n")
            ->write('$functions = ')->repr(array_filter($functions))->raw(";\n\n")
            ->write("try {\n")
            ->indent()
            ->write("\$this->env->getExtension('sandbox')->checkSecurity(\n")
            ->indent()
            ->write(!$tags ? "array(),\n" : "array('".implode("', '", array_keys($tags))."'),\n")
            ->write(!$filters ? "array(),\n" : "array('".implode("', '", array_keys($filters))."'),\n")
            ->write(!$functions ? "array()\n" : "array('".implode("', '", array_keys($functions))."')\n")
            ->outdent()
            ->write(");\n")
            ->outdent()
            ->write("} catch (Twig_Sandbox_SecurityError \$e) {\n")
            ->indent()
            ->write("\$e->setTemplateFile(\$this->getTemplateName());\n\n")
            ->write("if (\$e instanceof Twig_Sandbox_SecurityNotAllowedTagError && isset(\$tags[\$e->getTagName()])) {\n")
            ->indent()
            ->write("\$e->setTemplateLine(\$tags[\$e->getTagName()]);\n")
            ->outdent()
            ->write("} elseif (\$e instanceof Twig_Sandbox_SecurityNotAllowedFilterError && isset(\$filters[\$e->getFilterName()])) {\n")
            ->indent()
            ->write("\$e->setTemplateLine(\$filters[\$e->getFilterName()]);\n")
            ->outdent()
            ->write("} elseif (\$e instanceof Twig_Sandbox_SecurityNotAllowedFunctionError && isset(\$functions[\$e->getFunctionName()])) {\n")
            ->indent()
            ->write("\$e->setTemplateLine(\$functions[\$e->getFunctionName()]);\n")
            ->outdent()
            ->write("}\n\n")
            ->write("throw \$e;\n")
            ->outdent()
            ->write("}\n\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a do node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Do extends Twig_Node
{
    public function __construct(Twig_Node_Expression $expr, $lineno, $tag = null)
    {
        parent::__construct(array('expr' => $expr), array(), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write('')
            ->subcompile($this->getNode('expr'))
            ->raw(";\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents an embed node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Embed extends Twig_Node_Include
{
    // we don't inject the module to avoid node visitors to traverse it twice (as it will be already visited in the main module)
    public function __construct($filename, $index, Twig_Node_Expression $variables = null, $only = false, $ignoreMissing = false, $lineno, $tag = null)
    {
        parent::__construct(new Twig_Node_Expression_Constant('not_used', $lineno), $variables, $only, $ignoreMissing, $lineno, $tag);

        $this->setAttribute('filename', $filename);
        $this->setAttribute('index', $index);
    }

    protected function addGetTemplate(Twig_Compiler $compiler)
    {
        $compiler
            ->write('$this->loadTemplate(')
            ->string($this->getAttribute('filename'))
            ->raw(', ')
            ->repr($compiler->getFilename())
            ->raw(', ')
            ->repr($this->getLine())
            ->raw(', ')
            ->string($this->getAttribute('index'))
            ->raw(')')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Array extends Twig_Node_Expression
{
    protected $index;

    public function __construct(array $elements, $lineno)
    {
        parent::__construct($elements, array(), $lineno);

        $this->index = -1;
        foreach ($this->getKeyValuePairs() as $pair) {
            if ($pair['key'] instanceof Twig_Node_Expression_Constant && ctype_digit((string) $pair['key']->getAttribute('value')) && $pair['key']->getAttribute('value') > $this->index) {
                $this->index = $pair['key']->getAttribute('value');
            }
        }
    }

    public function getKeyValuePairs()
    {
        $pairs = array();

        foreach (array_chunk($this->nodes, 2) as $pair) {
            $pairs[] = array(
                'key' => $pair[0],
                'value' => $pair[1],
            );
        }

        return $pairs;
    }

    public function hasElement(Twig_Node_Expression $key)
    {
        foreach ($this->getKeyValuePairs() as $pair) {
            // we compare the string representation of the keys
            // to avoid comparing the line numbers which are not relevant here.
            if ((string) $key == (string) $pair['key']) {
                return true;
            }
        }

        return false;
    }

    public function addElement(Twig_Node_Expression $value, Twig_Node_Expression $key = null)
    {
        if (null === $key) {
            $key = new Twig_Node_Expression_Constant(++$this->index, $value->getLine());
        }

        array_push($this->nodes, $key, $value);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->raw('array(');
        $first = true;
        foreach ($this->getKeyValuePairs() as $pair) {
            if (!$first) {
                $compiler->raw(', ');
            }
            $first = false;

            $compiler
                ->subcompile($pair['key'])
                ->raw(' => ')
                ->subcompile($pair['value'])
            ;
        }
        $compiler->raw(')');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

class Twig_Node_Expression_AssignName extends Twig_Node_Expression_Name
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('$context[')
            ->string($this->getAttribute('name'))
            ->raw(']')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Add extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('+');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_And extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('&&');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_BitwiseAnd extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('&');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_BitwiseOr extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('|');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_BitwiseXor extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('^');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Concat extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('.');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Div extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('/');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2013 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_EndsWith extends Twig_Node_Expression_Binary
{
    public function compile(Twig_Compiler $compiler)
    {
        $left = $compiler->getVarName();
        $right = $compiler->getVarName();
        $compiler
            ->raw(sprintf('(is_string($%s = ', $left))
            ->subcompile($this->getNode('left'))
            ->raw(sprintf(') && is_string($%s = ', $right))
            ->subcompile($this->getNode('right'))
            ->raw(sprintf(') && (\'\' === $%2$s || $%2$s === substr($%1$s, -strlen($%2$s))))', $left, $right))
        ;
    }

    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Equal extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('==');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_FloorDiv extends Twig_Node_Expression_Binary
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler->raw('intval(floor(');
        parent::compile($compiler);
        $compiler->raw('))');
    }

    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('/');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Greater extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('>');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_GreaterEqual extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('>=');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_In extends Twig_Node_Expression_Binary
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('twig_in_filter(')
            ->subcompile($this->getNode('left'))
            ->raw(', ')
            ->subcompile($this->getNode('right'))
            ->raw(')')
        ;
    }

    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('in');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Less extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('<');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_LessEqual extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('<=');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2013 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Matches extends Twig_Node_Expression_Binary
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('preg_match(')
            ->subcompile($this->getNode('right'))
            ->raw(', ')
            ->subcompile($this->getNode('left'))
            ->raw(')')
        ;
    }

    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Mod extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('%');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Mul extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('*');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_NotEqual extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('!=');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_NotIn extends Twig_Node_Expression_Binary
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('!twig_in_filter(')
            ->subcompile($this->getNode('left'))
            ->raw(', ')
            ->subcompile($this->getNode('right'))
            ->raw(')')
        ;
    }

    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('not in');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Or extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('||');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Power extends Twig_Node_Expression_Binary
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('pow(')
            ->subcompile($this->getNode('left'))
            ->raw(', ')
            ->subcompile($this->getNode('right'))
            ->raw(')')
        ;
    }

    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('**');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Range extends Twig_Node_Expression_Binary
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('range(')
            ->subcompile($this->getNode('left'))
            ->raw(', ')
            ->subcompile($this->getNode('right'))
            ->raw(')')
        ;
    }

    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('..');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2013 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_StartsWith extends Twig_Node_Expression_Binary
{
    public function compile(Twig_Compiler $compiler)
    {
        $left = $compiler->getVarName();
        $right = $compiler->getVarName();
        $compiler
            ->raw(sprintf('(is_string($%s = ', $left))
            ->subcompile($this->getNode('left'))
            ->raw(sprintf(') && is_string($%s = ', $right))
            ->subcompile($this->getNode('right'))
            ->raw(sprintf(') && (\'\' === $%2$s || 0 === strpos($%1$s, $%2$s)))', $left, $right))
        ;
    }

    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Binary_Sub extends Twig_Node_Expression_Binary
{
    public function operator(Twig_Compiler $compiler)
    {
        return $compiler->raw('-');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
abstract class Twig_Node_Expression_Binary extends Twig_Node_Expression
{
    public function __construct(Twig_NodeInterface $left, Twig_NodeInterface $right, $lineno)
    {
        parent::__construct(array('left' => $left, 'right' => $right), array(), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('(')
            ->subcompile($this->getNode('left'))
            ->raw(' ')
        ;
        $this->operator($compiler);
        $compiler
            ->raw(' ')
            ->subcompile($this->getNode('right'))
            ->raw(')')
        ;
    }

    abstract public function operator(Twig_Compiler $compiler);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a block call node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_BlockReference extends Twig_Node_Expression
{
    public function __construct(Twig_NodeInterface $name, $asString = false, $lineno, $tag = null)
    {
        parent::__construct(array('name' => $name), array('as_string' => $asString, 'output' => false), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        if ($this->getAttribute('as_string')) {
            $compiler->raw('(string) ');
        }

        if ($this->getAttribute('output')) {
            $compiler
                ->addDebugInfo($this)
                ->write('$this->displayBlock(')
                ->subcompile($this->getNode('name'))
                ->raw(", \$context, \$blocks);\n")
            ;
        } else {
            $compiler
                ->raw('$this->renderBlock(')
                ->subcompile($this->getNode('name'))
                ->raw(', $context, $blocks)')
            ;
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
abstract class Twig_Node_Expression_Call extends Twig_Node_Expression
{
    protected function compileCallable(Twig_Compiler $compiler)
    {
        $closingParenthesis = false;
        if ($this->hasAttribute('callable') && $callable = $this->getAttribute('callable')) {
            if (is_string($callable)) {
                $compiler->raw($callable);
            } elseif (is_array($callable) && $callable[0] instanceof Twig_ExtensionInterface) {
                $compiler->raw(sprintf('$this->env->getExtension(\'%s\')->%s', $callable[0]->getName(), $callable[1]));
            } else {
                $type = ucfirst($this->getAttribute('type'));
                $compiler->raw(sprintf('call_user_func_array($this->env->get%s(\'%s\')->getCallable(), array', $type, $this->getAttribute('name')));
                $closingParenthesis = true;
            }
        } else {
            $compiler->raw($this->getAttribute('thing')->compile());
        }

        $this->compileArguments($compiler);

        if ($closingParenthesis) {
            $compiler->raw(')');
        }
    }

    protected function compileArguments(Twig_Compiler $compiler)
    {
        $compiler->raw('(');

        $first = true;

        if ($this->hasAttribute('needs_environment') && $this->getAttribute('needs_environment')) {
            $compiler->raw('$this->env');
            $first = false;
        }

        if ($this->hasAttribute('needs_context') && $this->getAttribute('needs_context')) {
            if (!$first) {
                $compiler->raw(', ');
            }
            $compiler->raw('$context');
            $first = false;
        }

        if ($this->hasAttribute('arguments')) {
            foreach ($this->getAttribute('arguments') as $argument) {
                if (!$first) {
                    $compiler->raw(', ');
                }
                $compiler->string($argument);
                $first = false;
            }
        }

        if ($this->hasNode('node')) {
            if (!$first) {
                $compiler->raw(', ');
            }
            $compiler->subcompile($this->getNode('node'));
            $first = false;
        }

        if ($this->hasNode('arguments') && null !== $this->getNode('arguments')) {
            $callable = $this->hasAttribute('callable') ? $this->getAttribute('callable') : null;

            $arguments = $this->getArguments($callable, $this->getNode('arguments'));

            foreach ($arguments as $node) {
                if (!$first) {
                    $compiler->raw(', ');
                }
                $compiler->subcompile($node);
                $first = false;
            }
        }

        $compiler->raw(')');
    }

    protected function getArguments($callable, $arguments)
    {
        $callType = $this->getAttribute('type');
        $callName = $this->getAttribute('name');

        $parameters = array();
        $named = false;
        foreach ($arguments as $name => $node) {
            if (!is_int($name)) {
                $named = true;
                $name = $this->normalizeName($name);
            } elseif ($named) {
                throw new Twig_Error_Syntax(sprintf('Positional arguments cannot be used after named arguments for %s "%s".', $callType, $callName));
            }

            $parameters[$name] = $node;
        }

        $isVariadic = $this->hasAttribute('is_variadic') && $this->getAttribute('is_variadic');
        if (!$named && !$isVariadic) {
            return $parameters;
        }

        if (!$callable) {
            if ($named) {
                $message = sprintf('Named arguments are not supported for %s "%s".', $callType, $callName);
            } else {
                $message = sprintf('Arbitrary positional arguments are not supported for %s "%s".', $callType, $callName);
            }

            throw new LogicException($message);
        }

        // manage named arguments
        $callableParameters = $this->getCallableParameters($callable, $isVariadic);
        $arguments = array();
        $names = array();
        $missingArguments = array();
        $optionalArguments = array();
        $pos = 0;
        foreach ($callableParameters as $callableParameter) {
            $names[] = $name = $this->normalizeName($callableParameter->name);

            if (array_key_exists($name, $parameters)) {
                if (array_key_exists($pos, $parameters)) {
                    throw new Twig_Error_Syntax(sprintf('Argument "%s" is defined twice for %s "%s".', $name, $callType, $callName));
                }

                if (!empty($missingArguments)) {
                    throw new Twig_Error_Syntax(sprintf(
                        'Argument "%s" could not be assigned for %s "%s(%s)" because it is mapped to an internal PHP function which cannot determine default value for optional argument%s "%s".',
                        $name, $callType, $callName, implode(', ', $names), count($missingArguments) > 1 ? 's' : '', implode('", "', $missingArguments))
                    );
                }

                $arguments = array_merge($arguments, $optionalArguments);
                $arguments[] = $parameters[$name];
                unset($parameters[$name]);
                $optionalArguments = array();
            } elseif (array_key_exists($pos, $parameters)) {
                $arguments = array_merge($arguments, $optionalArguments);
                $arguments[] = $parameters[$pos];
                unset($parameters[$pos]);
                $optionalArguments = array();
                ++$pos;
            } elseif ($callableParameter->isDefaultValueAvailable()) {
                $optionalArguments[] = new Twig_Node_Expression_Constant($callableParameter->getDefaultValue(), -1);
            } elseif ($callableParameter->isOptional()) {
                if (empty($parameters)) {
                    break;
                } else {
                    $missingArguments[] = $name;
                }
            } else {
                throw new Twig_Error_Syntax(sprintf('Value for argument "%s" is required for %s "%s".', $name, $callType, $callName));
            }
        }

        if ($isVariadic) {
            $arbitraryArguments = new Twig_Node_Expression_Array(array(), -1);
            foreach ($parameters as $key => $value) {
                if (is_int($key)) {
                    $arbitraryArguments->addElement($value);
                } else {
                    $arbitraryArguments->addElement($value, new Twig_Node_Expression_Constant($key, -1));
                }
                unset($parameters[$key]);
            }

            if ($arbitraryArguments->count()) {
                $arguments = array_merge($arguments, $optionalArguments);
                $arguments[] = $arbitraryArguments;
            }
        }

        if (!empty($parameters)) {
            $unknownParameter = null;
            foreach ($parameters as $parameter) {
                if ($parameter instanceof Twig_Node) {
                    $unknownParameter = $parameter;
                    break;
                }
            }

            throw new Twig_Error_Syntax(sprintf(
                'Unknown argument%s "%s" for %s "%s(%s)".',
                count($parameters) > 1 ? 's' : '', implode('", "', array_keys($parameters)), $callType, $callName, implode(', ', $names)
            ), $unknownParameter ? $unknownParameter->getLine() : -1);
        }

        return $arguments;
    }

    protected function normalizeName($name)
    {
        return strtolower(preg_replace(array('/([A-Z]+)([A-Z][a-z])/', '/([a-z\d])([A-Z])/'), array('\\1_\\2', '\\1_\\2'), $name));
    }

    private function getCallableParameters($callable, $isVariadic)
    {
        if (is_array($callable)) {
            $r = new ReflectionMethod($callable[0], $callable[1]);
        } elseif (is_object($callable) && !$callable instanceof Closure) {
            $r = new ReflectionObject($callable);
            $r = $r->getMethod('__invoke');
        } elseif (is_string($callable) && false !== strpos($callable, '::')) {
            $r = new ReflectionMethod($callable);
        } else {
            $r = new ReflectionFunction($callable);
        }

        $parameters = $r->getParameters();
        if ($this->hasNode('node')) {
            array_shift($parameters);
        }
        if ($this->hasAttribute('needs_environment') && $this->getAttribute('needs_environment')) {
            array_shift($parameters);
        }
        if ($this->hasAttribute('needs_context') && $this->getAttribute('needs_context')) {
            array_shift($parameters);
        }
        if ($this->hasAttribute('arguments') && null !== $this->getAttribute('arguments')) {
            foreach ($this->getAttribute('arguments') as $argument) {
                array_shift($parameters);
            }
        }
        if ($isVariadic) {
            $argument = end($parameters);
            if ($argument && $argument->isArray() && $argument->isDefaultValueAvailable() && array() === $argument->getDefaultValue()) {
                array_pop($parameters);
            } else {
                $callableName = $r->name;
                if ($r->getDeclaringClass()) {
                    $callableName = $r->getDeclaringClass()->name.'::'.$callableName;
                }

                throw new LogicException(sprintf('The last parameter of "%s" for %s "%s" must be an array with default value, eg. "array $arg = array()".', $callableName, $this->getAttribute('type'), $this->getAttribute('name')));
            }
        }

        return $parameters;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Conditional extends Twig_Node_Expression
{
    public function __construct(Twig_Node_Expression $expr1, Twig_Node_Expression $expr2, Twig_Node_Expression $expr3, $lineno)
    {
        parent::__construct(array('expr1' => $expr1, 'expr2' => $expr2, 'expr3' => $expr3), array(), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('((')
            ->subcompile($this->getNode('expr1'))
            ->raw(') ? (')
            ->subcompile($this->getNode('expr2'))
            ->raw(') : (')
            ->subcompile($this->getNode('expr3'))
            ->raw('))')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Constant extends Twig_Node_Expression
{
    public function __construct($value, $lineno)
    {
        parent::__construct(array(), array('value' => $value), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->repr($this->getAttribute('value'));
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Node_Expression_ExtensionReference class is deprecated since version 1.23 and will be removed in 2.0.', E_USER_DEPRECATED);

/**
 * Represents an extension call node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.23 and will be removed in 2.0.
 */
class Twig_Node_Expression_ExtensionReference extends Twig_Node_Expression
{
    public function __construct($name, $lineno, $tag = null)
    {
        parent::__construct(array(), array('name' => $name), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->raw(sprintf("\$this->env->getExtension('%s')", $this->getAttribute('name')));
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Returns the value or the default value when it is undefined or empty.
 *
 * <pre>
 *  {{ var.foo|default('foo item on var is not defined') }}
 * </pre>
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Filter_Default extends Twig_Node_Expression_Filter
{
    public function __construct(Twig_NodeInterface $node, Twig_Node_Expression_Constant $filterName, Twig_NodeInterface $arguments, $lineno, $tag = null)
    {
        $default = new Twig_Node_Expression_Filter($node, new Twig_Node_Expression_Constant('default', $node->getLine()), $arguments, $node->getLine());

        if ('default' === $filterName->getAttribute('value') && ($node instanceof Twig_Node_Expression_Name || $node instanceof Twig_Node_Expression_GetAttr)) {
            $test = new Twig_Node_Expression_Test_Defined(clone $node, 'defined', new Twig_Node(), $node->getLine());
            $false = count($arguments) ? $arguments->getNode(0) : new Twig_Node_Expression_Constant('', $node->getLine());

            $node = new Twig_Node_Expression_Conditional($test, $default, $false, $node->getLine());
        } else {
            $node = $default;
        }

        parent::__construct($node, $filterName, $arguments, $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->subcompile($this->getNode('node'));
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Filter extends Twig_Node_Expression_Call
{
    public function __construct(Twig_NodeInterface $node, Twig_Node_Expression_Constant $filterName, Twig_NodeInterface $arguments, $lineno, $tag = null)
    {
        parent::__construct(array('node' => $node, 'filter' => $filterName, 'arguments' => $arguments), array(), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $name = $this->getNode('filter')->getAttribute('value');
        $filter = $compiler->getEnvironment()->getFilter($name);

        $this->setAttribute('name', $name);
        $this->setAttribute('type', 'filter');
        $this->setAttribute('thing', $filter);
        $this->setAttribute('needs_environment', $filter->needsEnvironment());
        $this->setAttribute('needs_context', $filter->needsContext());
        $this->setAttribute('arguments', $filter->getArguments());
        if ($filter instanceof Twig_FilterCallableInterface || $filter instanceof Twig_SimpleFilter) {
            $this->setAttribute('callable', $filter->getCallable());
        }
        if ($filter instanceof Twig_SimpleFilter) {
            $this->setAttribute('is_variadic', $filter->isVariadic());
        }

        $this->compileCallable($compiler);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Function extends Twig_Node_Expression_Call
{
    public function __construct($name, Twig_NodeInterface $arguments, $lineno)
    {
        parent::__construct(array('arguments' => $arguments), array('name' => $name), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $name = $this->getAttribute('name');
        $function = $compiler->getEnvironment()->getFunction($name);

        $this->setAttribute('name', $name);
        $this->setAttribute('type', 'function');
        $this->setAttribute('thing', $function);
        $this->setAttribute('needs_environment', $function->needsEnvironment());
        $this->setAttribute('needs_context', $function->needsContext());
        $this->setAttribute('arguments', $function->getArguments());
        if ($function instanceof Twig_FunctionCallableInterface || $function instanceof Twig_SimpleFunction) {
            $this->setAttribute('callable', $function->getCallable());
        }
        if ($function instanceof Twig_SimpleFunction) {
            $this->setAttribute('is_variadic', $function->isVariadic());
        }

        $this->compileCallable($compiler);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_GetAttr extends Twig_Node_Expression
{
    public function __construct(Twig_Node_Expression $node, Twig_Node_Expression $attribute, Twig_Node_Expression $arguments = null, $type, $lineno)
    {
        parent::__construct(array('node' => $node, 'attribute' => $attribute, 'arguments' => $arguments), array('type' => $type, 'is_defined_test' => false, 'ignore_strict_check' => false, 'disable_c_ext' => false), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        if (function_exists('twig_template_get_attributes') && !$this->getAttribute('disable_c_ext')) {
            $compiler->raw('twig_template_get_attributes($this, ');
        } else {
            $compiler->raw('$this->getAttribute(');
        }

        if ($this->getAttribute('ignore_strict_check')) {
            $this->getNode('node')->setAttribute('ignore_strict_check', true);
        }

        $compiler->subcompile($this->getNode('node'));

        $compiler->raw(', ')->subcompile($this->getNode('attribute'));

        // only generate optional arguments when needed (to make generated code more readable)
        $needFourth = $this->getAttribute('ignore_strict_check');
        $needThird = $needFourth || $this->getAttribute('is_defined_test');
        $needSecond = $needThird || Twig_Template::ANY_CALL !== $this->getAttribute('type');
        $needFirst = $needSecond || null !== $this->getNode('arguments');

        if ($needFirst) {
            if (null !== $this->getNode('arguments')) {
                $compiler->raw(', ')->subcompile($this->getNode('arguments'));
            } else {
                $compiler->raw(', array()');
            }
        }

        if ($needSecond) {
            $compiler->raw(', ')->repr($this->getAttribute('type'));
        }

        if ($needThird) {
            $compiler->raw(', ')->repr($this->getAttribute('is_defined_test'));
        }

        if ($needFourth) {
            $compiler->raw(', ')->repr($this->getAttribute('ignore_strict_check'));
        }

        $compiler->raw(')');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_MethodCall extends Twig_Node_Expression
{
    public function __construct(Twig_Node_Expression $node, $method, Twig_Node_Expression_Array $arguments, $lineno)
    {
        parent::__construct(array('node' => $node, 'arguments' => $arguments), array('method' => $method, 'safe' => false), $lineno);

        if ($node instanceof Twig_Node_Expression_Name) {
            $node->setAttribute('always_defined', true);
        }
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->subcompile($this->getNode('node'))
            ->raw('->')
            ->raw($this->getAttribute('method'))
            ->raw('(')
        ;
        $first = true;
        foreach ($this->getNode('arguments')->getKeyValuePairs() as $pair) {
            if (!$first) {
                $compiler->raw(', ');
            }
            $first = false;

            $compiler->subcompile($pair['value']);
        }
        $compiler->raw(')');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Name extends Twig_Node_Expression
{
    protected $specialVars = array(
        '_self' => '$this',
        '_context' => '$context',
        '_charset' => '$this->env->getCharset()',
    );

    public function __construct($name, $lineno)
    {
        parent::__construct(array(), array('name' => $name, 'is_defined_test' => false, 'ignore_strict_check' => false, 'always_defined' => false), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $name = $this->getAttribute('name');

        $compiler->addDebugInfo($this);

        if ($this->getAttribute('is_defined_test')) {
            if ($this->isSpecial()) {
                $compiler->repr(true);
            } else {
                $compiler->raw('array_key_exists(')->repr($name)->raw(', $context)');
            }
        } elseif ($this->isSpecial()) {
            $compiler->raw($this->specialVars[$name]);
        } elseif ($this->getAttribute('always_defined')) {
            $compiler
                ->raw('$context[')
                ->string($name)
                ->raw(']')
            ;
        } else {
            // remove the non-PHP 5.4 version when PHP 5.3 support is dropped
            // as the non-optimized version is just a workaround for slow ternary operator
            // when the context has a lot of variables
            if (PHP_VERSION_ID >= 50400) {
                // PHP 5.4 ternary operator performance was optimized
                $compiler
                    ->raw('(isset($context[')
                    ->string($name)
                    ->raw(']) ? $context[')
                    ->string($name)
                    ->raw('] : ')
                ;

                if ($this->getAttribute('ignore_strict_check') || !$compiler->getEnvironment()->isStrictVariables()) {
                    $compiler->raw('null)');
                } else {
                    $compiler->raw('$this->getContext($context, ')->string($name)->raw('))');
                }
            } else {
                $compiler
                    ->raw('$this->getContext($context, ')
                    ->string($name)
                ;

                if ($this->getAttribute('ignore_strict_check')) {
                    $compiler->raw(', true');
                }

                $compiler
                    ->raw(')')
                ;
            }
        }
    }

    public function isSpecial()
    {
        return isset($this->specialVars[$this->getAttribute('name')]);
    }

    public function isSimple()
    {
        return !$this->isSpecial() && !$this->getAttribute('is_defined_test');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_NullCoalesce extends Twig_Node_Expression_Conditional
{
    public function __construct(Twig_NodeInterface $left, Twig_NodeInterface $right, $lineno)
    {
        $test = new Twig_Node_Expression_Binary_And(
            new Twig_Node_Expression_Test_Defined(clone $left, 'defined', new Twig_Node(), $left->getLine()),
            new Twig_Node_Expression_Unary_Not(new Twig_Node_Expression_Test_Null($left, 'null', new Twig_Node(), $left->getLine()), $left->getLine()),
            $left->getLine()
        );

        parent::__construct($test, $left, $right, $lineno);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a parent node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Parent extends Twig_Node_Expression
{
    public function __construct($name, $lineno, $tag = null)
    {
        parent::__construct(array(), array('output' => false, 'name' => $name), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        if ($this->getAttribute('output')) {
            $compiler
                ->addDebugInfo($this)
                ->write('$this->displayParentBlock(')
                ->string($this->getAttribute('name'))
                ->raw(", \$context, \$blocks);\n")
            ;
        } else {
            $compiler
                ->raw('$this->renderParentBlock(')
                ->string($this->getAttribute('name'))
                ->raw(', $context, $blocks)')
            ;
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_TempName extends Twig_Node_Expression
{
    public function __construct($name, $lineno)
    {
        parent::__construct(array(), array('name' => $name), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('$_')
            ->raw($this->getAttribute('name'))
            ->raw('_')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Checks if a variable is the exact same value as a constant.
 *
 * <pre>
 *  {% if post.status is constant('Post::PUBLISHED') %}
 *    the status attribute is exactly the same as Post::PUBLISHED
 *  {% endif %}
 * </pre>
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Test_Constant extends Twig_Node_Expression_Test
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('(')
            ->subcompile($this->getNode('node'))
            ->raw(' === constant(')
        ;

        if ($this->getNode('arguments')->hasNode(1)) {
            $compiler
                ->raw('get_class(')
                ->subcompile($this->getNode('arguments')->getNode(1))
                ->raw(')."::".')
            ;
        }

        $compiler
            ->subcompile($this->getNode('arguments')->getNode(0))
            ->raw('))')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Checks if a variable is defined in the current context.
 *
 * <pre>
 * {# defined works with variable names and variable attributes #}
 * {% if foo is defined %}
 *     {# ... #}
 * {% endif %}
 * </pre>
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Test_Defined extends Twig_Node_Expression_Test
{
    public function __construct(Twig_NodeInterface $node, $name, Twig_NodeInterface $arguments = null, $lineno)
    {
        if ($node instanceof Twig_Node_Expression_Name) {
            $node->setAttribute('is_defined_test', true);
        } elseif ($node instanceof Twig_Node_Expression_GetAttr) {
            $node->setAttribute('is_defined_test', true);

            $this->changeIgnoreStrictCheck($node);
        } elseif ($node instanceof Twig_Node_Expression_Constant || $node instanceof Twig_Node_Expression_Array) {
            $node = new Twig_Node_Expression_Constant(true, $node->getLine());
        } else {
            throw new Twig_Error_Syntax('The "defined" test only works with simple variables.', $this->getLine());
        }

        parent::__construct($node, $name, $arguments, $lineno);
    }

    protected function changeIgnoreStrictCheck(Twig_Node_Expression_GetAttr $node)
    {
        $node->setAttribute('ignore_strict_check', true);

        if ($node->getNode('node') instanceof Twig_Node_Expression_GetAttr) {
            $this->changeIgnoreStrictCheck($node->getNode('node'));
        }
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->subcompile($this->getNode('node'));
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Checks if a variable is divisible by a number.
 *
 * <pre>
 *  {% if loop.index is divisible by(3) %}
 * </pre>
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Test_Divisibleby extends Twig_Node_Expression_Test
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('(0 == ')
            ->subcompile($this->getNode('node'))
            ->raw(' % ')
            ->subcompile($this->getNode('arguments')->getNode(0))
            ->raw(')')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Checks if a number is even.
 *
 * <pre>
 *  {{ var is even }}
 * </pre>
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Test_Even extends Twig_Node_Expression_Test
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('(')
            ->subcompile($this->getNode('node'))
            ->raw(' % 2 == 0')
            ->raw(')')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Checks that a variable is null.
 *
 * <pre>
 *  {{ var is none }}
 * </pre>
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Test_Null extends Twig_Node_Expression_Test
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('(null === ')
            ->subcompile($this->getNode('node'))
            ->raw(')')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Checks if a number is odd.
 *
 * <pre>
 *  {{ var is odd }}
 * </pre>
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Test_Odd extends Twig_Node_Expression_Test
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('(')
            ->subcompile($this->getNode('node'))
            ->raw(' % 2 == 1')
            ->raw(')')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Checks if a variable is the same as another one (=== in PHP).
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Expression_Test_Sameas extends Twig_Node_Expression_Test
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->raw('(')
            ->subcompile($this->getNode('node'))
            ->raw(' === ')
            ->subcompile($this->getNode('arguments')->getNode(0))
            ->raw(')')
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Unary_Neg extends Twig_Node_Expression_Unary
{
    public function operator(Twig_Compiler $compiler)
    {
        $compiler->raw('-');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Unary_Not extends Twig_Node_Expression_Unary
{
    public function operator(Twig_Compiler $compiler)
    {
        $compiler->raw('!');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
class Twig_Node_Expression_Unary_Pos extends Twig_Node_Expression_Unary
{
    public function operator(Twig_Compiler $compiler)
    {
        $compiler->raw('+');
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
abstract class Twig_Node_Expression_Unary extends Twig_Node_Expression
{
    public function __construct(Twig_NodeInterface $node, $lineno)
    {
        parent::__construct(array('node' => $node), array(), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->raw(' ');
        $this->operator($compiler);
        $compiler->subcompile($this->getNode('node'));
    }

    abstract public function operator(Twig_Compiler $compiler);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Abstract class for all nodes that represents an expression.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
abstract class Twig_Node_Expression extends Twig_Node
{
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a flush node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Flush extends Twig_Node
{
    public function __construct($lineno, $tag)
    {
        parent::__construct(array(), array(), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write("flush();\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a for node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_For extends Twig_Node
{
    protected $loop;

    public function __construct(Twig_Node_Expression_AssignName $keyTarget, Twig_Node_Expression_AssignName $valueTarget, Twig_Node_Expression $seq, Twig_Node_Expression $ifexpr = null, Twig_NodeInterface $body, Twig_NodeInterface $else = null, $lineno, $tag = null)
    {
        $body = new Twig_Node(array($body, $this->loop = new Twig_Node_ForLoop($lineno, $tag)));

        if (null !== $ifexpr) {
            $body = new Twig_Node_If(new Twig_Node(array($ifexpr, $body)), null, $lineno, $tag);
        }

        parent::__construct(array('key_target' => $keyTarget, 'value_target' => $valueTarget, 'seq' => $seq, 'body' => $body, 'else' => $else), array('with_loop' => true, 'ifexpr' => null !== $ifexpr), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write("\$context['_parent'] = \$context;\n")
            ->write("\$context['_seq'] = twig_ensure_traversable(")
            ->subcompile($this->getNode('seq'))
            ->raw(");\n")
        ;

        if (null !== $this->getNode('else')) {
            $compiler->write("\$context['_iterated'] = false;\n");
        }

        if ($this->getAttribute('with_loop')) {
            $compiler
                ->write("\$context['loop'] = array(\n")
                ->write("  'parent' => \$context['_parent'],\n")
                ->write("  'index0' => 0,\n")
                ->write("  'index'  => 1,\n")
                ->write("  'first'  => true,\n")
                ->write(");\n")
            ;

            if (!$this->getAttribute('ifexpr')) {
                $compiler
                    ->write("if (is_array(\$context['_seq']) || (is_object(\$context['_seq']) && \$context['_seq'] instanceof Countable)) {\n")
                    ->indent()
                    ->write("\$length = count(\$context['_seq']);\n")
                    ->write("\$context['loop']['revindex0'] = \$length - 1;\n")
                    ->write("\$context['loop']['revindex'] = \$length;\n")
                    ->write("\$context['loop']['length'] = \$length;\n")
                    ->write("\$context['loop']['last'] = 1 === \$length;\n")
                    ->outdent()
                    ->write("}\n")
                ;
            }
        }

        $this->loop->setAttribute('else', null !== $this->getNode('else'));
        $this->loop->setAttribute('with_loop', $this->getAttribute('with_loop'));
        $this->loop->setAttribute('ifexpr', $this->getAttribute('ifexpr'));

        $compiler
            ->write("foreach (\$context['_seq'] as ")
            ->subcompile($this->getNode('key_target'))
            ->raw(' => ')
            ->subcompile($this->getNode('value_target'))
            ->raw(") {\n")
            ->indent()
            ->subcompile($this->getNode('body'))
            ->outdent()
            ->write("}\n")
        ;

        if (null !== $this->getNode('else')) {
            $compiler
                ->write("if (!\$context['_iterated']) {\n")
                ->indent()
                ->subcompile($this->getNode('else'))
                ->outdent()
                ->write("}\n")
            ;
        }

        $compiler->write("\$_parent = \$context['_parent'];\n");

        // remove some "private" loop variables (needed for nested loops)
        $compiler->write('unset($context[\'_seq\'], $context[\'_iterated\'], $context[\''.$this->getNode('key_target')->getAttribute('name').'\'], $context[\''.$this->getNode('value_target')->getAttribute('name').'\'], $context[\'_parent\'], $context[\'loop\']);'."\n");

        // keep the values set in the inner context for variables defined in the outer context
        $compiler->write("\$context = array_intersect_key(\$context, \$_parent) + \$_parent;\n");
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Internal node used by the for node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_ForLoop extends Twig_Node
{
    public function __construct($lineno, $tag = null)
    {
        parent::__construct(array(), array('with_loop' => false, 'ifexpr' => false, 'else' => false), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        if ($this->getAttribute('else')) {
            $compiler->write("\$context['_iterated'] = true;\n");
        }

        if ($this->getAttribute('with_loop')) {
            $compiler
                ->write("++\$context['loop']['index0'];\n")
                ->write("++\$context['loop']['index'];\n")
                ->write("\$context['loop']['first'] = false;\n")
            ;

            if (!$this->getAttribute('ifexpr')) {
                $compiler
                    ->write("if (isset(\$context['loop']['length'])) {\n")
                    ->indent()
                    ->write("--\$context['loop']['revindex0'];\n")
                    ->write("--\$context['loop']['revindex'];\n")
                    ->write("\$context['loop']['last'] = 0 === \$context['loop']['revindex0'];\n")
                    ->outdent()
                    ->write("}\n")
                ;
            }
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents an if node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_If extends Twig_Node
{
    public function __construct(Twig_NodeInterface $tests, Twig_NodeInterface $else = null, $lineno, $tag = null)
    {
        parent::__construct(array('tests' => $tests, 'else' => $else), array(), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->addDebugInfo($this);
        for ($i = 0, $count = count($this->getNode('tests')); $i < $count; $i += 2) {
            if ($i > 0) {
                $compiler
                    ->outdent()
                    ->write('} elseif (')
                ;
            } else {
                $compiler
                    ->write('if (')
                ;
            }

            $compiler
                ->subcompile($this->getNode('tests')->getNode($i))
                ->raw(") {\n")
                ->indent()
                ->subcompile($this->getNode('tests')->getNode($i + 1))
            ;
        }

        if ($this->hasNode('else') && null !== $this->getNode('else')) {
            $compiler
                ->outdent()
                ->write("} else {\n")
                ->indent()
                ->subcompile($this->getNode('else'))
            ;
        }

        $compiler
            ->outdent()
            ->write("}\n");
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents an import node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Import extends Twig_Node
{
    public function __construct(Twig_Node_Expression $expr, Twig_Node_Expression $var, $lineno, $tag = null)
    {
        parent::__construct(array('expr' => $expr, 'var' => $var), array(), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write('')
            ->subcompile($this->getNode('var'))
            ->raw(' = ')
        ;

        if ($this->getNode('expr') instanceof Twig_Node_Expression_Name && '_self' === $this->getNode('expr')->getAttribute('name')) {
            $compiler->raw('$this');
        } else {
            $compiler
                ->raw('$this->loadTemplate(')
                ->subcompile($this->getNode('expr'))
                ->raw(', ')
                ->repr($compiler->getFilename())
                ->raw(', ')
                ->repr($this->getLine())
                ->raw(')')
            ;
        }

        $compiler->raw(";\n");
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents an include node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Include extends Twig_Node implements Twig_NodeOutputInterface
{
    public function __construct(Twig_Node_Expression $expr, Twig_Node_Expression $variables = null, $only = false, $ignoreMissing = false, $lineno, $tag = null)
    {
        parent::__construct(array('expr' => $expr, 'variables' => $variables), array('only' => (bool) $only, 'ignore_missing' => (bool) $ignoreMissing), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->addDebugInfo($this);

        if ($this->getAttribute('ignore_missing')) {
            $compiler
                ->write("try {\n")
                ->indent()
            ;
        }

        $this->addGetTemplate($compiler);

        $compiler->raw('->display(');

        $this->addTemplateArguments($compiler);

        $compiler->raw(");\n");

        if ($this->getAttribute('ignore_missing')) {
            $compiler
                ->outdent()
                ->write("} catch (Twig_Error_Loader \$e) {\n")
                ->indent()
                ->write("// ignore missing template\n")
                ->outdent()
                ->write("}\n\n")
            ;
        }
    }

    protected function addGetTemplate(Twig_Compiler $compiler)
    {
        $compiler
             ->write('$this->loadTemplate(')
             ->subcompile($this->getNode('expr'))
             ->raw(', ')
             ->repr($compiler->getFilename())
             ->raw(', ')
             ->repr($this->getLine())
             ->raw(')')
         ;
    }

    protected function addTemplateArguments(Twig_Compiler $compiler)
    {
        if (null === $this->getNode('variables')) {
            $compiler->raw(false === $this->getAttribute('only') ? '$context' : 'array()');
        } elseif (false === $this->getAttribute('only')) {
            $compiler
                ->raw('array_merge($context, ')
                ->subcompile($this->getNode('variables'))
                ->raw(')')
            ;
        } else {
            $compiler->subcompile($this->getNode('variables'));
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a macro node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Macro extends Twig_Node
{
    const VARARGS_NAME = 'varargs';

    public function __construct($name, Twig_NodeInterface $body, Twig_NodeInterface $arguments, $lineno, $tag = null)
    {
        foreach ($arguments as $argumentName => $argument) {
            if (self::VARARGS_NAME === $argumentName) {
                throw new Twig_Error_Syntax(sprintf('The argument "%s" in macro "%s" cannot be defined because the variable "%s" is reserved for arbitrary arguments.', self::VARARGS_NAME, $name, self::VARARGS_NAME), $argument->getLine());
            }
        }

        parent::__construct(array('body' => $body, 'arguments' => $arguments), array('name' => $name), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write(sprintf('public function get%s(', $this->getAttribute('name')))
        ;

        $count = count($this->getNode('arguments'));
        $pos = 0;
        foreach ($this->getNode('arguments') as $name => $default) {
            $compiler
                ->raw('$__'.$name.'__ = ')
                ->subcompile($default)
            ;

            if (++$pos < $count) {
                $compiler->raw(', ');
            }
        }

        if (PHP_VERSION_ID >= 50600) {
            if ($count) {
                $compiler->raw(', ');
            }

            $compiler->raw('...$__varargs__');
        }

        $compiler
            ->raw(")\n")
            ->write("{\n")
            ->indent()
        ;

        $compiler
            ->write("\$context = \$this->env->mergeGlobals(array(\n")
            ->indent()
        ;

        foreach ($this->getNode('arguments') as $name => $default) {
            $compiler
                ->addIndentation()
                ->string($name)
                ->raw(' => $__'.$name.'__')
                ->raw(",\n")
            ;
        }

        $compiler
            ->addIndentation()
            ->string(self::VARARGS_NAME)
            ->raw(' => ')
        ;

        if (PHP_VERSION_ID >= 50600) {
            $compiler->raw("\$__varargs__,\n");
        } else {
            $compiler
                ->raw('func_num_args() > ')
                ->repr($count)
                ->raw(' ? array_slice(func_get_args(), ')
                ->repr($count)
                ->raw(") : array(),\n")
            ;
        }

        $compiler
            ->outdent()
            ->write("));\n\n")
            ->write("\$blocks = array();\n\n")
            ->write("ob_start();\n")
            ->write("try {\n")
            ->indent()
            ->subcompile($this->getNode('body'))
            ->outdent()
            ->write("} catch (Exception \$e) {\n")
            ->indent()
            ->write("ob_end_clean();\n\n")
            ->write("throw \$e;\n")
            ->outdent()
            ->write("}\n\n")
            ->write("return ('' === \$tmp = ob_get_clean()) ? '' : new Twig_Markup(\$tmp, \$this->env->getCharset());\n")
            ->outdent()
            ->write("}\n\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a module node.
 *
 * Consider this class as being final. If you need to customize the behavior of
 * the generated class, consider adding nodes to the following nodes: display_start,
 * display_end, constructor_start, constructor_end, and class_end.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Module extends Twig_Node
{
    public function __construct(Twig_NodeInterface $body, Twig_Node_Expression $parent = null, Twig_NodeInterface $blocks, Twig_NodeInterface $macros, Twig_NodeInterface $traits, $embeddedTemplates, $filename)
    {
        // embedded templates are set as attributes so that they are only visited once by the visitors
        parent::__construct(array(
            'parent' => $parent,
            'body' => $body,
            'blocks' => $blocks,
            'macros' => $macros,
            'traits' => $traits,
            'display_start' => new Twig_Node(),
            'display_end' => new Twig_Node(),
            'constructor_start' => new Twig_Node(),
            'constructor_end' => new Twig_Node(),
            'class_end' => new Twig_Node(),
        ), array(
            'filename' => $filename,
            'index' => null,
            'embedded_templates' => $embeddedTemplates,
        ), 1);
    }

    public function setIndex($index)
    {
        $this->setAttribute('index', $index);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $this->compileTemplate($compiler);

        foreach ($this->getAttribute('embedded_templates') as $template) {
            $compiler->subcompile($template);
        }
    }

    protected function compileTemplate(Twig_Compiler $compiler)
    {
        if (!$this->getAttribute('index')) {
            $compiler->write('<?php');
        }

        $this->compileClassHeader($compiler);

        if (
            count($this->getNode('blocks'))
            || count($this->getNode('traits'))
            || null === $this->getNode('parent')
            || $this->getNode('parent') instanceof Twig_Node_Expression_Constant
            || count($this->getNode('constructor_start'))
            || count($this->getNode('constructor_end'))
        ) {
            $this->compileConstructor($compiler);
        }

        $this->compileGetParent($compiler);

        $this->compileDisplay($compiler);

        $compiler->subcompile($this->getNode('blocks'));

        $this->compileMacros($compiler);

        $this->compileGetTemplateName($compiler);

        $this->compileIsTraitable($compiler);

        $this->compileDebugInfo($compiler);

        $this->compileClassFooter($compiler);
    }

    protected function compileGetParent(Twig_Compiler $compiler)
    {
        if (null === $parent = $this->getNode('parent')) {
            return;
        }

        $compiler
            ->write("protected function doGetParent(array \$context)\n", "{\n")
            ->indent()
            ->addDebugInfo($parent)
            ->write('return ')
        ;

        if ($parent instanceof Twig_Node_Expression_Constant) {
            $compiler->subcompile($parent);
        } else {
            $compiler
                ->raw('$this->loadTemplate(')
                ->subcompile($parent)
                ->raw(', ')
                ->repr($compiler->getFilename())
                ->raw(', ')
                ->repr($this->getNode('parent')->getLine())
                ->raw(')')
            ;
        }

        $compiler
            ->raw(";\n")
            ->outdent()
            ->write("}\n\n")
        ;
    }

    protected function compileClassHeader(Twig_Compiler $compiler)
    {
        $compiler
            ->write("\n\n")
            // if the filename contains */, add a blank to avoid a PHP parse error
            ->write('/* '.str_replace('*/', '* /', $this->getAttribute('filename'))." */\n")
            ->write('class '.$compiler->getEnvironment()->getTemplateClass($this->getAttribute('filename'), $this->getAttribute('index')))
            ->raw(sprintf(" extends %s\n", $compiler->getEnvironment()->getBaseTemplateClass()))
            ->write("{\n")
            ->indent()
        ;
    }

    protected function compileConstructor(Twig_Compiler $compiler)
    {
        $compiler
            ->write("public function __construct(Twig_Environment \$env)\n", "{\n")
            ->indent()
            ->subcompile($this->getNode('constructor_start'))
            ->write("parent::__construct(\$env);\n\n")
        ;

        // parent
        if (null === $parent = $this->getNode('parent')) {
            $compiler->write("\$this->parent = false;\n\n");
        } elseif ($parent instanceof Twig_Node_Expression_Constant) {
            $compiler
                ->addDebugInfo($parent)
                ->write('$this->parent = $this->loadTemplate(')
                ->subcompile($parent)
                ->raw(', ')
                ->repr($compiler->getFilename())
                ->raw(', ')
                ->repr($this->getNode('parent')->getLine())
                ->raw(");\n")
            ;
        }

        $countTraits = count($this->getNode('traits'));
        if ($countTraits) {
            // traits
            foreach ($this->getNode('traits') as $i => $trait) {
                $this->compileLoadTemplate($compiler, $trait->getNode('template'), sprintf('$_trait_%s', $i));

                $compiler
                    ->addDebugInfo($trait->getNode('template'))
                    ->write(sprintf("if (!\$_trait_%s->isTraitable()) {\n", $i))
                    ->indent()
                    ->write("throw new Twig_Error_Runtime('Template \"'.")
                    ->subcompile($trait->getNode('template'))
                    ->raw(".'\" cannot be used as a trait.');\n")
                    ->outdent()
                    ->write("}\n")
                    ->write(sprintf("\$_trait_%s_blocks = \$_trait_%s->getBlocks();\n\n", $i, $i))
                ;

                foreach ($trait->getNode('targets') as $key => $value) {
                    $compiler
                        ->write(sprintf('if (!isset($_trait_%s_blocks[', $i))
                        ->string($key)
                        ->raw("])) {\n")
                        ->indent()
                        ->write("throw new Twig_Error_Runtime(sprintf('Block ")
                        ->string($key)
                        ->raw(' is not defined in trait ')
                        ->subcompile($trait->getNode('template'))
                        ->raw(".'));\n")
                        ->outdent()
                        ->write("}\n\n")

                        ->write(sprintf('$_trait_%s_blocks[', $i))
                        ->subcompile($value)
                        ->raw(sprintf('] = $_trait_%s_blocks[', $i))
                        ->string($key)
                        ->raw(sprintf(']; unset($_trait_%s_blocks[', $i))
                        ->string($key)
                        ->raw("]);\n\n")
                    ;
                }
            }

            if ($countTraits > 1) {
                $compiler
                    ->write("\$this->traits = array_merge(\n")
                    ->indent()
                ;

                for ($i = 0; $i < $countTraits; ++$i) {
                    $compiler
                        ->write(sprintf('$_trait_%s_blocks'.($i == $countTraits - 1 ? '' : ',')."\n", $i))
                    ;
                }

                $compiler
                    ->outdent()
                    ->write(");\n\n")
                ;
            } else {
                $compiler
                    ->write("\$this->traits = \$_trait_0_blocks;\n\n")
                ;
            }

            $compiler
                ->write("\$this->blocks = array_merge(\n")
                ->indent()
                ->write("\$this->traits,\n")
                ->write("array(\n")
            ;
        } else {
            $compiler
                ->write("\$this->blocks = array(\n")
            ;
        }

        // blocks
        $compiler
            ->indent()
        ;

        foreach ($this->getNode('blocks') as $name => $node) {
            $compiler
                ->write(sprintf("'%s' => array(\$this, 'block_%s'),\n", $name, $name))
            ;
        }

        if ($countTraits) {
            $compiler
                ->outdent()
                ->write(")\n")
            ;
        }

        $compiler
            ->outdent()
            ->write(");\n")
            ->outdent()
            ->subcompile($this->getNode('constructor_end'))
            ->write("}\n\n")
        ;
    }

    protected function compileDisplay(Twig_Compiler $compiler)
    {
        $compiler
            ->write("protected function doDisplay(array \$context, array \$blocks = array())\n", "{\n")
            ->indent()
            ->subcompile($this->getNode('display_start'))
            ->subcompile($this->getNode('body'))
        ;

        if (null !== $parent = $this->getNode('parent')) {
            $compiler->addDebugInfo($parent);
            if ($parent instanceof Twig_Node_Expression_Constant) {
                $compiler->write('$this->parent');
            } else {
                $compiler->write('$this->getParent($context)');
            }
            $compiler->raw("->display(\$context, array_merge(\$this->blocks, \$blocks));\n");
        }

        $compiler
            ->subcompile($this->getNode('display_end'))
            ->outdent()
            ->write("}\n\n")
        ;
    }

    protected function compileClassFooter(Twig_Compiler $compiler)
    {
        $compiler
            ->subcompile($this->getNode('class_end'))
            ->outdent()
            ->write("}\n")
        ;
    }

    protected function compileMacros(Twig_Compiler $compiler)
    {
        $compiler->subcompile($this->getNode('macros'));
    }

    protected function compileGetTemplateName(Twig_Compiler $compiler)
    {
        $compiler
            ->write("public function getTemplateName()\n", "{\n")
            ->indent()
            ->write('return ')
            ->repr($this->getAttribute('filename'))
            ->raw(";\n")
            ->outdent()
            ->write("}\n\n")
        ;
    }

    protected function compileIsTraitable(Twig_Compiler $compiler)
    {
        // A template can be used as a trait if:
        //   * it has no parent
        //   * it has no macros
        //   * it has no body
        //
        // Put another way, a template can be used as a trait if it
        // only contains blocks and use statements.
        $traitable = null === $this->getNode('parent') && 0 === count($this->getNode('macros'));
        if ($traitable) {
            if ($this->getNode('body') instanceof Twig_Node_Body) {
                $nodes = $this->getNode('body')->getNode(0);
            } else {
                $nodes = $this->getNode('body');
            }

            if (!count($nodes)) {
                $nodes = new Twig_Node(array($nodes));
            }

            foreach ($nodes as $node) {
                if (!count($node)) {
                    continue;
                }

                if ($node instanceof Twig_Node_Text && ctype_space($node->getAttribute('data'))) {
                    continue;
                }

                if ($node instanceof Twig_Node_BlockReference) {
                    continue;
                }

                $traitable = false;
                break;
            }
        }

        if ($traitable) {
            return;
        }

        $compiler
            ->write("public function isTraitable()\n", "{\n")
            ->indent()
            ->write(sprintf("return %s;\n", $traitable ? 'true' : 'false'))
            ->outdent()
            ->write("}\n\n")
        ;
    }

    protected function compileDebugInfo(Twig_Compiler $compiler)
    {
        $compiler
            ->write("public function getDebugInfo()\n", "{\n")
            ->indent()
            ->write(sprintf("return %s;\n", str_replace("\n", '', var_export(array_reverse($compiler->getDebugInfo(), true), true))))
            ->outdent()
            ->write("}\n")
        ;
    }

    protected function compileLoadTemplate(Twig_Compiler $compiler, $node, $var)
    {
        if ($node instanceof Twig_Node_Expression_Constant) {
            $compiler
                ->write(sprintf('%s = $this->loadTemplate(', $var))
                ->subcompile($node)
                ->raw(', ')
                ->repr($compiler->getFilename())
                ->raw(', ')
                ->repr($node->getLine())
                ->raw(");\n")
            ;
        } else {
            throw new LogicException('Trait templates can only be constant nodes');
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a node that outputs an expression.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Print extends Twig_Node implements Twig_NodeOutputInterface
{
    public function __construct(Twig_Node_Expression $expr, $lineno, $tag = null)
    {
        parent::__construct(array('expr' => $expr), array(), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write('echo ')
            ->subcompile($this->getNode('expr'))
            ->raw(";\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a sandbox node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Sandbox extends Twig_Node
{
    public function __construct(Twig_NodeInterface $body, $lineno, $tag = null)
    {
        parent::__construct(array('body' => $body), array(), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write("\$sandbox = \$this->env->getExtension('sandbox');\n")
            ->write("if (!\$alreadySandboxed = \$sandbox->isSandboxed()) {\n")
            ->indent()
            ->write("\$sandbox->enableSandbox();\n")
            ->outdent()
            ->write("}\n")
            ->subcompile($this->getNode('body'))
            ->write("if (!\$alreadySandboxed) {\n")
            ->indent()
            ->write("\$sandbox->disableSandbox();\n")
            ->outdent()
            ->write("}\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Twig_Node_SandboxedPrint adds a check for the __toString() method
 * when the variable is an object and the sandbox is activated.
 *
 * When there is a simple Print statement, like {{ article }},
 * and if the sandbox is enabled, we need to check that the __toString()
 * method is allowed if 'article' is an object.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_SandboxedPrint extends Twig_Node_Print
{
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write('echo $this->env->getExtension(\'sandbox\')->ensureToStringAllowed(')
            ->subcompile($this->getNode('expr'))
            ->raw(");\n")
        ;
    }

    /**
     * Removes node filters.
     *
     * This is mostly needed when another visitor adds filters (like the escaper one).
     *
     * @param Twig_Node $node A Node
     *
     * @return Twig_Node
     */
    protected function removeNodeFilter($node)
    {
        if ($node instanceof Twig_Node_Expression_Filter) {
            return $this->removeNodeFilter($node->getNode('node'));
        }

        return $node;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a set node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Set extends Twig_Node
{
    public function __construct($capture, Twig_NodeInterface $names, Twig_NodeInterface $values, $lineno, $tag = null)
    {
        parent::__construct(array('names' => $names, 'values' => $values), array('capture' => $capture, 'safe' => false), $lineno, $tag);

        /*
         * Optimizes the node when capture is used for a large block of text.
         *
         * {% set foo %}foo{% endset %} is compiled to $context['foo'] = new Twig_Markup("foo");
         */
        if ($this->getAttribute('capture')) {
            $this->setAttribute('safe', true);

            $values = $this->getNode('values');
            if ($values instanceof Twig_Node_Text) {
                $this->setNode('values', new Twig_Node_Expression_Constant($values->getAttribute('data'), $values->getLine()));
                $this->setAttribute('capture', false);
            }
        }
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->addDebugInfo($this);

        if (count($this->getNode('names')) > 1) {
            $compiler->write('list(');
            foreach ($this->getNode('names') as $idx => $node) {
                if ($idx) {
                    $compiler->raw(', ');
                }

                $compiler->subcompile($node);
            }
            $compiler->raw(')');
        } else {
            if ($this->getAttribute('capture')) {
                $compiler
                    ->write("ob_start();\n")
                    ->subcompile($this->getNode('values'))
                ;
            }

            $compiler->subcompile($this->getNode('names'), false);

            if ($this->getAttribute('capture')) {
                $compiler->raw(" = ('' === \$tmp = ob_get_clean()) ? '' : new Twig_Markup(\$tmp, \$this->env->getCharset())");
            }
        }

        if (!$this->getAttribute('capture')) {
            $compiler->raw(' = ');

            if (count($this->getNode('names')) > 1) {
                $compiler->write('array(');
                foreach ($this->getNode('values') as $idx => $value) {
                    if ($idx) {
                        $compiler->raw(', ');
                    }

                    $compiler->subcompile($value);
                }
                $compiler->raw(')');
            } else {
                if ($this->getAttribute('safe')) {
                    $compiler
                        ->raw("('' === \$tmp = ")
                        ->subcompile($this->getNode('values'))
                        ->raw(") ? '' : new Twig_Markup(\$tmp, \$this->env->getCharset())")
                    ;
                } else {
                    $compiler->subcompile($this->getNode('values'));
                }
            }
        }

        $compiler->raw(";\n");
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

class Twig_Node_SetTemp extends Twig_Node
{
    public function __construct($name, $lineno)
    {
        parent::__construct(array(), array('name' => $name), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $name = $this->getAttribute('name');
        $compiler
            ->addDebugInfo($this)
            ->write('if (isset($context[')
            ->string($name)
            ->raw('])) { $_')
            ->raw($name)
            ->raw('_ = $context[')
            ->repr($name)
            ->raw(']; } else { $_')
            ->raw($name)
            ->raw("_ = null; }\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a spaceless node.
 *
 * It removes spaces between HTML tags.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Spaceless extends Twig_Node
{
    public function __construct(Twig_NodeInterface $body, $lineno, $tag = 'spaceless')
    {
        parent::__construct(array('body' => $body), array(), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write("ob_start();\n")
            ->subcompile($this->getNode('body'))
            ->write("echo trim(preg_replace('/>\s+</', '><', ob_get_clean()));\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a text node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node_Text extends Twig_Node implements Twig_NodeOutputInterface
{
    public function __construct($data, $lineno)
    {
        parent::__construct(array(), array('data' => $data), $lineno);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->addDebugInfo($this)
            ->write('echo ')
            ->string($this->getAttribute('data'))
            ->raw(";\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a node in the AST.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Node implements Twig_NodeInterface
{
    protected $nodes;
    protected $attributes;
    protected $lineno;
    protected $tag;

    /**
     * Constructor.
     *
     * The nodes are automatically made available as properties ($this->node).
     * The attributes are automatically made available as array items ($this['name']).
     *
     * @param array  $nodes      An array of named nodes
     * @param array  $attributes An array of attributes (should not be nodes)
     * @param int    $lineno     The line number
     * @param string $tag        The tag name associated with the Node
     */
    public function __construct(array $nodes = array(), array $attributes = array(), $lineno = 0, $tag = null)
    {
        $this->nodes = $nodes;
        $this->attributes = $attributes;
        $this->lineno = $lineno;
        $this->tag = $tag;
    }

    public function __toString()
    {
        $attributes = array();
        foreach ($this->attributes as $name => $value) {
            $attributes[] = sprintf('%s: %s', $name, str_replace("\n", '', var_export($value, true)));
        }

        $repr = array(get_class($this).'('.implode(', ', $attributes));

        if (count($this->nodes)) {
            foreach ($this->nodes as $name => $node) {
                $len = strlen($name) + 4;
                $noderepr = array();
                foreach (explode("\n", (string) $node) as $line) {
                    $noderepr[] = str_repeat(' ', $len).$line;
                }

                $repr[] = sprintf('  %s: %s', $name, ltrim(implode("\n", $noderepr)));
            }

            $repr[] = ')';
        } else {
            $repr[0] .= ')';
        }

        return implode("\n", $repr);
    }

    /**
     * @deprecated since 1.16.1 (to be removed in 2.0)
     */
    public function toXml($asDom = false)
    {
        @trigger_error(sprintf('%s is deprecated since version 1.16.1 and will be removed in 2.0.', __METHOD__), E_USER_DEPRECATED);

        $dom = new DOMDocument('1.0', 'UTF-8');
        $dom->formatOutput = true;
        $dom->appendChild($xml = $dom->createElement('twig'));

        $xml->appendChild($node = $dom->createElement('node'));
        $node->setAttribute('class', get_class($this));

        foreach ($this->attributes as $name => $value) {
            $node->appendChild($attribute = $dom->createElement('attribute'));
            $attribute->setAttribute('name', $name);
            $attribute->appendChild($dom->createTextNode($value));
        }

        foreach ($this->nodes as $name => $n) {
            if (null === $n) {
                continue;
            }

            $child = $n->toXml(true)->getElementsByTagName('node')->item(0);
            $child = $dom->importNode($child, true);
            $child->setAttribute('name', $name);

            $node->appendChild($child);
        }

        return $asDom ? $dom : $dom->saveXML();
    }

    public function compile(Twig_Compiler $compiler)
    {
        foreach ($this->nodes as $node) {
            $node->compile($compiler);
        }
    }

    public function getLine()
    {
        return $this->lineno;
    }

    public function getNodeTag()
    {
        return $this->tag;
    }

    /**
     * Returns true if the attribute is defined.
     *
     * @param string $name The attribute name
     *
     * @return bool true if the attribute is defined, false otherwise
     */
    public function hasAttribute($name)
    {
        return array_key_exists($name, $this->attributes);
    }

    /**
     * Gets an attribute value by name.
     *
     * @param string $name
     *
     * @return mixed
     */
    public function getAttribute($name)
    {
        if (!array_key_exists($name, $this->attributes)) {
            throw new LogicException(sprintf('Attribute "%s" does not exist for Node "%s".', $name, get_class($this)));
        }

        return $this->attributes[$name];
    }

    /**
     * Sets an attribute by name to a value.
     *
     * @param string $name
     * @param mixed  $value
     */
    public function setAttribute($name, $value)
    {
        $this->attributes[$name] = $value;
    }

    /**
     * Removes an attribute by name.
     *
     * @param string $name
     */
    public function removeAttribute($name)
    {
        unset($this->attributes[$name]);
    }

    /**
     * Returns true if the node with the given name exists.
     *
     * @param string $name
     *
     * @return bool
     */
    public function hasNode($name)
    {
        return array_key_exists($name, $this->nodes);
    }

    /**
     * Gets a node by name.
     *
     * @param string $name
     *
     * @return Twig_Node
     */
    public function getNode($name)
    {
        if (!array_key_exists($name, $this->nodes)) {
            throw new LogicException(sprintf('Node "%s" does not exist for Node "%s".', $name, get_class($this)));
        }

        return $this->nodes[$name];
    }

    /**
     * Sets a node.
     *
     * @param string    $name
     * @param Twig_Node $node
     */
    public function setNode($name, $node = null)
    {
        $this->nodes[$name] = $node;
    }

    /**
     * Removes a node by name.
     *
     * @param string $name
     */
    public function removeNode($name)
    {
        unset($this->nodes[$name]);
    }

    public function count()
    {
        return count($this->nodes);
    }

    public function getIterator()
    {
        return new ArrayIterator($this->nodes);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a node in the AST.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 3.0)
 */
interface Twig_NodeInterface extends Countable, IteratorAggregate
{
    /**
     * Compiles the node to PHP.
     *
     * @param Twig_Compiler $compiler A Twig_Compiler instance
     */
    public function compile(Twig_Compiler $compiler);

    public function getLine();

    public function getNodeTag();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a displayable node in the AST.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface Twig_NodeOutputInterface
{
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Twig_NodeTraverser is a node traverser.
 *
 * It visits all nodes and their children and calls the given visitor for each.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_NodeTraverser
{
    protected $env;
    protected $visitors = array();

    /**
     * Constructor.
     *
     * @param Twig_Environment            $env      A Twig_Environment instance
     * @param Twig_NodeVisitorInterface[] $visitors An array of Twig_NodeVisitorInterface instances
     */
    public function __construct(Twig_Environment $env, array $visitors = array())
    {
        $this->env = $env;
        foreach ($visitors as $visitor) {
            $this->addVisitor($visitor);
        }
    }

    /**
     * Adds a visitor.
     *
     * @param Twig_NodeVisitorInterface $visitor A Twig_NodeVisitorInterface instance
     */
    public function addVisitor(Twig_NodeVisitorInterface $visitor)
    {
        if (!isset($this->visitors[$visitor->getPriority()])) {
            $this->visitors[$visitor->getPriority()] = array();
        }

        $this->visitors[$visitor->getPriority()][] = $visitor;
    }

    /**
     * Traverses a node and calls the registered visitors.
     *
     * @param Twig_NodeInterface $node A Twig_NodeInterface instance
     *
     * @return Twig_NodeInterface
     */
    public function traverse(Twig_NodeInterface $node)
    {
        ksort($this->visitors);
        foreach ($this->visitors as $visitors) {
            foreach ($visitors as $visitor) {
                $node = $this->traverseForVisitor($visitor, $node);
            }
        }

        return $node;
    }

    protected function traverseForVisitor(Twig_NodeVisitorInterface $visitor, Twig_NodeInterface $node = null)
    {
        if (null === $node) {
            return;
        }

        $node = $visitor->enterNode($node, $this->env);

        foreach ($node as $k => $n) {
            if (false !== $n = $this->traverseForVisitor($visitor, $n)) {
                $node->setNode($k, $n);
            } else {
                $node->removeNode($k);
            }
        }

        return $visitor->leaveNode($node, $this->env);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Twig_NodeVisitor_Escaper implements output escaping.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_NodeVisitor_Escaper extends Twig_BaseNodeVisitor
{
    protected $statusStack = array();
    protected $blocks = array();
    protected $safeAnalysis;
    protected $traverser;
    protected $defaultStrategy = false;
    protected $safeVars = array();

    public function __construct()
    {
        $this->safeAnalysis = new Twig_NodeVisitor_SafeAnalysis();
    }

    /**
     * {@inheritdoc}
     */
    protected function doEnterNode(Twig_Node $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_Module) {
            if ($env->hasExtension('escaper') && $defaultStrategy = $env->getExtension('escaper')->getDefaultStrategy($node->getAttribute('filename'))) {
                $this->defaultStrategy = $defaultStrategy;
            }
            $this->safeVars = array();
        } elseif ($node instanceof Twig_Node_AutoEscape) {
            $this->statusStack[] = $node->getAttribute('value');
        } elseif ($node instanceof Twig_Node_Block) {
            $this->statusStack[] = isset($this->blocks[$node->getAttribute('name')]) ? $this->blocks[$node->getAttribute('name')] : $this->needEscaping($env);
        } elseif ($node instanceof Twig_Node_Import) {
            $this->safeVars[] = $node->getNode('var')->getAttribute('name');
        }

        return $node;
    }

    /**
     * {@inheritdoc}
     */
    protected function doLeaveNode(Twig_Node $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_Module) {
            $this->defaultStrategy = false;
            $this->safeVars = array();
        } elseif ($node instanceof Twig_Node_Expression_Filter) {
            return $this->preEscapeFilterNode($node, $env);
        } elseif ($node instanceof Twig_Node_Print) {
            return $this->escapePrintNode($node, $env, $this->needEscaping($env));
        }

        if ($node instanceof Twig_Node_AutoEscape || $node instanceof Twig_Node_Block) {
            array_pop($this->statusStack);
        } elseif ($node instanceof Twig_Node_BlockReference) {
            $this->blocks[$node->getAttribute('name')] = $this->needEscaping($env);
        }

        return $node;
    }

    protected function escapePrintNode(Twig_Node_Print $node, Twig_Environment $env, $type)
    {
        if (false === $type) {
            return $node;
        }

        $expression = $node->getNode('expr');

        if ($this->isSafeFor($type, $expression, $env)) {
            return $node;
        }

        $class = get_class($node);

        return new $class(
            $this->getEscaperFilter($type, $expression),
            $node->getLine()
        );
    }

    protected function preEscapeFilterNode(Twig_Node_Expression_Filter $filter, Twig_Environment $env)
    {
        $name = $filter->getNode('filter')->getAttribute('value');

        $type = $env->getFilter($name)->getPreEscape();
        if (null === $type) {
            return $filter;
        }

        $node = $filter->getNode('node');
        if ($this->isSafeFor($type, $node, $env)) {
            return $filter;
        }

        $filter->setNode('node', $this->getEscaperFilter($type, $node));

        return $filter;
    }

    protected function isSafeFor($type, Twig_NodeInterface $expression, $env)
    {
        $safe = $this->safeAnalysis->getSafe($expression);

        if (null === $safe) {
            if (null === $this->traverser) {
                $this->traverser = new Twig_NodeTraverser($env, array($this->safeAnalysis));
            }

            $this->safeAnalysis->setSafeVars($this->safeVars);

            $this->traverser->traverse($expression);
            $safe = $this->safeAnalysis->getSafe($expression);
        }

        return in_array($type, $safe) || in_array('all', $safe);
    }

    protected function needEscaping(Twig_Environment $env)
    {
        if (count($this->statusStack)) {
            return $this->statusStack[count($this->statusStack) - 1];
        }

        return $this->defaultStrategy ? $this->defaultStrategy : false;
    }

    protected function getEscaperFilter($type, Twig_NodeInterface $node)
    {
        $line = $node->getLine();
        $name = new Twig_Node_Expression_Constant('escape', $line);
        $args = new Twig_Node(array(new Twig_Node_Expression_Constant((string) $type, $line), new Twig_Node_Expression_Constant(null, $line), new Twig_Node_Expression_Constant(true, $line)));

        return new Twig_Node_Expression_Filter($node, $name, $args, $line);
    }

    /**
     * {@inheritdoc}
     */
    public function getPriority()
    {
        return 0;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Twig_NodeVisitor_Optimizer tries to optimizes the AST.
 *
 * This visitor is always the last registered one.
 *
 * You can configure which optimizations you want to activate via the
 * optimizer mode.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_NodeVisitor_Optimizer extends Twig_BaseNodeVisitor
{
    const OPTIMIZE_ALL = -1;
    const OPTIMIZE_NONE = 0;
    const OPTIMIZE_FOR = 2;
    const OPTIMIZE_RAW_FILTER = 4;
    const OPTIMIZE_VAR_ACCESS = 8;

    protected $loops = array();
    protected $loopsTargets = array();
    protected $optimizers;
    protected $prependedNodes = array();
    protected $inABody = false;

    /**
     * Constructor.
     *
     * @param int $optimizers The optimizer mode
     */
    public function __construct($optimizers = -1)
    {
        if (!is_int($optimizers) || $optimizers > (self::OPTIMIZE_FOR | self::OPTIMIZE_RAW_FILTER | self::OPTIMIZE_VAR_ACCESS)) {
            throw new InvalidArgumentException(sprintf('Optimizer mode "%s" is not valid.', $optimizers));
        }

        $this->optimizers = $optimizers;
    }

    /**
     * {@inheritdoc}
     */
    protected function doEnterNode(Twig_Node $node, Twig_Environment $env)
    {
        if (self::OPTIMIZE_FOR === (self::OPTIMIZE_FOR & $this->optimizers)) {
            $this->enterOptimizeFor($node, $env);
        }

        if (PHP_VERSION_ID < 50400 && self::OPTIMIZE_VAR_ACCESS === (self::OPTIMIZE_VAR_ACCESS & $this->optimizers) && !$env->isStrictVariables() && !$env->hasExtension('sandbox')) {
            if ($this->inABody) {
                if (!$node instanceof Twig_Node_Expression) {
                    if (get_class($node) !== 'Twig_Node') {
                        array_unshift($this->prependedNodes, array());
                    }
                } else {
                    $node = $this->optimizeVariables($node, $env);
                }
            } elseif ($node instanceof Twig_Node_Body) {
                $this->inABody = true;
            }
        }

        return $node;
    }

    /**
     * {@inheritdoc}
     */
    protected function doLeaveNode(Twig_Node $node, Twig_Environment $env)
    {
        $expression = $node instanceof Twig_Node_Expression;

        if (self::OPTIMIZE_FOR === (self::OPTIMIZE_FOR & $this->optimizers)) {
            $this->leaveOptimizeFor($node, $env);
        }

        if (self::OPTIMIZE_RAW_FILTER === (self::OPTIMIZE_RAW_FILTER & $this->optimizers)) {
            $node = $this->optimizeRawFilter($node, $env);
        }

        $node = $this->optimizePrintNode($node, $env);

        if (self::OPTIMIZE_VAR_ACCESS === (self::OPTIMIZE_VAR_ACCESS & $this->optimizers) && !$env->isStrictVariables() && !$env->hasExtension('sandbox')) {
            if ($node instanceof Twig_Node_Body) {
                $this->inABody = false;
            } elseif ($this->inABody) {
                if (!$expression && get_class($node) !== 'Twig_Node' && $prependedNodes = array_shift($this->prependedNodes)) {
                    $nodes = array();
                    foreach (array_unique($prependedNodes) as $name) {
                        $nodes[] = new Twig_Node_SetTemp($name, $node->getLine());
                    }

                    $nodes[] = $node;
                    $node = new Twig_Node($nodes);
                }
            }
        }

        return $node;
    }

    protected function optimizeVariables(Twig_NodeInterface $node, Twig_Environment $env)
    {
        if ('Twig_Node_Expression_Name' === get_class($node) && $node->isSimple()) {
            $this->prependedNodes[0][] = $node->getAttribute('name');

            return new Twig_Node_Expression_TempName($node->getAttribute('name'), $node->getLine());
        }

        return $node;
    }

    /**
     * Optimizes print nodes.
     *
     * It replaces:
     *
     *   * "echo $this->render(Parent)Block()" with "$this->display(Parent)Block()"
     *
     * @param Twig_NodeInterface $node A Node
     * @param Twig_Environment   $env  The current Twig environment
     *
     * @return Twig_NodeInterface
     */
    protected function optimizePrintNode(Twig_NodeInterface $node, Twig_Environment $env)
    {
        if (!$node instanceof Twig_Node_Print) {
            return $node;
        }

        if (
            $node->getNode('expr') instanceof Twig_Node_Expression_BlockReference ||
            $node->getNode('expr') instanceof Twig_Node_Expression_Parent
        ) {
            $node->getNode('expr')->setAttribute('output', true);

            return $node->getNode('expr');
        }

        return $node;
    }

    /**
     * Removes "raw" filters.
     *
     * @param Twig_NodeInterface $node A Node
     * @param Twig_Environment   $env  The current Twig environment
     *
     * @return Twig_NodeInterface
     */
    protected function optimizeRawFilter(Twig_NodeInterface $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_Expression_Filter && 'raw' == $node->getNode('filter')->getAttribute('value')) {
            return $node->getNode('node');
        }

        return $node;
    }

    /**
     * Optimizes "for" tag by removing the "loop" variable creation whenever possible.
     *
     * @param Twig_NodeInterface $node A Node
     * @param Twig_Environment   $env  The current Twig environment
     */
    protected function enterOptimizeFor(Twig_NodeInterface $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_For) {
            // disable the loop variable by default
            $node->setAttribute('with_loop', false);
            array_unshift($this->loops, $node);
            array_unshift($this->loopsTargets, $node->getNode('value_target')->getAttribute('name'));
            array_unshift($this->loopsTargets, $node->getNode('key_target')->getAttribute('name'));
        } elseif (!$this->loops) {
            // we are outside a loop
            return;
        }

        // when do we need to add the loop variable back?

        // the loop variable is referenced for the current loop
        elseif ($node instanceof Twig_Node_Expression_Name && 'loop' === $node->getAttribute('name')) {
            $node->setAttribute('always_defined', true);
            $this->addLoopToCurrent();
        }

        // optimize access to loop targets
        elseif ($node instanceof Twig_Node_Expression_Name && in_array($node->getAttribute('name'), $this->loopsTargets)) {
            $node->setAttribute('always_defined', true);
        }

        // block reference
        elseif ($node instanceof Twig_Node_BlockReference || $node instanceof Twig_Node_Expression_BlockReference) {
            $this->addLoopToCurrent();
        }

        // include without the only attribute
        elseif ($node instanceof Twig_Node_Include && !$node->getAttribute('only')) {
            $this->addLoopToAll();
        }

        // include function without the with_context=false parameter
        elseif ($node instanceof Twig_Node_Expression_Function
            && 'include' === $node->getAttribute('name')
            && (!$node->getNode('arguments')->hasNode('with_context')
                 || false !== $node->getNode('arguments')->getNode('with_context')->getAttribute('value')
               )
        ) {
            $this->addLoopToAll();
        }

        // the loop variable is referenced via an attribute
        elseif ($node instanceof Twig_Node_Expression_GetAttr
            && (!$node->getNode('attribute') instanceof Twig_Node_Expression_Constant
                || 'parent' === $node->getNode('attribute')->getAttribute('value')
               )
            && (true === $this->loops[0]->getAttribute('with_loop')
                || ($node->getNode('node') instanceof Twig_Node_Expression_Name
                    && 'loop' === $node->getNode('node')->getAttribute('name')
                   )
               )
        ) {
            $this->addLoopToAll();
        }
    }

    /**
     * Optimizes "for" tag by removing the "loop" variable creation whenever possible.
     *
     * @param Twig_NodeInterface $node A Node
     * @param Twig_Environment   $env  The current Twig environment
     */
    protected function leaveOptimizeFor(Twig_NodeInterface $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_For) {
            array_shift($this->loops);
            array_shift($this->loopsTargets);
            array_shift($this->loopsTargets);
        }
    }

    protected function addLoopToCurrent()
    {
        $this->loops[0]->setAttribute('with_loop', true);
    }

    protected function addLoopToAll()
    {
        foreach ($this->loops as $loop) {
            $loop->setAttribute('with_loop', true);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function getPriority()
    {
        return 255;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

class Twig_NodeVisitor_SafeAnalysis extends Twig_BaseNodeVisitor
{
    protected $data = array();
    protected $safeVars = array();

    public function setSafeVars($safeVars)
    {
        $this->safeVars = $safeVars;
    }

    public function getSafe(Twig_NodeInterface $node)
    {
        $hash = spl_object_hash($node);
        if (!isset($this->data[$hash])) {
            return;
        }

        foreach ($this->data[$hash] as $bucket) {
            if ($bucket['key'] !== $node) {
                continue;
            }

            if (in_array('html_attr', $bucket['value'])) {
                $bucket['value'][] = 'html';
            }

            return $bucket['value'];
        }
    }

    protected function setSafe(Twig_NodeInterface $node, array $safe)
    {
        $hash = spl_object_hash($node);
        if (isset($this->data[$hash])) {
            foreach ($this->data[$hash] as &$bucket) {
                if ($bucket['key'] === $node) {
                    $bucket['value'] = $safe;

                    return;
                }
            }
        }
        $this->data[$hash][] = array(
            'key' => $node,
            'value' => $safe,
        );
    }

    /**
     * {@inheritdoc}
     */
    protected function doEnterNode(Twig_Node $node, Twig_Environment $env)
    {
        return $node;
    }

    /**
     * {@inheritdoc}
     */
    protected function doLeaveNode(Twig_Node $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_Expression_Constant) {
            // constants are marked safe for all
            $this->setSafe($node, array('all'));
        } elseif ($node instanceof Twig_Node_Expression_BlockReference) {
            // blocks are safe by definition
            $this->setSafe($node, array('all'));
        } elseif ($node instanceof Twig_Node_Expression_Parent) {
            // parent block is safe by definition
            $this->setSafe($node, array('all'));
        } elseif ($node instanceof Twig_Node_Expression_Conditional) {
            // intersect safeness of both operands
            $safe = $this->intersectSafe($this->getSafe($node->getNode('expr2')), $this->getSafe($node->getNode('expr3')));
            $this->setSafe($node, $safe);
        } elseif ($node instanceof Twig_Node_Expression_Filter) {
            // filter expression is safe when the filter is safe
            $name = $node->getNode('filter')->getAttribute('value');
            $args = $node->getNode('arguments');
            if (false !== $filter = $env->getFilter($name)) {
                $safe = $filter->getSafe($args);
                if (null === $safe) {
                    $safe = $this->intersectSafe($this->getSafe($node->getNode('node')), $filter->getPreservesSafety());
                }
                $this->setSafe($node, $safe);
            } else {
                $this->setSafe($node, array());
            }
        } elseif ($node instanceof Twig_Node_Expression_Function) {
            // function expression is safe when the function is safe
            $name = $node->getAttribute('name');
            $args = $node->getNode('arguments');
            $function = $env->getFunction($name);
            if (false !== $function) {
                $this->setSafe($node, $function->getSafe($args));
            } else {
                $this->setSafe($node, array());
            }
        } elseif ($node instanceof Twig_Node_Expression_MethodCall) {
            if ($node->getAttribute('safe')) {
                $this->setSafe($node, array('all'));
            } else {
                $this->setSafe($node, array());
            }
        } elseif ($node instanceof Twig_Node_Expression_GetAttr && $node->getNode('node') instanceof Twig_Node_Expression_Name) {
            $name = $node->getNode('node')->getAttribute('name');
            // attributes on template instances are safe
            if ('_self' == $name || in_array($name, $this->safeVars)) {
                $this->setSafe($node, array('all'));
            } else {
                $this->setSafe($node, array());
            }
        } else {
            $this->setSafe($node, array());
        }

        return $node;
    }

    protected function intersectSafe(array $a = null, array $b = null)
    {
        if (null === $a || null === $b) {
            return array();
        }

        if (in_array('all', $a)) {
            return $b;
        }

        if (in_array('all', $b)) {
            return $a;
        }

        return array_intersect($a, $b);
    }

    /**
     * {@inheritdoc}
     */
    public function getPriority()
    {
        return 0;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Twig_NodeVisitor_Sandbox implements sandboxing.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_NodeVisitor_Sandbox extends Twig_BaseNodeVisitor
{
    protected $inAModule = false;
    protected $tags;
    protected $filters;
    protected $functions;

    /**
     * {@inheritdoc}
     */
    protected function doEnterNode(Twig_Node $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_Module) {
            $this->inAModule = true;
            $this->tags = array();
            $this->filters = array();
            $this->functions = array();

            return $node;
        } elseif ($this->inAModule) {
            // look for tags
            if ($node->getNodeTag() && !isset($this->tags[$node->getNodeTag()])) {
                $this->tags[$node->getNodeTag()] = $node;
            }

            // look for filters
            if ($node instanceof Twig_Node_Expression_Filter && !isset($this->filters[$node->getNode('filter')->getAttribute('value')])) {
                $this->filters[$node->getNode('filter')->getAttribute('value')] = $node;
            }

            // look for functions
            if ($node instanceof Twig_Node_Expression_Function && !isset($this->functions[$node->getAttribute('name')])) {
                $this->functions[$node->getAttribute('name')] = $node;
            }

            // wrap print to check __toString() calls
            if ($node instanceof Twig_Node_Print) {
                return new Twig_Node_SandboxedPrint($node->getNode('expr'), $node->getLine(), $node->getNodeTag());
            }
        }

        return $node;
    }

    /**
     * {@inheritdoc}
     */
    protected function doLeaveNode(Twig_Node $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_Module) {
            $this->inAModule = false;

            $node->setNode('display_start', new Twig_Node(array(new Twig_Node_CheckSecurity($this->filters, $this->tags, $this->functions), $node->getNode('display_start'))));
        }

        return $node;
    }

    /**
     * {@inheritdoc}
     */
    public function getPriority()
    {
        return 0;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Twig_NodeVisitorInterface is the interface the all node visitor classes must implement.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface Twig_NodeVisitorInterface
{
    /**
     * Called before child nodes are visited.
     *
     * @param Twig_NodeInterface $node The node to visit
     * @param Twig_Environment   $env  The Twig environment instance
     *
     * @return Twig_NodeInterface The modified node
     */
    public function enterNode(Twig_NodeInterface $node, Twig_Environment $env);

    /**
     * Called after child nodes are visited.
     *
     * @param Twig_NodeInterface $node The node to visit
     * @param Twig_Environment   $env  The Twig environment instance
     *
     * @return Twig_NodeInterface|false The modified node or false if the node must be removed
     */
    public function leaveNode(Twig_NodeInterface $node, Twig_Environment $env);

    /**
     * Returns the priority for this visitor.
     *
     * Priority should be between -10 and 10 (0 is the default).
     *
     * @return int The priority level
     */
    public function getPriority();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Default parser implementation.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Parser implements Twig_ParserInterface
{
    protected $stack = array();
    protected $stream;
    protected $parent;
    protected $handlers;
    protected $visitors;
    protected $expressionParser;
    protected $blocks;
    protected $blockStack;
    protected $macros;
    protected $env;
    protected $reservedMacroNames;
    protected $importedSymbols;
    protected $traits;
    protected $embeddedTemplates = array();

    /**
     * Constructor.
     *
     * @param Twig_Environment $env A Twig_Environment instance
     */
    public function __construct(Twig_Environment $env)
    {
        $this->env = $env;
    }

    public function getEnvironment()
    {
        return $this->env;
    }

    public function getVarName()
    {
        return sprintf('__internal_%s', hash('sha256', uniqid(mt_rand(), true), false));
    }

    public function getFilename()
    {
        return $this->stream->getFilename();
    }

    /**
     * {@inheritdoc}
     */
    public function parse(Twig_TokenStream $stream, $test = null, $dropNeedle = false)
    {
        // push all variables into the stack to keep the current state of the parser
        // using get_object_vars() instead of foreach would lead to https://bugs.php.net/71336
        $vars = array();
        foreach ($this as $k => $v) {
            $vars[$k] = $v;
        }

        unset($vars['stack'], $vars['env'], $vars['handlers'], $vars['visitors'], $vars['expressionParser'], $vars['reservedMacroNames']);
        $this->stack[] = $vars;

        // tag handlers
        if (null === $this->handlers) {
            $this->handlers = $this->env->getTokenParsers();
            $this->handlers->setParser($this);
        }

        // node visitors
        if (null === $this->visitors) {
            $this->visitors = $this->env->getNodeVisitors();
        }

        if (null === $this->expressionParser) {
            $this->expressionParser = new Twig_ExpressionParser($this, $this->env->getUnaryOperators(), $this->env->getBinaryOperators());
        }

        $this->stream = $stream;
        $this->parent = null;
        $this->blocks = array();
        $this->macros = array();
        $this->traits = array();
        $this->blockStack = array();
        $this->importedSymbols = array(array());
        $this->embeddedTemplates = array();

        try {
            $body = $this->subparse($test, $dropNeedle);

            if (null !== $this->parent && null === $body = $this->filterBodyNodes($body)) {
                $body = new Twig_Node();
            }
        } catch (Twig_Error_Syntax $e) {
            if (!$e->getTemplateFile()) {
                $e->setTemplateFile($this->getFilename());
            }

            if (!$e->getTemplateLine()) {
                $e->setTemplateLine($this->stream->getCurrent()->getLine());
            }

            throw $e;
        }

        $node = new Twig_Node_Module(new Twig_Node_Body(array($body)), $this->parent, new Twig_Node($this->blocks), new Twig_Node($this->macros), new Twig_Node($this->traits), $this->embeddedTemplates, $this->getFilename());

        $traverser = new Twig_NodeTraverser($this->env, $this->visitors);

        $node = $traverser->traverse($node);

        // restore previous stack so previous parse() call can resume working
        foreach (array_pop($this->stack) as $key => $val) {
            $this->$key = $val;
        }

        return $node;
    }

    public function subparse($test, $dropNeedle = false)
    {
        $lineno = $this->getCurrentToken()->getLine();
        $rv = array();
        while (!$this->stream->isEOF()) {
            switch ($this->getCurrentToken()->getType()) {
                case Twig_Token::TEXT_TYPE:
                    $token = $this->stream->next();
                    $rv[] = new Twig_Node_Text($token->getValue(), $token->getLine());
                    break;

                case Twig_Token::VAR_START_TYPE:
                    $token = $this->stream->next();
                    $expr = $this->expressionParser->parseExpression();
                    $this->stream->expect(Twig_Token::VAR_END_TYPE);
                    $rv[] = new Twig_Node_Print($expr, $token->getLine());
                    break;

                case Twig_Token::BLOCK_START_TYPE:
                    $this->stream->next();
                    $token = $this->getCurrentToken();

                    if ($token->getType() !== Twig_Token::NAME_TYPE) {
                        throw new Twig_Error_Syntax('A block must start with a tag name.', $token->getLine(), $this->getFilename());
                    }

                    if (null !== $test && call_user_func($test, $token)) {
                        if ($dropNeedle) {
                            $this->stream->next();
                        }

                        if (1 === count($rv)) {
                            return $rv[0];
                        }

                        return new Twig_Node($rv, array(), $lineno);
                    }

                    $subparser = $this->handlers->getTokenParser($token->getValue());
                    if (null === $subparser) {
                        if (null !== $test) {
                            $e = new Twig_Error_Syntax(sprintf('Unexpected "%s" tag', $token->getValue()), $token->getLine(), $this->getFilename());

                            if (is_array($test) && isset($test[0]) && $test[0] instanceof Twig_TokenParserInterface) {
                                $e->appendMessage(sprintf(' (expecting closing tag for the "%s" tag defined near line %s).', $test[0]->getTag(), $lineno));
                            }
                        } else {
                            $e = new Twig_Error_Syntax(sprintf('Unknown "%s" tag.', $token->getValue()), $token->getLine(), $this->getFilename());
                            $e->addSuggestions($token->getValue(), array_keys($this->env->getTags()));
                        }

                        throw $e;
                    }

                    $this->stream->next();

                    $node = $subparser->parse($token);
                    if (null !== $node) {
                        $rv[] = $node;
                    }
                    break;

                default:
                    throw new Twig_Error_Syntax('Lexer or parser ended up in unsupported state.', 0, $this->getFilename());
            }
        }

        if (1 === count($rv)) {
            return $rv[0];
        }

        return new Twig_Node($rv, array(), $lineno);
    }

    public function addHandler($name, $class)
    {
        $this->handlers[$name] = $class;
    }

    public function addNodeVisitor(Twig_NodeVisitorInterface $visitor)
    {
        $this->visitors[] = $visitor;
    }

    public function getBlockStack()
    {
        return $this->blockStack;
    }

    public function peekBlockStack()
    {
        return $this->blockStack[count($this->blockStack) - 1];
    }

    public function popBlockStack()
    {
        array_pop($this->blockStack);
    }

    public function pushBlockStack($name)
    {
        $this->blockStack[] = $name;
    }

    public function hasBlock($name)
    {
        return isset($this->blocks[$name]);
    }

    public function getBlock($name)
    {
        return $this->blocks[$name];
    }

    public function setBlock($name, Twig_Node_Block $value)
    {
        $this->blocks[$name] = new Twig_Node_Body(array($value), array(), $value->getLine());
    }

    public function hasMacro($name)
    {
        return isset($this->macros[$name]);
    }

    public function setMacro($name, Twig_Node_Macro $node)
    {
        if ($this->isReservedMacroName($name)) {
            throw new Twig_Error_Syntax(sprintf('"%s" cannot be used as a macro name as it is a reserved keyword.', $name), $node->getLine(), $this->getFilename());
        }

        $this->macros[$name] = $node;
    }

    public function isReservedMacroName($name)
    {
        if (null === $this->reservedMacroNames) {
            $this->reservedMacroNames = array();
            $r = new ReflectionClass($this->env->getBaseTemplateClass());
            foreach ($r->getMethods() as $method) {
                $methodName = strtolower($method->getName());

                if ('get' === substr($methodName, 0, 3) && isset($methodName[3])) {
                    $this->reservedMacroNames[] = substr($methodName, 3);
                }
            }
        }

        return in_array(strtolower($name), $this->reservedMacroNames);
    }

    public function addTrait($trait)
    {
        $this->traits[] = $trait;
    }

    public function hasTraits()
    {
        return count($this->traits) > 0;
    }

    public function embedTemplate(Twig_Node_Module $template)
    {
        $template->setIndex(mt_rand());

        $this->embeddedTemplates[] = $template;
    }

    public function addImportedSymbol($type, $alias, $name = null, Twig_Node_Expression $node = null)
    {
        $this->importedSymbols[0][$type][$alias] = array('name' => $name, 'node' => $node);
    }

    public function getImportedSymbol($type, $alias)
    {
        foreach ($this->importedSymbols as $functions) {
            if (isset($functions[$type][$alias])) {
                return $functions[$type][$alias];
            }
        }
    }

    public function isMainScope()
    {
        return 1 === count($this->importedSymbols);
    }

    public function pushLocalScope()
    {
        array_unshift($this->importedSymbols, array());
    }

    public function popLocalScope()
    {
        array_shift($this->importedSymbols);
    }

    /**
     * Gets the expression parser.
     *
     * @return Twig_ExpressionParser The expression parser
     */
    public function getExpressionParser()
    {
        return $this->expressionParser;
    }

    public function getParent()
    {
        return $this->parent;
    }

    public function setParent($parent)
    {
        $this->parent = $parent;
    }

    /**
     * Gets the token stream.
     *
     * @return Twig_TokenStream The token stream
     */
    public function getStream()
    {
        return $this->stream;
    }

    /**
     * Gets the current token.
     *
     * @return Twig_Token The current token
     */
    public function getCurrentToken()
    {
        return $this->stream->getCurrent();
    }

    protected function filterBodyNodes(Twig_NodeInterface $node)
    {
        // check that the body does not contain non-empty output nodes
        if (
            ($node instanceof Twig_Node_Text && !ctype_space($node->getAttribute('data')))
            ||
            (!$node instanceof Twig_Node_Text && !$node instanceof Twig_Node_BlockReference && $node instanceof Twig_NodeOutputInterface)
        ) {
            if (false !== strpos((string) $node, chr(0xEF).chr(0xBB).chr(0xBF))) {
                throw new Twig_Error_Syntax('A template that extends another one cannot have a body but a byte order mark (BOM) has been detected; it must be removed.', $node->getLine(), $this->getFilename());
            }

            throw new Twig_Error_Syntax('A template that extends another one cannot have a body.', $node->getLine(), $this->getFilename());
        }

        // bypass "set" nodes as they "capture" the output
        if ($node instanceof Twig_Node_Set) {
            return $node;
        }

        if ($node instanceof Twig_NodeOutputInterface) {
            return;
        }

        foreach ($node as $k => $n) {
            if (null !== $n && null === $this->filterBodyNodes($n)) {
                $node->removeNode($k);
            }
        }

        return $node;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface implemented by parser classes.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 3.0)
 */
interface Twig_ParserInterface
{
    /**
     * Converts a token stream to a node tree.
     *
     * @param Twig_TokenStream $stream A token stream instance
     *
     * @return Twig_Node_Module A node tree
     *
     * @throws Twig_Error_Syntax When the token stream is syntactically or semantically wrong
     */
    public function parse(Twig_TokenStream $stream);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Profiler_Dumper_Blackfire
{
    public function dump(Twig_Profiler_Profile $profile)
    {
        $data = array();
        $this->dumpProfile('main()', $profile, $data);
        $this->dumpChildren('main()', $profile, $data);

        $start = microtime(true);
        $str = <<<EOF
file-format: BlackfireProbe
cost-dimensions: wt mu pmu
request-start: {$start}


EOF;

        foreach ($data as $name => $values) {
            $str .= "{$name}//{$values['ct']} {$values['wt']} {$values['mu']} {$values['pmu']}\n";
        }

        return $str;
    }

    private function dumpChildren($parent, Twig_Profiler_Profile $profile, &$data)
    {
        foreach ($profile as $p) {
            if ($p->isTemplate()) {
                $name = $p->getTemplate();
            } else {
                $name = sprintf('%s::%s(%s)', $p->getTemplate(), $p->getType(), $p->getName());
            }
            $this->dumpProfile(sprintf('%s==>%s', $parent, $name), $p, $data);
            $this->dumpChildren($name, $p, $data);
        }
    }

    private function dumpProfile($edge, Twig_Profiler_Profile $profile, &$data)
    {
        if (isset($data[$edge])) {
            $data[$edge]['ct'] += 1;
            $data[$edge]['wt'] += floor($profile->getDuration() * 1000000);
            $data[$edge]['mu'] += $profile->getMemoryUsage();
            $data[$edge]['pmu'] += $profile->getPeakMemoryUsage();
        } else {
            $data[$edge] = array(
                'ct' => 1,
                'wt' => floor($profile->getDuration() * 1000000),
                'mu' => $profile->getMemoryUsage(),
                'pmu' => $profile->getPeakMemoryUsage(),
            );
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Profiler_Dumper_Html extends Twig_Profiler_Dumper_Text
{
    private static $colors = array(
        'block' => '#dfd',
        'macro' => '#ddf',
        'template' => '#ffd',
        'big' => '#d44',
    );

    public function dump(Twig_Profiler_Profile $profile)
    {
        return '<pre>'.parent::dump($profile).'</pre>';
    }

    protected function formatTemplate(Twig_Profiler_Profile $profile, $prefix)
    {
        return sprintf('%sâ”” <span style="background-color: %s">%s</span>', $prefix, self::$colors['template'], $profile->getTemplate());
    }

    protected function formatNonTemplate(Twig_Profiler_Profile $profile, $prefix)
    {
        return sprintf('%sâ”” %s::%s(<span style="background-color: %s">%s</span>)', $prefix, $profile->getTemplate(), $profile->getType(), isset(self::$colors[$profile->getType()]) ? self::$colors[$profile->getType()] : 'auto', $profile->getName());
    }

    protected function formatTime(Twig_Profiler_Profile $profile, $percent)
    {
        return sprintf('<span style="color: %s">%.2fms/%.0f%%</span>', $percent > 20 ? self::$colors['big'] : 'auto', $profile->getDuration() * 1000, $percent);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Profiler_Dumper_Text
{
    private $root;

    public function dump(Twig_Profiler_Profile $profile)
    {
        return $this->dumpProfile($profile);
    }

    protected function formatTemplate(Twig_Profiler_Profile $profile, $prefix)
    {
        return sprintf('%sâ”” %s', $prefix, $profile->getTemplate());
    }

    protected function formatNonTemplate(Twig_Profiler_Profile $profile, $prefix)
    {
        return sprintf('%sâ”” %s::%s(%s)', $prefix, $profile->getTemplate(), $profile->getType(), $profile->getName());
    }

    protected function formatTime(Twig_Profiler_Profile $profile, $percent)
    {
        return sprintf('%.2fms/%.0f%%', $profile->getDuration() * 1000, $percent);
    }

    private function dumpProfile(Twig_Profiler_Profile $profile, $prefix = '', $sibling = false)
    {
        if ($profile->isRoot()) {
            $this->root = $profile->getDuration();
            $start = $profile->getName();
        } else {
            if ($profile->isTemplate()) {
                $start = $this->formatTemplate($profile, $prefix);
            } else {
                $start = $this->formatNonTemplate($profile, $prefix);
            }
            $prefix .= $sibling ? 'â”‚ ' : '  ';
        }

        $percent = $this->root ? $profile->getDuration() / $this->root * 100 : 0;

        if ($profile->getDuration() * 1000 < 1) {
            $str = $start."\n";
        } else {
            $str = sprintf("%s %s\n", $start, $this->formatTime($profile, $percent));
        }

        $nCount = count($profile->getProfiles());
        foreach ($profile as $i => $p) {
            $str .= $this->dumpProfile($p, $prefix, $i + 1 !== $nCount);
        }

        return $str;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a profile enter node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Profiler_Node_EnterProfile extends Twig_Node
{
    public function __construct($extensionName, $type, $name, $varName)
    {
        parent::__construct(array(), array('extension_name' => $extensionName, 'name' => $name, 'type' => $type, 'var_name' => $varName));
    }

    /**
     * {@inheritdoc}
     */
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->write(sprintf('$%s = $this->env->getExtension(', $this->getAttribute('var_name')))
            ->repr($this->getAttribute('extension_name'))
            ->raw(");\n")
            ->write(sprintf('$%s->enter($%s = new Twig_Profiler_Profile($this->getTemplateName(), ', $this->getAttribute('var_name'), $this->getAttribute('var_name').'_prof'))
            ->repr($this->getAttribute('type'))
            ->raw(', ')
            ->repr($this->getAttribute('name'))
            ->raw("));\n\n")
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a profile leave node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Profiler_Node_LeaveProfile extends Twig_Node
{
    public function __construct($varName)
    {
        parent::__construct(array(), array('var_name' => $varName));
    }

    /**
     * {@inheritdoc}
     */
    public function compile(Twig_Compiler $compiler)
    {
        $compiler
            ->write("\n")
            ->write(sprintf("\$%s->leave(\$%s);\n\n", $this->getAttribute('var_name'), $this->getAttribute('var_name').'_prof'))
        ;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Profiler_NodeVisitor_Profiler extends Twig_BaseNodeVisitor
{
    private $extensionName;

    public function __construct($extensionName)
    {
        $this->extensionName = $extensionName;
    }

    /**
     * {@inheritdoc}
     */
    protected function doEnterNode(Twig_Node $node, Twig_Environment $env)
    {
        return $node;
    }

    /**
     * {@inheritdoc}
     */
    protected function doLeaveNode(Twig_Node $node, Twig_Environment $env)
    {
        if ($node instanceof Twig_Node_Module) {
            $varName = $this->getVarName();
            $node->setNode('display_start', new Twig_Node(array(new Twig_Profiler_Node_EnterProfile($this->extensionName, Twig_Profiler_Profile::TEMPLATE, $node->getAttribute('filename'), $varName), $node->getNode('display_start'))));
            $node->setNode('display_end', new Twig_Node(array(new Twig_Profiler_Node_LeaveProfile($varName), $node->getNode('display_end'))));
        } elseif ($node instanceof Twig_Node_Block) {
            $varName = $this->getVarName();
            $node->setNode('body', new Twig_Node_Body(array(
                new Twig_Profiler_Node_EnterProfile($this->extensionName, Twig_Profiler_Profile::BLOCK, $node->getAttribute('name'), $varName),
                $node->getNode('body'),
                new Twig_Profiler_Node_LeaveProfile($varName),
            )));
        } elseif ($node instanceof Twig_Node_Macro) {
            $varName = $this->getVarName();
            $node->setNode('body', new Twig_Node_Body(array(
                new Twig_Profiler_Node_EnterProfile($this->extensionName, Twig_Profiler_Profile::MACRO, $node->getAttribute('name'), $varName),
                $node->getNode('body'),
                new Twig_Profiler_Node_LeaveProfile($varName),
            )));
        }

        return $node;
    }

    private function getVarName()
    {
        return sprintf('__internal_%s', hash('sha256', uniqid(mt_rand(), true), false));
    }

    /**
     * {@inheritdoc}
     */
    public function getPriority()
    {
        return 0;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2015 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Profiler_Profile implements IteratorAggregate, Serializable
{
    const ROOT = 'ROOT';
    const BLOCK = 'block';
    const TEMPLATE = 'template';
    const MACRO = 'macro';

    private $template;
    private $name;
    private $type;
    private $starts = array();
    private $ends = array();
    private $profiles = array();

    public function __construct($template = 'main', $type = self::ROOT, $name = 'main')
    {
        $this->template = $template;
        $this->type = $type;
        $this->name = 0 === strpos($name, '__internal_') ? 'INTERNAL' : $name;
        $this->enter();
    }

    public function getTemplate()
    {
        return $this->template;
    }

    public function getType()
    {
        return $this->type;
    }

    public function getName()
    {
        return $this->name;
    }

    public function isRoot()
    {
        return self::ROOT === $this->type;
    }

    public function isTemplate()
    {
        return self::TEMPLATE === $this->type;
    }

    public function isBlock()
    {
        return self::BLOCK === $this->type;
    }

    public function isMacro()
    {
        return self::MACRO === $this->type;
    }

    public function getProfiles()
    {
        return $this->profiles;
    }

    public function addProfile(Twig_Profiler_Profile $profile)
    {
        $this->profiles[] = $profile;
    }

    /**
     * Returns the duration in microseconds.
     *
     * @return int
     */
    public function getDuration()
    {
        if ($this->isRoot() && $this->profiles) {
            // for the root node with children, duration is the sum of all child durations
            $duration = 0;
            foreach ($this->profiles as $profile) {
                $duration += $profile->getDuration();
            }

            return $duration;
        }

        return isset($this->ends['wt']) && isset($this->starts['wt']) ? $this->ends['wt'] - $this->starts['wt'] : 0;
    }

    /**
     * Returns the memory usage in bytes.
     *
     * @return int
     */
    public function getMemoryUsage()
    {
        return isset($this->ends['mu']) && isset($this->starts['mu']) ? $this->ends['mu'] - $this->starts['mu'] : 0;
    }

    /**
     * Returns the peak memory usage in bytes.
     *
     * @return int
     */
    public function getPeakMemoryUsage()
    {
        return isset($this->ends['pmu']) && isset($this->starts['pmu']) ? $this->ends['pmu'] - $this->starts['pmu'] : 0;
    }

    /**
     * Starts the profiling.
     */
    public function enter()
    {
        $this->starts = array(
            'wt' => microtime(true),
            'mu' => memory_get_usage(),
            'pmu' => memory_get_peak_usage(),
        );
    }

    /**
     * Stops the profiling.
     */
    public function leave()
    {
        $this->ends = array(
            'wt' => microtime(true),
            'mu' => memory_get_usage(),
            'pmu' => memory_get_peak_usage(),
        );
    }

    public function getIterator()
    {
        return new ArrayIterator($this->profiles);
    }

    public function serialize()
    {
        return serialize(array($this->template, $this->name, $this->type, $this->starts, $this->ends, $this->profiles));
    }

    public function unserialize($data)
    {
        list($this->template, $this->name, $this->type, $this->starts, $this->ends, $this->profiles) = unserialize($data);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Exception thrown when a security error occurs at runtime.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Sandbox_SecurityError extends Twig_Error
{
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Exception thrown when a not allowed filter is used in a template.
 *
 * @author Martin HasoÅˆ <martin.hason@gmail.com>
 */
class Twig_Sandbox_SecurityNotAllowedFilterError extends Twig_Sandbox_SecurityError
{
    private $filterName;

    public function __construct($message, $functionName, $lineno = -1, $filename = null, Exception $previous = null)
    {
        parent::__construct($message, $lineno, $filename, $previous);
        $this->filterName = $functionName;
    }

    public function getFilterName()
    {
        return $this->filterName;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Exception thrown when a not allowed function is used in a template.
 *
 * @author Martin HasoÅˆ <martin.hason@gmail.com>
 */
class Twig_Sandbox_SecurityNotAllowedFunctionError extends Twig_Sandbox_SecurityError
{
    private $functionName;

    public function __construct($message, $functionName, $lineno = -1, $filename = null, Exception $previous = null)
    {
        parent::__construct($message, $lineno, $filename, $previous);
        $this->functionName = $functionName;
    }

    public function getFunctionName()
    {
        return $this->functionName;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Exception thrown when a not allowed tag is used in a template.
 *
 * @author Martin HasoÅˆ <martin.hason@gmail.com>
 */
class Twig_Sandbox_SecurityNotAllowedTagError extends Twig_Sandbox_SecurityError
{
    private $tagName;

    public function __construct($message, $tagName, $lineno = -1, $filename = null, Exception $previous = null)
    {
        parent::__construct($message, $lineno, $filename, $previous);
        $this->tagName = $tagName;
    }

    public function getTagName()
    {
        return $this->tagName;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a security policy which need to be enforced when sandbox mode is enabled.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Sandbox_SecurityPolicy implements Twig_Sandbox_SecurityPolicyInterface
{
    protected $allowedTags;
    protected $allowedFilters;
    protected $allowedMethods;
    protected $allowedProperties;
    protected $allowedFunctions;

    public function __construct(array $allowedTags = array(), array $allowedFilters = array(), array $allowedMethods = array(), array $allowedProperties = array(), array $allowedFunctions = array())
    {
        $this->allowedTags = $allowedTags;
        $this->allowedFilters = $allowedFilters;
        $this->setAllowedMethods($allowedMethods);
        $this->allowedProperties = $allowedProperties;
        $this->allowedFunctions = $allowedFunctions;
    }

    public function setAllowedTags(array $tags)
    {
        $this->allowedTags = $tags;
    }

    public function setAllowedFilters(array $filters)
    {
        $this->allowedFilters = $filters;
    }

    public function setAllowedMethods(array $methods)
    {
        $this->allowedMethods = array();
        foreach ($methods as $class => $m) {
            $this->allowedMethods[$class] = array_map('strtolower', is_array($m) ? $m : array($m));
        }
    }

    public function setAllowedProperties(array $properties)
    {
        $this->allowedProperties = $properties;
    }

    public function setAllowedFunctions(array $functions)
    {
        $this->allowedFunctions = $functions;
    }

    public function checkSecurity($tags, $filters, $functions)
    {
        foreach ($tags as $tag) {
            if (!in_array($tag, $this->allowedTags)) {
                throw new Twig_Sandbox_SecurityNotAllowedTagError(sprintf('Tag "%s" is not allowed.', $tag), $tag);
            }
        }

        foreach ($filters as $filter) {
            if (!in_array($filter, $this->allowedFilters)) {
                throw new Twig_Sandbox_SecurityNotAllowedFilterError(sprintf('Filter "%s" is not allowed.', $filter), $filter);
            }
        }

        foreach ($functions as $function) {
            if (!in_array($function, $this->allowedFunctions)) {
                throw new Twig_Sandbox_SecurityNotAllowedFunctionError(sprintf('Function "%s" is not allowed.', $function), $function);
            }
        }
    }

    public function checkMethodAllowed($obj, $method)
    {
        if ($obj instanceof Twig_TemplateInterface || $obj instanceof Twig_Markup) {
            return true;
        }

        $allowed = false;
        $method = strtolower($method);
        foreach ($this->allowedMethods as $class => $methods) {
            if ($obj instanceof $class) {
                $allowed = in_array($method, $methods);

                break;
            }
        }

        if (!$allowed) {
            throw new Twig_Sandbox_SecurityError(sprintf('Calling "%s" method on a "%s" object is not allowed.', $method, get_class($obj)));
        }
    }

    public function checkPropertyAllowed($obj, $property)
    {
        $allowed = false;
        foreach ($this->allowedProperties as $class => $properties) {
            if ($obj instanceof $class) {
                $allowed = in_array($property, is_array($properties) ? $properties : array($properties));

                break;
            }
        }

        if (!$allowed) {
            throw new Twig_Sandbox_SecurityError(sprintf('Calling "%s" property on a "%s" object is not allowed.', $property, get_class($obj)));
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interfaces that all security policy classes must implements.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface Twig_Sandbox_SecurityPolicyInterface
{
    public function checkSecurity($tags, $filters, $functions);

    public function checkMethodAllowed($obj, $method);

    public function checkPropertyAllowed($obj, $method);
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009-2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a template filter.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_SimpleFilter
{
    protected $name;
    protected $callable;
    protected $options;
    protected $arguments = array();

    public function __construct($name, $callable, array $options = array())
    {
        $this->name = $name;
        $this->callable = $callable;
        $this->options = array_merge(array(
            'needs_environment' => false,
            'needs_context' => false,
            'is_variadic' => false,
            'is_safe' => null,
            'is_safe_callback' => null,
            'pre_escape' => null,
            'preserves_safety' => null,
            'node_class' => 'Twig_Node_Expression_Filter',
            'deprecated' => false,
            'alternative' => null,
        ), $options);
    }

    public function getName()
    {
        return $this->name;
    }

    public function getCallable()
    {
        return $this->callable;
    }

    public function getNodeClass()
    {
        return $this->options['node_class'];
    }

    public function setArguments($arguments)
    {
        $this->arguments = $arguments;
    }

    public function getArguments()
    {
        return $this->arguments;
    }

    public function needsEnvironment()
    {
        return $this->options['needs_environment'];
    }

    public function needsContext()
    {
        return $this->options['needs_context'];
    }

    public function getSafe(Twig_Node $filterArgs)
    {
        if (null !== $this->options['is_safe']) {
            return $this->options['is_safe'];
        }

        if (null !== $this->options['is_safe_callback']) {
            return call_user_func($this->options['is_safe_callback'], $filterArgs);
        }
    }

    public function getPreservesSafety()
    {
        return $this->options['preserves_safety'];
    }

    public function getPreEscape()
    {
        return $this->options['pre_escape'];
    }

    public function isVariadic()
    {
        return $this->options['is_variadic'];
    }

    public function isDeprecated()
    {
        return (bool) $this->options['deprecated'];
    }

    public function getDeprecatedVersion()
    {
        return $this->options['deprecated'];
    }

    public function getAlternative()
    {
        return $this->options['alternative'];
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010-2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a template function.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_SimpleFunction
{
    protected $name;
    protected $callable;
    protected $options;
    protected $arguments = array();

    public function __construct($name, $callable, array $options = array())
    {
        $this->name = $name;
        $this->callable = $callable;
        $this->options = array_merge(array(
            'needs_environment' => false,
            'needs_context' => false,
            'is_variadic' => false,
            'is_safe' => null,
            'is_safe_callback' => null,
            'node_class' => 'Twig_Node_Expression_Function',
            'deprecated' => false,
            'alternative' => null,
        ), $options);
    }

    public function getName()
    {
        return $this->name;
    }

    public function getCallable()
    {
        return $this->callable;
    }

    public function getNodeClass()
    {
        return $this->options['node_class'];
    }

    public function setArguments($arguments)
    {
        $this->arguments = $arguments;
    }

    public function getArguments()
    {
        return $this->arguments;
    }

    public function needsEnvironment()
    {
        return $this->options['needs_environment'];
    }

    public function needsContext()
    {
        return $this->options['needs_context'];
    }

    public function getSafe(Twig_Node $functionArgs)
    {
        if (null !== $this->options['is_safe']) {
            return $this->options['is_safe'];
        }

        if (null !== $this->options['is_safe_callback']) {
            return call_user_func($this->options['is_safe_callback'], $functionArgs);
        }

        return array();
    }

    public function isVariadic()
    {
        return $this->options['is_variadic'];
    }

    public function isDeprecated()
    {
        return (bool) $this->options['deprecated'];
    }

    public function getDeprecatedVersion()
    {
        return $this->options['deprecated'];
    }

    public function getAlternative()
    {
        return $this->options['alternative'];
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Default base class for compiled templates.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
abstract class Twig_Template implements Twig_TemplateInterface
{
    protected static $cache = array();

    protected $parent;
    protected $parents = array();
    protected $env;
    protected $blocks = array();
    protected $traits = array();

    /**
     * Constructor.
     *
     * @param Twig_Environment $env A Twig_Environment instance
     */
    public function __construct(Twig_Environment $env)
    {
        $this->env = $env;
    }

    /**
     * Returns the template name.
     *
     * @return string The template name
     */
    abstract public function getTemplateName();

    /**
     * @deprecated since 1.20 (to be removed in 2.0)
     */
    public function getEnvironment()
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 1.20 and will be removed in 2.0.', E_USER_DEPRECATED);

        return $this->env;
    }

    /**
     * Returns the parent template.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * @param array $context
     *
     * @return Twig_TemplateInterface|false The parent template or false if there is no parent
     *
     * @internal
     */
    public function getParent(array $context)
    {
        if (null !== $this->parent) {
            return $this->parent;
        }

        try {
            $parent = $this->doGetParent($context);

            if (false === $parent) {
                return false;
            }

            if ($parent instanceof self) {
                return $this->parents[$parent->getTemplateName()] = $parent;
            }

            if (!isset($this->parents[$parent])) {
                $this->parents[$parent] = $this->loadTemplate($parent);
            }
        } catch (Twig_Error_Loader $e) {
            $e->setTemplateFile(null);
            $e->guess();

            throw $e;
        }

        return $this->parents[$parent];
    }

    protected function doGetParent(array $context)
    {
        return false;
    }

    public function isTraitable()
    {
        return true;
    }

    /**
     * Displays a parent block.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * @param string $name    The block name to display from the parent
     * @param array  $context The context
     * @param array  $blocks  The current set of blocks
     *
     * @internal
     */
    public function displayParentBlock($name, array $context, array $blocks = array())
    {
        $name = (string) $name;

        if (isset($this->traits[$name])) {
            $this->traits[$name][0]->displayBlock($name, $context, $blocks, false);
        } elseif (false !== $parent = $this->getParent($context)) {
            $parent->displayBlock($name, $context, $blocks, false);
        } else {
            throw new Twig_Error_Runtime(sprintf('The template has no parent and no traits defining the "%s" block', $name), -1, $this->getTemplateName());
        }
    }

    /**
     * Displays a block.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * @param string $name      The block name to display
     * @param array  $context   The context
     * @param array  $blocks    The current set of blocks
     * @param bool   $useBlocks Whether to use the current set of blocks
     *
     * @internal
     */
    public function displayBlock($name, array $context, array $blocks = array(), $useBlocks = true)
    {
        $name = (string) $name;

        if ($useBlocks && isset($blocks[$name])) {
            $template = $blocks[$name][0];
            $block = $blocks[$name][1];
        } elseif (isset($this->blocks[$name])) {
            $template = $this->blocks[$name][0];
            $block = $this->blocks[$name][1];
        } else {
            $template = null;
            $block = null;
        }

        if (null !== $template) {
            // avoid RCEs when sandbox is enabled
            if (!$template instanceof self) {
                throw new LogicException('A block must be a method on a Twig_Template instance.');
            }

            try {
                $template->$block($context, $blocks);
            } catch (Twig_Error $e) {
                if (!$e->getTemplateFile()) {
                    $e->setTemplateFile($template->getTemplateName());
                }

                // this is mostly useful for Twig_Error_Loader exceptions
                // see Twig_Error_Loader
                if (false === $e->getTemplateLine()) {
                    $e->setTemplateLine(-1);
                    $e->guess();
                }

                throw $e;
            } catch (Exception $e) {
                throw new Twig_Error_Runtime(sprintf('An exception has been thrown during the rendering of a template ("%s").', $e->getMessage()), -1, $template->getTemplateName(), $e);
            }
        } elseif (false !== $parent = $this->getParent($context)) {
            $parent->displayBlock($name, $context, array_merge($this->blocks, $blocks), false);
        }
    }

    /**
     * Renders a parent block.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * @param string $name    The block name to render from the parent
     * @param array  $context The context
     * @param array  $blocks  The current set of blocks
     *
     * @return string The rendered block
     *
     * @internal
     */
    public function renderParentBlock($name, array $context, array $blocks = array())
    {
        ob_start();
        $this->displayParentBlock($name, $context, $blocks);

        return ob_get_clean();
    }

    /**
     * Renders a block.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * @param string $name      The block name to render
     * @param array  $context   The context
     * @param array  $blocks    The current set of blocks
     * @param bool   $useBlocks Whether to use the current set of blocks
     *
     * @return string The rendered block
     *
     * @internal
     */
    public function renderBlock($name, array $context, array $blocks = array(), $useBlocks = true)
    {
        ob_start();
        $this->displayBlock($name, $context, $blocks, $useBlocks);

        return ob_get_clean();
    }

    /**
     * Returns whether a block exists or not.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * This method does only return blocks defined in the current template
     * or defined in "used" traits.
     *
     * It does not return blocks from parent templates as the parent
     * template name can be dynamic, which is only known based on the
     * current context.
     *
     * @param string $name The block name
     *
     * @return bool true if the block exists, false otherwise
     *
     * @internal
     */
    public function hasBlock($name)
    {
        return isset($this->blocks[(string) $name]);
    }

    /**
     * Returns all block names.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * @return array An array of block names
     *
     * @see hasBlock
     *
     * @internal
     */
    public function getBlockNames()
    {
        return array_keys($this->blocks);
    }

    protected function loadTemplate($template, $templateName = null, $line = null, $index = null)
    {
        try {
            if (is_array($template)) {
                return $this->env->resolveTemplate($template);
            }

            if ($template instanceof self) {
                return $template;
            }

            return $this->env->loadTemplate($template, $index);
        } catch (Twig_Error $e) {
            if (!$e->getTemplateFile()) {
                $e->setTemplateFile($templateName ? $templateName : $this->getTemplateName());
            }

            if ($e->getTemplateLine()) {
                throw $e;
            }

            if (!$line) {
                $e->guess();
            } else {
                $e->setTemplateLine($line);
            }

            throw $e;
        }
    }

    /**
     * Returns all blocks.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * @return array An array of blocks
     *
     * @see hasBlock
     *
     * @internal
     */
    public function getBlocks()
    {
        return $this->blocks;
    }

    /**
     * Returns the template source code.
     *
     * @return string|null The template source code or null if it is not available
     */
    public function getSource()
    {
        $reflector = new ReflectionClass($this);
        $file = $reflector->getFileName();

        if (!file_exists($file)) {
            return;
        }

        $source = file($file, FILE_IGNORE_NEW_LINES);
        array_splice($source, 0, $reflector->getEndLine());

        $i = 0;
        while (isset($source[$i]) && '/* */' === substr_replace($source[$i], '', 3, -2)) {
            $source[$i] = str_replace('*//* ', '*/', substr($source[$i], 3, -2));
            ++$i;
        }
        array_splice($source, $i);

        return implode("\n", $source);
    }

    /**
     * {@inheritdoc}
     */
    public function display(array $context, array $blocks = array())
    {
        $this->displayWithErrorHandling($this->env->mergeGlobals($context), array_merge($this->blocks, $blocks));
    }

    /**
     * {@inheritdoc}
     */
    public function render(array $context)
    {
        $level = ob_get_level();
        ob_start();
        try {
            $this->display($context);
        } catch (Exception $e) {
            while (ob_get_level() > $level) {
                ob_end_clean();
            }

            throw $e;
        }

        return ob_get_clean();
    }

    protected function displayWithErrorHandling(array $context, array $blocks = array())
    {
        try {
            $this->doDisplay($context, $blocks);
        } catch (Twig_Error $e) {
            if (!$e->getTemplateFile()) {
                $e->setTemplateFile($this->getTemplateName());
            }

            // this is mostly useful for Twig_Error_Loader exceptions
            // see Twig_Error_Loader
            if (false === $e->getTemplateLine()) {
                $e->setTemplateLine(-1);
                $e->guess();
            }

            throw $e;
        } catch (Exception $e) {
            throw new Twig_Error_Runtime(sprintf('An exception has been thrown during the rendering of a template ("%s").', $e->getMessage()), -1, $this->getTemplateName(), $e);
        }
    }

    /**
     * Auto-generated method to display the template with the given context.
     *
     * @param array $context An array of parameters to pass to the template
     * @param array $blocks  An array of blocks to pass to the template
     */
    abstract protected function doDisplay(array $context, array $blocks = array());

    /**
     * Returns a variable from the context.
     *
     * This method is for internal use only and should never be called
     * directly.
     *
     * This method should not be overridden in a sub-class as this is an
     * implementation detail that has been introduced to optimize variable
     * access for versions of PHP before 5.4. This is not a way to override
     * the way to get a variable value.
     *
     * @param array  $context           The context
     * @param string $item              The variable to return from the context
     * @param bool   $ignoreStrictCheck Whether to ignore the strict variable check or not
     *
     * @return mixed The content of the context variable
     *
     * @throws Twig_Error_Runtime if the variable does not exist and Twig is running in strict mode
     *
     * @internal
     */
    final protected function getContext($context, $item, $ignoreStrictCheck = false)
    {
        if (!array_key_exists($item, $context)) {
            if ($ignoreStrictCheck || !$this->env->isStrictVariables()) {
                return;
            }

            throw new Twig_Error_Runtime(sprintf('Variable "%s" does not exist', $item), -1, $this->getTemplateName());
        }

        return $context[$item];
    }

    /**
     * Returns the attribute value for a given array/object.
     *
     * @param mixed  $object            The object or array from where to get the item
     * @param mixed  $item              The item to get from the array or object
     * @param array  $arguments         An array of arguments to pass if the item is an object method
     * @param string $type              The type of attribute (@see Twig_Template constants)
     * @param bool   $isDefinedTest     Whether this is only a defined check
     * @param bool   $ignoreStrictCheck Whether to ignore the strict attribute check or not
     *
     * @return mixed The attribute value, or a Boolean when $isDefinedTest is true, or null when the attribute is not set and $ignoreStrictCheck is true
     *
     * @throws Twig_Error_Runtime if the attribute does not exist and Twig is running in strict mode and $isDefinedTest is false
     */
    protected function getAttribute($object, $item, array $arguments = array(), $type = self::ANY_CALL, $isDefinedTest = false, $ignoreStrictCheck = false)
    {
        // array
        if (self::METHOD_CALL !== $type) {
            $arrayItem = is_bool($item) || is_float($item) ? (int) $item : $item;

            if ((is_array($object) && array_key_exists($arrayItem, $object))
                || ($object instanceof ArrayAccess && isset($object[$arrayItem]))
            ) {
                if ($isDefinedTest) {
                    return true;
                }

                return $object[$arrayItem];
            }

            if (self::ARRAY_CALL === $type || !is_object($object)) {
                if ($isDefinedTest) {
                    return false;
                }

                if ($ignoreStrictCheck || !$this->env->isStrictVariables()) {
                    return;
                }

                if ($object instanceof ArrayAccess) {
                    $message = sprintf('Key "%s" in object with ArrayAccess of class "%s" does not exist', $arrayItem, get_class($object));
                } elseif (is_object($object)) {
                    $message = sprintf('Impossible to access a key "%s" on an object of class "%s" that does not implement ArrayAccess interface', $item, get_class($object));
                } elseif (is_array($object)) {
                    if (empty($object)) {
                        $message = sprintf('Key "%s" does not exist as the array is empty', $arrayItem);
                    } else {
                        $message = sprintf('Key "%s" for array with keys "%s" does not exist', $arrayItem, implode(', ', array_keys($object)));
                    }
                } elseif (self::ARRAY_CALL === $type) {
                    if (null === $object) {
                        $message = sprintf('Impossible to access a key ("%s") on a null variable', $item);
                    } else {
                        $message = sprintf('Impossible to access a key ("%s") on a %s variable ("%s")', $item, gettype($object), $object);
                    }
                } elseif (null === $object) {
                    $message = sprintf('Impossible to access an attribute ("%s") on a null variable', $item);
                } else {
                    $message = sprintf('Impossible to access an attribute ("%s") on a %s variable ("%s")', $item, gettype($object), $object);
                }

                throw new Twig_Error_Runtime($message, -1, $this->getTemplateName());
            }
        }

        if (!is_object($object)) {
            if ($isDefinedTest) {
                return false;
            }

            if ($ignoreStrictCheck || !$this->env->isStrictVariables()) {
                return;
            }

            if (null === $object) {
                $message = sprintf('Impossible to invoke a method ("%s") on a null variable', $item);
            } else {
                $message = sprintf('Impossible to invoke a method ("%s") on a %s variable ("%s")', $item, gettype($object), $object);
            }

            throw new Twig_Error_Runtime($message, -1, $this->getTemplateName());
        }

        // object property
        if (self::METHOD_CALL !== $type && !$object instanceof self) { // Twig_Template does not have public properties, and we don't want to allow access to internal ones
            if (isset($object->$item) || array_key_exists((string) $item, $object)) {
                if ($isDefinedTest) {
                    return true;
                }

                if ($this->env->hasExtension('sandbox')) {
                    $this->env->getExtension('sandbox')->checkPropertyAllowed($object, $item);
                }

                return $object->$item;
            }
        }

        $class = get_class($object);

        // object method
        if (!isset(self::$cache[$class]['methods'])) {
            // get_class_methods returns all methods accessible in the scope, but we only want public ones to be accessible in templates
            if ($object instanceof self) {
                $ref = new ReflectionClass($class);
                $methods = array();

                foreach ($ref->getMethods(ReflectionMethod::IS_PUBLIC) as $refMethod) {
                    $methodName = strtolower($refMethod->name);

                    // Accessing the environment from templates is forbidden to prevent untrusted changes to the environment
                    if ('getenvironment' !== $methodName) {
                        $methods[$methodName] = true;
                    }
                }

                self::$cache[$class]['methods'] = $methods;
            } else {
                self::$cache[$class]['methods'] = array_change_key_case(array_flip(get_class_methods($object)));
            }
        }

        $call = false;
        $lcItem = strtolower($item);
        if (isset(self::$cache[$class]['methods'][$lcItem])) {
            $method = (string) $item;
        } elseif (isset(self::$cache[$class]['methods']['get'.$lcItem])) {
            $method = 'get'.$item;
        } elseif (isset(self::$cache[$class]['methods']['is'.$lcItem])) {
            $method = 'is'.$item;
        } elseif (isset(self::$cache[$class]['methods']['__call'])) {
            $method = (string) $item;
            $call = true;
        } else {
            if ($isDefinedTest) {
                return false;
            }

            if ($ignoreStrictCheck || !$this->env->isStrictVariables()) {
                return;
            }

            throw new Twig_Error_Runtime(sprintf('Method "%s" for object "%s" does not exist', $item, get_class($object)), -1, $this->getTemplateName());
        }

        if ($isDefinedTest) {
            return true;
        }

        if ($this->env->hasExtension('sandbox')) {
            $this->env->getExtension('sandbox')->checkMethodAllowed($object, $method);
        }

        // Some objects throw exceptions when they have __call, and the method we try
        // to call is not supported. If ignoreStrictCheck is true, we should return null.
        try {
            $ret = call_user_func_array(array($object, $method), $arguments);
        } catch (BadMethodCallException $e) {
            if ($call && ($ignoreStrictCheck || !$this->env->isStrictVariables())) {
                return;
            }
            throw $e;
        }

        // useful when calling a template method from a template
        // this is not supported but unfortunately heavily used in the Symfony profiler
        if ($object instanceof Twig_TemplateInterface) {
            return $ret === '' ? '' : new Twig_Markup($ret, $this->env->getCharset());
        }

        return $ret;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface implemented by all compiled templates.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 3.0)
 */
interface Twig_TemplateInterface
{
    const ANY_CALL = 'any';
    const ARRAY_CALL = 'array';
    const METHOD_CALL = 'method';

    /**
     * Renders the template with the given context and returns it as string.
     *
     * @param array $context An array of parameters to pass to the template
     *
     * @return string The rendered template
     */
    public function render(array $context);

    /**
     * Displays the template with the given context.
     *
     * @param array $context An array of parameters to pass to the template
     * @param array $blocks  An array of blocks to pass to the template
     */
    public function display(array $context, array $blocks = array());

    /**
     * Returns the bound environment for this template.
     *
     * @return Twig_Environment The current environment
     */
    public function getEnvironment();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Test_Function class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleTest instead.', E_USER_DEPRECATED);

/**
 * Represents a function template test.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Test_Function extends Twig_Test
{
    protected $function;

    public function __construct($function, array $options = array())
    {
        $options['callable'] = $function;

        parent::__construct($options);

        $this->function = $function;
    }

    public function compile()
    {
        return $this->function;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Integration test helper.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Karma Dordrak <drak@zikula.org>
 */
abstract class Twig_Test_IntegrationTestCase extends \PHPUnit\Framework\TestCase
{
    /**
     * @return string
     */
    abstract protected function getFixturesDir();

    /**
     * @return Twig_ExtensionInterface[]
     */
    protected function getExtensions()
    {
        return array();
    }

    /**
     * @return Twig_SimpleFilter[]
     */
    protected function getTwigFilters()
    {
        return array();
    }

    /**
     * @return Twig_SimpleFunction[]
     */
    protected function getTwigFunctions()
    {
        return array();
    }

    /**
     * @return Twig_SimpleTest[]
     */
    protected function getTwigTests()
    {
        return array();
    }

    /**
     * @dataProvider getTests
     */
    public function testIntegration($file, $message, $condition, $templates, $exception, $outputs)
    {
        $this->doIntegrationTest($file, $message, $condition, $templates, $exception, $outputs);
    }

    /**
     * @dataProvider getLegacyTests
     * @group legacy
     */
    public function testLegacyIntegration($file, $message, $condition, $templates, $exception, $outputs)
    {
        $this->doIntegrationTest($file, $message, $condition, $templates, $exception, $outputs);
    }

    public function getTests($name, $legacyTests = false)
    {
        $fixturesDir = realpath($this->getFixturesDir());
        $tests = array();

        foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($fixturesDir), RecursiveIteratorIterator::LEAVES_ONLY) as $file) {
            if (!preg_match('/\.test$/', $file)) {
                continue;
            }

            if ($legacyTests xor false !== strpos($file->getRealpath(), '.legacy.test')) {
                continue;
            }

            $test = file_get_contents($file->getRealpath());

            if (preg_match('/--TEST--\s*(.*?)\s*(?:--CONDITION--\s*(.*))?\s*((?:--TEMPLATE(?:\(.*?\))?--(?:.*?))+)\s*(?:--DATA--\s*(.*))?\s*--EXCEPTION--\s*(.*)/sx', $test, $match)) {
                $message = $match[1];
                $condition = $match[2];
                $templates = self::parseTemplates($match[3]);
                $exception = $match[5];
                $outputs = array(array(null, $match[4], null, ''));
            } elseif (preg_match('/--TEST--\s*(.*?)\s*(?:--CONDITION--\s*(.*))?\s*((?:--TEMPLATE(?:\(.*?\))?--(?:.*?))+)--DATA--.*?--EXPECT--.*/s', $test, $match)) {
                $message = $match[1];
                $condition = $match[2];
                $templates = self::parseTemplates($match[3]);
                $exception = false;
                preg_match_all('/--DATA--(.*?)(?:--CONFIG--(.*?))?--EXPECT--(.*?)(?=\-\-DATA\-\-|$)/s', $test, $outputs, PREG_SET_ORDER);
            } else {
                throw new InvalidArgumentException(sprintf('Test "%s" is not valid.', str_replace($fixturesDir.'/', '', $file)));
            }

            $tests[] = array(str_replace($fixturesDir.'/', '', $file), $message, $condition, $templates, $exception, $outputs);
        }

        if ($legacyTests && empty($tests)) {
            // add a dummy test to avoid a PHPUnit message
            return array(array('not', '-', '', array(), '', array()));
        }

        return $tests;
    }

    public function getLegacyTests()
    {
        return $this->getTests('testLegacyIntegration', true);
    }

    protected function doIntegrationTest($file, $message, $condition, $templates, $exception, $outputs)
    {
        if ($condition) {
            eval('$ret = '.$condition.';');
            if (!$ret) {
                $this->markTestSkipped($condition);
            }
        }

        $loader = new Twig_Loader_Array($templates);

        foreach ($outputs as $i => $match) {
            $config = array_merge(array(
                'cache' => false,
                'strict_variables' => true,
            ), $match[2] ? eval($match[2].';') : array());
            $twig = new Twig_Environment($loader, $config);
            $twig->addGlobal('global', 'global');
            foreach ($this->getExtensions() as $extension) {
                $twig->addExtension($extension);
            }

            foreach ($this->getTwigFilters() as $filter) {
                $twig->addFilter($filter);
            }

            foreach ($this->getTwigTests() as $test) {
                $twig->addTest($test);
            }

            foreach ($this->getTwigFunctions() as $function) {
                $twig->addFunction($function);
            }

            // avoid using the same PHP class name for different cases
            // only for PHP 5.2+
            if (PHP_VERSION_ID >= 50300) {
                $p = new ReflectionProperty($twig, 'templateClassPrefix');
                $p->setAccessible(true);
                $p->setValue($twig, '__TwigTemplate_'.hash('sha256', uniqid(mt_rand(), true), false).'_');
            }

            try {
                $template = $twig->loadTemplate('index.twig');
            } catch (Exception $e) {
                if (false !== $exception) {
                    $message = $e->getMessage();
                    $this->assertSame(trim($exception), trim(sprintf('%s: %s', get_class($e), $message)));
                    $this->assertSame('.', substr($message, strlen($message) - 1), $message, 'Exception message must end with a dot.');

                    return;
                }

                if ($e instanceof Twig_Error_Syntax) {
                    $e->setTemplateFile($file);

                    throw $e;
                }

                throw new Twig_Error(sprintf('%s: %s', get_class($e), $e->getMessage()), -1, $file, $e);
            }

            try {
                $output = trim($template->render(eval($match[1].';')), "\n ");
            } catch (Exception $e) {
                if (false !== $exception) {
                    $this->assertSame(trim($exception), trim(sprintf('%s: %s', get_class($e), $e->getMessage())));

                    return;
                }

                if ($e instanceof Twig_Error_Syntax) {
                    $e->setTemplateFile($file);
                } else {
                    $e = new Twig_Error(sprintf('%s: %s', get_class($e), $e->getMessage()), -1, $file, $e);
                }

                $output = trim(sprintf('%s: %s', get_class($e), $e->getMessage()));
            }

            if (false !== $exception) {
                list($class) = explode(':', $exception);
                $this->assertThat(null, new PHPUnit_Framework_Constraint_Exception($class));
            }

            $expected = trim($match[3], "\n ");

            if ($expected !== $output) {
                printf("Compiled templates that failed on case %d:\n", $i + 1);

                foreach (array_keys($templates) as $name) {
                    echo "Template: $name\n";
                    $source = $loader->getSource($name);
                    echo $twig->compile($twig->parse($twig->tokenize($source, $name)));
                }
            }
            $this->assertEquals($expected, $output, $message.' (in '.$file.')');
        }
    }

    protected static function parseTemplates($test)
    {
        $templates = array();
        preg_match_all('/--TEMPLATE(?:\((.*?)\))?--(.*?)(?=\-\-TEMPLATE|$)/s', $test, $matches, PREG_SET_ORDER);
        foreach ($matches as $match) {
            $templates[($match[1] ? $match[1] : 'index.twig')] = $match[2];
        }

        return $templates;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Test_Method class is deprecated since version 1.12 and will be removed in 2.0. Use Twig_SimpleTest instead.', E_USER_DEPRECATED);

/**
 * Represents a method template test.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Test_Method extends Twig_Test
{
    protected $extension;
    protected $method;

    public function __construct(Twig_ExtensionInterface $extension, $method, array $options = array())
    {
        $options['callable'] = array($extension, $method);

        parent::__construct($options);

        $this->extension = $extension;
        $this->method = $method;
    }

    public function compile()
    {
        return sprintf('$this->env->getExtension(\'%s\')->%s', $this->extension->getName(), $this->method);
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

@trigger_error('The Twig_Test_Node class is deprecated since version 1.12 and will be removed in 2.0.', E_USER_DEPRECATED);

/**
 * Represents a template test as a Node.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_Test_Node extends Twig_Test
{
    protected $class;

    public function __construct($class, array $options = array())
    {
        parent::__construct($options);

        $this->class = $class;
    }

    public function getClass()
    {
        return $this->class;
    }

    public function compile()
    {
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
abstract class Twig_Test_NodeTestCase extends \PHPUnit\Framework\TestCase
{
    abstract public function getTests();

    /**
     * @dataProvider getTests
     */
    public function testCompile($node, $source, $environment = null, $isPattern = false)
    {
        $this->assertNodeCompilation($source, $node, $environment, $isPattern);
    }

    public function assertNodeCompilation($source, Twig_Node $node, Twig_Environment $environment = null, $isPattern = false)
    {
        $compiler = $this->getCompiler($environment);
        $compiler->compile($node);

        if ($isPattern) {
            $this->assertStringMatchesFormat($source, trim($compiler->getSource()));
        } else {
            $this->assertEquals($source, trim($compiler->getSource()));
        }
    }

    protected function getCompiler(Twig_Environment $environment = null)
    {
        return new Twig_Compiler(null === $environment ? $this->getEnvironment() : $environment);
    }

    protected function getEnvironment()
    {
        return new Twig_Environment(new Twig_Loader_Array(array()));
    }

    protected function getVariableGetter($name, $line = false)
    {
        $line = $line > 0 ? "// line {$line}\n" : '';

        if (PHP_VERSION_ID >= 50400) {
            return sprintf('%s(isset($context["%s"]) ? $context["%s"] : null)', $line, $name, $name);
        }

        return sprintf('%s$this->getContext($context, "%s")', $line, $name);
    }

    protected function getAttributeGetter()
    {
        if (function_exists('twig_template_get_attributes')) {
            return 'twig_template_get_attributes($this, ';
        }

        return '$this->getAttribute(';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a callable template test.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
interface Twig_TestCallableInterface
{
    public function getCallable();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a template test.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
interface Twig_TestInterface
{
    /**
     * Compiles a test.
     *
     * @return string The PHP code for the test
     */
    public function compile();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a Token.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Token
{
    protected $value;
    protected $type;
    protected $lineno;

    const EOF_TYPE = -1;
    const TEXT_TYPE = 0;
    const BLOCK_START_TYPE = 1;
    const VAR_START_TYPE = 2;
    const BLOCK_END_TYPE = 3;
    const VAR_END_TYPE = 4;
    const NAME_TYPE = 5;
    const NUMBER_TYPE = 6;
    const STRING_TYPE = 7;
    const OPERATOR_TYPE = 8;
    const PUNCTUATION_TYPE = 9;
    const INTERPOLATION_START_TYPE = 10;
    const INTERPOLATION_END_TYPE = 11;

    /**
     * Constructor.
     *
     * @param int    $type   The type of the token
     * @param string $value  The token value
     * @param int    $lineno The line position in the source
     */
    public function __construct($type, $value, $lineno)
    {
        $this->type = $type;
        $this->value = $value;
        $this->lineno = $lineno;
    }

    /**
     * Returns a string representation of the token.
     *
     * @return string A string representation of the token
     */
    public function __toString()
    {
        return sprintf('%s(%s)', self::typeToString($this->type, true), $this->value);
    }

    /**
     * Tests the current token for a type and/or a value.
     *
     * Parameters may be:
     * * just type
     * * type and value (or array of possible values)
     * * just value (or array of possible values) (NAME_TYPE is used as type)
     *
     * @param array|int         $type   The type to test
     * @param array|string|null $values The token value
     *
     * @return bool
     */
    public function test($type, $values = null)
    {
        if (null === $values && !is_int($type)) {
            $values = $type;
            $type = self::NAME_TYPE;
        }

        return ($this->type === $type) && (
            null === $values ||
            (is_array($values) && in_array($this->value, $values)) ||
            $this->value == $values
        );
    }

    /**
     * Gets the line.
     *
     * @return int The source line
     */
    public function getLine()
    {
        return $this->lineno;
    }

    /**
     * Gets the token type.
     *
     * @return int The token type
     */
    public function getType()
    {
        return $this->type;
    }

    /**
     * Gets the token value.
     *
     * @return string The token value
     */
    public function getValue()
    {
        return $this->value;
    }

    /**
     * Returns the constant representation (internal) of a given type.
     *
     * @param int  $type  The type as an integer
     * @param bool $short Whether to return a short representation or not
     *
     * @return string The string representation
     */
    public static function typeToString($type, $short = false)
    {
        switch ($type) {
            case self::EOF_TYPE:
                $name = 'EOF_TYPE';
                break;
            case self::TEXT_TYPE:
                $name = 'TEXT_TYPE';
                break;
            case self::BLOCK_START_TYPE:
                $name = 'BLOCK_START_TYPE';
                break;
            case self::VAR_START_TYPE:
                $name = 'VAR_START_TYPE';
                break;
            case self::BLOCK_END_TYPE:
                $name = 'BLOCK_END_TYPE';
                break;
            case self::VAR_END_TYPE:
                $name = 'VAR_END_TYPE';
                break;
            case self::NAME_TYPE:
                $name = 'NAME_TYPE';
                break;
            case self::NUMBER_TYPE:
                $name = 'NUMBER_TYPE';
                break;
            case self::STRING_TYPE:
                $name = 'STRING_TYPE';
                break;
            case self::OPERATOR_TYPE:
                $name = 'OPERATOR_TYPE';
                break;
            case self::PUNCTUATION_TYPE:
                $name = 'PUNCTUATION_TYPE';
                break;
            case self::INTERPOLATION_START_TYPE:
                $name = 'INTERPOLATION_START_TYPE';
                break;
            case self::INTERPOLATION_END_TYPE:
                $name = 'INTERPOLATION_END_TYPE';
                break;
            default:
                throw new LogicException(sprintf('Token of type "%s" does not exist.', $type));
        }

        return $short ? $name : 'Twig_Token::'.$name;
    }

    /**
     * Returns the english representation of a given type.
     *
     * @param int $type The type as an integer
     *
     * @return string The string representation
     */
    public static function typeToEnglish($type)
    {
        switch ($type) {
            case self::EOF_TYPE:
                return 'end of template';
            case self::TEXT_TYPE:
                return 'text';
            case self::BLOCK_START_TYPE:
                return 'begin of statement block';
            case self::VAR_START_TYPE:
                return 'begin of print statement';
            case self::BLOCK_END_TYPE:
                return 'end of statement block';
            case self::VAR_END_TYPE:
                return 'end of print statement';
            case self::NAME_TYPE:
                return 'name';
            case self::NUMBER_TYPE:
                return 'number';
            case self::STRING_TYPE:
                return 'string';
            case self::OPERATOR_TYPE:
                return 'operator';
            case self::PUNCTUATION_TYPE:
                return 'punctuation';
            case self::INTERPOLATION_START_TYPE:
                return 'begin of string interpolation';
            case self::INTERPOLATION_END_TYPE:
                return 'end of string interpolation';
            default:
                throw new LogicException(sprintf('Token of type "%s" does not exist.', $type));
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Marks a section of a template to be escaped or not.
 *
 * <pre>
 * {% autoescape true %}
 *   Everything will be automatically escaped in this block
 * {% endautoescape %}
 *
 * {% autoescape false %}
 *   Everything will be outputed as is in this block
 * {% endautoescape %}
 *
 * {% autoescape true js %}
 *   Everything will be automatically escaped in this block
 *   using the js escaping strategy
 * {% endautoescape %}
 * </pre>
 */
class Twig_TokenParser_AutoEscape extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $lineno = $token->getLine();
        $stream = $this->parser->getStream();

        if ($stream->test(Twig_Token::BLOCK_END_TYPE)) {
            $value = 'html';
        } else {
            $expr = $this->parser->getExpressionParser()->parseExpression();
            if (!$expr instanceof Twig_Node_Expression_Constant) {
                throw new Twig_Error_Syntax('An escaping strategy must be a string or a bool.', $stream->getCurrent()->getLine(), $stream->getFilename());
            }
            $value = $expr->getAttribute('value');

            $compat = true === $value || false === $value;

            if (true === $value) {
                $value = 'html';
            }

            if ($compat && $stream->test(Twig_Token::NAME_TYPE)) {
                @trigger_error('Using the autoescape tag with "true" or "false" before the strategy name is deprecated since version 1.21.', E_USER_DEPRECATED);

                if (false === $value) {
                    throw new Twig_Error_Syntax('Unexpected escaping strategy as you set autoescaping to false.', $stream->getCurrent()->getLine(), $stream->getFilename());
                }

                $value = $stream->next()->getValue();
            }
        }

        $stream->expect(Twig_Token::BLOCK_END_TYPE);
        $body = $this->parser->subparse(array($this, 'decideBlockEnd'), true);
        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        return new Twig_Node_AutoEscape($value, $body, $lineno, $this->getTag());
    }

    public function decideBlockEnd(Twig_Token $token)
    {
        return $token->test('endautoescape');
    }

    public function getTag()
    {
        return 'autoescape';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Marks a section of a template as being reusable.
 *
 * <pre>
 *  {% block head %}
 *    <link rel="stylesheet" href="style.css" />
 *    <title>{% block title %}{% endblock %} - My Webpage</title>
 *  {% endblock %}
 * </pre>
 */
class Twig_TokenParser_Block extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $lineno = $token->getLine();
        $stream = $this->parser->getStream();
        $name = $stream->expect(Twig_Token::NAME_TYPE)->getValue();
        if ($this->parser->hasBlock($name)) {
            throw new Twig_Error_Syntax(sprintf("The block '%s' has already been defined line %d.", $name, $this->parser->getBlock($name)->getLine()), $stream->getCurrent()->getLine(), $stream->getFilename());
        }
        $this->parser->setBlock($name, $block = new Twig_Node_Block($name, new Twig_Node(array()), $lineno));
        $this->parser->pushLocalScope();
        $this->parser->pushBlockStack($name);

        if ($stream->nextIf(Twig_Token::BLOCK_END_TYPE)) {
            $body = $this->parser->subparse(array($this, 'decideBlockEnd'), true);
            if ($token = $stream->nextIf(Twig_Token::NAME_TYPE)) {
                $value = $token->getValue();

                if ($value != $name) {
                    throw new Twig_Error_Syntax(sprintf('Expected endblock for block "%s" (but "%s" given).', $name, $value), $stream->getCurrent()->getLine(), $stream->getFilename());
                }
            }
        } else {
            $body = new Twig_Node(array(
                new Twig_Node_Print($this->parser->getExpressionParser()->parseExpression(), $lineno),
            ));
        }
        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        $block->setNode('body', $body);
        $this->parser->popBlockStack();
        $this->parser->popLocalScope();

        return new Twig_Node_BlockReference($name, $lineno, $this->getTag());
    }

    public function decideBlockEnd(Twig_Token $token)
    {
        return $token->test('endblock');
    }

    public function getTag()
    {
        return 'block';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Evaluates an expression, discarding the returned value.
 */
class Twig_TokenParser_Do extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $expr = $this->parser->getExpressionParser()->parseExpression();

        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);

        return new Twig_Node_Do($expr, $token->getLine(), $this->getTag());
    }

    public function getTag()
    {
        return 'do';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2012 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Embeds a template.
 */
class Twig_TokenParser_Embed extends Twig_TokenParser_Include
{
    public function parse(Twig_Token $token)
    {
        $stream = $this->parser->getStream();

        $parent = $this->parser->getExpressionParser()->parseExpression();

        list($variables, $only, $ignoreMissing) = $this->parseArguments();

        // inject a fake parent to make the parent() function work
        $stream->injectTokens(array(
            new Twig_Token(Twig_Token::BLOCK_START_TYPE, '', $token->getLine()),
            new Twig_Token(Twig_Token::NAME_TYPE, 'extends', $token->getLine()),
            new Twig_Token(Twig_Token::STRING_TYPE, '__parent__', $token->getLine()),
            new Twig_Token(Twig_Token::BLOCK_END_TYPE, '', $token->getLine()),
        ));

        $module = $this->parser->parse($stream, array($this, 'decideBlockEnd'), true);

        // override the parent with the correct one
        $module->setNode('parent', $parent);

        $this->parser->embedTemplate($module);

        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        return new Twig_Node_Embed($module->getAttribute('filename'), $module->getAttribute('index'), $variables, $only, $ignoreMissing, $token->getLine(), $this->getTag());
    }

    public function decideBlockEnd(Twig_Token $token)
    {
        return $token->test('endembed');
    }

    public function getTag()
    {
        return 'embed';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Extends a template by another one.
 *
 * <pre>
 *  {% extends "base.html" %}
 * </pre>
 */
class Twig_TokenParser_Extends extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        if (!$this->parser->isMainScope()) {
            throw new Twig_Error_Syntax('Cannot extend from a block.', $token->getLine(), $this->parser->getFilename());
        }

        if (null !== $this->parser->getParent()) {
            throw new Twig_Error_Syntax('Multiple extends tags are forbidden.', $token->getLine(), $this->parser->getFilename());
        }
        $this->parser->setParent($this->parser->getExpressionParser()->parseExpression());

        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);
    }

    public function getTag()
    {
        return 'extends';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Filters a section of a template by applying filters.
 *
 * <pre>
 * {% filter upper %}
 *  This text becomes uppercase
 * {% endfilter %}
 * </pre>
 */
class Twig_TokenParser_Filter extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $name = $this->parser->getVarName();
        $ref = new Twig_Node_Expression_BlockReference(new Twig_Node_Expression_Constant($name, $token->getLine()), true, $token->getLine(), $this->getTag());

        $filter = $this->parser->getExpressionParser()->parseFilterExpressionRaw($ref, $this->getTag());
        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);

        $body = $this->parser->subparse(array($this, 'decideBlockEnd'), true);
        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);

        $block = new Twig_Node_Block($name, $body, $token->getLine());
        $this->parser->setBlock($name, $block);

        return new Twig_Node_Print($filter, $token->getLine(), $this->getTag());
    }

    public function decideBlockEnd(Twig_Token $token)
    {
        return $token->test('endfilter');
    }

    public function getTag()
    {
        return 'filter';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Flushes the output to the client.
 *
 * @see flush()
 */
class Twig_TokenParser_Flush extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);

        return new Twig_Node_Flush($token->getLine(), $this->getTag());
    }

    public function getTag()
    {
        return 'flush';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Loops over each item of a sequence.
 *
 * <pre>
 * <ul>
 *  {% for user in users %}
 *    <li>{{ user.username|e }}</li>
 *  {% endfor %}
 * </ul>
 * </pre>
 */
class Twig_TokenParser_For extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $lineno = $token->getLine();
        $stream = $this->parser->getStream();
        $targets = $this->parser->getExpressionParser()->parseAssignmentExpression();
        $stream->expect(Twig_Token::OPERATOR_TYPE, 'in');
        $seq = $this->parser->getExpressionParser()->parseExpression();

        $ifexpr = null;
        if ($stream->nextIf(Twig_Token::NAME_TYPE, 'if')) {
            $ifexpr = $this->parser->getExpressionParser()->parseExpression();
        }

        $stream->expect(Twig_Token::BLOCK_END_TYPE);
        $body = $this->parser->subparse(array($this, 'decideForFork'));
        if ($stream->next()->getValue() == 'else') {
            $stream->expect(Twig_Token::BLOCK_END_TYPE);
            $else = $this->parser->subparse(array($this, 'decideForEnd'), true);
        } else {
            $else = null;
        }
        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        if (count($targets) > 1) {
            $keyTarget = $targets->getNode(0);
            $keyTarget = new Twig_Node_Expression_AssignName($keyTarget->getAttribute('name'), $keyTarget->getLine());
            $valueTarget = $targets->getNode(1);
            $valueTarget = new Twig_Node_Expression_AssignName($valueTarget->getAttribute('name'), $valueTarget->getLine());
        } else {
            $keyTarget = new Twig_Node_Expression_AssignName('_key', $lineno);
            $valueTarget = $targets->getNode(0);
            $valueTarget = new Twig_Node_Expression_AssignName($valueTarget->getAttribute('name'), $valueTarget->getLine());
        }

        if ($ifexpr) {
            $this->checkLoopUsageCondition($stream, $ifexpr);
            $this->checkLoopUsageBody($stream, $body);
        }

        return new Twig_Node_For($keyTarget, $valueTarget, $seq, $ifexpr, $body, $else, $lineno, $this->getTag());
    }

    public function decideForFork(Twig_Token $token)
    {
        return $token->test(array('else', 'endfor'));
    }

    public function decideForEnd(Twig_Token $token)
    {
        return $token->test('endfor');
    }

    // the loop variable cannot be used in the condition
    protected function checkLoopUsageCondition(Twig_TokenStream $stream, Twig_NodeInterface $node)
    {
        if ($node instanceof Twig_Node_Expression_GetAttr && $node->getNode('node') instanceof Twig_Node_Expression_Name && 'loop' == $node->getNode('node')->getAttribute('name')) {
            throw new Twig_Error_Syntax('The "loop" variable cannot be used in a looping condition.', $node->getLine(), $stream->getFilename());
        }

        foreach ($node as $n) {
            if (!$n) {
                continue;
            }

            $this->checkLoopUsageCondition($stream, $n);
        }
    }

    // check usage of non-defined loop-items
    // it does not catch all problems (for instance when a for is included into another or when the variable is used in an include)
    protected function checkLoopUsageBody(Twig_TokenStream $stream, Twig_NodeInterface $node)
    {
        if ($node instanceof Twig_Node_Expression_GetAttr && $node->getNode('node') instanceof Twig_Node_Expression_Name && 'loop' == $node->getNode('node')->getAttribute('name')) {
            $attribute = $node->getNode('attribute');
            if ($attribute instanceof Twig_Node_Expression_Constant && in_array($attribute->getAttribute('value'), array('length', 'revindex0', 'revindex', 'last'))) {
                throw new Twig_Error_Syntax(sprintf('The "loop.%s" variable is not defined when looping with a condition.', $attribute->getAttribute('value')), $node->getLine(), $stream->getFilename());
            }
        }

        // should check for parent.loop.XXX usage
        if ($node instanceof Twig_Node_For) {
            return;
        }

        foreach ($node as $n) {
            if (!$n) {
                continue;
            }

            $this->checkLoopUsageBody($stream, $n);
        }
    }

    public function getTag()
    {
        return 'for';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Imports macros.
 *
 * <pre>
 *   {% from 'forms.html' import forms %}
 * </pre>
 */
class Twig_TokenParser_From extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $macro = $this->parser->getExpressionParser()->parseExpression();
        $stream = $this->parser->getStream();
        $stream->expect('import');

        $targets = array();
        do {
            $name = $stream->expect(Twig_Token::NAME_TYPE)->getValue();

            $alias = $name;
            if ($stream->nextIf('as')) {
                $alias = $stream->expect(Twig_Token::NAME_TYPE)->getValue();
            }

            $targets[$name] = $alias;

            if (!$stream->nextIf(Twig_Token::PUNCTUATION_TYPE, ',')) {
                break;
            }
        } while (true);

        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        $node = new Twig_Node_Import($macro, new Twig_Node_Expression_AssignName($this->parser->getVarName(), $token->getLine()), $token->getLine(), $this->getTag());

        foreach ($targets as $name => $alias) {
            if ($this->parser->isReservedMacroName($name)) {
                throw new Twig_Error_Syntax(sprintf('"%s" cannot be an imported macro as it is a reserved keyword.', $name), $token->getLine(), $stream->getFilename());
            }

            $this->parser->addImportedSymbol('function', $alias, 'get'.$name, $node->getNode('var'));
        }

        return $node;
    }

    public function getTag()
    {
        return 'from';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Tests a condition.
 *
 * <pre>
 * {% if users %}
 *  <ul>
 *    {% for user in users %}
 *      <li>{{ user.username|e }}</li>
 *    {% endfor %}
 *  </ul>
 * {% endif %}
 * </pre>
 */
class Twig_TokenParser_If extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $lineno = $token->getLine();
        $expr = $this->parser->getExpressionParser()->parseExpression();
        $stream = $this->parser->getStream();
        $stream->expect(Twig_Token::BLOCK_END_TYPE);
        $body = $this->parser->subparse(array($this, 'decideIfFork'));
        $tests = array($expr, $body);
        $else = null;

        $end = false;
        while (!$end) {
            switch ($stream->next()->getValue()) {
                case 'else':
                    $stream->expect(Twig_Token::BLOCK_END_TYPE);
                    $else = $this->parser->subparse(array($this, 'decideIfEnd'));
                    break;

                case 'elseif':
                    $expr = $this->parser->getExpressionParser()->parseExpression();
                    $stream->expect(Twig_Token::BLOCK_END_TYPE);
                    $body = $this->parser->subparse(array($this, 'decideIfFork'));
                    $tests[] = $expr;
                    $tests[] = $body;
                    break;

                case 'endif':
                    $end = true;
                    break;

                default:
                    throw new Twig_Error_Syntax(sprintf('Unexpected end of template. Twig was looking for the following tags "else", "elseif", or "endif" to close the "if" block started at line %d).', $lineno), $stream->getCurrent()->getLine(), $stream->getFilename());
            }
        }

        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        return new Twig_Node_If(new Twig_Node($tests), $else, $lineno, $this->getTag());
    }

    public function decideIfFork(Twig_Token $token)
    {
        return $token->test(array('elseif', 'else', 'endif'));
    }

    public function decideIfEnd(Twig_Token $token)
    {
        return $token->test(array('endif'));
    }

    public function getTag()
    {
        return 'if';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Imports macros.
 *
 * <pre>
 *   {% import 'forms.html' as forms %}
 * </pre>
 */
class Twig_TokenParser_Import extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $macro = $this->parser->getExpressionParser()->parseExpression();
        $this->parser->getStream()->expect('as');
        $var = new Twig_Node_Expression_AssignName($this->parser->getStream()->expect(Twig_Token::NAME_TYPE)->getValue(), $token->getLine());
        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);

        $this->parser->addImportedSymbol('template', $var->getAttribute('name'));

        return new Twig_Node_Import($macro, $var, $token->getLine(), $this->getTag());
    }

    public function getTag()
    {
        return 'import';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Includes a template.
 *
 * <pre>
 *   {% include 'header.html' %}
 *     Body
 *   {% include 'footer.html' %}
 * </pre>
 */
class Twig_TokenParser_Include extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $expr = $this->parser->getExpressionParser()->parseExpression();

        list($variables, $only, $ignoreMissing) = $this->parseArguments();

        return new Twig_Node_Include($expr, $variables, $only, $ignoreMissing, $token->getLine(), $this->getTag());
    }

    protected function parseArguments()
    {
        $stream = $this->parser->getStream();

        $ignoreMissing = false;
        if ($stream->nextIf(Twig_Token::NAME_TYPE, 'ignore')) {
            $stream->expect(Twig_Token::NAME_TYPE, 'missing');

            $ignoreMissing = true;
        }

        $variables = null;
        if ($stream->nextIf(Twig_Token::NAME_TYPE, 'with')) {
            $variables = $this->parser->getExpressionParser()->parseExpression();
        }

        $only = false;
        if ($stream->nextIf(Twig_Token::NAME_TYPE, 'only')) {
            $only = true;
        }

        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        return array($variables, $only, $ignoreMissing);
    }

    public function getTag()
    {
        return 'include';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Defines a macro.
 *
 * <pre>
 * {% macro input(name, value, type, size) %}
 *    <input type="{{ type|default('text') }}" name="{{ name }}" value="{{ value|e }}" size="{{ size|default(20) }}" />
 * {% endmacro %}
 * </pre>
 */
class Twig_TokenParser_Macro extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $lineno = $token->getLine();
        $stream = $this->parser->getStream();
        $name = $stream->expect(Twig_Token::NAME_TYPE)->getValue();

        $arguments = $this->parser->getExpressionParser()->parseArguments(true, true);

        $stream->expect(Twig_Token::BLOCK_END_TYPE);
        $this->parser->pushLocalScope();
        $body = $this->parser->subparse(array($this, 'decideBlockEnd'), true);
        if ($token = $stream->nextIf(Twig_Token::NAME_TYPE)) {
            $value = $token->getValue();

            if ($value != $name) {
                throw new Twig_Error_Syntax(sprintf('Expected endmacro for macro "%s" (but "%s" given).', $name, $value), $stream->getCurrent()->getLine(), $stream->getFilename());
            }
        }
        $this->parser->popLocalScope();
        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        $this->parser->setMacro($name, new Twig_Node_Macro($name, new Twig_Node_Body(array($body)), $arguments, $lineno, $this->getTag()));
    }

    public function decideBlockEnd(Twig_Token $token)
    {
        return $token->test('endmacro');
    }

    public function getTag()
    {
        return 'macro';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Marks a section of a template as untrusted code that must be evaluated in the sandbox mode.
 *
 * <pre>
 * {% sandbox %}
 *     {% include 'user.html' %}
 * {% endsandbox %}
 * </pre>
 *
 * @see http://www.twig-project.org/doc/api.html#sandbox-extension for details
 */
class Twig_TokenParser_Sandbox extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);
        $body = $this->parser->subparse(array($this, 'decideBlockEnd'), true);
        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);

        // in a sandbox tag, only include tags are allowed
        if (!$body instanceof Twig_Node_Include) {
            foreach ($body as $node) {
                if ($node instanceof Twig_Node_Text && ctype_space($node->getAttribute('data'))) {
                    continue;
                }

                if (!$node instanceof Twig_Node_Include) {
                    throw new Twig_Error_Syntax('Only "include" tags are allowed within a "sandbox" section.', $node->getLine(), $this->parser->getFilename());
                }
            }
        }

        return new Twig_Node_Sandbox($body, $token->getLine(), $this->getTag());
    }

    public function decideBlockEnd(Twig_Token $token)
    {
        return $token->test('endsandbox');
    }

    public function getTag()
    {
        return 'sandbox';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Defines a variable.
 *
 * <pre>
 *  {% set foo = 'foo' %}
 *
 *  {% set foo = [1, 2] %}
 *
 *  {% set foo = {'foo': 'bar'} %}
 *
 *  {% set foo = 'foo' ~ 'bar' %}
 *
 *  {% set foo, bar = 'foo', 'bar' %}
 *
 *  {% set foo %}Some content{% endset %}
 * </pre>
 */
class Twig_TokenParser_Set extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $lineno = $token->getLine();
        $stream = $this->parser->getStream();
        $names = $this->parser->getExpressionParser()->parseAssignmentExpression();

        $capture = false;
        if ($stream->nextIf(Twig_Token::OPERATOR_TYPE, '=')) {
            $values = $this->parser->getExpressionParser()->parseMultitargetExpression();

            $stream->expect(Twig_Token::BLOCK_END_TYPE);

            if (count($names) !== count($values)) {
                throw new Twig_Error_Syntax('When using set, you must have the same number of variables and assignments.', $stream->getCurrent()->getLine(), $stream->getFilename());
            }
        } else {
            $capture = true;

            if (count($names) > 1) {
                throw new Twig_Error_Syntax('When using set with a block, you cannot have a multi-target.', $stream->getCurrent()->getLine(), $stream->getFilename());
            }

            $stream->expect(Twig_Token::BLOCK_END_TYPE);

            $values = $this->parser->subparse(array($this, 'decideBlockEnd'), true);
            $stream->expect(Twig_Token::BLOCK_END_TYPE);
        }

        return new Twig_Node_Set($capture, $names, $values, $lineno, $this->getTag());
    }

    public function decideBlockEnd(Twig_Token $token)
    {
        return $token->test('endset');
    }

    public function getTag()
    {
        return 'set';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Remove whitespaces between HTML tags.
 *
 * <pre>
 * {% spaceless %}
 *      <div>
 *          <strong>foo</strong>
 *      </div>
 * {% endspaceless %}
 *
 * {# output will be <div><strong>foo</strong></div> #}
 * </pre>
 */
class Twig_TokenParser_Spaceless extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $lineno = $token->getLine();

        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);
        $body = $this->parser->subparse(array($this, 'decideSpacelessEnd'), true);
        $this->parser->getStream()->expect(Twig_Token::BLOCK_END_TYPE);

        return new Twig_Node_Spaceless($body, $lineno, $this->getTag());
    }

    public function decideSpacelessEnd(Twig_Token $token)
    {
        return $token->test('endspaceless');
    }

    public function getTag()
    {
        return 'spaceless';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2011 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Imports blocks defined in another template into the current template.
 *
 * <pre>
 * {% extends "base.html" %}
 *
 * {% use "blocks.html" %}
 *
 * {% block title %}{% endblock %}
 * {% block content %}{% endblock %}
 * </pre>
 *
 * @see http://www.twig-project.org/doc/templates.html#horizontal-reuse for details.
 */
class Twig_TokenParser_Use extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $template = $this->parser->getExpressionParser()->parseExpression();
        $stream = $this->parser->getStream();

        if (!$template instanceof Twig_Node_Expression_Constant) {
            throw new Twig_Error_Syntax('The template references in a "use" statement must be a string.', $stream->getCurrent()->getLine(), $stream->getFilename());
        }

        $targets = array();
        if ($stream->nextIf('with')) {
            do {
                $name = $stream->expect(Twig_Token::NAME_TYPE)->getValue();

                $alias = $name;
                if ($stream->nextIf('as')) {
                    $alias = $stream->expect(Twig_Token::NAME_TYPE)->getValue();
                }

                $targets[$name] = new Twig_Node_Expression_Constant($alias, -1);

                if (!$stream->nextIf(Twig_Token::PUNCTUATION_TYPE, ',')) {
                    break;
                }
            } while (true);
        }

        $stream->expect(Twig_Token::BLOCK_END_TYPE);

        $this->parser->addTrait(new Twig_Node(array('template' => $template, 'targets' => new Twig_Node($targets))));
    }

    public function getTag()
    {
        return 'use';
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Base class for all token parsers.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
abstract class Twig_TokenParser implements Twig_TokenParserInterface
{
    /**
     * @var Twig_Parser
     */
    protected $parser;

    /**
     * Sets the parser associated with this token parser.
     *
     * @param Twig_Parser $parser A Twig_Parser instance
     */
    public function setParser(Twig_Parser $parser)
    {
        $this->parser = $parser;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 * (c) 2010 Arnaud Le Blanc
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Default implementation of a token parser broker.
 *
 * @author Arnaud Le Blanc <arnaud.lb@gmail.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
class Twig_TokenParserBroker implements Twig_TokenParserBrokerInterface
{
    protected $parser;
    protected $parsers = array();
    protected $brokers = array();

    /**
     * Constructor.
     *
     * @param array|Traversable $parsers                 A Traversable of Twig_TokenParserInterface instances
     * @param array|Traversable $brokers                 A Traversable of Twig_TokenParserBrokerInterface instances
     * @param bool              $triggerDeprecationError
     */
    public function __construct($parsers = array(), $brokers = array(), $triggerDeprecationError = true)
    {
        if ($triggerDeprecationError) {
            @trigger_error('The '.__CLASS__.' class is deprecated since version 1.12 and will be removed in 2.0.', E_USER_DEPRECATED);
        }

        foreach ($parsers as $parser) {
            if (!$parser instanceof Twig_TokenParserInterface) {
                throw new LogicException('$parsers must a an array of Twig_TokenParserInterface.');
            }
            $this->parsers[$parser->getTag()] = $parser;
        }
        foreach ($brokers as $broker) {
            if (!$broker instanceof Twig_TokenParserBrokerInterface) {
                throw new LogicException('$brokers must a an array of Twig_TokenParserBrokerInterface.');
            }
            $this->brokers[] = $broker;
        }
    }

    /**
     * Adds a TokenParser.
     *
     * @param Twig_TokenParserInterface $parser A Twig_TokenParserInterface instance
     */
    public function addTokenParser(Twig_TokenParserInterface $parser)
    {
        $this->parsers[$parser->getTag()] = $parser;
    }

    /**
     * Removes a TokenParser.
     *
     * @param Twig_TokenParserInterface $parser A Twig_TokenParserInterface instance
     */
    public function removeTokenParser(Twig_TokenParserInterface $parser)
    {
        $name = $parser->getTag();
        if (isset($this->parsers[$name]) && $parser === $this->parsers[$name]) {
            unset($this->parsers[$name]);
        }
    }

    /**
     * Adds a TokenParserBroker.
     *
     * @param Twig_TokenParserBroker $broker A Twig_TokenParserBroker instance
     */
    public function addTokenParserBroker(Twig_TokenParserBroker $broker)
    {
        $this->brokers[] = $broker;
    }

    /**
     * Removes a TokenParserBroker.
     *
     * @param Twig_TokenParserBroker $broker A Twig_TokenParserBroker instance
     */
    public function removeTokenParserBroker(Twig_TokenParserBroker $broker)
    {
        if (false !== $pos = array_search($broker, $this->brokers)) {
            unset($this->brokers[$pos]);
        }
    }

    /**
     * Gets a suitable TokenParser for a tag.
     *
     * First looks in parsers, then in brokers.
     *
     * @param string $tag A tag name
     *
     * @return null|Twig_TokenParserInterface A Twig_TokenParserInterface or null if no suitable TokenParser was found
     */
    public function getTokenParser($tag)
    {
        if (isset($this->parsers[$tag])) {
            return $this->parsers[$tag];
        }
        $broker = end($this->brokers);
        while (false !== $broker) {
            $parser = $broker->getTokenParser($tag);
            if (null !== $parser) {
                return $parser;
            }
            $broker = prev($this->brokers);
        }
    }

    public function getParsers()
    {
        return $this->parsers;
    }

    public function getParser()
    {
        return $this->parser;
    }

    public function setParser(Twig_ParserInterface $parser)
    {
        $this->parser = $parser;
        foreach ($this->parsers as $tokenParser) {
            $tokenParser->setParser($parser);
        }
        foreach ($this->brokers as $broker) {
            $broker->setParser($parser);
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 * (c) 2010 Arnaud Le Blanc
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface implemented by token parser brokers.
 *
 * Token parser brokers allows to implement custom logic in the process of resolving a token parser for a given tag name.
 *
 * @author Arnaud Le Blanc <arnaud.lb@gmail.com>
 *
 * @deprecated since 1.12 (to be removed in 2.0)
 */
interface Twig_TokenParserBrokerInterface
{
    /**
     * Gets a TokenParser suitable for a tag.
     *
     * @param string $tag A tag name
     *
     * @return null|Twig_TokenParserInterface A Twig_TokenParserInterface or null if no suitable TokenParser was found
     */
    public function getTokenParser($tag);

    /**
     * Calls Twig_TokenParserInterface::setParser on all parsers the implementation knows of.
     *
     * @param Twig_ParserInterface $parser A Twig_ParserInterface interface
     */
    public function setParser(Twig_ParserInterface $parser);

    /**
     * Gets the Twig_ParserInterface.
     *
     * @return null|Twig_ParserInterface A Twig_ParserInterface instance or null
     */
    public function getParser();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2010 Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Interface implemented by token parsers.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface Twig_TokenParserInterface
{
    /**
     * Sets the parser associated with this token parser.
     *
     * @param Twig_Parser $parser A Twig_Parser instance
     */
    public function setParser(Twig_Parser $parser);

    /**
     * Parses a token and returns a node.
     *
     * @param Twig_Token $token A Twig_Token instance
     *
     * @return Twig_NodeInterface A Twig_NodeInterface instance
     *
     * @throws Twig_Error_Syntax
     */
    public function parse(Twig_Token $token);

    /**
     * Gets the tag name associated with this token parser.
     *
     * @return string The tag name
     */
    public function getTag();
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) 2009 Fabien Potencier
 * (c) 2009 Armin Ronacher
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Represents a token stream.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_TokenStream
{
    protected $tokens;
    protected $current = 0;
    protected $filename;

    /**
     * Constructor.
     *
     * @param array  $tokens   An array of tokens
     * @param string $filename The name of the filename which tokens are associated with
     */
    public function __construct(array $tokens, $filename = null)
    {
        $this->tokens = $tokens;
        $this->filename = $filename;
    }

    /**
     * Returns a string representation of the token stream.
     *
     * @return string
     */
    public function __toString()
    {
        return implode("\n", $this->tokens);
    }

    public function injectTokens(array $tokens)
    {
        $this->tokens = array_merge(array_slice($this->tokens, 0, $this->current), $tokens, array_slice($this->tokens, $this->current));
    }

    /**
     * Sets the pointer to the next token and returns the old one.
     *
     * @return Twig_Token
     */
    public function next()
    {
        if (!isset($this->tokens[++$this->current])) {
            throw new Twig_Error_Syntax('Unexpected end of template.', $this->tokens[$this->current - 1]->getLine(), $this->filename);
        }

        return $this->tokens[$this->current - 1];
    }

    /**
     * Tests a token, sets the pointer to the next one and returns it or throws a syntax error.
     *
     * @return Twig_Token|null The next token if the condition is true, null otherwise
     */
    public function nextIf($primary, $secondary = null)
    {
        if ($this->tokens[$this->current]->test($primary, $secondary)) {
            return $this->next();
        }
    }

    /**
     * Tests a token and returns it or throws a syntax error.
     *
     * @return Twig_Token
     */
    public function expect($type, $value = null, $message = null)
    {
        $token = $this->tokens[$this->current];
        if (!$token->test($type, $value)) {
            $line = $token->getLine();
            throw new Twig_Error_Syntax(sprintf('%sUnexpected token "%s" of value "%s" ("%s" expected%s).',
                $message ? $message.'. ' : '',
                Twig_Token::typeToEnglish($token->getType()), $token->getValue(),
                Twig_Token::typeToEnglish($type), $value ? sprintf(' with value "%s"', $value) : ''),
                $line,
                $this->filename
            );
        }
        $this->next();

        return $token;
    }

    /**
     * Looks at the next token.
     *
     * @param int $number
     *
     * @return Twig_Token
     */
    public function look($number = 1)
    {
        if (!isset($this->tokens[$this->current + $number])) {
            throw new Twig_Error_Syntax('Unexpected end of template.', $this->tokens[$this->current + $number - 1]->getLine(), $this->filename);
        }

        return $this->tokens[$this->current + $number];
    }

    /**
     * Tests the current token.
     *
     * @return bool
     */
    public function test($primary, $secondary = null)
    {
        return $this->tokens[$this->current]->test($primary, $secondary);
    }

    /**
     * Checks if end of stream was reached.
     *
     * @return bool
     */
    public function isEOF()
    {
        return $this->tokens[$this->current]->getType() === Twig_Token::EOF_TYPE;
    }

    /**
     * Gets the current token.
     *
     * @return Twig_Token
     */
    public function getCurrent()
    {
        return $this->tokens[$this->current];
    }

    /**
     * Gets the filename associated with this stream.
     *
     * @return string
     */
    public function getFilename()
    {
        return $this->filename;
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Util_DeprecationCollector
{
    private $twig;
    private $deprecations;

    public function __construct(Twig_Environment $twig)
    {
        $this->twig = $twig;
    }

    /**
     * Returns deprecations for templates contained in a directory.
     *
     * @param string $dir A directory where templates are stored
     * @param string $ext Limit the loaded templates by extension
     *
     * @return array() An array of deprecations
     */
    public function collectDir($dir, $ext = '.twig')
    {
        $iterator = new RegexIterator(
            new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($dir), RecursiveIteratorIterator::LEAVES_ONLY
            ), '{'.preg_quote($ext).'$}'
        );

        return $this->collect(new Twig_Util_TemplateDirIterator($iterator));
    }

    /**
     * Returns deprecations for passed templates.
     *
     * @param Iterator $iterator An iterator of templates (where keys are template names and values the contents of the template)
     *
     * @return array() An array of deprecations
     */
    public function collect(Iterator $iterator)
    {
        $this->deprecations = array();

        set_error_handler(array($this, 'errorHandler'));

        foreach ($iterator as $name => $contents) {
            try {
                $this->twig->parse($this->twig->tokenize($contents, $name));
            } catch (Twig_Error_Syntax $e) {
                // ignore templates containing syntax errors
            }
        }

        restore_error_handler();

        $deprecations = $this->deprecations;
        $this->deprecations = array();

        return $deprecations;
    }

    /**
     * @internal
     */
    public function errorHandler($type, $msg)
    {
        if (E_USER_DEPRECATED === $type) {
            $this->deprecations[] = $msg;
        }
    }
}
<?php

/*
 * This file is part of Twig.
 *
 * (c) Fabien Potencier
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Twig_Util_TemplateDirIterator extends IteratorIterator
{
    public function current()
    {
        return file_get_contents(parent::current());
    }

    public function key()
    {
        return (string) parent::key();
    }
}
<?php
if ( ! extension_loaded('fileutil') && ! function_exists('futil_pathsplit') ) {

define('SIZE_KB', 1024);
define('SIZE_MB', 1048576);
define('SIZE_GB', 1073741824);

function futil_findbin($bin, $pathstr = null)
{
    $paths = explode(':', $pathstr ?: getenv('PATH') );
    foreach( $paths as $path ) {
        if( file_exists($path . DIRECTORY_SEPARATOR . $bin) ) {
            return $path . DIRECTORY_SEPARATOR . $bin;
        }
    }
    return false;
}

function futil_pathsplit($path)
{
    return explode(DIRECTORY_SEPARATOR, $path);
}

function futil_scanpath($path)
{
    if ( ! file_exists($path) )
        return false;
    if ( is_file($path) )
        return false;

    $list = scandir($path);
    foreach( $list as &$item ) {
        if ( "." === $item || ".." === $item ) 
            continue;
        $item = $path . DIRECTORY_SEPARATOR . $item;
    }
    return $list;
}

function futil_scanpath_dir($path)
{
    if ( ! file_exists($path) )
        return false;
    if ( is_file($path) )
        return false;


    $list = scandir($path);
    $newlist = array();
    foreach( $list as $item ) {
        if ( "." === $item || ".." === $item ) 
            continue;

        if ( is_dir($path . DIRECTORY_SEPARATOR . $item) ) {
            $newlist[] = $path . DIRECTORY_SEPARATOR . $item;
        }
    }
    return $newlist;
}

function futil_ctime_compare($filename1, $filename2)
{
    $t1 = filectime($filename1);
    $t2 = filectime($filename2);
    if ( $t1 > $t2 ) {
        return 1;
    } elseif ( $t1 == $t2 ) {
        return 0;
    } elseif ( $t1 < $t2 ) {
        return -1;
    }
    return false;
}

function futil_mtime_compare($filename1, $filename2)
{
    $t1 = filemtime($filename1);
    $t2 = filemtime($filename2);
    if ( $t1 > $t2 ) {
        return 1;
    } elseif ( $t1 == $t2 ) {
        return 0;
    } elseif ( $t1 < $t2 ) {
        return -1;
    }
    return false;
}

function futil_lastmtime($filelist)
{
    $lastmtime = 0;
    foreach($filelist as $file) {
        $mtime = filemtime($file);
        if ( $mtime > $lastmtime ) 
            $lastmtime = $mtime;
    }
    return $lastmtime;
}

function futil_lastctime($filelist)
{
    $lastctime = 0;
    foreach($filelist as $file) {
        $ctime = filectime($file);
        if ( $ctime > $lastctime ) 
            $lastctime = $ctime;
    }
    return $lastctime;
}

function futil_pathjoin($a = null)
{
    if( ! is_array($a) ) {
        $a = func_get_args();
    }
    $len = count($a);
    $len1 = $len - 1;
    for ( $i = 0;  $i < $len ; $i++ ) {
        if ( $i < $len1 ) {
            $a[$i] = rtrim($a[$i],DIRECTORY_SEPARATOR);
        }
        if ( $i > 0 ) {
            $a[$i] = ltrim($a[$i],DIRECTORY_SEPARATOR);
        }
    }
    return join(DIRECTORY_SEPARATOR , $a);
}


function futil_mkdir_if_not_exists($path, $mask = null , $recurse = null)
{
    if ( ! file_exists( $path ) ) {
        return mkdir($path, $mask, $recurse);
    }
    return false;
}

function futil_unlink_if_exists($path)
{
    if ( file_exists($path) ) {
        return unlink($path);
    }
    return false;
}

function futil_rmdir_if_exists($path)
{
    if ( file_exists($path) ) {
        return rmdir($path);
    }
    return false;
}


function futil_rmtree($path)
{
    $iter = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path), RecursiveIteratorIterator::CHILD_FIRST);
    foreach($iter as $fileinfo){
        if( $fileinfo->isDir() ) {
            if (  $fileinfo->getFilename() === "." 
                || $fileinfo->getFilename() === ".." )
                continue;
            rmdir( $fileinfo->getPathname() );
        } elseif ($fileinfo->isFile()) {
            unlink( $fileinfo->getPathname() );
        }
    }
    if ( is_dir($path) ) {
        rmdir($path);
    } elseif ( is_file($path) ) {
        unlink($path);
    }
    return true;
}


function futil_paths_remove_basepath($paths,$basepath)
{
    return array_map(function($item) use ($basepath) {
        return substr($item,strlen($basepath));
    }, $paths );
}


function futil_paths_append(& $paths,$path2, $modify = false)
{
    if ( $modify ) {
        foreach( $paths as & $path ) {
            $path = futil_pathjoin($path ,$path2);
        }
    } else {
        $newpaths = array();
        foreach( $paths as $path ) {
            $newpaths[] = futil_pathjoin($path ,$path2);
        }
        return $newpaths;
    }
}

function futil_paths_prepend(& $paths,$path2, $modify = false)
{
    if ( $modify ) {
        foreach( $paths as & $path ) {
            $path = futil_pathjoin($path2 ,$path);
        }
    } else {
        $newpaths = array();
        foreach( $paths as $path ) {
            $newpaths[] = futil_pathjoin($path2 ,$path);
        }
        return $newpaths;
    }
}

/**
 * @param array $paths filter out directories
 */
function futil_paths_filter_file($paths)
{
    $newpaths = array();
    foreach( $paths as $path ) {
        if ( is_file($path) ) {
            $newpaths[] = $path;
        }
    }
    return $newpaths;
}


/**
 * @param array $paths filter out directories
 */
function futil_paths_filter_dir($paths)
{
    $newpaths = array();
    foreach( $paths as $path ) {
        if ( is_dir($path) ) {
            $newpaths[] = $path;
        }
    }
    return $newpaths;
}


function futil_replace_extension($filename, $newext)
{
    $parts = explode('.',$filename);
    if (count($parts) > 1) {
        array_pop($parts);
    }
    $parts[] = $newext;
    return join('.',$parts);
}


function futil_get_extension($filename)
{
    return pathinfo($filename, PATHINFO_EXTENSION);
}



function futil_prettysize($bytes)
{
    if ( $bytes < 1024 ) {
        return $bytes . ' B';
    }

    if ( $bytes < SIZE_MB) {
        return sprintf("%d KB", $bytes / SIZE_KB);
    }

    if ( $bytes < SIZE_GB ) {
        return sprintf("%.1f MB", $bytes / SIZE_MB);
    }

    if ( $bytes < SIZE_GB * 1024 ) {
        return sprintf("%.1f GB", $bytes / SIZE_GB );
    }

    return sprintf("%.1f GB", $bytes / SIZE_GB);
}


function futil_filename_append_suffix( $filename , $suffix )
{
    $pos = strrpos( $filename , '.' );
    if ($pos !== false) {
        return substr( $filename , 0 , $pos )
            . $suffix
            . substr( $filename , $pos );
    }
    return $filename . $suffix;
}

function futil_get_contents_from_files($files)
{
    $content = '';
    foreach( $files as $file ) {
        if ( file_exists($file) ) {
            if ( $fileContent = file_get_contents($file) ) {
                $content .= $fileContent;
            }
        }
    }
    return $content;
}


function futil_get_contents_array_from_files($files)
{
    $contents = array();
    foreach( $files as $file ) {
        if ( file_exists($file) ) {
            if ( $fileContent = file_get_contents($file) ) {
                $block = array(
                    'path'    => $file,
                    'content' => $fileContent,
                );
                $contents[] = $block;
            }
        }
    }
    return $contents;
}

function futil_copy_if_newer($source,$dest) 
{
    if ( file_exists($dest) && ( filemtime($source) < filemtime($dest) ) ) {
        return false;
    }
    copy($source, $dest);
}

function futil_copy_if_not_exists($source,$dest)
{
    if ( ! file_exists($dest) ) {
        copy($source,$dest);
    }
}


}
<?php
/*
 * This file is part of the UniversalCache package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace UniversalCache;

class ApcCache
{
    public $namespace = '';

    public $defaultExpiry = 0;

    public function __construct( $options = array() )
    {
        if ( isset($options['namespace']) ) {
            $this->namespace = $options['namespace'];
        }
        if ( isset($options['default_expiry'] ) ) {
            $this->defaultExpiry = $options['default_expiry'];
        }
    }

    public function get($key)
    {
        return apc_fetch( $this->namespace . ':' . $key );
    }

    public function set($key,$value,$ttl = null)
    {
        if( null === $ttl && $this->defaultExpiry )
            $ttl = $this->defaultExpiry;
        apc_store( $this->namespace . ':' . $key , $value , $ttl );
    }

    public function remove($key)
    {
        apc_delete( $this->namespace . ':' . $key );
    }

    public function clear()
    {
        apc_clear_cache();
    }

    public function __get($name)
    {
        return $this->get($name);
    }

    public function __set($name,$value)
    {
        $this->set($name,$value);
    }

    static function getInstance()
    {
        static $instance;
        return $instance ? $instance : $instance = new static;
    }

}


<?php
/*
 * This file is part of the UniversalCache package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace UniversalCache;

interface CacheInterface
{
    public function get($key);
    public function set($key,$value,$ttl = 0);
    public function remove($key);
    public function clear();
}

<?php
namespace UniversalCache;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use SerializerKit;

class FileSystemCache
{
    public $expiry; // seconds

    public $filenameBuilder;

    public $serializer;

    public $cacheDir = 'cache';

    public $umask = 0777;

    public function __construct($options = array() )
    {
        if ( isset($options['expiry']) ) {
            $this->expiry = $options['expiry'];
        }

        if ( isset($options['cache_dir']) ) {
            $this->cacheDir = $options['cache_dir'];
        } else {
            $this->cacheDir = 'cache';
        }

        if ( isset($options['serializer']) ) {
            $this->serializer = $options['serializer'];
        }

        if ( ! file_exists($this->cacheDir) ) {
            mkdir($this->cacheDir, $this->umask, true );
        }

        $this->filenameBuilder = function($key) {
            return preg_replace('#\W+#','_',$key);
        };
    }


    public function _getCacheFilepath($key)
    {
        $filename = preg_replace('#\W+#','_',$key);
        $subdir   = crc32($key);
        futil_mkdir_if_not_exists( $this->cacheDir . DIRECTORY_SEPARATOR . $subdir , $this->umask , true );
        return $this->cacheDir . DIRECTORY_SEPARATOR . $subdir . DIRECTORY_SEPARATOR . $filename;
    }

    public function _decodeFile($file) 
    {
        $content = file_get_contents($file);
        if ( $this->serializer ) {
            return $this->serializer->decode( $content );
        }
        return unserialize($content);
    }

    public function _encodeFile($file,$data)
    {
        $content = null;
        if( $this->serializer ) {
            $content = $this->serializer->encode( $data );
        } else {
            $content = serialize($data);
        }
        return file_put_contents( $file, $content );
    }

    public function __get($key)
    {
        return $this->get($key);
    }

    public function __set($key,$val)
    {
        return $this->set($key,$val);
    }

    public function get($key) 
    {
        $path = $this->_getCacheFilepath($key);

        if ( ! file_exists($path) ) {
            return null;
        }

        // is expired ?
        if( $this->expiry && (time() - filemtime($path)) > $this->expiry ) {
            return null;
        }

        return $this->_decodeFile($path);
    }

    public function set($key,$value,$ttl = 0) 
    {
        $path = $this->_getCacheFilepath($key);
        return $this->_encodeFile($path,$value) !== false;
    }

    public function remove($key) 
    {
        $path = $this->_getCacheFilepath($key);
        futil_unlink_if_exists($path);
    }

    public function clear() 
    {
        $iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this->cacheDir),
                                                RecursiveIteratorIterator::CHILD_FIRST);
        foreach ($iterator as $path) {
            if( $path->isFile() ) {
                unlink( $path->__toString() );
            }
        }
    }
}





<?php
/*
 * This file is part of the UniversalCache package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace UniversalCache;
use Memcache;
use Exception;
use RuntimeException;

class MemcacheCache 
{
    private $handle;
    public $compress = false;

    /**
     * @param array $options 
     *
     *    servers [ ['localhost',65566], [...] ]
     */
    public function __construct($options = array() )
    {
        $this->handle = new Memcache;
        if ( isset($options['server']) ) {
            $server = $options['server'];
            if ( false === $this->handle->addServer( $server[0] , $server[1] ) ) {
                throw new RuntimeException("Could not add memcache server.");
            }
        }
        elseif ( isset($options['servers']) ) {
            $servers = $options['servers'];
            foreach( $servers as $server ) {
                if ( false === $this->handle->addServer( $server[0] , $server[1] ) ) {
                    throw new RuntimeException("Could not add memcache server.");
                }
            }
        }
    }

    public function getHandle()
    {
        return $this->handle;
    }

    public function __get($key)
    {
        return $this->get($key);
    }

    public function __set($key,$val)
    {
        return $this->set($key,$val);
    }

    public function set($key,$value,$ttl = 0)
    {
        $this->handle->set( $key , serialize( $value ) , $this->compress , $ttl );
    }

    public function get($key)
    {
        $v = $this->handle->get( $key );
        if ( $v ) {
            return unserialize($v);
        }
    }

    public function remove($key)
    {
        $this->handle->delete($key);
    }

    public function clear()
    {
        $this->handle->flush();
    }

    static function getInstance()
    {
        static $instance;
        return $instance ? $instance : $instance = new static;
    }

}

<?php
namespace UniversalCache;

class MemoryCache
{
    private $_cache = array();

    public function get($key)
    {
        if ( isset($this->_cache[ $key ] ) )
            return $this->_cache[ $key ];
    }

    public function set($key,$value,$ttl = 0)
    {
        $this->_cache[ $key ] = $value;
    }

    public function __set($key,$value)
    {
        $this->set($key,$value);
    }

    public function __get($key)
    {
        return $this->get($key);
    }

    public function remove($key)
    {
        unset( $this->_cache[ $key ] );
    }

    public function clear()
    {
        $this->_cache = array();
    }

    static function getInstance()
    {
        static $instance;
        return $instance ? $instance : $instance = new static;
    }

}
<?php
/*
 * This file is part of the UniversalCache package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace UniversalCache;
use ReflectionClass;
use Exception;


/**
 * UniversalCache class provides an interface to operate data on different 
 * cache backend,
 * you may put the fastest cache backend to the first position, so that you can 
 * fetch the cache very quickly.
 *
 *
 * e.g.,
 *
 *    use UniversalCache;
 *    $cache = new UniversalCache(array( 
 *      new ApcCache(array( 'namespace' => 'app_' )),
 *      new FileSystemCache(array( 'cache_dir' => ... ))
 *    ));
 *    $cache->set('key', 'value');
 *    $value = $cache->get('key');
 *
 */

class UniversalCache 
{
    private $backends = array();

    public function __construct($backends)
    {
        $this->backends = (array)$backends;
    }

    public function addBackend( $backend )
    {
        $this->backends[] = $backend;
    }

    public function get( $key )
    {
        foreach( $this->backends as $b ) {
            if( ($value = $b->get( $key )) !== false ) {
                return $value;
            }
        }
    }

    public function set( $key , $value , $ttl = 1000 ) 
    {
        foreach( $this->backends as $b ) {
            $b->set( $key , $value , $ttl );
        }
    }

    public function remove($key)
    {
        foreach( $this->backends as $b ) {
            $b->remove( $key );
        }
    }

    public function clear()
    {
        foreach( $this->backends as $b ) {
            $b->clear();
        }
    }

    public function getBackends()
    {
        return $this->backends;
    }

    public static function create()
    {
        $args = func_get_args();
        $class = array_shift( $args );
        $backendClass = '\\UniversalCache\\' . $class;
        $rc = new ReflectionClass($backendClass);
        $b = $rc->newInstanceArgs($args);

        // $b = call_user_func_array( array($backendClass,'new') , $args );
        // $b = new $backendClass( $args );
        return $b;
    }

}
<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit;
use GetOptionKit\OptionCollection;

class Argument 
{
    public $arg;

    public function __construct($arg)
    {
        $this->arg = $arg;
    }


    public function isLongOption()
    {
        return substr($this->arg,0,2) === '--';
    }

    public function isShortOption()
    {
        return (substr($this->arg,0,1) === '-' ) 
            && (substr($this->arg,1,1) !== '-');
    }

    public function isEmpty()
    {
        return $this->arg === null || empty($this->arg) && ('0' !== $this->arg);
    }


    /**
     * Check if an option is one of the option in the collection
     */
    public function anyOfOptions(OptionCollection $options)
    {
        $name = $this->getOptionName();
        $keys = $options->keys();
        return in_array($name, $keys);
    }


    /**
     * Check current argument is an option by the preceding dash.
     * note this method does not work for string with negative value.
     *
     *   -a
     *   --foo
     */
    public function isOption()
    {
        return $this->isShortOption() || $this->isLongOption();
    }


    public function getOption() {
        if (preg_match('/^([-]+[a-zA-Z0-9-]+)/', $this->arg, $regs)) {
            return $regs[1];
        }
    }


    /**
     * Parse option and return the name after dash. e.g., 
     * '--foo' returns 'foo'
     * '-f' returns 'f'
     *
     * @return string
     */
    public function getOptionName()
    {
        if (preg_match('/^[-]+([a-zA-Z0-9-]+)/',$this->arg,$regs)) {
            return $regs[1];
        }
    }

    public function splitAsOption() {
        return explode('=', $this->arg, 2);
    }

    public function containsOptionValue()
    {
        return preg_match('/=.+/',$this->arg);
    }

    public function getOptionValue()
    {
        if (preg_match('/=(.+)/',$this->arg,$regs)) {
            return $regs[1];
        }
    }

    /** 
     * Check combined short flags for "-abc" or "-vvv"
     *
     * like: -abc
     */
    public function withExtraFlagOptions()
    {
        return preg_match('/^-[a-zA-Z0-9]{2,}/',$this->arg);
    }

    public function extractExtraFlagOptions()
    {
        $args = array();
        for($i=2;$i< strlen($this->arg); ++$i) {
            $args[] = '-' . $this->arg[$i];
        }
        $this->arg = substr($this->arg,0,2); # -[a-z]
        return $args;
    }

    public function __toString()
    {
        return $this->arg;
    }

}



<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit;
use GetOptionKit\Option;
use GetOptionKit\OptionCollection;
use GetOptionKit\OptionResult;
use GetOptionKit\OptionParser;
use GetOptionKit\ContinuousOptionParser;
use Exception;

/* A wrapper class for continuous option parser */
class ContinuousOptionKit extends GetOptionKit
{
    public function __construct()
    {
        $this->specs = new OptionCollection;
        $this->parser = new ContinuousOptionParser( $this->specs );
    }

    public function parse(array $argv ) 
    {
        return $this->parser->parse( $argv );
    }

    public function isEnd()
    {
        return $this->parser->isEnd();
    }

    public function continueParse()
    {
        return $this->parser->continueParse();
    }
}

<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit;
use GetOptionKit\Option;
use GetOptionKit\OptionResult;
use GetOptionKit\Argument;
use GetOptionKit\OptionParser;
use GetOptionKit\OptionCollection;
use Exception;
use GetOptionKit\Exception\InvalidOptionException;
use GetOptionKit\Exception\RequireValueException;

/**
 * A common command line argument format:
 *
 *      app.php
 *         [--app-options]
 *
 *      [subcommand
 *          --subcommand-options]
 *      [subcommand
 *          --subcommand-options]
 *      [subcommand
 *          --subcommand-options]
 *
 *      [arguments]
 *
 * ContinuousOptionParser is for the process flow:
 *
 * init app options,
 * parse app options
 *
 *
 *
 * while not end
 *   if stop at command
 *     shift command
 *     parse command options
 *   else if stop at arguments
 *     shift arguments
 *     execute current command with the arguments.
 *
 *  Example code:
 *
 *
 *      // subcommand stack
 *      $subcommands = array('subcommand1','subcommand2','subcommand3');
 *
 *      // different command has its own options
 *      $subcommand_specs = array(
 *          'subcommand1' => $cmdspecs,
 *          'subcommand2' => $cmdspecs,
 *          'subcommand3' => $cmdspecs,
 *      );
 *
 *      // for saved options
 *      $subcommand_options = array();
 *
 *      // command arguments
 *      $arguments = array();
 * 
 *      $argv = explode(' ','-v -d -c subcommand1 -a -b -c subcommand2 -c subcommand3 arg1 arg2 arg3');
 *
 *      // parse application options first
 *      $parser = new ContinuousOptionParser( $appspecs );
 *      $app_options = $parser->parse( $argv );
 *      while( ! $parser->isEnd() ) {
 *          if( $parser->getCurrentArgument() == $subcommands[0] ) {
 *              $parser->advance();
 *              $subcommand = array_shift( $subcommands );
 *              $parser->setSpecs( $subcommand_specs[$subcommand] );
 *              $subcommand_options[ $subcommand ] = $parser->continueParse();
 *          } else {
 *              $arguments[] = $parser->advance();
 *          }
 *      }
 *
 *
 **/
class ContinuousOptionParser extends OptionParser
{
    public $index;
    public $length;
    public $argv;

    /* for the constructor , the option specs is application options */
    public function __construct(OptionCollection $specs)
    {
        parent::__construct($specs);
        $this->index = 1;
    }

    public function startFrom($index)
    {
        $this->index = $index;
    }

    public function isEnd()
    {
        # echo "!! {$this->index} >= {$this->length}\n";
        return ($this->index >= $this->length);
    }

    public function advance()
    {
        $arg = $this->argv[ $this->index++ ];
        return $arg;
    }

    public function getCurrentArgument()
    {
        return $this->argv[ $this->index ];
    }

    public function continueParse()
    {
        return $this->parse($this->argv);
    }

    public function parse(array $argv)
    {
        // create new Result object.
        $result = new OptionResult;
        $argv = $this->preprocessingArguments($argv);

        $this->argv = $argv;
        $this->length = count($argv);

        // register option result from options with default value 
        foreach ($this->specs as $spec) {
            if ($spec->defaultValue !== null) {
                $result->set($spec->getId() , $spec);
            }
        }

        if ($this->isEnd()) {
            return $result;
        }


        // from last parse index
        for ( ; $this->index < $this->length; ++$this->index ) 
        {
            $arg = new Argument( $argv[$this->index] );

            /* let the application decide for: command or arguments */
            if (! $arg->isOption()) {
                # echo "stop at {$this->index}\n";
                return $result;
            }

            // if the option is with extra flags,
            //   split it out, and insert into the argv array
            //
            //   like -abc
            if ($arg->withExtraFlagOptions() ) {
                $extra = $arg->extractExtraFlagOptions();
                array_splice( $argv, $this->index + 1, 0, $extra );
                $argv[$this->index] = $arg->arg; // update argument to current argv list.
                $len = count($argv);   // update argv list length
            }

            $next = null;
            if ($this->index + 1 < count($argv) )  {
                $next = new Argument( $argv[$this->index + 1] );
            }

            $spec = $this->specs->get( $arg->getOptionName() );
            if (! $spec) {
                throw new InvalidOptionException("Invalid option: " . $arg );
            }

            if ($spec->isRequired()) {
                if ( ! $this->foundRequireValue($spec,$arg,$next) ) {
                    throw new RequireValueException( "Option '{$arg->getOptionName()}' requires a value." );
                }

                $this->takeOptionValue($spec,$arg,$next);
                if ($next && ! $next->anyOfOptions($this->specs)) {
                    $this->index++;
                }
                $result->set($spec->getId(), $spec);
            } elseif ($spec->isMultiple()) 
            {
                $this->pushOptionValue($spec,$arg,$next);
                if ($next && ! $next->anyOfOptions($this->specs) ) {
                    $this->index++;
                }
                $result->set( $spec->getId() , $spec);
            } elseif ($spec->isOptional())
            {
                $this->takeOptionValue($spec,$arg,$next);
                if (($spec->value || $spec->defaultValue) && $next && ! $next->anyOfOptions($this->specs)) {
                    $this->index++;
                }
                $result->set($spec->getId() , $spec);
            } elseif ($spec->isFlag()) {
                $spec->setValue(true);
                $result->set( $spec->getId() , $spec);
            } else 
            {
                throw new Exception('Unknown attribute.');
            }
        }
        return $result;
    }

}
<?php
namespace GetOptionKit\Exception;
use Exception;

class InvalidOptionException extends Exception { }



<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit\Exception;
use Exception;

class NonNumericException extends Exception { }


<?php
namespace GetOptionKit\Exception;

use Exception;

class RequireValueException extends Exception { }

<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit;
use GetOptionKit\Option;
use GetOptionKit\OptionCollection;
use GetOptionKit\OptionResult;
use GetOptionKit\OptionParser;
use Exception;

class GetOptionKit 
{
    public $parser;
    public $specs;

    public function __construct($specs = null)
    {
        $this->specs = $specs ?: new OptionCollection;
        $this->parser = new OptionParser( $this->specs );
    }

    /* 
     * return current parser 
     * */
    public function getParser()
    {
        return $this->parser;
    }

    /* get all option specification */
    public function getSpecs()
    {
        return $this->specs;
    }

    /* a helper to build option specification object from string spec 
     *
     * @param $specString string
     * @param $description string
     * @param $key
     *
     * */
    public function add($specString, $description , $key = null ) 
    {
        $spec = $this->specs->add($specString,$description,$key);
        return $spec;
    }

    /* get option specification by Id */
    public function get($id)
    {
        return $this->specs->get($id);
    }

    public function parse(array $argv ) 
    {
        return $this->parser->parse( $argv );
    }

    public function printOptions( $class = 'GetOptionKit\OptionPrinter' )
    {
        $this->specs->printOptions( $class );
    }

}

<?php
require 'Argument.php';
require 'Exception/NonNumericException.php';
require 'Exception/InvalidOptionException.php';
require 'Exception/RequireValueException.php';
require 'OptionResult.php';
require 'Option.php';
require 'OptionCollection.php';
require 'OptionPrinterInterface.php';
require 'OptionPrinter.php';
require 'OptionParser.php';
require 'GetOptionKit.php';
require 'ContinuousOptionParser.php';
require 'ContinuousOptionKit.php';
<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */

namespace GetOptionKit;
use GetOptionKit\Exception\NonNumericException;
use Exception;
use LogicException;
use InvalidArgumentException;

class InvalidOptionValue extends Exception {  }

class Option 
{
    public $short;


    public $long;

    /**
     * @var string the description of this option
     */
    public $desc;

    /**
     * @var string The option key
     */
    public $key;  /* key to store values */

    public $value;

    public $type;

    public $valueName; /* name for the value place holder, for printing */

    public $isa;

    public $isaOption;

    public $validValues;

    public $suggestions;

    public $defaultValue;

    public $incremental = false;

    /**
     * @var Closure The filter closure of the option value.
     */
    public $filter;

    public $validator;

    public $multiple = false;

    public $optional = false;

    public $required = false;

    public $flag     = false;


    /**
     * @var callable trigger callback after value is set.
     */
    protected $trigger;


    public function __construct($specString = null)
    {
        if( $specString ) {
            $this->initFromSpecString($specString);
        }
    }

    /**
     * Build spec attributes from spec string 
     *
     * @param string $specString
     */
    public function initFromSpecString($specString)
    {
        $pattern = '/
        (
                (?:[a-zA-Z0-9-]+)
                (?:
                    \|
                    (?:[a-zA-Z0-9-]+)
                )?
        )
        ([:+?])?
        (?:=(boolean|string|number|date|file|url|email|ip|ipv6|ipv4))?
        /x';

        if( preg_match( $pattern, $specString , $regs ) === false ) {
            throw new Exception( "Unknown spec string" );
        }

        $orig       = $regs[0];
        $name       = $regs[1];
        $attributes = isset($regs[2]) ? $regs[2] : null;
        $type       = isset($regs[3]) ? $regs[3] : null;

        $short = null;
        $long = null;

        // check long,short option name.
        if( strpos($name,'|') !== false ) {
            list($short,$long) = explode('|',$name);
        } elseif( strlen($name) === 1 ) {
            $short = $name;
        } elseif( strlen($name) > 1 ) {
            $long = $name;
        }

        $this->short  = $short;
        $this->long   = $long;

        // option is required.
        if( strpos($attributes,':') !== false ) {
            $this->required();
        }
        // option with multiple value
        elseif ( strpos($attributes,'+') !== false ) {
            $this->multiple();
        }
        // option is optional.(zero or one value)
        elseif ( strpos($attributes,'?') !== false ) {
            $this->optional();
        }
        // option is multiple value and optional (zero or more)
        elseif( strpos($attributes,'*') !== false ) {
            throw new Exception('not implemented yet');
        }
        // is a flag option
        else {
            $this->flag();
        }
        if( $type ) {
            $this->isa($type);
        }
    }


    /*
     * get the option key for result key mapping.
     */
    public function getId()
    {
        if( $this->key )
            return $this->key;
        if( $this->long )
            return $this->long;
        if( $this->short )
            return $this->short;
    }

    /**
     * To make -v, -vv, -vvv works 
     */
    public function incremental()
    {
        $this->incremental = true;
        return $this;
    }

    public function required()
    {
        $this->required = true;
        return $this;
    }

    public function defaultValue($value)
    {
        $this->defaultValue = $value;
        return $this;
    }

    public function multiple()
    {
        $this->multiple = true;
        $this->value = array();  # for value pushing
        return $this;
    }

    public function optional()
    {
        $this->optional = true;
        return $this;
    }

    public function flag()
    {
        $this->flag = true;
        return $this;
    }


    public function trigger(callable $trigger)
    {
        $this->trigger = $trigger;
        return $this;
    }


    public function isIncremental()
    {
        return $this->incremental;
    }


    public function isFlag()
    {
        return $this->flag;
    }

    public function isMultiple()
    {
        return $this->multiple;
    }

    public function isRequired()
    {
        return $this->required;
    }

    public function isOptional()
    {
        return $this->optional;
    }

    public function isTypeNumber()
    {
        return $this->isa == 'number';
    }

    public function isType($type) {
        return $this->isa === $type;
    }

    public function getTypeClass() {
        $class = 'GetOptionKit\\ValueType\\' . ucfirst($this->isa) . 'Type';
        if ( class_exists($class, true) ) {
            return new $class($this->isaOption);
        }
        return false;
    }

    public function testValue($value) {
        if ( $type = $this->getTypeClass() ) {
            return $type->test($value);
        }
        return true; // always true if type class is not found.
    }

    protected function _preprocessValue($value) {
        $val = $value;

        if ($isa = ucfirst($this->isa)) {
            if ($type = $this->getTypeClass()) {
                if ($type->test($value)) {
                    $val = $type->parse($value);
                } else {
                    throw new InvalidOptionValue("Invalid value for {$this->renderReadableSpec(false)}. Requires a type $isa.");
                }
            } else {
                throw new LogicException("Type class of $isa not found.");

            }
        }

        // check pre-filter for option value
        if ( $this->filter ) {
            $val = call_user_func($this->filter, $val);
        }

        // check validValues
        if ($validValues = $this->getValidValues()) {
            if ( ! in_array($value, $validValues) ) {
                throw new InvalidOptionValue("valid values are: " . join(', ', $validValues) );
            }
        }
        return $val;
    }

    public function callTrigger()
    {
        if ($this->trigger) {
            if ($ret = call_user_func($this->trigger, $this->value)) {
                $this->value = $ret;
            }
        }
    }

    /*
     * set option value
     */
    public function setValue($value)
    {
        $this->value = $this->_preprocessValue($value);
        $this->callTrigger();
    }


    /**
     * This method is for incremental option
     */
    public function increaseValue()
    {
        if (!$this->value ) {
            $this->value = 1;
        } else {
            $this->value++;
        }
        $this->callTrigger();
    }

    /**
     * push option value, when the option accept multiple values 
     *
     * @param mixed
     */
    public function pushValue($value)
    {
        $value = $this->_preprocessValue($value);
        $this->value[] = $value;
        $this->callTrigger();
    }

    public function desc($desc)
    {
        $this->desc = $desc;
    }

    /**
     * valueName is for option value hinting:
     *
     *   --name=<name>
     */
    public function valueName($name)
    {
        $this->valueName = $name;
        return $this;
    }

    public function renderValueHint() {
        $n = 'value';
        if ($this->valueName) {
            $n = $this->valueName;
        } elseif ($this->isa) {
            $n = $this->isa;
        }

        $val = $this->defaultValue; // Unknown mixed type.
        // This allows for `0` and `false` values to be displayed also.
        if ((is_scalar($val) && strlen((string) $val)) || is_bool($val)) {
            if (is_bool($val)) {
                $n .= ':' . ($val ? 'true' : 'false');
            } else {
                $n .= ':' . $val;
            }
        }

        if ($this->isRequired()) {
            return sprintf('=<%s>', $n);
        }
        if ($this->isOptional()) {
            return sprintf('[=<%s>]', $n);
        }
        return '';
    }


    public function getValue() {
        if (null !== $this->value) {
            return $this->value;
        }
        return $this->defaultValue;
    }

    /*
     * set option spec key for saving option result
     */
    public function setKey($key)
    {
        $this->key = $key;
    }

    /**
     * get readable spec for printing
     * 
     * @param string $renderHint render also value hint
     */
    public function renderReadableSpec($renderHint = true)
    {
        $c1 = '';
        if( $this->short && $this->long )
            $c1 = sprintf('-%s, --%s',$this->short,$this->long);
        elseif( $this->short )
            $c1 = sprintf('-%s',$this->short);
        elseif( $this->long )
            $c1 = sprintf('--%s',$this->long );
        if($renderHint) $c1 .= $this->renderValueHint();
        return $c1;
    }

    public function __toString()
    {
        $c1 = $this->renderReadableSpec();
        $return = '';
        $return .= sprintf("* key:%-8s spec:%s  desc:%s",$this->getId(), $c1,$this->desc) . "\n";
        $val = $this->getValue();
        if (is_array($val)) {
            $return .= '  ' . print_r(  $val, true ) . "\n";
        } else {
            $return .= sprintf("  value => %s" , $val) . "\n";
        }
        return $return;
    }


    /**
     * Value Type Setters
     *
     * @param string $type the value type, valid values are 'number', 'string', 
     *                      'file', 'boolean', you can also use your own value type name.
     *
     * @param mixed  $option option(s) for value type class (optionnal)
     *
     */
    public function isa($type, $option = null) {
        // "bool" was kept for backward compatibility
        if ($type === "bool") {
            $type = "boolean";
        }
        $this->isa = $type;
        $this->isaOption = $option;
        return $this;
    }

    /**
     * Assign validValues to member value.
     */
    public function validValues($values) {
        $this->validValues = $values;
        return $this;
    }

    /**
     * Assign suggestions
     *
     * @param Closure|Array
     */
    public function suggestions($suggestions) {
        $this->suggestions = $suggestions;
        return $this;
    }


    /**
     * Return valud values array
     *
     * @return string[] or nil
     */
    public function getValidValues() { 
        if ($this->validValues) {
            if (is_callable($this->validValues)) {
                return call_user_func($this->validValues);
            }
            return $this->validValues;
        }
    }



    /**
     * Return suggestions
     *
     * @return string[] or nil
     */
    public function getSuggestions() { 
        if ( $this->suggestions ) {
            if (is_callable($this->suggestions)) {
                return call_user_func($this->suggestions);
            }
            return $this->suggestions;
        }
    }

    public function validate($value) {
        if ($this->validator) {
            $ret = call_user_func($this->validator, $value);
            if (is_array($ret)) {
                return $ret;
            } elseif ($ret === false) {
                return array(false, "Invalid value: $value");
            }
            throw new InvalidArgumentException("Invalid return value from the validator.");
        }
        return array(true);
    }



    public function validator($cb) {
        $this->validator = $cb;
        return $this;
    }

    /**
     * Set up a filter function for the option value.
     */
    public function filter($cb) {
        if ( ! is_callable($cb) ) {
            throw new Exception("Non-callable value for filter");
        }
        $this->filter = $cb;
        return $this;
    }

}


<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit;
use GetOptionKit\Option;
use Iterator;
use ArrayIterator;
use IteratorAggregate;
use Countable;

class OptionCollection
    implements IteratorAggregate, Countable
{
    public $data = array();

    /**
     * @var Option[string]
     *
     * read-only property
     */
    public $longOptions = array();

    /**
     * @var Option[string]
     *
     * read-only property
     */
    public $shortOptions = array();

    /**
     * @var Option[]
     *
     * read-only property
     */
    public $options = array();



    public function __construct()
    {
        $this->data = array();
    }

    public function __clone()
    {
        foreach( $this->data as $k => $v ) {
            $this->data[ $k ] = clone $v;
        }
        foreach( $this->longOptions as $k => $v ) {
            $this->longOptions[ $k ] = clone $v;
        }
        foreach( $this->shortOptions as $k => $v ) {
            $this->shortOptions[ $k ] = clone $v;
        }
        foreach( $this->options as $k => $v ) {
            $this->options[ $k ] = clone $v;
        }
    }

    /**
     * add( [spec string], [desc string] )
     *
     * add( [option object] )
     */
    public function add()
    {
        $num = func_num_args();
        $args = func_get_args();
        $first = $args[0];

        if (is_object($first) && $first instanceof Option) {
            $this->addObject( $first );
        } else if ( is_string( $first ) ) {
            $specString  = $args[0];
            $desc = isset($args[1]) ? $args[1] : null;
            $key         = isset($args[2]) ? $args[2] : null;

            // parse spec string
            $spec = new Option($specString);
            if( $desc )
                $spec->desc($desc);
            if( $key )
                $spec->key = $key;
            $this->add( $spec );
            return $spec;
        } else {
            throw new Exception( 'Unknown Spec Type' );
        }
    }

    /**
     * Add option object
     *
     * @param Object $spec the option object.
     */
    public function addObject( Option $spec )
    {
        $this->data[ $spec->getId() ] = $spec;
        if( $spec->long )
            $this->longOptions[ $spec->long ] = $spec;
        if( $spec->short )
            $this->shortOptions[ $spec->short ] = $spec;
        $this->options[] = $spec;
        if( ! $spec->long && ! $spec->short )
            throw new Exception('Wrong option spec');
    }

    public function getLongOption( $name )
    {
        return isset($this->longOptions[ $name ]) ? $this->longOptions[ $name ] : null;
    }

    public function getShortOption( $name )
    {
        return isset($this->shortOptions[ $name ]) ? $this->shortOptions[ $name ] : null;
    }

    /* Get spec by spec id */
    public function get($id)
    {
        if (isset($this->data[$id])) {
            return $this->data[$id];
        } elseif (isset($this->longOptions[$id])) {
            return $this->longOptions[$id];
        } elseif (isset($this->shortOptions[$id])) {
            return $this->shortOptions[$id];
        }
    }


    public function find($name) {
        foreach( $this->options as $option ) {
            if ($option->short == $name || $option->long == $name) {
                return $option;
            }
        }
    }

    public function size()
    {
        return count($this->data);
    }

    public function all()
    {
        return $this->data;
    }

    public function toArray()
    {
        $array = array();
        foreach($this->data as $k => $spec) {
            $item = array();
            if ($spec->long) {
                $item['long'] = $spec->long;
            }
            if ($spec->short ) {
                $item['short'] = $spec->short;
            }
            $item['desc'] = $spec->desc;
            $array[] = $item;
        }
        return $array;
    }

    public function keys()
    {
        return array_merge(array_keys($this->longOptions), array_keys($this->shortOptions));
    }

    public function count() {
        return count($this->data);
    }


    public function getIterator() {
        return new ArrayIterator($this->data);
    }
}
<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit;
use GetOptionKit\Option;
use GetOptionKit\OptionCollection;
use GetOptionKit\OptionResult;
use GetOptionKit\Argument;
use Exception;
use GetOptionKit\Exception\InvalidOptionException;
use GetOptionKit\Exception\RequireValueException;

class OptionParser 
{
    public $specs;
    public $longOptions;
    public $shortOptions;

    public function __construct(OptionCollection $specs)
    {
        $this->specs = $specs;
    }

    public function setSpecs(OptionCollection $specs)
    {
        $this->specs = $specs;
    }


    /* a helper to build option specification object from string spec 
     *
     * @param $specString string
     * @param $description string
     * @param $key
     *
     * */
    public function addSpec($specString, $description , $key = null ) 
    {
        $spec = $this->specs->add($specString,$description,$key);
        return $spec;
    }

    /* get option specification by Id */
    public function getSpec($id)
    {
        return $this->specs->get($id);
    }




    /* detect option */
    public function isOption($arg)
    {
        return substr($arg,0,1) === '-';
    }

    /* take option value from current argument or from the next argument */
    public function takeOptionValue(Option $spec, $arg, $next)
    {
        if ($next && !$next->anyOfOptions($this->specs)) {
            $spec->setValue($next->arg);
        } else if ($spec->defaultValue) {
            $spec->setValue($spec->defaultValue);
        } else if ($spec->isFlag()) {
            $spec->setValue(true);
        } else if ($next && !$next->isEmpty()) {
            $spec->setValue($next->arg);
        } else {
            $spec->setValue(true);
        }
    }

    /* 
     * push value to multipl value option
     */
    public function pushOptionValue(Option $spec,$arg,$next)
    {
        if ($next && ! $next->anyOfOptions($this->specs)) {
            $spec->pushValue( $next->arg );
        }
    }

    public function foundRequireValue(Option $spec,$arg,$next)
    {
        /* argument doesn't contain value and next argument is option */
        if ($next && ! $next->isEmpty() && !$next->anyOfOptions($this->specs)) {
            return true;
        }
        return false;
    }


    public function preprocessingArguments(array $argv)
    {
        // preprocessing arguments
        $newArgv = array();
        $afterDash = false;
        foreach($argv as $arg) {
            if ($arg == '--') {
                $afterDash = true;
            }
            if ($afterDash) {
                $newArgv[] = $arg;
                continue;
            }

            $a = new Argument($arg);
            if ($a->anyOfOptions($this->specs) && $a->containsOptionValue()) {
                list($opt,$val) = $a->splitAsOption();
                array_push($newArgv, $opt, $val);
            } else {
                array_push($newArgv, $arg);
            }
        }
        return $newArgv;
    }


    /**
     * @param array $argv
     * @return OptionResult|Option[]
     * @throws Exception\RequireValueException
     * @throws Exception\InvalidOptionException
     * @throws \Exception
     */
    public function parse(array $argv)
    {
        $result = new OptionResult;
        $argv = $this->preprocessingArguments($argv);


        foreach ($this->specs as $spec) {
            if ($spec->defaultValue !== null) {
                $result->set($spec->getId() , $spec);
            }
        }


        $len = count($argv);
        for ($i = 0; $i < $len; ++$i)
        {
            $arg = new Argument( $argv[$i] );

            // if looks like not an option, push it to argument list.
            // TODO: we might want to support argument with preceding dash (?)
            if (! $arg->isOption()) {
                $result->addArgument( $arg );
                continue;
            }

            // if the option is with extra flags,
            //   split the string, and insert into the argv array
            if ($arg->withExtraFlagOptions()) {
                $extra = $arg->extractExtraFlagOptions();
                array_splice( $argv, $i+1, 0, $extra );
                $argv[$i] = $arg->arg; // update argument to current argv list.
                $len = count($argv);   // update argv list length
            }


            $next = null;
            if ($i + 1 < count($argv) )  {
                $next = new Argument($argv[$i + 1]);
            }

            $spec = $this->specs->get($arg->getOptionName());
            if (! $spec) {
                throw new InvalidOptionException("Invalid option: " . $arg );
            }

            if ($spec->isRequired()) {
                if (! $this->foundRequireValue($spec, $arg, $next) ) {
                    throw new RequireValueException( "Option {$arg->getOptionName()} requires a value. given '{$next}'");
                }
                $this->takeOptionValue($spec, $arg, $next);
                if ($next && ! $next->anyOfOptions($this->specs)) {
                    $i++;
                }
                $result->set($spec->getId(), $spec);

            } 
            elseif ($spec->isMultiple()) 
            {
                $this->pushOptionValue($spec,$arg,$next);
                if ($next && $next->isOption()) {
                    $i++;
                }
                $result->set($spec->getId(), $spec);
            }
            elseif ($spec->isOptional())
            {
                $this->takeOptionValue($spec,$arg,$next);
                if (($spec->value || $spec->defaultValue) && $next && !$next->isOption() ) {
                    $i++;
                }
                $result->set( $spec->getId() , $spec);
            }
            elseif ($spec->isIncremental())
            {
                $spec->increaseValue();
                $result->set($spec->getId() , $spec);
            }
            elseif ($spec->isFlag())
            {
                $spec->setValue(true);
                $result->set($spec->getId() , $spec);
            }
            else
            {
                throw new Exception('Unknown attribute.');
            }
        }
        return $result;
    }
}
<?php
/**
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit\OptionPrinter;
use GetOptionKit\OptionCollection;
use GetOptionKit\Option;
use GetOptionKit\OptionPrinter\OptionPrinterInterface;

class ConsoleOptionPrinter implements OptionPrinterInterface
{

    public $screenWidth = 78;


    /**
     * Render readable spec
     */
    public function renderOption(Option $opt)
    {
        $c1 = '';
        if ( $opt->short && $opt->long ) {
            $c1 = sprintf('-%s, --%s',$opt->short,$opt->long);
        } elseif( $opt->short ) {
            $c1 = sprintf('-%s',$opt->short);
        } elseif( $opt->long ) {
            $c1 = sprintf('--%s',$opt->long );
        }
        $c1 .= $opt->renderValueHint();
        return $c1;
    }


    /**
     * render option descriptions
     *
     * @return string output
     */
    public function render(OptionCollection $options)
    {
        # echo "* Available options:\n";
        $lines = array();
        foreach( $options as $option ) {
            $c1 = $this->renderOption($option);
            $lines[] = "\t" . $c1;
            $lines[] = wordwrap("\t\t" . $option->desc, $this->screenWidth, "\n\t\t");  # wrap text
            $lines[] = "";
        }
        return join("\n",$lines);
    }
}


<?php
namespace GetOptionKit\OptionPrinter;
use GetOptionKit\OptionCollection;
use GetOptionKit\Option;

interface OptionPrinterInterface {
    public function renderOption(Option $option);
    public function render(OptionCollection $options);
}


<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit;
use ArrayIterator;
use ArrayAccess;
use Iterator;
use IteratorAggregate;
use GetOptionKit\Argument;
use GetOptionKit\Option;

/**
 * Define the getopt parsing result
 *
 * create option result from array()
 *
 *     OptionResult::create($spec, array( 
 *         'key' => 'value'
 *     ), array( ... arguments ... ) );
 *
 */
class OptionResult 
    implements IteratorAggregate, ArrayAccess
{
    /**
     * @var array option specs, key => Option object 
     * */
    public $keys = array();

    private $currentKey;

    /* arguments */
    public $arguments = array();

    public function getIterator() {
        return new ArrayIterator($this->keys);
    }

    public function __isset($key)
    {
        return isset($this->keys[$key]);
    }

    public function __get($key)
    {
        if (isset($this->keys[$key])) {
            return $this->keys[$key]->getValue();
        }

        // verifying if we got a camelCased key: http://stackoverflow.com/a/7599674/102960
        //    get $options->baseDir as $option->{'base-dir'}
        $parts = preg_split('/(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])/', $key);
        if (sizeof($parts) > 1) {
            $key = join('-', array_map('strtolower', $parts));
        }
        if (isset($this->keys[$key])) {
            return $this->keys[$key]->getValue();
        }
    }

    public function __set($key, $value)
    {
        $this->keys[ $key ] = $value;
    }

    public function has($key)
    {
        return isset($this->keys[ $key ]);
    }

    public function set($key, Option $value)
    {
        $this->keys[ $key ] = $value;
    }

    public function addArgument(Argument $arg)
    {
        $this->arguments[] = $arg;
    }

    public function getArguments()
    {
        return array_map( function($e) { return $e->__toString(); }, $this->arguments );
    }

    public function offsetSet($name,$value)
    {
        $this->keys[ $name ] = $value;
    }
    
    public function offsetExists($name)
    {
        return isset($this->keys[ $name ]);
    }
    
    public function offsetGet($name)
    {
        return $this->keys[ $name ];
    }
    
    public function offsetUnset($name)
    {
        unset($this->keys[$name]);
    }
    
    public function toArray()
    {
        $array = array();
        foreach ($this->keys as $key => $option ) {
            $array[ $key ] = $option->getValue();
        }
        return $array;
    }

    static function create($specs, array $values = array(), array $arguments = null)
    {
        $new = new self;
        foreach ($specs as $spec) {
            $id = $spec->getId();
            if (isset($values[$id])) {
                $new->$id = $spec;
                $spec->setValue( $values[$id] );
            }
            if ($arguments) {
                foreach ($arguments as $arg){
                    $new->addArgument( new Argument( $arg ) );
                }
            }
        }
        return $new;
    }

}

<?php
/*
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace GetOptionKit;

/**
 * SplClassLoader implementation that implements the technical interoperability
 * standards for PHP 5.3 namespaces and class names.
 *
 * http://groups.google.com/group/php-standards/web/final-proposal
 *
 *     // Example which loads classes for the Doctrine Common package in the
 *     // Doctrine\Common namespace.
 *     $classLoader = new SplClassLoader('Doctrine\Common', '/path/to/doctrine');
 *     $classLoader->register();
 *
 * @author Jonathan H. Wage <jonwage@gmail.com>
 * @author Roman S. Borschel <roman@code-factory.org>
 * @author Matthew Weier O'Phinney <matthew@zend.com>
 * @author Kris Wallsmith <kris.wallsmith@gmail.com>
 * @author Fabien Potencier <fabien.potencier@symfony-project.org>
 */
class SplClassLoader
{
    private $_fileExtension = '.php';
    private $_namespace;
    private $_includePath;
    private $_namespaceSeparator = '\\';

    /**
     * Creates a new <tt>SplClassLoader</tt> that loads classes of the
     * specified namespace.
     * 
     * @param string $ns The namespace to use.
     */
    public function __construct($ns = null, $includePath = null)
    {
        $this->_namespace = $ns;
        $this->_includePath = $includePath;
    }


    /**
     * Sets the namespace separator used by classes in the namespace of this class loader.
     * 
     * @param string $sep The separator to use.
     */
    public function setNamespaceSeparator($sep)
    {
        $this->_namespaceSeparator = $sep;
    }

    /**
     * Gets the namespace seperator used by classes in the namespace of this class loader.
     *
     * @return void
     */
    public function getNamespaceSeparator()
    {
        return $this->_namespaceSeparator;
    }

    /**
     * Sets the base include path for all class files in the namespace of this class loader.
     * 
     * @param string $includePath
     */
    public function setIncludePath($includePath)
    {
        $this->_includePath = $includePath;
    }

    /**
     * Gets the base include path for all class files in the namespace of this class loader.
     *
     * @return string $includePath
     */
    public function getIncludePath()
    {
        return $this->_includePath;
    }

    /**
     * Sets the file extension of class files in the namespace of this class loader.
     * 
     * @param string $fileExtension
     */
    public function setFileExtension($fileExtension)
    {
        $this->_fileExtension = $fileExtension;
    }

    /**
     * Gets the file extension of class files in the namespace of this class loader.
     *
     * @return string $fileExtension
     */
    public function getFileExtension()
    {
        return $this->_fileExtension;
    }

    /**
     * Installs this class loader on the SPL autoload stack.
     */
    public function register()
    {
        spl_autoload_register(array($this, 'loadClass'));
    }

    /**
     * Uninstalls this class loader from the SPL autoloader stack.
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

    /**
     * Loads the given class or interface.
     *
     * @param string $className The name of the class to load.
     * @return void
     */
    public function loadClass($className)
    {
        if (null === $this->_namespace || $this->_namespace.$this->_namespaceSeparator === substr($className, 0, strlen($this->_namespace.$this->_namespaceSeparator))) {
            $fileName = '';
            $namespace = '';
            if (false !== ($lastNsPos = strripos($className, $this->_namespaceSeparator))) {
                $namespace = substr($className, 0, $lastNsPos);
                $className = substr($className, $lastNsPos + 1);
                $fileName = str_replace($this->_namespaceSeparator, DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;
            }
            $fileName .= str_replace('_', DIRECTORY_SEPARATOR, $className) . $this->_fileExtension;

            $target = ($this->_includePath !== null ? $this->_includePath . DIRECTORY_SEPARATOR : '') . $fileName;
            if( file_exists($target) )
                require $target;
        }
    }
}
<?php
namespace GetOptionKit\ValueType;

abstract class BaseType
{
    /**
     * Type option
     * 
     * @var mixed
     */
    public $option;

    public function __construct($option = null)
    {
        if($option) $this->option = $option;
    }

    /**
     * Test a value to see if it fit the type
     *
     * @param mixed $value
     */
    abstract public function test($value);

    /**
     * Parse a string value into it's type value
     *
     * @param mixed $value
     */
    abstract public function parse($value);
}<?php
namespace GetOptionKit\ValueType;

class BooleanType extends BaseType
{
    public function test($value) { 
        if (is_string($value) ) {
            $value = strtolower($value);
            return ('0' == $value || '1' == $value || 'true' == $value || 'false' == $value);
        }
        return is_bool($value);
    }

    public function parse($value) {
        $value = strtolower($value);
        if ($value == '0' || $value == 'false')
            return false;
        if ($value == '1' || $value == 'true')
            return true;
        return false;
    }

}



<?php
namespace GetOptionKit\ValueType;

/**
 * An alias class for boolean type
 */
class BoolType extends BooleanType
{
}



<?php
namespace GetOptionKit\ValueType;

class DateType extends BaseType
{
    public function test($value) {
        return date_parse($value) !== FALSE ? TRUE : FALSE;
    }

    public function parse($value) {
        return date_parse($value);
    }
}

<?php
namespace GetOptionKit\ValueType;
use SplFileInfo;

class DirType extends BaseType
{
    public function test($value) 
    {
        return is_dir($value);
    }

    public function parse($value) 
    {
        return new SplFileInfo($value);
    }
}


<?php
namespace GetOptionKit\ValueType;

class EmailType extends BaseType
{
    public function test($value) {
        return filter_var($value, FILTER_VALIDATE_EMAIL);
    }

    public function parse($value) {
        return strval($value);
    }
}<?php
namespace GetOptionKit\ValueType;
use SplFileInfo;

class FileType extends BaseType
{
    public function test($value) {
        return is_file($value);
    }

    public function parse($value) {
        return new SplFileInfo($value);
    }
}


<?php
namespace GetOptionKit\ValueType;

class IpType extends BaseType
{
    public function test($value) {
        return filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4 | FILTER_FLAG_IPV6);
    }

    public function parse($value) {
        return strval($value);
    }
}
<?php
namespace GetOptionKit\ValueType;

class Ipv4Type extends BaseType
{
    public function test($value) {
        return filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4);
    }

    public function parse($value) {
        return strval($value);
    }
}
<?php
namespace GetOptionKit\ValueType;

class Ipv6Type extends BaseType
{
    public function test($value) {
        return filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6);
    }

    public function parse($value) {
        return strval($value);
    }
}
<?php
namespace GetOptionKit\ValueType;

class NumberType extends BaseType
{
    public function test($value) { 
        return is_numeric($value);
    }

    public function parse($value) {
        return intval($value);
    }
}



<?php
namespace GetOptionKit\ValueType;
use SplFileInfo;

class PathType extends BaseType
{
    public function test($value)
    {
        return file_exists($value);
    }

    public function parse($value)
    {
        return new SplFileInfo($value);
    }
}


<?php
namespace GetOptionKit\ValueType;

class RegexType extends BaseType
{
    public $matches = [];

    public function test($value) { 
        if(empty($this->option)) return false;
        $pm = preg_match( $this->option, $value);
        if($pm == 0) $pm = false;
        return $pm;
    }

    public function parse($value) {
        return strval($value);
    }
}


<?php
namespace GetOptionKit\ValueType;

class StringType extends BaseType
{
    public function test($value) { 
        return is_string($value);
    }

    public function parse($value) {
        return strval($value);
    }
}


<?php
namespace GetOptionKit\ValueType;

class UrlType extends BaseType
{
    public function test($value) {
        return filter_var($value, FILTER_VALIDATE_URL);
    }

    public function parse($value) {
        return strval($value);
    }
}<?php
/*
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This software consists of voluntary contributions made by many individuals
 * and is licensed under the MIT license. For more information, see
 * <http://www.doctrine-project.org>.
 */

namespace Doctrine\Common\Inflector;

/**
 * Doctrine inflector has static methods for inflecting text.
 *
 * The methods in these classes are from several different sources collected
 * across several different php projects and several different authors. The
 * original author names and emails are not known.
 *
 * Pluralize & Singularize implementation are borrowed from CakePHP with some modifications.
 *
 * @link   www.doctrine-project.org
 * @since  1.0
 * @author Konsta Vesterinen <kvesteri@cc.hut.fi>
 * @author Jonathan H. Wage <jonwage@gmail.com>
 */
class Inflector
{
    /**
     * Plural inflector rules.
     *
     * @var array
     */
    private static $plural = array(
        'rules' => array(
            '/(s)tatus$/i' => '\1\2tatuses',
            '/(quiz)$/i' => '\1zes',
            '/^(ox)$/i' => '\1\2en',
            '/([m|l])ouse$/i' => '\1ice',
            '/(matr|vert|ind)(ix|ex)$/i' => '\1ices',
            '/(x|ch|ss|sh)$/i' => '\1es',
            '/([^aeiouy]|qu)y$/i' => '\1ies',
            '/(hive)$/i' => '\1s',
            '/(?:([^f])fe|([lr])f)$/i' => '\1\2ves',
            '/sis$/i' => 'ses',
            '/([ti])um$/i' => '\1a',
            '/(p)erson$/i' => '\1eople',
            '/(m)an$/i' => '\1en',
            '/(c)hild$/i' => '\1hildren',
            '/(f)oot$/i' => '\1eet',
            '/(buffal|her|potat|tomat|volcan)o$/i' => '\1\2oes',
            '/(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|vir)us$/i' => '\1i',
            '/us$/i' => 'uses',
            '/(alias)$/i' => '\1es',
            '/(analys|ax|cris|test|thes)is$/i' => '\1es',
            '/s$/' => 's',
            '/^$/' => '',
            '/$/' => 's',
        ),
        'uninflected' => array(
            '.*[nrlm]ese', '.*deer', '.*fish', '.*measles', '.*ois', '.*pox', '.*sheep', 'people', 'cookie'
        ),
        'irregular' => array(
            'atlas' => 'atlases',
            'axe' => 'axes',
            'beef' => 'beefs',
            'brother' => 'brothers',
            'cafe' => 'cafes',
            'chateau' => 'chateaux',
            'child' => 'children',
            'cookie' => 'cookies',
            'corpus' => 'corpuses',
            'cow' => 'cows',
            'criterion' => 'criteria',
            'curriculum' => 'curricula',
            'demo' => 'demos',
            'domino' => 'dominoes',
            'echo' => 'echoes',
            'foot' => 'feet',
            'fungus' => 'fungi',
            'ganglion' => 'ganglions',
            'genie' => 'genies',
            'genus' => 'genera',
            'graffito' => 'graffiti',
            'hippopotamus' => 'hippopotami',
            'hoof' => 'hoofs',
            'human' => 'humans',
            'iris' => 'irises',
            'leaf' => 'leaves',
            'loaf' => 'loaves',
            'man' => 'men',
            'medium' => 'media',
            'memorandum' => 'memoranda',
            'money' => 'monies',
            'mongoose' => 'mongooses',
            'motto' => 'mottoes',
            'move' => 'moves',
            'mythos' => 'mythoi',
            'niche' => 'niches',
            'nucleus' => 'nuclei',
            'numen' => 'numina',
            'occiput' => 'occiputs',
            'octopus' => 'octopuses',
            'opus' => 'opuses',
            'ox' => 'oxen',
            'penis' => 'penises',
            'person' => 'people',
            'plateau' => 'plateaux',
            'runner-up' => 'runners-up',
            'sex' => 'sexes',
            'soliloquy' => 'soliloquies',
            'son-in-law' => 'sons-in-law',
            'syllabus' => 'syllabi',
            'testis' => 'testes',
            'thief' => 'thieves',
            'tooth' => 'teeth',
            'tornado' => 'tornadoes',
            'trilby' => 'trilbys',
            'turf' => 'turfs',
            'volcano' => 'volcanoes',
        )
    );

    /**
     * Singular inflector rules.
     *
     * @var array
     */
    private static $singular = array(
        'rules' => array(
            '/(s)tatuses$/i' => '\1\2tatus',
            '/^(.*)(menu)s$/i' => '\1\2',
            '/(quiz)zes$/i' => '\\1',
            '/(matr)ices$/i' => '\1ix',
            '/(vert|ind)ices$/i' => '\1ex',
            '/^(ox)en/i' => '\1',
            '/(alias)(es)*$/i' => '\1',
            '/(buffal|her|potat|tomat|volcan)oes$/i' => '\1o',
            '/(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|viri?)i$/i' => '\1us',
            '/([ftw]ax)es/i' => '\1',
            '/(analys|ax|cris|test|thes)es$/i' => '\1is',
            '/(shoe|slave)s$/i' => '\1',
            '/(o)es$/i' => '\1',
            '/ouses$/' => 'ouse',
            '/([^a])uses$/' => '\1us',
            '/([m|l])ice$/i' => '\1ouse',
            '/(x|ch|ss|sh)es$/i' => '\1',
            '/(m)ovies$/i' => '\1\2ovie',
            '/(s)eries$/i' => '\1\2eries',
            '/([^aeiouy]|qu)ies$/i' => '\1y',
            '/([lr])ves$/i' => '\1f',
            '/(tive)s$/i' => '\1',
            '/(hive)s$/i' => '\1',
            '/(drive)s$/i' => '\1',
            '/([^fo])ves$/i' => '\1fe',
            '/(^analy)ses$/i' => '\1sis',
            '/(analy|diagno|^ba|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i' => '\1\2sis',
            '/([ti])a$/i' => '\1um',
            '/(p)eople$/i' => '\1\2erson',
            '/(m)en$/i' => '\1an',
            '/(c)hildren$/i' => '\1\2hild',
            '/(f)eet$/i' => '\1oot',
            '/(n)ews$/i' => '\1\2ews',
            '/eaus$/' => 'eau',
            '/^(.*us)$/' => '\\1',
            '/s$/i' => '',
        ),
        'uninflected' => array(
            '.*[nrlm]ese',
            '.*deer',
            '.*fish',
            '.*measles',
            '.*ois',
            '.*pox',
            '.*sheep',
            '.*ss',
        ),
        'irregular' => array(
            'criteria'  => 'criterion',
            'curves'    => 'curve',
            'emphases'  => 'emphasis',
            'foes'      => 'foe',
            'hoaxes'    => 'hoax',
            'media'     => 'medium',
            'neuroses'  => 'neurosis',
            'waves'     => 'wave',
            'oases'     => 'oasis',
        )
    );

    /**
     * Words that should not be inflected.
     *
     * @var array
     */
    private static $uninflected = array(
        'Amoyese', 'bison', 'Borghese', 'bream', 'breeches', 'britches', 'buffalo', 'cantus',
        'carp', 'chassis', 'clippers', 'cod', 'coitus', 'Congoese', 'contretemps', 'corps',
        'debris', 'diabetes', 'djinn', 'eland', 'elk', 'equipment', 'Faroese', 'flounder',
        'Foochowese', 'gallows', 'Genevese', 'Genoese', 'Gilbertese', 'graffiti',
        'headquarters', 'herpes', 'hijinks', 'Hottentotese', 'information', 'innings',
        'jackanapes', 'Kiplingese', 'Kongoese', 'Lucchese', 'mackerel', 'Maltese', '.*?media',
        'mews', 'moose', 'mumps', 'Nankingese', 'news', 'nexus', 'Niasese',
        'Pekingese', 'Piedmontese', 'pincers', 'Pistoiese', 'pliers', 'Portuguese',
        'proceedings', 'rabies', 'rice', 'rhinoceros', 'salmon', 'Sarawakese', 'scissors',
        'sea[- ]bass', 'series', 'Shavese', 'shears', 'siemens', 'species', 'staff', 'swine',
        'testes', 'trousers', 'trout', 'tuna', 'Vermontese', 'Wenchowese', 'whiting',
        'wildebeest', 'Yengeese'
    );

    /**
     * Method cache array.
     *
     * @var array
     */
    private static $cache = array();

    /**
     * The initial state of Inflector so reset() works.
     *
     * @var array
     */
    private static $initialState = array();

    /**
     * Converts a word into the format for a Doctrine table name. Converts 'ModelName' to 'model_name'.
     *
     * @param string $word The word to tableize.
     *
     * @return string The tableized word.
     */
    public static function tableize($word)
    {
        return strtolower(preg_replace('~(?<=\\w)([A-Z])~', '_$1', $word));
    }

    /**
     * Converts a word into the format for a Doctrine class name. Converts 'table_name' to 'TableName'.
     *
     * @param string $word The word to classify.
     *
     * @return string The classified word.
     */
    public static function classify($word)
    {
        return str_replace(" ", "", ucwords(strtr($word, "_-", "  ")));
    }

    /**
     * Camelizes a word. This uses the classify() method and turns the first character to lowercase.
     *
     * @param string $word The word to camelize.
     *
     * @return string The camelized word.
     */
    public static function camelize($word)
    {
        return lcfirst(self::classify($word));
    }

    /**
     * Uppercases words with configurable delimeters between words.
     *
     * Takes a string and capitalizes all of the words, like PHP's built-in
     * ucwords function.  This extends that behavior, however, by allowing the
     * word delimeters to be configured, rather than only separating on
     * whitespace.
     *
     * Here is an example:
     * <code>
     * <?php
     * $string = 'top-o-the-morning to all_of_you!';
     * echo \Doctrine\Common\Inflector\Inflector::ucwords($string);
     * // Top-O-The-Morning To All_of_you!
     *
     * echo \Doctrine\Common\Inflector\Inflector::ucwords($string, '-_ ');
     * // Top-O-The-Morning To All_Of_You!
     * ?>
     * </code>
     *
     * @param string $string The string to operate on.
     * @param string $delimiters A list of word separators.
     *
     * @return string The string with all delimeter-separated words capitalized.
     */
    public static function ucwords($string, $delimiters = " \n\t\r\0\x0B-")
    {
        return preg_replace_callback(
            '/[^' . preg_quote($delimiters, '/') . ']+/',
            function($matches) {
                return ucfirst($matches[0]);
            },
            $string
        );
    }

    /**
     * Clears Inflectors inflected value caches, and resets the inflection
     * rules to the initial values.
     *
     * @return void
     */
    public static function reset()
    {
        if (empty(self::$initialState)) {
            self::$initialState = get_class_vars('Inflector');

            return;
        }

        foreach (self::$initialState as $key => $val) {
            if ($key != 'initialState') {
                self::${$key} = $val;
            }
        }
    }

    /**
     * Adds custom inflection $rules, of either 'plural' or 'singular' $type.
     *
     * ### Usage:
     *
     * {{{
     * Inflector::rules('plural', array('/^(inflect)or$/i' => '\1ables'));
     * Inflector::rules('plural', array(
     *     'rules' => array('/^(inflect)ors$/i' => '\1ables'),
     *     'uninflected' => array('dontinflectme'),
     *     'irregular' => array('red' => 'redlings')
     * ));
     * }}}
     *
     * @param string  $type  The type of inflection, either 'plural' or 'singular'
     * @param array   $rules An array of rules to be added.
     * @param boolean $reset If true, will unset default inflections for all
     *                       new rules that are being defined in $rules.
     *
     * @return void
     */
    public static function rules($type, $rules, $reset = false)
    {
        foreach ($rules as $rule => $pattern) {
            if ( ! is_array($pattern)) {
                continue;
            }

            if ($reset) {
                self::${$type}[$rule] = $pattern;
            } else {
                self::${$type}[$rule] = ($rule === 'uninflected')
                    ? array_merge($pattern, self::${$type}[$rule])
                    : $pattern + self::${$type}[$rule];
            }

            unset($rules[$rule], self::${$type}['cache' . ucfirst($rule)]);

            if (isset(self::${$type}['merged'][$rule])) {
                unset(self::${$type}['merged'][$rule]);
            }

            if ($type === 'plural') {
                self::$cache['pluralize'] = self::$cache['tableize'] = array();
            } elseif ($type === 'singular') {
                self::$cache['singularize'] = array();
            }
        }

        self::${$type}['rules'] = $rules + self::${$type}['rules'];
    }

    /**
     * Returns a word in plural form.
     *
     * @param string $word The word in singular form.
     *
     * @return string The word in plural form.
     */
    public static function pluralize($word)
    {
        if (isset(self::$cache['pluralize'][$word])) {
            return self::$cache['pluralize'][$word];
        }

        if (!isset(self::$plural['merged']['irregular'])) {
            self::$plural['merged']['irregular'] = self::$plural['irregular'];
        }

        if (!isset(self::$plural['merged']['uninflected'])) {
            self::$plural['merged']['uninflected'] = array_merge(self::$plural['uninflected'], self::$uninflected);
        }

        if (!isset(self::$plural['cacheUninflected']) || !isset(self::$plural['cacheIrregular'])) {
            self::$plural['cacheUninflected'] = '(?:' . implode('|', self::$plural['merged']['uninflected']) . ')';
            self::$plural['cacheIrregular']   = '(?:' . implode('|', array_keys(self::$plural['merged']['irregular'])) . ')';
        }

        if (preg_match('/(.*)\\b(' . self::$plural['cacheIrregular'] . ')$/i', $word, $regs)) {
            self::$cache['pluralize'][$word] = $regs[1] . substr($word, 0, 1) . substr(self::$plural['merged']['irregular'][strtolower($regs[2])], 1);
            
            return self::$cache['pluralize'][$word];
        }

        if (preg_match('/^(' . self::$plural['cacheUninflected'] . ')$/i', $word, $regs)) {
            self::$cache['pluralize'][$word] = $word;

            return $word;
        }

        foreach (self::$plural['rules'] as $rule => $replacement) {
            if (preg_match($rule, $word)) {
                self::$cache['pluralize'][$word] = preg_replace($rule, $replacement, $word);

                return self::$cache['pluralize'][$word];
            }
        }
    }

    /**
     * Returns a word in singular form.
     *
     * @param string $word The word in plural form.
     *
     * @return string The word in singular form.
     */
    public static function singularize($word)
    {
        if (isset(self::$cache['singularize'][$word])) {
            return self::$cache['singularize'][$word];
        }

        if (!isset(self::$singular['merged']['uninflected'])) {
            self::$singular['merged']['uninflected'] = array_merge(
                self::$singular['uninflected'],
                self::$uninflected
            );
        }

        if (!isset(self::$singular['merged']['irregular'])) {
            self::$singular['merged']['irregular'] = array_merge(
                self::$singular['irregular'],
                array_flip(self::$plural['irregular'])
            );
        }

        if (!isset(self::$singular['cacheUninflected']) || !isset(self::$singular['cacheIrregular'])) {
            self::$singular['cacheUninflected'] = '(?:' . join('|', self::$singular['merged']['uninflected']) . ')';
            self::$singular['cacheIrregular'] = '(?:' . join('|', array_keys(self::$singular['merged']['irregular'])) . ')';
        }

        if (preg_match('/(.*)\\b(' . self::$singular['cacheIrregular'] . ')$/i', $word, $regs)) {
            self::$cache['singularize'][$word] = $regs[1] . substr($word, 0, 1) . substr(self::$singular['merged']['irregular'][strtolower($regs[2])], 1);
            
            return self::$cache['singularize'][$word];
        }

        if (preg_match('/^(' . self::$singular['cacheUninflected'] . ')$/i', $word, $regs)) {
            self::$cache['singularize'][$word] = $word;

            return $word;
        }

        foreach (self::$singular['rules'] as $rule => $replacement) {
            if (preg_match($rule, $word)) {
                self::$cache['singularize'][$word] = preg_replace($rule, $replacement, $word);

                return self::$cache['singularize'][$word];
            }
        }

        self::$cache['singularize'][$word] = $word;

        return $word;
    }
}
<?php
namespace CodeGen;

trait Annotator
{

    /**
     * @var Comment|CommentBlock
     */
    public $comment;

    public function annotate($comment)
    {
        $lines = explode("\n", $comment);
        if (count($lines) === 0) {
            return;
        }
        if (count($lines) == 1) {
            $this->comment = new Comment($comment);
        } else {
            $this->comment = new CommentBlock($comment);
        }
    }

    public function renderAnnotate(array $args = array())
    {
        return $this->comment->render($args) . "\n";
    }

}



<?php
namespace CodeGen;

/**
 * Method/Function argument
 */
class Argument implements Renderable
{
    protected $name;

    protected $default;

    public function __construct($name, $default = NULL)
    {
        $this->name = $name;
        $this->default = $default;
    }

    public function getName()
    {
        return $this->name;
    }

    public function getDefault()
    {
        return $this->default;
    }

    public function render(array $args = array())
    {
        $code = $this->name;
        if ($this->default) {
            $code .= ' = ' . VariableDeflator::deflate($this->default);
        }
        return $code;
    }

}




<?php
namespace CodeGen;

use ArrayAccess;
use ArrayIterator;
use IteratorAggregate;

/**
 * Argument list for function call
 */
class ArgumentList implements Renderable, ArrayAccess, IteratorAggregate
{
    protected $arguments;

    public function __construct(array $arguments = array())
    {
        $this->arguments = $arguments;
    }

    public function setArguments(array $args)
    {
        $this->arguments = $args;
    }

    public function add($arg)
    {
        $this->arguments[] = $arg;
        return $this;
    }


    public function offsetExists($offset)
    {
        return isset($this->arguments[$offset]);
    }

    public function offsetGet($offset)
    {
        return $this->arguments[$offset];
    }

    public function offsetUnset($offset)
    {
        unset($this->arguments[$offset]);
    }

    public function offsetSet($offset, $value)
    {
        if ($offset) {
            $this->arguments[$offset] = $value;
        } else {
            $this->arguments[] = $value;
        }
    }

    public function getIterator()
    {
        return new ArrayIterator($this->arguments);
    }

    public function render(array $args = array())
    {
        $strs = array();
        foreach ($this->arguments as $arg) {
            $strs[] = VariableDeflator::deflate($arg);
        }
        return implode(', ', $strs);
    }
}

<?php
namespace CodeGen;

use ArrayAccess;
use ArrayIterator;
use CodeGen\Exception\InvalidArgumentTypeException;
use IteratorAggregate;


/**
 * A block class can generate multiple-linke block code.
 *
 * It uses line-based unit to generate code, however the added
 * element doesn't have to be string, it can be anything
 * stringify-able objects (support __toString() method) or
 * implemented with Renderable interface.
 */
class Block implements IteratorAggregate, ArrayAccess, Renderable
{
    public $lines = array();

    public $args = array();

    public function __construct(array $lines = array())
    {
        $this->lines = $lines;
    }

    /**
     * The default indent level.
     */
    public $indentLevel = 0;

    public function setDefaultArguments(array $args)
    {
        $this->args = $args;
        return $this;
    }

    public function setLines(array $lines)
    {
        $this->lines = $lines;
        return $this;
    }

    /**
     * Allow text can be set with array
     */
    public function setBody($text)
    {
        if (is_string($text)) {
            $this->lines = explode("\n", $text);
        } elseif (is_array($text)) {
            $this->lines = $text;
        } else {
            throw new InvalidArgumentTypeException('Invalid body type', $text, array('string', 'array'));
        }
    }

    public function appendRenderable(Renderable $obj)
    {
        $this->lines[] = $obj;
    }

    public function appendLine($line)
    {
        $this->lines[] = $line;
    }

    public function increaseIndentLevel()
    {
        $this->indentLevel++;
        return $this;
    }

    public function decreaseIndentLevel()
    {
        $this->indentLevel--;
        return $this;
    }

    public function indent()
    {
        $this->indentLevel++;
    }

    public function unindent()
    {
        $this->indentLevel--;
    }

    public function splice($from, $length, array $replacement = array())
    {
        return array_splice($this->lines, $from, $length, $replacement);
    }


    public function setIndentLevel($indent)
    {
        $this->indentLevel = $indent;
    }

    public function render(array $args = array())
    {
        $tab = Indenter::indent($this->indentLevel);
        $body = '';
        foreach ($this->lines as $line) {
            if (is_string($line)) {
                $body .= $tab . $line . "\n";
            } else if ($line instanceof Renderable) {
                $subbody = rtrim($line->render()); // trim the trailing white-space
                $sublines = explode("\n", $subbody);
                foreach ($sublines as $subline) {
                    $body .= $tab . $subline . "\n";
                }
            } else {
                //var_dump( $line );
                throw new InvalidArgumentTypeException('Unsupported line object type', $line, array('string', 'Renderable'));
            }
        }
        return Utils::renderStringTemplate($body, array_merge($this->args, $args));
    }

    // ============ interface ArrayAggregator implementation =============
    public function getIterator()
    {
        return new ArrayIterator($this->lines);
    }

    // ============ interface ArrayAccess implementation =============
    public function offsetSet($key, $value)
    {
        if ($key) {
            $this->lines[$key] = $value;
        } else {
            $this->lines[] = $value;
        }
    }

    public function offsetExists($key)
    {
        return isset($this->lines[$key]);
    }

    public function offsetGet($key)
    {
        return $this->lines[$key];
    }

    public function offsetUnset($key)
    {
        unset($this->lines[$key]);
    }


}




<?php
namespace CodeGen;

/**
 * A BracketedBlock is a block that uses bracket to wrap the inner block.
 */
class BracketedBlock extends Block
{
    public function render(array $args = array())
    {
        $tab = Indenter::indent($this->indentLevel);
        $this->increaseIndentLevel(); // increaseIndentLevel to indent the inner block.
        $body = '';
        $body .= $tab . "{\n";
        $body .= parent::render($args);
        $body .= $tab . "}\n";
        return $body;
    }

}




<?php
namespace CodeGen;

use CodeGen\Statement\Statement;

class ClassConst extends Statement implements Renderable
{
    /**
     * @var Renderable|string
     */
    public $name;

    public $value;

    public function __construct($name, $value)
    {
        $this->name = $name;
        $this->value = $value;
    }

    public function render(array $args = array())
    {
        return Indenter::indent($this->indentLevel) . 'const ' . $this->name . ' = ' . var_export($this->value, true) . ';';
    }

    public function __toString()
    {
        return $this->render();
    }

}

<?php
namespace CodeGen;

use ArrayAccess;

class ClassMethod extends UserFunction implements Renderable, ArrayAccess
{
    public $scope = 'public';

    public function setScope($scope)
    {
        $this->scope = $scope;
    }

    /**
     * @param array $args
     * @return string
     */
    public function render(array $args = array())
    {
        $block = $this->getBlock();
        $block->setIndentLevel($this->indentLevel);
        return Indenter::indent($this->indentLevel) . $this->scope . ' function ' . $this->name . '(' . $this->renderArguments() . ")\n"
        . $block->render($args);
    }

    public function __toString()
    {
        return $this->render();
    }

    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->block[] = $value;
        } else {
            $this->block[$offset] = $value;
        }
    }

    public function offsetExists($offset)
    {
        return isset($this->block[$offset]);
    }

    public function offsetGet($offset)
    {
        return $this->block[$offset];
    }

    public function offsetUnset($offset)
    {
        unset($this->block[$offset]);
    }


}

<?php
namespace CodeGen;

class ClassName implements Renderable
{
    public $name;

    public $namespace;

    public $root = false;

    public function __construct($className)
    {
        if ($className[0] === '\\') {
            $this->root = true;
            $className = substr($className, 1);
        }

        // parse namespace
        if (strpos($className, '\\') !== false) {
            $p = explode('\\', ltrim($className, '\\'));
            $this->name = end($p);
            $this->namespace = implode('\\', array_splice($p, 0, count($p) - 1));
        } else {
            $this->name = $className;
        }
    }


    /**
     * @return string return short class name
     */
    public function getName()
    {
        return $this->name;
    }


    public function setNamespace($ns)
    {
        $this->namespace = $ns;
        return $this;
    }

    /**
     * This method followe ReflectionClass's interface.
     *
     * @return boolean return true if the class name is in namespace.
     */
    public function inNamespace()
    {
        return $this->namespace ? true : false;
    }

    /**
     * This method followe ReflectionClass's interface
     *
     * @return string return namespace name
     */
    public function getNamespaceName()
    {
        return $this->namespace;
    }


    public function getFullName()
    {
        if ($this->namespace) {
            return ($this->root ? '\\' : '') . $this->namespace . '\\' . $this->name;
        } else {
            return ($this->root ? '\\' : '') . $this->name;
        }
    }

    public function render(array $args = array())
    {
        return $this->getFullName();
    }

    public function __toString()
    {
        return $this->render();
    }
}

<?php
namespace CodeGen;

use CodeGen\Statement\Statement;

class ClassProperty extends Statement implements Renderable
{
    public $name;
    public $scope = 'public';
    public $value;

    public function __construct($name, $value, $scope = 'public')
    {
        $this->name = $name;
        $this->value = $value;
        $this->scope = $scope;
    }


    public function render(array $args = array())
    {
        $code = Indenter::indent($this->indentLevel) . $this->scope . ' $' . $this->name;
        if ($this->value) {
            $code .= ' = ' . var_export($this->value, true);
        }
        return $code . ';';
    }

    public function __toString()
    {
        return $this->render();
    }


}

<?php
namespace CodeGen;

class ClassStaticVariable extends ClassProperty implements Renderable
{
    /**
     * @param array $args
     * @return string
     */
    public function render(array $args = array())
    {
        return Indenter::indent($this->indentLevel) . $this->scope . ' static $' . $this->name . ' = ' . var_export($this->value, true) . ';';
    }

    public function __toString()
    {
        return $this->render();
    }
}

<?php
namespace CodeGen;

use CodeGen\Statement\Statement;

/**
 * use HelloWorld { sayHello as private myPrivateHello; }
 * use HelloWorld { sayHello as protected; }
 *
 * use A, B {
 *      B::smallTalk insteadof A;
 *      A::bigTalk insteadof B;
 * }
 *
 * class Aliased_Talker {
 *    use A, B {
 *      B::smallTalk insteadof A;
 *      A::bigTalk insteadof B;
 *      B::bigTalk as talk;
 *    }
 * }
 */
class ClassTrait extends Statement implements Renderable
{
    public $classes = array();

    public $definitions = array();

    public function __construct(array $classes)
    {
        $this->classes = $classes;
    }

    public function useInsteadOf($aMethod, $b)
    {
        $this->definitions[] = "$aMethod insteadof $b;";
        return $this;
    }

    public function useAs($aMethod, $methodB)
    {
        $this->definitions[] = "$aMethod as $methodB;";
        return $this;
    }

    public function render(array $args = array())
    {
        $out = Indenter::indent($this->indentLevel) . 'use ' . implode(', ', $this->classes);
        if (0 === count($this->definitions)) {
            $out .= ';';
        } else {
            $block = new BracketedBlock;
            foreach ($this->definitions as $def) {
                $block[] = $def;
            }
            $out .= $block->render($args);
        }
        return $out;
    }
}



<?php
namespace CodeGen;

use CodeGen\Exception\InvalidArgumentTypeException;

class Comment extends Line implements Renderable
{
    public $comment;

    public function __construct($comment)
    {
        $this->comment = $comment;
    }

    public function render(array $args = array())
    {
        $tab = Indenter::indent($this->indentLevel);
        $out = $tab . '// ';
        if (is_string($this->comment)) {
            $out .= $this->comment;
        } else if ($this->comment instanceof Renderable) {
            $out .= $this->comment->render($args);
        } else {
            throw new InvalidArgumentTypeException('Invalid type for comment.', $this->comment, ['string', 'Renderable']);
        }
        return $out;
    }

}




<?php
namespace CodeGen;

use Exception;

class CommentBlock extends Block implements Renderable
{
    public function render(array $args = array())
    {
        $tab = Indenter::indent($this->indentLevel);
        $body = '';

        $body .= $tab . "/**\n";

        foreach ($this->lines as $line) {
            if (is_string($line)) {
                $body .= $tab . ' * ' . $line . "\n";
            } else if ($line instanceof Renderable) {
                $subbody = rtrim($line->render()); // trim the trailing white-space
                $sublines = explode("\n", $subbody);
                foreach ($sublines as $subline) {
                    $body .= $tab . ' * ' . $subline . "\n";
                }
            } else {
                throw new Exception('Unsupported line object.');
            }
        }
        $body .= " */\n";
        return Utils::renderStringTemplate($body, array_merge($this->args, $args));
    }

}




<?php
namespace CodeGen;

class Constant implements Renderable
{
    protected $val;

    public function __construct($val)
    {
        $this->val = $val;
    }

    public function render(array $args = array())
    {
        if (is_scalar($this->val)) {
            return var_export($this->val, true);
        }
        return $this->val;
    }
}





<?php
namespace CodeGen\Exception;

use InvalidArgumentException;

class InvalidArgumentTypeException extends InvalidArgumentException
{
    public $expectingTypes = array();

    public $givenType;

    public function __construct($message, $givenVariable, array $expectingTypes = array())
    {
        parent::__construct($message);
        if (is_object($givenVariable)) {
            $this->givenType = get_class($givenVariable);
        } else {
            $this->givenType = gettype($givenVariable);
        }
        $this->expectingTypes = $expectingTypes;
    }
}



<?php
namespace CodeGen;

interface Exportable
{
    public function __get_state();
}




<?php
namespace CodeGen\Expr;

use CodeGen\Renderable;
use CodeGen\VariableDeflator;

class AssignExpr implements Renderable
{

    protected $lvalue;

    protected $expr;

    public function __construct($lvalue, $expr)
    {
        $this->lvalue = $lvalue;
        $this->expr = $expr;
    }


    public function render(array $args = array())
    {
        return VariableDeflator::deflate($this->lvalue) . ' = ' . VariableDeflator::deflate($this->expr);
    }

}




<?php
namespace CodeGen\Expr;

use CodeGen\ArgumentList;
use CodeGen\Renderable;
use CodeGen\Variable;

/**
 * CallExpr is basically the same thing as method call,
 * but it allows you to change the method call operator.
 */
class CallExpr implements Renderable
{
    /**
     * @var Variable|string
     */
    public $objectName;

    public $method;

    public $arguments;

    protected $op;

    public function __construct($objectName = null, $op = '->', $method, array $arguments = array())
    {
        $this->objectName = $objectName;
        $this->op = $op;
        $this->method = $method;
        $this->arguments = new ArgumentList($arguments);
    }

    public function method($method)
    {
        $this->method = $method;
        return $this;
    }

    public function op($op)
    {
        $this->op = $op;
        return $this;
    }

    public function setArguments(array $args)
    {
        $this->arguments = new ArgumentList($args);
    }

    public function addArgument($arg)
    {
        $this->arguments[] = $arg;
        return $this;
    }

    public function render(array $args = array())
    {
        $out = '';
        if ($this->objectName) {
            if ($this->objectName instanceof Renderable) {
                $out .= $this->objectName->render($args);
            } else {
                $out .= $this->objectName;
            }
            $out .= $this->op;
        }
        $out .= $this->method . '(' . $this->arguments->render($args) . ')';
        return $out;
    }

    public function __toString()
    {
        return $this->render();
    }

}



<?php
namespace CodeGen\Expr;

use CodeGen\ArgumentList;
use CodeGen\Renderable;
use CodeGen\Variable;

/**
 * CallExpr is basically the same thing as method call,
 * but it allows you to change the method call operator.
 */
class FunctionCall implements Renderable
{
    /**
     * @var Variable|string
     */
    public $function;

    public $arguments;

    public function __construct($function, array $arguments = array())
    {
        $this->function = $function;
        $this->arguments = new ArgumentList($arguments);
    }

    public function setArguments(array $args)
    {
        $this->arguments = new ArgumentList($args);
    }

    public function addArgument($arg)
    {
        $this->arguments[] = $arg;
        return $this;
    }

    public function render(array $args = array())
    {
        return $this->function . '(' . $this->arguments->render($args) . ')';
    }

    public function __toString()
    {
        return $this->render();
    }

}



<?php
namespace CodeGen\Expr;

use CodeGen\ArgumentList;
use CodeGen\Renderable;
use CodeGen\Variable;

class MethodCall implements Renderable
{
    /**
     * @var Variable|string
     */
    public $objectName;

    public $method;

    public $arguments;

    protected $op = '->';

    public function __construct($objectName = '$this', $method = NULL, array $arguments = array())
    {
        $this->objectName = $objectName;
        if ($method) {
            $this->method = $method;
        }
        $this->arguments = new ArgumentList($arguments);
    }

    public function method($name)
    {
        $this->method = $name;
        return $this;
    }

    public function setArguments(array $args)
    {
        $this->arguments = new ArgumentList($args);
    }

    public function addArgument($arg)
    {
        $this->arguments[] = $arg;
        return $this;
    }

    public function render(array $args = array())
    {
        $out = '';

        if ($this->objectName instanceof Renderable) {
            $out .= $this->objectName->render($args);
        } else {
            $out .= $this->objectName;
        }
        $out .= $this->op . $this->method . '(' . $this->arguments->render($args) . ')';
        return $out;
    }

    public function __toString()
    {
        return $this->render();
    }

}



<?php
namespace CodeGen\Expr;
/**
 * Deprecated. shouldn't be used.
 */
class MethodCallExpr extends MethodCall
{
}




<?php
namespace CodeGen\Expr;

use CodeGen\ArgumentList;
use CodeGen\Renderable;

class NewObject implements Renderable
{
    public $className;

    public $arguments;

    public function __construct($className, array $arguments = array())
    {
        $this->className = $className;
        $this->arguments = new ArgumentList($arguments);
    }

    public function setArguments(array $args)
    {
        $this->arguments = new ArgumentList($args);
    }

    public function addArgument($arg)
    {
        $this->arguments[] = $arg;
        return $this;
    }

    public function render(array $args = array())
    {
        return 'new ' . $this->className . '(' . $this->arguments->render($args) . ')';
    }

    public function __toString()
    {
        return $this->render();
    }

}



<?php
namespace CodeGen\Expr;

class NewObjectExpr extends NewObject
{
}

<?php
namespace CodeGen\Expr;

use CodeGen\Renderable;
use CodeGen\Variable;

class ObjectProperty implements Renderable
{
    /**
     * @var Variable|string
     */
    public $objectName;
    public $property;


    protected $op = '->';

    public function __construct($objectName, $property)
    {
        $this->objectName = $objectName;
        $this->property = $property;
    }

    public function render(array $args = array())
    {
        $out = '';

        if ($this->objectName instanceof Renderable) {
            $out .= $this->objectName->render($args);
        } else {
            $out .= $this->objectName;
        }
        $out .= $this->op . $this->property;
        return $out;
    }

    public function __toString()
    {
        return $this->render();
    }

}



<?php
namespace CodeGen\Expr;

/**
 * This is a shorthand class for generating $this->foo( ... );
 */
class SelfMethodCall extends MethodCall
{
    public function __construct($method = NULL, array $arguments = array())
    {
        parent::__construct('$this', $method, $arguments);
    }
}

<?php
namespace CodeGen\Expr;

/**
 * Deprecated.
 */
class SelfMethodCallExpr extends SelfMethodCall
{
}

<?php
namespace CodeGen\Expr;

use CodeGen\ArgumentList;
use CodeGen\Renderable;

class StaticMethodCall implements Renderable
{
    public $className;

    public $method;

    public $arguments;

    public function __construct($className, $method = NULL, array $arguments = array())
    {
        $this->className = $className;
        if ($method) {
            $this->method = $method;
        }
        $this->arguments = new ArgumentList($arguments);
    }

    public function method($name)
    {
        $this->method = $name;
        return $this;
    }

    public function setArguments(array $args)
    {
        $this->arguments = new ArgumentList($args);
    }

    public function addArgument($arg)
    {
        $this->arguments[] = $arg;
        return $this;
    }

    public function render(array $args = array())
    {
        return $this->className . '::' . $this->method . '(' . $this->arguments->render($args) . ')';
    }

    public function __toString()
    {
        return $this->render();
    }

}



<?php
namespace CodeGen\Frameworks\PHPUnit;

use CodeGen\Expr\SelfMethodCall;
use CodeGen\Statement\Statement;

function push_if($array, $element)
{
    if ($element) {
        $array[] = $element;
    }
    return $array;
}

class Assertions
{
    static public function assertEquals($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertEquals', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertRegExp($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertRegExp', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertStringMatchesFormat($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertStringMatchesFormat', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertStringMatchesFormatFile($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertStringMatchesFormatFile', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertStringEqualsFile($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertStringEqualsFile', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertStringStartsWith($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertStringStartsWith', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertStringEndsWith($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertStringEndsWith', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }


    static public function assertSame($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertSame', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertNull($actual, $message = '')
    {
        $expr = new SelfMethodCall('assertNull', push_if(array($actual), $message));
        return new Statement($expr);
    }

    static public function assertNotEmpty($actual, $message = '')
    {
        $expr = new SelfMethodCall('assertNotEmpty', push_if(array($actual), $message));
        return new Statement($expr);
    }

    static public function assertEmpty($actual, $message = '')
    {
        $expr = new SelfMethodCall('assertEmpty', push_if(array($actual), $message));
        return new Statement($expr);
    }

    static public function assertArrayHasKey($key, array $array, $message = '')
    {
        $expr = new SelfMethodCall('assertArrayHasKey', push_if(array($key, $array), $message));
        return new Statement($expr);
    }

    static public function assertClassHasAttribute($attribute, $class, $message = '')
    {
        $expr = new SelfMethodCall('assertClassHasAttribute', push_if(array($attribute, $class), $message));
        return new Statement($expr);
    }

    static public function assertClassHasStaticAttribute($attribute, $class, $message = '')
    {
        $expr = new SelfMethodCall('assertClassHasStaticAttribute', push_if(array($attribute, $class), $message));
        return new Statement($expr);
    }

    static public function assertContains($element, $array, $message = '')
    {
        $expr = new SelfMethodCall('assertContains', push_if(array($element, $array), $message));
        return new Statement($expr);
    }

    static public function assertContainsOnly($element, $array, $message = '')
    {
        $expr = new SelfMethodCall('assertContainsOnly', push_if(array($element, $array), $message));
        return new Statement($expr);
    }

    static public function assertCount($count, $array, $message = '')
    {
        $expr = new SelfMethodCall('assertCount', push_if(array($count, $array), $message));
        return new Statement($expr);
    }

    static public function assertTrue($val, $message = '')
    {
        $expr = new SelfMethodCall('assertTrue', push_if(array($val), $message));
        return new Statement($expr);
    }

    static public function assertFalse($val, $message = '')
    {
        $expr = new SelfMethodCall('assertFalse', push_if(array($val), $message));
        return new Statement($expr);
    }

    static public function assertFileEquals($fileExpected, $fileActual, $message = '')
    {
        $expr = new SelfMethodCall('assertFileEquals', push_if(array($fileExpected, $fileActual), $message));
        return new Statement($expr);
    }

    static public function assertJsonFileEqualsJsonFile($fileExpected, $fileActual, $message = '')
    {
        $expr = new SelfMethodCall('assertJsonFileEqualsJsonFile', push_if(array($fileExpected, $fileActual), $message));
        return new Statement($expr);
    }

    static public function assertFileExists($fileActual, $message = '')
    {
        $expr = new SelfMethodCall('assertFileExists', push_if(array($fileActual), $message));
        return new Statement($expr);
    }

    static public function assertGreaterThan($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertGreaterThan', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertGreaterThanOrEqual($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertGreaterThanOrEqual', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertLessThan($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertLessThan', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertLessThanOrEqual($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertLessThanOrEqual', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }


    static public function assertInstanceOf($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertInstanceOf', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

    static public function assertInternalType($expected, $actual, $message = '')
    {
        $expr = new SelfMethodCall('assertInternalType', push_if(array($expected, $actual), $message));
        return new Statement($expr);
    }

}



<?php
namespace CodeGen\Frameworks\PHPUnit;

use CodeGen\ClassMethod;
use CodeGen\UserClass;
use Doctrine\Common\Inflector\Inflector;

class PHPUnitFrameworkTestCase extends UserClass
{
    public function __construct($title)
    {
        $class = Inflector::classify(preg_replace('/\W+/', ' ', $title));
        parent::__construct($class);
        $this->extendClass('\PHPUnit\Framework\TestCase', true);
    }

    public function addTest($testName)
    {
        $methodName = 'test' . Inflector::classify($testName);
        $testMethod = new ClassMethod($methodName, array(), array());
        $testMethod->setScope('public');
        $this->methods[] = $testMethod;
        return $testMethod;
    }
}




<?php
namespace CodeGen\Generator;

use CodeGen\UserClass;
use ReflectionObject;
use ReflectionProperty;

/**
 * Generate UserClass for applciation based on the runtime object.
 */
class AppClassGenerator
{
    protected $options = array();

    public function __construct(array $options = array())
    {
        $this->options = array_merge(array(
            'namespace' => null,
            'prefix' => 'App',
            'reflection_property_filter' => ReflectionProperty::IS_PUBLIC | ReflectionProperty::IS_PROTECTED,
            'property_filter' => null,
        ), $options);
    }


    protected function isValueExportable($value)
    {
        return is_array($value) || is_scalar($value) || is_null($value);
    }


    public function generate($object, UserClass $userClass = null)
    {
        $reflObject = new ReflectionObject($object);

        if (!$userClass) {
            $className = $this->options['prefix'] . $reflObject->getShortName();
            if (!$this->options['namespace'] && $reflObject->inNamespace()) {
                $namespace = $reflObject->getNamespaceName();
                $className = '\\' . $namespace . '\\' . $className;
            } else {
                $className = $this->options['namespace'] . '\\' . $className;
            }
            $userClass = new UserClass($className);
            $userClass->extendClass('\\' . $reflObject->getName(), false);
        }

        $properties = $reflObject->getProperties($this->options['reflection_property_filter']);
        $propertyFilter = $this->options['property_filter'];
        foreach ($properties as $reflProperty) {
            $reflProperty->setAccessible(true);

            if ($propertyFilter && !$propertyFilter($reflProperty)) {
                continue;
            }

            $propertyName = $reflProperty->getName();
            $propertyValue = $reflProperty->getValue($object);


            // check if the property value is exportable
            // $propertyValue
            if (!$this->isValueExportable($propertyValue)) {
                continue;
            }

            if ($reflProperty->isPublic()) {
                $userClass->addPublicProperty($propertyName, $propertyValue);
            } else if ($reflProperty->isProtected()) {
                $userClass->addProtectedProperty($propertyName, $propertyValue);
            }
            // $appClass->addPublicProperty('files', $this->files);
        }
        return $userClass;
    }
}




<?php
namespace CodeGen\Generator;

use CodeGen\UserClass;


/**
 * Unfinished
 */
class ArrayAccessGenerator
{
    public function __construct()
    {

    }

    /*
    abstract public boolean offsetExists ( mixed $offset )
    abstract public mixed offsetGet ( mixed $offset )
    abstract public void offsetSet ( mixed $offset , mixed $value )
    abstract public void offsetUnset ( mixed $offset )
    */
    public function generate($arrayPropertyName, UserClass $class)
    {
        $class->implementInterface('ArrayAccess');

        // $class->addProtectedProperty
        $class->addMethod('public', 'offsetSet', array('$key', '$val'), array(
            "\$this->{$arrayPropertyName}[\$key] = \$val;"
        ));
        $class->addMethod('public', 'offsetGet', array('$key'), array(
            "return \$this->{$arrayPropertyName}[\$key];"
        ));
        $class->addMethod('public', 'offsetExists', array('$key'), array(
            "return isset(\$this->{$arrayPropertyName}[\$key]);",
        ));
        $class->addMethod('public', 'offsetUnset', array('$key'), array(
            "unsetset(\$this->{$arrayPropertyName}[\$key]);",
        ));
        return $class;
    }
}




<?php
namespace CodeGen;

class Indenter
{
    static public $expandTab = true;

    static public $spaceWidth = 4;

    /**
     * @param int $level
     * @return string
     */
    static public function indent($level = 1)
    {
        if (self::$expandTab) {
            $tab = str_repeat(' ', self::$spaceWidth);
            return str_repeat($tab, $level);
        } else {
            return str_repeat("\t", $level);
        }

    }
}




<?php
namespace CodeGen;

class LicenseBlock extends CommentBlock
{

    const GPL = 'Copyright (C) {{year}} {{holder|raw}}

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>. ';


    const MIT = 'Copyright (c) {{year}} {{holder|raw}}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
';
    const BSD3 = 'Copyright (c) {{year}}, {{holder|raw}} All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.';

    public function __construct($license, $year, $holder)
    {
        $license = strtolower($license);
        $content = '';
        switch ($license) {
            case 'gpl':
                $content = self::GPL;
                break;
            case 'mit':
                $content = self::MIT;
                break;
            case 'bsd-3':
                $content = self::BSD3;
                break;
        }
        $content = Utils::renderStringTemplate($content, array(
            'year' => $year,
            'holder' => $holder,
        ));
        parent::__construct(explode("\n", $content));
    }

}




<?php
namespace CodeGen;


/**
 * @codeCoverageIgnore
 */
abstract class Line implements Renderable
{

    public $indentLevel = 0;


    public $content;

    public function __construct($content = NULL)
    {
        $this->content = $content;
    }

    public function setIndentLevel($level)
    {
        $this->indentLevel = $level;
    }

    public function increaseIndentLevel()
    {
        $this->indentLevel++;
    }

    public function decreaseIndentLevel()
    {
        $this->indentLevel--;
    }

    public function render(array $args = array())
    {
        // XXX: apply template here
        return $this->content;
    }

    public function __toString()
    {
        return $this->render();
    }
}



<?php
namespace CodeGen;

class Raw
{
    /**
     * @var string
     */
    protected $code;

    public function __construct($code)
    {
        $this->code = $code;
    }

    public function __toString()
    {
        return (string)$this->code;
    }
}




<?php
namespace CodeGen;

interface Renderable
{
    public function render(array $args = array());
}


<?php
namespace CodeGen\Statement;

use CodeGen\Expr\AssignExpr;
use CodeGen\Renderable;

class AssignStatement extends Statement implements Renderable
{
    public function __construct($lvalue, $expr)
    {
        $this->expr = new AssignExpr($lvalue, $expr);
    }
}




<?php
namespace CodeGen\Statement;

use CodeGen\Exception\InvalidArgumentTypeException;
use CodeGen\Renderable;

class ConditionalStatement extends Statement implements Renderable
{
    protected $conditions = array();

    protected $elseBlock;

    public function __construct($expr, $then, $elseBlock = null)
    {
        $this->conditions[] = array($expr, $then);
        $this->elseBlock = $elseBlock;
    }

    public function when($expr, $then)
    {
        $this->conditions[] = array($expr, $then);
    }

    public function render(array $args = array())
    {
        foreach ($this->conditions as $condition) {
            list($expr, $code) = $condition;

            $ret = false;
            if (is_callable($expr)) {
                $ret = call_user_func($expr);
            } else if (is_bool($expr)) {
                $ret = $expr;
            } else {
                $ret = $expr ? true : false;
            }

            if ($ret) {
                if (is_callable($code)) {
                    $code = call_user_func($code);
                }

                if (is_string($code)) {
                    return $code;
                } else if ($code instanceof Renderable) {
                    return $code->render($args);
                } else {
                    throw new InvalidArgumentTypeException('Unsupported line object type', $code, array('string', 'Renderable'));
                }
            }
        }

        if ($this->elseBlock) {
            if (is_string($this->elseBlock)) {
                return $this->elseBlock;
            } else if ($this->elseBlock instanceof Renderable) {
                return $this->elseBlock->render($args);
            } else {
                throw new InvalidArgumentTypeException('Unsupported line object type', $this->elseBlock, array('string', 'Renderable'));
            }
        }
        return $ret;
    }
}





<?php
namespace CodeGen\Statement;

use CodeGen\Expr\FunctionCall;
use CodeGen\Renderable;

class DefineStatement extends Statement implements Renderable
{
    public function __construct($symbol, $value)
    {
        $this->expr = new FunctionCall('define', [$symbol, $value]);
    }

    public function render(array $args = array())
    {
        return $this->expr->render($args) . ';';
    }

}





<?php
namespace CodeGen\Statement;

use CodeGen\Renderable;

class ElseIfStatement extends IfStatement implements Renderable
{
    public function __construct(Renderable $condition, $elseifblock = NULL)
    {
        parent::__construct($condition, $elseifblock);
    }

    public function render(array $args = array())
    {
        return ' else ' . parent::render($args);
    }
}
<?php
namespace CodeGen\Statement;

use CodeGen\Block;
use CodeGen\Renderable;
use CodeGen\Utils;

class ElseStatement extends Block implements Renderable
{
    public $else;

    public function __construct($block)
    {
        $this->else = Utils::evalCallback($block);
    }

    public function render(array $args = array())
    {
        $this->else->setIndentLevel($this->indentLevel + 1);
        $this[] = ' else {';
        $this[] = $this->else;
        $this[] = '}';
        return parent::render($args);
    }
}
<?php
namespace CodeGen\Statement;

use CodeGen\Block;
use CodeGen\Renderable;
use CodeGen\Utils;

class ForEachStatement extends Block implements Renderable
{
    /**
     * @var Block
     */
    public $forEachBlock;

    protected $forVariable;
    protected $asVariable;
    protected $keyVariable;

    public function __construct($forVariable, $asVariable = '$item', $keyVariable = NULL, $forEachBlock = NULL)
    {
        parent::__construct();

        $this->forVariable = $forVariable;
        $this->asVariable = $asVariable;
        $this->keyVariable = $keyVariable;

        if ($forEachBlock) {
            $this->forEachBlock = Utils::evalCallback($forEachBlock);
        } else {
            $this->forEachBlock = new Block();
        }
    }

    public function render(array $args = array())
    {
        $this->forEachBlock->setIndentLevel($this->indentLevel + 1);

        if ($this->keyVariable) {
            $this->lines[] = 'foreach (' . $this->forVariable . ' as ' . $this->keyVariable . ' => ' . $this->asVariable . ') {';
        } else {
            $this->lines[] = 'foreach (' . $this->forVariable . ' as ' . $this->asVariable . ') {';
        }

        $this->lines[] = $this->forEachBlock;
        $this->lines[] = '}';

        return parent::render($args);
    }

}







<?php
namespace CodeGen\Statement;

use CodeGen\Expr\CallExpr;
use CodeGen\Renderable;

class FunctionCallStatement extends Statement implements Renderable
{
    public function __construct($function, array $arguments = array())
    {
        $this->expr = new CallExpr(null, null, $function, $arguments);
    }
}




<?php
namespace CodeGen\Statement;

use CodeGen\Block;
use CodeGen\Renderable;
use CodeGen\Utils;
use CodeGen\VariableDeflator;

class IfElseStatement extends IfStatement implements Renderable
{
    public $else;

    protected $elifs = array();

    public function __construct(Renderable $condition, $ifBlock = NULL, $elseBlock = NULL)
    {
        parent::__construct($condition, $ifBlock);

        if ($elseBlock) {
            $this->else = Utils::evalCallback($elseBlock);
        } else {
            $this->else = new Block;
        }
    }

    public function render(array $args = array())
    {
        $this->if->setIndentLevel($this->indentLevel + 1);
        $this->else->setIndentLevel($this->indentLevel + 1);

        $this[] = 'if (' . VariableDeflator::deflate($this->condition) . ') {';
        $this[] = $this->if;
        $this[] = '} else {';
        $this[] = $this->else;
        $this[] = '}';

        return Block::render($args);
    }
}
<?php
namespace CodeGen\Statement;

use CodeGen\Renderable;
use CodeGen\Variable;
use CodeGen\VariableDeflator;

class ArrayIssetExpr implements Renderable
{
    protected $keys;

    protected $var;

    public function __construct(Variable $var, $keys)
    {
        $this->var = $var;
        $this->keys = (array)$keys;
    }

    public function render(array $args = array())
    {
        $out = 'isset(' . $this->var->render($args);
        foreach ($this->keys as $key) {
            if ($key === null) {
                $out .= '[]';
            } else {
                $out .= '[' . VariableDeflator::deflate($key) . ']';
            }
        }
        $out .= ')';
        return $out;
    }
}


class IfIssetStatement extends IfStatement
{
    public function __construct(Variable $var, $keys, $block = NULL)
    {
        parent::__construct(new ArrayIssetExpr($var, $keys), $block);
    }
}





<?php
namespace CodeGen\Statement;

use CodeGen\Block;
use CodeGen\Renderable;
use CodeGen\Utils;
use CodeGen\VariableDeflator;

class IfStatement extends Block implements Renderable
{
    protected $condition;

    public $if;

    protected $else;

    protected $elseifs = array();

    public function __construct(Renderable $condition, $block = NULL)
    {
        $this->condition = $condition;
        if ($block) {
            $this->if = Utils::evalCallback($block);
        } else {
            $this->if = new Block;
        }
    }

    /**
     * This method was named 'elif' here because we can't use 'elseif' or 'elseIf' as the
     * method name.
     *
     * @param Expr $condition
     * @param Block $block
     */
    public function elif($condition, $block)
    {
        $this->elseifs[] = new ElseIfStatement($condition, $block);
        return $this;
    }

    public function __call($method, $args)
    {
        if ($method === 'else') {
            return $this->_else($args[0]);
        }
    }

    public function _else($block)
    {
        $this->else = new ElseStatement($block);
        return $this;
    }

    public function render(array $args = array())
    {
        $this->if->setIndentLevel($this->indentLevel + 1);
        $this[] = 'if (' . VariableDeflator::deflate($this->condition) . ') {';
        $this[] = $this->if;

        $trailingBlocks = array();
        if (!empty($this->elseifs)) {
            foreach ($this->elseifs as $elseIf) {
                $trailingBlocks[] = rtrim($elseIf->render($args));
            }
        }
        if ($this->else) {
            $trailingBlocks[] = rtrim($this->else->render($args));
        }

        $this[] = '}' . join('', $trailingBlocks);
        return parent::render($args);
    }

}







<?php
namespace CodeGen\Statement;

use CodeGen\Expr\MethodCall;
use CodeGen\Renderable;

class MethodCallStatement extends Statement implements Renderable
{
    public function __construct($objectName = '$this', $method = NULL, array $arguments = array())
    {
        $this->expr = new MethodCall($objectName, $method, $arguments);
    }
}




<?php
namespace CodeGen\Statement;

use ReflectionClass;

class RequireClassStatement extends RequireStatement
{
    public function __construct($class)
    {
        $refl = new ReflectionClass($class);
        $file = $refl->getFileName();
        $this->expr = $file;
    }
}



<?php
namespace CodeGen\Statement;

use CodeGen\Renderable;

class RequireComposerAutoloadStatement extends RequireStatement
{
    /**
     * @param array $prefixes lookup prefixes
     */
    public function __construct(array $prefixes = array())
    {
        $prefixes[] = getcwd();
        foreach ($prefixes as $prefix) {
            $path = $prefix . DIRECTORY_SEPARATOR . 'vendor/autoload.php';
            if (file_exists($path)) {
                $this->expr = $path;
                break;
            }
        }
    }

    public function render(array $args = array())
    {
        if ($this->expr instanceof Renderable) {
            return 'require ' . $this->expr->render($args) . ';';
        } else {
            return 'require ' . var_export($this->expr, true) . ';';
        }
    }

}



<?php
namespace CodeGen\Statement;

use CodeGen\Renderable;

class RequireOnceStatement extends Statement implements Renderable
{
    public function render(array $args = array())
    {
        if ($this->expr instanceof Renderable) {
            return 'require_once ' . $this->expr->render($args) . ';';
        } else {
            return 'require_once ' . var_export($this->expr, true) . ';';
        }
    }
}



<?php
namespace CodeGen\Statement;

use CodeGen\Renderable;

class RequireStatement extends Statement implements Renderable
{
    public function __construct($file)
    {
        $this->expr = $file;
    }

    public function render(array $args = array())
    {
        if ($this->expr instanceof Renderable) {
            return 'require ' . $this->expr->render($args) . ';';
        } else {
            return 'require ' . var_export($this->expr, true) . ';';
        }
    }

}



<?php
namespace CodeGen\Statement;

use CodeGen\Line;
use CodeGen\Renderable;

class Statement extends Line implements Renderable
{
    /**
     * @var Renderable
     */
    public $expr;

    public function __construct(Renderable $expr)
    {
        $this->expr = $expr;
    }

    /**
     * @param array $args
     * @return string
     */
    public function render(array $args = array())
    {
        return $this->expr->render($args) . ';';
    }

}



<?php
namespace CodeGen\Statement;

use CodeGen\Block;
use CodeGen\Renderable;
use CodeGen\Utils;

class TryCatchStatement extends Block implements Renderable
{
    /**
     * @var Block
     */
    public $tryBlock;
    /**
     * @var Block
     */
    public $catchBlock;
    /**
     * @var string
     */
    protected $catchClass;
    /**
     * @var string
     */
    protected $catchClassAlias;

    public function __construct($catchClass = '\Exception', $catchClassAlias = '$e', $tryBlock = NULL, $catchBlock = NULL)
    {
        parent::__construct();
        $this->catchClass = $catchClass;
        $this->catchClassAlias = $catchClassAlias;
        if ($tryBlock) {
            $this->tryBlock = Utils::evalCallback($tryBlock);
        } else {
            $this->tryBlock = new Block();
        }
        if ($catchBlock) {
            $this->catchBlock = Utils::evalCallback($catchBlock);
        } else {
            $this->catchBlock = new Block();
        }
    }

    public function render(array $args = array())
    {
        $this->tryBlock->setIndentLevel($this->indentLevel + 1);
        $this->catchBlock->setIndentLevel($this->indentLevel + 1);

        $this->lines[] = 'try {';
        $this->lines[] = $this->tryBlock;
        $this->lines[] = '}catch  (' . $this->catchClass . ' ' . $this->catchClassAlias . ') {';
        $this->lines[] = $this->catchBlock;
        $this->lines[] = '}';

        return parent::render($args);
    }

}







<?php
namespace CodeGen\Statement;

use CodeGen\Renderable;

class UseStatement extends Statement implements Renderable
{
    protected $as;

    protected $class;

    public function __construct($class, $as = null)
    {
        $this->class = ltrim($class, '\\');
        $this->as = $as ? ltrim($as, '\\') : null;
    }

    public function getComponents()
    {
        return explode('\\', $this->class);
    }

    public function render(array $args = array())
    {
        $code = 'use ' . $this->class;
        if ($this->as) {
            $code .= ' ' . $this->as;
        }
        return $code . ';';
    }
}
<?php
namespace CodeGen\Testing;

use CodeGen\Renderable;
use PHPUnit\Framework\TestCase;

abstract class CodeGenTestCase extends \PHPUnit\Framework\TestCase
{

    public function assertCodeEquals($expected, Renderable $code, array $args = array())
    {
        $out = $code->render($args);
        static::assertEquals($expected, $out);
    }


    public function assertCodeEqualsFile($fixtureFile, Renderable $code, array $args = array())
    {
        $out = $code->render($args);
        if (!file_exists($fixtureFile) || getenv('OVERRIDE_FIXTURE')) {
            echo "\nGenerating fixture file with below content: $fixtureFile\n";
            echo "======================\n";
            echo $out . "\n";
            echo "======================\n";
            file_put_contents($fixtureFile, $out);
        }
        static::assertStringEqualsFile($fixtureFile, $out, "Testing $fixtureFile");
    }
}



<?php
namespace CodeGen;

use CodeGen\Statement\Statement;

class UseClass extends Statement implements Renderable
{
    public $as;
    public $class;

    public function __construct($class, $as = null)
    {
        $this->class = ltrim($class, '\\');
        $this->as = $as ? ltrim($as, '\\') : null;
    }

    public function getComponents()
    {
        return explode('\\', $this->class);
    }

    public function render(array $args = array())
    {
        $code = 'use ' . $this->class;
        if ($this->as) {
            $code .= ' as ' . $this->as;
        }
        return $code . ';';
    }
}
<?php
namespace CodeGen;

use Exception;

class UserClass implements Renderable
{

    /**
     * @var ClassName
     */
    public $class;

    public $extends;

    public $interfaces = array();

    public $uses = array();

    public $methods = array();

    public $consts = array();

    public $properties = array();

    public $staticVars = array();


    /**
     * @var boolean final class?
     */
    public $final;

    /**
     * Registered trait
     */
    public $traits = array();

    public $usedClasses = array();

    /**
     * constructor create a new class template object
     *
     * @param string $className
     *
     * a sample options:
     *
     * $t = new ClassDeclare('NewClassFoo')
     *
     */
    public function __construct($className)
    {
        $this->setClass($className);
    }

    public function setClass($className)
    {
        $this->class = new ClassName($className);
    }

    public function in($namespace)
    {
        $this->class->setNamespace($namespace);
        return $this;
    }


    public function useClass($className, $as = null)
    {
        if ($as) {
            if (isset($this->usedClasses[$as])) {
                return;
            }
            $this->usedClasses[$as] = $className;
        } else {
            if (isset($this->usedClasses[$className])) {
                return;
            }
            $this->usedClasses[$className] = $className;
        }
        $this->uses[] = new UseClass($className, $as);
    }


    /**
     * Add extends property
     *
     * @param boolean $useAlias means append 'use' statement automatically.
     */
    public function extendClass($className, $useAlias = true)
    {
        if ($className[0] === '\\' && $useAlias) {
            $className = ltrim($className, '\\');
            $this->useClass($className);

            $_p = explode('\\', $className);
            $shortClassName = end($_p);
            $this->extends = new ClassName($shortClassName);
        } else {
            $this->extends = new ClassName($className);
        }
    }

    public function implementInterface($interface)
    {
        $class = new ClassName($interface);
        $this->useClass($interface);
        $this->interfaces[] = $class;
    }

    public function implementClass($className)
    {
        $class = new ClassName($className);
        $this->useClass($className);
        $this->interfaces[] = $class;
    }

    public function addMethod($scope, $methodName, array $arguments = array(), $body = array(), array $bodyArguments = array())
    {
        $method = new ClassMethod($methodName, $arguments, $body, $bodyArguments);
        $method->setScope($scope);
        $this->methods[$methodName] = $method;
        return $method;
    }

    public function addMethodObject(ClassMethod $method)
    {
        $this->methods[$method->getName()] = $method;
    }

    public function addConst($name, $value)
    {
        $this->consts[] = new ClassConst($name, $value);
    }

    public function addConstObject(ClassConst $const)
    {
        $this->consts[] = $const;
    }

    public function addConsts($array)
    {
        foreach ($array as $name => $value) {
            $this->consts[] = new ClassConst($name, $value);
        }
    }

    public function addProperty($name, $value, $scope = 'public')
    {
        $this->properties[] = new ClassProperty($name, $value, $scope);
        return $this;
    }

    public function addPublicProperty($name, $value)
    {
        return $this->addProperty($name, $value, 'public');
    }

    public function addProtectedProperty($name, $value)
    {
        return $this->addProperty($name, $value, 'protected');
    }

    public function addPrivateProperty($name, $value)
    {
        return $this->addProperty($name, $value, 'private');
    }


    public function addStaticVar($name, $value, $scope = 'public')
    {
        $this->staticVars[] = new ClassStaticVariable($name, $value, $scope);
        return $this;
    }


    /**
     * Returns the short class name
     *
     * @return string short class name
     */
    public function getShortClassName()
    {
        return $this->class->getName();
    }

    public function getClassName()
    {
        return $this->class->getFullName();
    }

    public function render(array $args = array())
    {
        $lines = array(); // Add an option to render with a php tag
        if ($this->class->namespace) {
            $lines[] = 'namespace ' . $this->class->namespace . ';';
        }

        // When there is no namespace, we should skip the first-level class use statement.
        if ($this->uses) {
            foreach ($this->uses as $u) {
                // If we are not in a namespace, just skip these one component use statement
                if (!$this->class->namespace && count($u->getComponents()) == 1) {
                    continue;
                }
                $lines[] = $u->render();
            }
        }

        $classDeclare = ($this->final ? 'final ' : '')
            . 'class ' . $this->class->name
            ;

        $lines[] = $classDeclare;
        if ($this->extends) {
            $lines[] = Indenter::indent(1) . 'extends ' . $this->extends->render();
        }
        if ($this->interfaces) {
            $lines[] = Indenter::indent(1) . 'implements ' . implode(', ', array_map(function ($class) {
                    return $class->name;
                }, $this->interfaces));
        }

        $block = new BracketedBlock;
        foreach ($this->traits as $trait) {
            $block[] = $trait;
        }

        foreach ($this->consts as $const) {
            $block[] = $const;
        }

        foreach ($this->staticVars as $var) {
            $block[] = $var;
        }

        foreach ($this->properties as $property) {
            $block[] = $property;
        }

        foreach ($this->methods as $method) {
            $method->getBlock()->setIndentLevel(1);
            $block[] = $method;
        }
        $lines[] = $block->render($args);
        return implode("\n", $lines);
    }

    public function getPsr0ClassPath()
    {
        return str_replace('\\', DIRECTORY_SEPARATOR, $this->class->getFullName()) . '.php';
    }

    public function makeFinal()
    {
        $this->final = true;
    }

    public function requireAt($path, array $args = array())
    {
        $code = "<?php\n" . $this->render($args);
        if (file_put_contents($path, $code) === false) {
            return false;
        }
        require $path;
        return $path;

    }

    public function generateAt($path, array $args = array())
    {
        $code = "<?php\n" . $this->render($args);
        if (file_put_contents($path, $code) === false) {
            return false;
        }
        return $path;
    }

    public function generatePsr4ClassUnder($directory, array $args = array())
    {
        $className = $this->class->name;

        // translate psr4 class map to actual directory
        if (is_array($directory)) {
            $fullClassName = $this->class->getFullName();
            foreach ($directory as $nsprefix => $nsdir) {
                // found matched namesspace
                if (strpos($fullClassName, $nsprefix) === 0) {
                    $className = ltrim(substr($fullClassName, strlen($nsprefix)), '\\');
                    $directory = rtrim($nsdir, DIRECTORY_SEPARATOR);
                    continue;
                }
            }
            if (is_array($directory)) {
                throw new Exception("Can't translate class name into corresponding directory.");
            }
        }

        $className = str_replace('\\', DIRECTORY_SEPARATOR, $className);

        $code = "<?php\n" . $this->render($args);
        $path = $directory . DIRECTORY_SEPARATOR . $className . '.php';
        if ($dir = dirname($path)) {
            if (!file_exists($dir)) {
                mkdir($dir, 0755, true);
            }
        }
        if (file_put_contents($path, $code) === false) {
            return false;
        }
        return $path;
    }

    /**
     * for Foo\Bar class,
     *
     * $this->generatePsr0ClassUnder('src');
     *
     * will generate class at src/Foo/Bar.php
     */
    public function generatePsr0ClassUnder($directory, array $args = array())
    {
        $code = "<?php\n" . $this->render($args);
        $classPath = $this->getPsr0ClassPath();
        $path = $directory . DIRECTORY_SEPARATOR . $classPath;
        if ($dir = dirname($path)) {
            if (!file_exists($dir)) {
                mkdir($dir, 0755, true);
            }
        }
        if (file_put_contents($path, $code) === false) {
            return false;
        }
        return $path;
    }


    /**
     * This method was used for generating filename for class cache.
     * SHOULD BE DEPRECATED
     */
    public function getSplFilePath()
    {
        return str_replace('\\', '_', $this->class->getFullName());
    }

    public function addTrait(ClassTrait $trait)
    {
        $this->traits[] = $trait;
    }

    public function useTrait($class)
    {
        $classes = func_get_args();
        $self = $this;
        $classes = array_map(function ($fullClassName) use ($self) {
            // split classnames into "use" statement 
            $p = explode('\\', ltrim($fullClassName, '\\'));
            $className = end($p);
            if (count($p) > 1) {
                $this->useClass($fullClassName);
            }
            return $className;
        }, $classes);
        $trait = new ClassTrait($classes);
        $this->addTrait($trait);
        return $trait;
    }
}

<?php
namespace CodeGen;

class UserFunction extends Block implements Renderable
{
    public $name;

    public $arguments = array();

    public $bodyArguments = array();

    public $indentLevel = 0;

    /**
     * @var Block
     *
     * The body block
     */
    public $block;

    /**
     * Class Method Constructor
     *
     * @param string $name the function name.
     * @param array $arguments the argument of the function prototype.
     * @param string $body the code of the function.
     * @param array $bodyArguments the template arguments of the code of the function.
     */
    public function __construct($name, array $arguments = array(), $body = '', array $bodyArguments = array())
    {
        $this->name = $name;
        $this->arguments = $arguments;

        $this->block = new BracketedBlock;
        if ($body) {
            $this->block->setBody($body);
        }
        if ($bodyArguments) {
            $this->block->setDefaultArguments($bodyArguments);
        }
    }

    public function getName()
    {
        return $this->name;
    }

    public function setIndentLevel($level)
    {
        $this->indentLevel = $level;
    }

    public function increaseIndentLevel()
    {
        $this->indentLevel++;
    }

    public function decreaseIndentLevel()
    {
        $this->indentLevel--;
    }


    public function setBlock(Block $block)
    {
        $this->block = $block;
    }

    public function getBlock()
    {
        return $this->block;
    }

    public function setArguments(array $args)
    {
        $this->arguments = $args;
    }

    protected function renderArguments()
    {
        return implode(', ', $this->arguments);
    }

    public function render(array $args = array())
    {
        return 'function ' . $this->name . '(' . $this->renderArguments() . ")\n"
        . $this->block->render($args);
    }

}





<?php
namespace CodeGen;

use Closure;
use Twig_Environment;
use Twig_Loader_Array;


class Utils
{
    protected static $stringloader;

    protected static $twig;

    static public function renderStringTemplate($templateContent, array $args = array(), Twig_Environment $env = null)
    {
        if (!$env) {
            if (self::$twig) {
                $env = self::$twig;
            } else {
                $env = new Twig_Environment(new Twig_Loader_Array(array()));
            }
        }
        $template = $env->createTemplate($templateContent);

        if (is_callable($args)) {
            $args = call_user_func($args);
        } elseif ($args instanceof Closure) {
            $args = $args();
        }
        return $template->render($args);
    }

    static public function evalCallback($cb)
    {
        return is_callable($cb) ? $cb() : $cb;
    }

    static public function indent($indent = 1, $spaces = 4)
    {
        return str_repeat(' ', $spaces * $indent);
    }
}




<?php
namespace CodeGen;

class Variable implements Renderable
{
    protected $name;

    protected $templateApply = false;

    protected $templateArgs = array();

    public function __construct($name)
    {
        $this->name = $name;
    }

    public function templateApply(array $templateArgs = array())
    {
        $this->templateApply = true;
        $this->templateArgs = $templateArgs;
    }

    static public function template($name, array $args = array())
    {
        $var = new self($name);
        $var->templateApply($args);
        return $var;
    }

    public function render(array $args = array())
    {
        if ($this->templateApply) {
            return Utils::renderStringTemplate($this->name, array_merge($this->templateArgs, $args));
        }
        return $this->name;
    }
}





<?php
namespace CodeGen;

use LogicException;

class VariableDeflator
{
    static public function deflate($arg)
    {
        // Raw string output
        if (is_string($arg)) {
            if ($arg[0] === '$') {
                return $arg;
            }
            return var_export($arg, true);
        } else if ($arg instanceof Renderable) {
            return $arg->render(array());
        } else if ($arg instanceof Raw) {
            return (string)$arg;
        } else if ($arg instanceof Exportable || method_exists($arg, '__get_state')) {
            $class = get_class($arg);
            return $class . '::__set_state(' . var_export($arg->__get_state(), true) . ')';
        } else if (is_array($arg) || is_scalar($arg) || method_exists($arg, '__set_state')) {
            return var_export($arg, true);
        } else if ($arg === null) {
            return '';
        } else {
            throw new LogicException('Can\'t deflate variable');
        }
    }
}




<?php
namespace ClassTemplate;
use Exception;
use ReflectionClass;
use ReflectionObject;
use CodeGen\UserClass;
use CodeGen\Renderable;

class ClassFile extends UserClass
{
    public $templateFile;
    public $templateDirs;
    public $options = array();

    /**
     * constructor create a new class template object
     *
     * @param string $className
     * @param array $options 
     *
     * a sample options:
     * 
     * $t = new ClassTemplate('NewClassFoo',[
     *   'template_dirs' => [ path1, path2 ],
     *   'template' => 'Class.php.twig',
     *   'template_args' => [ ... predefined template arguments ],
     *   'twig' => [ 'cache' => false, ... ]
     * ])
     *
     */
    public function __construct($className, array $options = array())
    {
        parent::__construct($className);
        $this->setOptions($options);
    }

    public function setOptions(array $options)
    {
        $this->options = $options;
    }

    public function setOption($key, $val) {
        $this->options[$key] = $val;
    }

    public function render(array $args = array())
    {
        return "<?php\n" . parent::render($args);
    }

    public function writeTo($file)
    {
        return file_put_contents($file, $this->render());
    }

    public function getSplFilePath()
    {
        return str_replace('\\', DIRECTORY_SEPARATOR, ltrim($this->class->getFullName(),'\\'));
    }

    public function load() {
        $tmpname = tempnam('/tmp', $this->getSplFilePath());
        if (file_put_contents($tmpname, $this->render()) != false) {
            return require $tmpname;
        }
        throw new Exception("Can not load class file $tmpname");
    }
}

<?php
namespace ClassTemplate;
use ReflectionClass;

class ClassInjection
{
    public $lines = array();

    /**
     * @var array Contents for injection
     */
    public $contents = array();


    /**
     * @var integer Original content line length inside the boundary.
     */
    public $contentLength = 0;


    /**
     * @var string Boundary string
     */
    public $boundary;


    /**
     * @var integer boundary start line
     */
    public $boundaryStartLine;


    /**
     * @var integer boundary end line
     */
    public $boundaryEndLine;


    /**
     * @var mixed target class object.
     */
    public $targetClass;


    /**
     * @var string targe class file name
     */
    public $filename;



    /**
     *
     * @param mixed target object
     *
     */
    public function __construct($class)
    {
        $this->targetClass = $class;
        $this->reflection = new ReflectionClass($class);
        $this->filename = $this->reflection->getFilename();
    }


    public function replaceContent($content)
    {
        $this->contents = array($content);
    }


    public function appendContent($content) 
    {
        $this->contents[] = $content;
    }

    public function getBoundary() 
    {
        if($this->boundary)
            return $this->boundary;
        $content = join("\n",$this->contents);
        $this->boundary = md5($content);
        return $this->boundary;
    }

    public function read() 
    {
        $filename = $this->reflection->getFilename();

        $this->lines    = array();
        $this->contents = array();
        $this->lines    = explode("\n",file_get_contents($filename));
        $this->contentLength = 0;
        $inBoundary = false;
        for ( $i = 0; $i < count($this->lines); $i++ ) {
            $line = $this->lines[$i];
            // parse for start boundary
            if( preg_match('/^\s*#boundary start (\w+)/',$line,$regs) ) {
                $inBoundary = true;
                $this->boundary = $regs[1];
                $this->boundaryStartLine = $i + 1;
            }
            elseif( preg_match('/^\s*#boundary end (\w+)/',$line,$regs) ) {
                $inBoundary = false;
                $this->boundaryEndLine = $i + 1;
            }
            elseif( $inBoundary ) {
                $this->contentLength++;
                $this->contents[] = $line;
            }
        }
    }


    /**
     * Returns new inner content
     */
    public function buildContent()
    {
        $contents = $this->contents;
        array_unshift( $contents, '#boundary start ' . $this->getBoundary() );
        array_push(    $contents, '#boundary end ' . $this->getBoundary() );
        return $contents;
    }

    public function removeContent()
    {
        $this->contents = array();
    }

    public function write() {
        if($this->boundaryStartLine && $this->boundaryEndLine ) {
            array_splice($this->lines, $this->boundaryStartLine - 1, $this->contentLength + 2, $this->buildContent() );
            file_put_contents($this->filename, join("\n",$this->lines) );
        }
        else {
            $endline = $this->reflection->getEndLine();
            array_splice($this->lines,$endline - 1,0, $this->buildContent() );
            file_put_contents( $this->filename, join("\n",$this->lines) );
        }

        // re-read content to update boundary information
        $this->read();
    }

    public function __toString()
    {
        return join("\n",$this->lines);
    }
}

<?php
namespace ClassTemplate;
use Exception;
use ReflectionClass;
use ReflectionObject;
use CodeGen\Renderable;
use CodeGen\Block;

class File extends Block
{

    public function render(array $args = array())
    {
        return "<?php\n" . parent::render($args);
    }

    public function writeTo($file)
    {
        return file_put_contents($file, $this->render());
    }

}


<?php
namespace ClassTemplate;
use Exception;
use ReflectionClass;
use ReflectionObject;
use ClassTemplate\ClassTrait;
use CodeGen\Renderable;
use ClassTemplate\ClassFile;

class TemplateClassFile extends ClassFile implements Renderable
{
    /**
     * @var TemplateView object.
     */
    protected $view;

    public $templateFile;
    public $templateDirs;
    public $options = array();
    public $msgIds = array();

    public function __construct($className, array $options = array())
    {
        if( !isset($options['template_dirs']) ) {
            $ro = new ReflectionObject($this);
            $dir = dirname($ro->getFilename()) . DIRECTORY_SEPARATOR . 'Templates';
            $options['template_dirs'] = array($dir);
        }
        if( !isset($options['template']) ) {
            $options['template'] = 'Class.php.twig';
        }

        $this->options = $options;
        $this->templateFile = $options['template'];
        $this->templateDirs = $options['template_dirs'];
        $this->setClass($className);

        $this->view = new TemplateView($this->templateDirs, 
            (isset($options['twig']) ? $options['twig'] : array()),
            (isset($options['template_args']) ? $options['template_args'] : array())
        );
        $this->view->class = $this;
    }

    public function __set($n,$v) {
        $this->view->__set($n,$v);
    }

    public function render(array $args = array())
    {
        foreach ($args as $n => $v) {
            $this->view->__set($n,$v);
        }
        $content = $this->view->renderFile($this->templateFile);
        if ( isset($this->options['trim_tag']) && strpos($content, '<?php') === 0 ) {
            return substr($content, 5);
        }
        return $content;
    }

    public function getView() {
        return $this->view;
    }

    public function setView($view) {
        $this->view = $view;
    }


    public function addMsgId($msgId) {
        $this->msgIds[] = $msgId;
    }

    public function setMsgIds($msgIds) {
        $this->msgIds = $msgIds;
    }
}
<?php
/**
This is an auto-generated file,
Please DO NOT modify this file directly.
*/
{% if class.class.namespace %}
namespace {{ class.class.namespace }};
{% endif %}

{% for u in class.uses %}
{{u|raw}}
{% endfor %}

class {{ class.class.name }} {% if class.extends %} extends {{ class.extends }} {% endif %}
{
{% for t in class.traits %}
{{t|raw}}
{% endfor %}

{% for con in class.consts %}
{{con|raw}}
{% endfor %}

{% for property in class.properties %}
{{property|raw}}
{% endfor %}

{% for con in class.staticVars %}
{{con|raw}}
{% endfor %}

{% for method in class.methods %}
{{method|raw}}
{% endfor %}
}

<?php
namespace ClassTemplate;
use Exception;
use SerializerKit\PhpSerializer;
use Twig_Loader_Filesystem;
use Twig_Environment;
use Twig_SimpleFilter;

function twig_var_export($obj)
{
    $ser = new PhpSerializer;
    $ser->return = false;
    return $ser->encode( $obj );
}

class TemplateView
{
    private $loader;
    private $twig;

    public $stash = array();
    public $overwrite = false;

    public function __construct( $dirs , $options = array(), $stash = array() )
    {
        $this->loader = new \Twig_Loader_Filesystem( $dirs );
        $this->twig = new \Twig_Environment($this->loader, array(
            'cache' => false,
            'auto_reload' => true,
            'autoescape' => false,
            'debug' => true,
        ) + $options );
        $this->stash = $stash;
        $this->twig->addFilter(new Twig_SimpleFilter('export','\ClassTemplate\twig_var_export'));
    }

    public function __set($n,$v)
    {
        $this->stash[ $n ] = $v;
    }

    public function __get($n)
    {
        return $this->stash[ $n ];
    }

    public function renderFile($file)
    {
        $template = $this->twig->loadTemplate($file);
        return $template->render( $this->stash );
    }

}

<?php
namespace Universal\ClassLoader;
use Universal\ClassLoader\ClassLoader;
use Exception;

class ApcClassLoader extends SplClassLoader
{
    public $apcprefix = 'apc';

    public function __construct($prefix = '_apc', $namespaces = null)
    {
        parent::__construct( $namespaces );
        $this->apcPrefix = $prefix;
    }

    public function setApcPrefix($prefix)
    {
        $this->apcPrefix = $prefix;
    }

    public function loadClass($class)
    {
        if( ($file = apc_fetch($this->apcPrefix . $class) ) !== false ) {
            require $file;
            return true;
        }

        if ($file = $this->resolveClass($class)) {
            apc_store( $this->apcPrefix . $class , $file );
            require $file;
            return true;
        }
        return false;
    }
}

<?php 
namespace Universal\ClassLoader;
use Universal\ClassLoader\ClassLoader;

/**
 * Base Path Classloader:
 *
 * In base path classloader, we dont check namespace
 *
 * $loader = new BasePathClassLoader( array( 
 *      'vendor/pear', 'external_vendor/src'
 * ) );
 * $loader->register();
 *
 */
class BasePathClassLoader implements ClassLoader
{

    static $instance;

    /**
     * library paths
     */
    public $paths = array();

    /**
     * use php include path ?
     *
     * @var boolean 
     */
    public $useIncludePath;

    public function __construct($paths)
    {
        $this->paths = $paths;
        self::$instance = $this;
    }

    public function getInstance() 
    {
        return self::$instance ?: self::$instance = new self;
    }

    /**
     * extract PHP5LIB paths from env 
     */
    public function useEnvPhpLib()
    {
        if ($lib = getenv('PHP5LIB')) {
            $paths = explode( ':' , $lib );
            foreach( $paths as $path )
                $this->paths[] = $path;
        }
    }

    /**
     * find class file path
     *
     * @param string $fullclass
     */
    public function resolveClass($fullclass)
    {
        $fullclass = ltrim($fullclass,'\\');
        # echo "Fullclass: " . $fullclass . "\n";

        $subpath = null;
        if( ($r = strrpos($fullclass,'\\')) !== false ) {
            $namespace = substr($fullclass,0,$r);
            $classname = substr($fullclass,$r + 1);
            $subpath = str_replace('\\', DIRECTORY_SEPARATOR, $namespace )
                    . DIRECTORY_SEPARATOR . str_replace( '_' , DIRECTORY_SEPARATOR , $classname ) 
                    . '.php';

            # echo "namespace: $ns in $namespace\n";
            foreach( $this->paths as $d ) {
                $path = $d . DIRECTORY_SEPARATOR . $subpath;
                if( file_exists($path) )
                    return $path;
            }
        }
        else {
            // use prefix to load class (pear style), convert _ to DIRECTORY_SEPARATOR.
            $subpath = str_replace('_', DIRECTORY_SEPARATOR, $fullclass).'.php';
            foreach ($this->paths as $dir ) {
                $file = $dir.DIRECTORY_SEPARATOR.$subpath;
                if (file_exists($file))
                    return $file;
            }
        }

        if ($this->useIncludePath && $file = stream_resolve_include_path($subpath))
            return $file;
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            # echo "File: $file.\n";
            require $file;
        }
    }


    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }


    /**
     * unregister the spl autoloader
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }


    /**
     * use include path
     *
     * @param boolean $bool
     */
    public function useIncludePath($bool)
    {
        $this->useIncludePath = $bool;
    }
}

<?php
namespace Universal\ClassLoader;
use Universal\ClassLoader\ClassLoader;

class BytecodeClassLoader
{

}

<?php
namespace Universal\ClassLoader;

class ChainedClassLoader implements ClassLoader
{
    protected $classloaders = array();

    public function __construct(array $classloaders = array())
    {
        $this->classloaders = $classloaders;
    }

    public function resolveClass($fullClass)
    {
        foreach ($this->classloaders as $loader) {
            if ($classPath = $loader->resolveClass($fullClass)) {
                return $classPath;
            }
        }
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            require $file;
        }
    }

    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * unregister the spl autoloader
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

}



<?php
/**
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <yoanlin93@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Universal\ClassLoader;

interface ClassLoader { 

    public function register($prepend = false);

    public function unregister();

    public function resolveClass($fullclass);

    public function loadClass($class);

}


<?php
namespace Universal\ClassLoader;


class MapClassLoader
{

    protected $classMap;

    public function __construct(array $map)
    {
        $this->classMap = $map;
    }


    /**
     * find class file path
     *
     * @param string $fullclass
     */
    public function resolveClass($fullclass)
    {
        if (isset($this->classMap[$fullclass])) {
            return $this->classMap[$fullclass];
        }
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            require $file;
            return true;
        }
        return false;
    }


    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }
    
}


<?php 
namespace Universal\ClassLoader;
if( ! class_exists('\Universal\ClassLoader\PathIncluder') ) {

/**
 * Include Path manipulator
 *
 * provides a simple api for include path
 *
 * $includer = new PathIncluder;
 * $includer->add( 'path/to/lib' );
 * $includer->setup();   // write set_include_path
 */
class PathIncluder 
{

    /**
     * @var array Custom include paths
     */
    private $paths;

    /**
     * @var array Original include paths
     */
    private $origPaths;

    function __construct($paths) 
    {
        $this->origPaths = explode(PATH_SEPARATOR,get_include_path());
        $this->paths = array_merge( (array) $paths , $this->origPaths );
    }

    /**
     * @return array include paths
     */
    function getPaths()
    {
        return $this->paths;
    }


    /**
     * remove include path
     *
     * @param string $path
     */
    function remove($path)
    {
        // search and remove
        if( ($index = array_search( $path , $this->paths )) !== FALSE ) {
            unset( $this->paths[ $index ] );
        }
    }

    /**
     * insert path at beginning
     *
     * @param string $path 
     */
    function insert($path)
    {
        array_unshift( $this->paths, $path );
    }


    /**
     * add include path
     *
     * @param string $path
     */
    function add($path)
    {
        $this->paths[] = $path;
    }

    /**
     * inflate path array with PATH_SEPARATOR
     */
    function inflate()
    {
        return join( PATH_SEPARATOR , $this->paths );
    }

    /**
     * set include path
     */
    function setup()
    {
        set_include_path( join( PATH_SEPARATOR , $this->paths ) );
    }

}

}
<?php
/**
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <yoanlin93@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace Universal\ClassLoader;

class Psr0ClassLoader implements ClassLoader
{

    /**
     * namespace mapping
     *
     * @var array
     */
    protected $namespaces = array();

    public function __construct(array $namespaces = array()) 
    {
        $this->namespaces = $namespaces;
    }

    public function addNamespaces(array $namespaceMaps) 
    {
        $this->namespaces = array_merge($this->namespaces, $namespaceMaps);
    }


    public function addNamespace($ns, $dirs)
    {
        $this->namespaces[$ns] = (array) $dirs;
    }


    /**
     * find class file path
     *
     * @param string $fullclass
     */
    public function resolveClass($fullclass)
    {
        if (($r = strrpos($fullclass,'\\')) !== false) {
            $namespace = substr($fullclass,0,$r);
            $classname = substr($fullclass,$r + 1);
            $subpath = strtr($fullclass, '\\', DIRECTORY_SEPARATOR) . '.php';
            foreach ($this->namespaces as $ns => $dirs) {
                if (strpos($namespace,$ns) === 0) {
                    foreach ((array) $dirs as $dir) {
                        $path = $dir . DIRECTORY_SEPARATOR . $subpath;
                        if (file_exists($path)) {
                            return $path;
                        }
                    }
                }
            }
        }
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            require $file;
            return true;
        }
        return false;
    }

    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * unregister the spl autoloader
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }
}




<?php
/**
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <yoanlin93@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Universal\ClassLoader;
use Universal\ClassLoader\ClassLoader;

class Psr4ClassLoader implements ClassLoader
{
    protected $prefixes = array();

    public function __construct(array $prefixes = array()) 
    {
        $this->prefixes = $prefixes;
    }

    public function addPrefix($prefix, $baseDir, $trim = false)
    {
        if ($trim) {
            $prefix = trim($prefix, '\\') . '\\';
            $baseDir = rtrim($baseDir, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
        }
        $this->prefixes[] = array($prefix, $baseDir);
    }


    public function addPrefixes(array $prefixes, $trim = false)
    {
        foreach ($prefixes as $prefix => $baseDir) {
            $this->addPrefix($prefix, $baseDir, $trim);
        }
    }


    /**
     * find class file path
     *
     * @param string $fullclass
     */
    public function resolveClass($fullclass)
    {
        # echo "Fullclass: " . $fullclass . "\n";
        foreach ($this->prefixes as $prefixMap) {
            list($prefix, $dir) = $prefixMap;
            if (strpos($fullclass, $prefix) === 0) {
                $len = strlen($prefix);
                $classSuffix = substr($fullclass, $len);
                $subpath = str_replace('\\', DIRECTORY_SEPARATOR, $classSuffix) . '.php';
                $classPath = $dir . $subpath;
                if (file_exists($classPath)) {
                    return $classPath;
                }
            }
        }
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            require $file;
            return true;
        }
        return false;
    }



    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

}

<?php
/**
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <yoanlin93@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Load Class with namespaces
 *
 *      $loader = new \UniversalClassLoader\SplClassLoader( array(  
 *               'Vendor\Onion' => 'path/to/Onion',
 *               'Vendor\CLIFramework' => 'path/to/CLIFramework',
 *      ));
 *
 *      $loader->addNamespace(array( 
 *          'NS' => 
 *      ));
 *
 *      $loader->useIncludePath();
 *      $loader->register();
 *
 */
namespace Universal\ClassLoader;
use Exception;
use InvalidArgumentException;
use Universal\ClassLoader\ClassLoader;

if( ! class_exists('\Universal\ClassLoader\SplClassLoader') ) {

/**
 * SplClassLoader
 *
 * PSR-0 Auto ClassLoader
 */
class SplClassLoader implements ClassLoader
{
    static $instance;

    /**
     * namespace mapping
     *
     * @var array
     */
    public $namespaces = array();

    /**
     * prefix mapping
     *
     * @var array
     */
    public $prefixes = array();



    public $fallbacks = array();

    /**
     * use php include path ?
     *
     * @var boolean 
     */
    public $useIncludePath;

    /**
     * mode
     */
    public $mode;


    /**
     * construct 
     *
     * @param array $namespaces 
     */
    public function __construct($namespaces = null)
    {
        if( $namespaces )
            $this->addNamespace( $namespaces );
        self::$instance = $this;
    }

    public function getInstance() 
    {
        return self::$instance ?: self::$instance = new self;
    }


    /**
     * add namespace
     *
     * @param array $ns
     */
    public function addNamespace($ns = array())
    {
        if( is_array($ns) ) {
            foreach( $ns as $n => $dirs )
                $this->namespaces[ $n ] = (array) $dirs;
            return;
        } 
        else {
            $args = func_get_args();
            if( count( $args ) == 2 ) {
                $this->namespaces[ $args[0] ] = (array) $args[1];
                return;
            }
            
        }
        throw new InvalidArgumentException;
    }


    /**
     * add prefix
     *
     * @param array $ps
     */
    public function addPrefix($ps = array())
    {
        if (is_array($ps)) {
            foreach ($ps as $prefix => $dirs) {
                $this->prefixes[$prefix] = (array) $dirs;
            }
        } else {
            list($prefix, $dirs) = func_get_args();
            $this->prefixes[$prefix] = (array) $dirs;
        }
    }

    public function addFallback($path)
    {
        $this->fallbacks[] = $path;
    }

    /**
     * use include path
     *
     * @param boolean $bool
     */
    public function useIncludePath($bool)
    {
        $this->useIncludePath = $bool;
    }

    /**
     * register to spl_autoload_register
     *
     * @param boolean $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }


    /**
     * unregister the spl autoloader
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }


    /**
     * find class file path
     *
     * @param string $fullclass
     */
    public function resolveClass($fullclass)
    {
        $fullclass = ltrim($fullclass,'\\');
        # echo "Fullclass: " . $fullclass . "\n";

        $subpath = null;
        if( ($r = strrpos($fullclass,'\\')) !== false ) {
            $namespace = substr($fullclass,0,$r);
            $classname = substr($fullclass,$r + 1);
            $subpath = str_replace('\\', DIRECTORY_SEPARATOR, $namespace )
                    . DIRECTORY_SEPARATOR . str_replace( '_' , DIRECTORY_SEPARATOR , $classname ) 
                    . '.php';
            foreach ($this->namespaces as $ns => $dirs) {

                # echo "namespace: $ns in $namespace\n";
                if( strpos($namespace,$ns) !== 0 )
                    continue;

                foreach( $dirs as $d ) {
                    $path = $d . DIRECTORY_SEPARATOR . $subpath;
                    if( file_exists($path) )
                        return $path;
                }
            }
        }
        else {
            // use prefix to load class (pear style), convert _ to DIRECTORY_SEPARATOR.
            $subpath = str_replace('_', DIRECTORY_SEPARATOR, $fullclass).'.php';
            foreach ($this->prefixes as $p => $dirs) {
                if (strpos($fullclass, $p) !== 0)
                    continue;
                foreach ($dirs as $dir) {
                    $file = $dir . DIRECTORY_SEPARATOR . $subpath;
                    if (file_exists($file))
                        return $file;
                }
            }
        }

        foreach( $this->fallbacks as $fallback ) {
            $file = $fallback . DIRECTORY_SEPARATOR . $subpath;
            if( file_exists($file) )
                return $file;
        }

        if ($this->useIncludePath && $file = stream_resolve_include_path($subpath)) {
            return $file;
        }
    }

    public function loadClass($class)
    {
        if ($file = $this->resolveClass($class)) {
            require $file;
            return true;
        }
        return false;
    }

}

}
<?php
/*
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace Universal\Container;
use Exception;

class ObjectContainerException extends Exception {  }

class ObjectContainer 
{
    public $_builders = array();

    public $_singletonObjects = array();

    public $throwIfNotFound = false;


    /** 
     * Check if we have a builder.
     *
     * @param string $key builder key.
     */
    public function hasBuilder($key)
    {
        return isset($this->_builders[ $key ]);
    }


    /**
     * Get object instance or build a new object instance.
     *
     * @param string $key
     * @param array $args
     */
    public function getObject($key,$args = array())
    {
        if( isset( $this->_singletonObjects[ $key ] ) ) {
            return $this->_singletonObjects[ $key ];
        }
        elseif( $build = $this->getBuilder($key) ) {
            if( isset($build['singleton']) && $build['singleton'] ) {
                return $this->_singletonObjects[ $key ] = $this->_buildObject($build['builder'],$args);
            }
            return $this->_buildObject($build['builder'],$args);
        }
        else {
            if( $this->throwIfNotFound ) {
                throw new ObjectContainerException("object builder not found: $key");
            }
        }
    }

    protected function _buildObject($b,$args = array())
    {
        if( is_callable($b) ) {
            return call_user_func_array($b,$args);
        } 
        elseif( is_array($b) ) {
            return call_user_func_array($b,$args);
        }
        elseif( is_string($b) ) {
            $callable = explode('#',$b);
            $class = $callable[0];
            if( class_exists($class,true) ) {
                if( isset($callable[1]) ) {
                    return call_user_func_array($callable,$args);
                } else {
                    return new $b;
                }
            }
            else {
                throw new ObjectContainerException("Can not build object from $b");
            }
        }
        return $b;
    }


    /**
     * Build new object instance
     */
    public function build($key,$args = array())
    {
        if( $builder = $this->getBuilder($key) ) {
            return $this->_buildObject($builder['builder'], $args);
        }
    }


    /**
     * Get builder
     *
     * @param string $key
     */
    public function getBuilder($key)
    {
        if( isset($this->_builders[$key]) ) {
            return $this->_builders[ $key ];
        }
    }


    /**
     * Set object builder
     *
     * @param string $key
     * @param closure $builder
     */
    public function setBuilder($key,$builder,$singleton = true)
    {
        $this->_builders[ $key ] = array( 
            'singleton' => $singleton,
            'builder' => $builder,
        );
    }


    /**
     * Register a factory builder
     */
    public function registerFactory($key,$builder)
    {
        $this->_builders[ $key ] = array( 
            'singleton' => false,
            'builder' => $builder,
        );
    }

    public function __get($key)
    {
        return $this->getObject($key);
    }

    public function __set($key,$builder) 
    {
        $this->setBuilder($key,$builder);
    }

    public function __isset($key)
    {
        return $this->hasBuilder($key);
    }

}
<?php
/*
 * This file is part of the Universal package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace Universal\Event;

/**
 * A Simple PHP Event dispatcher
 *
 *
 * TODO: Move this PhpEvent to a standard-alone component.
 * TODO: implement an extension for this.
 */
class PhpEvent
{
    /**
     * Event pool
     *
     * @var array save event callbacks
     */
    public $eventPool = array();

    /**
     * Register event name
     *
     * @param string $ev
     * @param closure $cb callable function
     */
    public function register($ev,$cb)
    {
        if (! isset($this->eventPool[ $ev ] )) {
            $this->eventPool[ $ev ] = array();
        }
        $this->eventPool[ $ev ][] = $cb;
    }

    /**
     * This is an alias of register method.
     *
     * @param string $ev
     * @param closure $cb callable function
     */
    public function bind($ev,$cb)
    {
        if (! isset($this->eventPool[ $ev ] )) {
            $this->eventPool[ $ev ] = array();
        }
        $this->eventPool[ $ev ][] = $cb;
    }




    /**
     * Trigger event with event name
     *
     * @param string $evname event name
     * @param mixed extra parameters
     */
    public function trigger($evname)
    {
        $results = array();
        if( isset( $this->eventPool[ $evname ] ) ) {
            $args = func_get_args();
            array_shift( $args );
            foreach( $this->eventPool[ $evname ] as $cb ) {
                /**
                 * to break the event trigger, just return false.
                 */
                if( ($ret = call_user_func_array( $cb , $args )) === false ) 
                    break;
                $results[] = $ret;
            }
        }
        return $results;
    }


    /**
     * clear event pool
     */
    public function clear()
    {
        // clear event pool
        $this->eventPool = array();
    }


    /**
     * static singleton method
     */
    static function getInstance()
    {
        static $instance;
        return $instance ? $instance : $instance = new static;
    }

}
<?php
namespace Universal\Exception;
use Universal\Exception\UploadException;

class InvalidUploadFileException extends UploadException
{
}



<?php
namespace Universal\Exception;
use Universal\Exception\UploadException;

class UploadedFileMoveFailException extends UploadException
{
}






<?php
namespace Universal\Exception;
use Universal\Exception\UploadException;

class UploadErrorException extends UploadException
{
}






<?php
namespace Universal\Exception;
use RuntimeException;

class UploadException extends RuntimeException
{
    protected $file = array();

    public function __construct(array $filestash = array(), $message, $code = 0, $previous = null) {
        $this->file = $filestash;
        parent::__construct($message, $code, $previous);
    }

    /*
    public function __debugInfo() {
        return [
            'file' => $this->file,
            'message' => $this->message,
        ];
    }
    */




}




<?php
namespace Universal\FileSystem;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;

class PathUtils {

    static function path_join($list)
    {
        $args = null;
        if( is_array($list) ) {
            $args = $list;
        } else {
            $args = func_get_args();
        }
        return call_user_func(  'join' , DIRECTORY_SEPARATOR , $args );
    }

    static function mkdir( $path , $verbose = false , $mode = 0777 )
    {
        if( $verbose )
            echo "Creating dir: $path\n";
        mkdir($path,$mode);
    }

    static function rmtree( $paths , $verbose = false )
    {
        $paths = (array) $paths;
        foreach( $paths as $path ) {

            if( ! file_exists( $path ) )
                die( "$path does not exist." );

            if( is_dir( $path ) ) 
            {
                $iterator = new \DirectoryIterator($path);
                foreach ($iterator as $fileinfo) 
                {
                    if( $fileinfo->isDir() ) {
                        if( $fileinfo->getFilename() == "." )
                            continue;

                        if( $fileinfo->getFilename() == ".." )
                            continue;
                        self::rmtree( $fileinfo->getPathname() );

                        if( $verbose )
                            echo "\trmdir: " . $fileinfo->getPathname() . "\n";
                    }
                    elseif ($fileinfo->isFile()) {
                        if( $verbose )
                            echo "\tunlink file: " . $fileinfo->getPathname() . "\n";
                    
                        if( unlink( $fileinfo->getPathname() ) == false )
                            die( "File delete error: {$fileinto->getPathname()}" );
                    }
                }
                rmdir( $path );
            } 
            elseif( is_file( $path ) ) {
                unlink( $path );
            }


        }

    }

    static function mkpath( $paths , $verbose = false , $mode = 0777 )
    {
        $paths = (array) $paths;
        foreach( $paths as $path ) {
            if( $verbose )
                echo "\tCreating directory $path\n";
            if( file_exists( $path ) )
                continue;
            mkdir( $path, $mode , true );  // recursive
        }
    }

    static function create_keepfile( $path )
    {
        $keepfile = static::path_join( $path , '.keep' );
        touch( $keepfile );
    }

    /* substract cwd path */
    static function relative_path( $abspath ) 
    {
        $path = realpath( $abspath );
        $cwd = getcwd();
        return substr( $path , strlen( $cwd ) + 1 );
    }

    /* remove base path , return relative path */
    static function remove_base( $path , $base )
    {
        return substr( $path , strlen( $base ) + 1 );
    }

    static function expand_path( $path ) 
    {
        $start = strpos( $path , '{' );
        $end   = strpos( $path , '}' , $start );

        if( $start === false || $end === false )
            return (array) $path;

        $expand = explode(',',substr( $path , $start + 1 , $end - $start - 1 ));
        $wstr_start = substr( $path , 0 , $start  );
        $wstr_end   = substr( $path , $end + 1 );
        $paths = array();
        foreach( $expand as $item )
        {
            $paths[] = $wstr_start . $item . $wstr_end;
        }
        return $paths;
    }

    /* 
     * Expand dir to file paths
     *
     * Return file list with fullpath.
     * */
    static function expand_dir($dir)
    {
        if( is_dir($dir) ) {
            $files = array();
            $iterator = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($dir),
                                                    \RecursiveIteratorIterator::CHILD_FIRST);
            foreach ($iterator as $path) {
                if ($path->isDir()) {
                    # rmdir($path->__toString());
                } elseif( $path->isFile() ) { 
                    array_push( $files , $path->__toString() );
                }
            }
            return $files;
        }
        return array($dir);
    }




    static function concat_files( $files )
    {
        $content = '';
        foreach( $files as $file ) {
            $content .= file_get_contents( $file );
        }
        return $content;
    }

    static function filename_append_md5( $filename , $filePath = null )
    {
        $suffix = $filePath ? md5( $filePath ) : md5( time() );
        $pos = strrpos( $filename , '.' );
        if( $pos ) {
            return 
                substr( $filename , 0 , $pos )
                . $suffix 
                . substr( $filename , $pos );
        }
        return $filename . $suffix;
    }

    static function filename_suffix( $filename , $suffix )
    {
        $pos = strrpos( $filename , '.' );
        if( $pos ) {
            return 
                substr( $filename , 0 , $pos )
                . $suffix 
                . substr( $filename , $pos );
        }
        return $filename . $suffix;
    }

    static function mimetype( $file )
    {
        $fi = new \finfo( FILEINFO_MIME );
        $mime_type = $fi->buffer(file_get_contents($file));
        return $mime_type;
    }

}

<?php
namespace Universal\Http;
use Exception;

/**
 *    $cookie = new Cookie;
 *    $cookie->path = '/path';
 *    $cookie->set( 'name' , 123 );
 */
class Cookie
{

    public $expire = 0;

    public $path;

    public $domain;

    public $secure = false;

    public $httponly = false;


    /**
     * setcookie API
     *
     *  bool setcookie ( 
     *      string $name [, string $value 
     *                   [, int $expire = 0 
     *                   [, string $path 
     *                   [, string $domain 
     *                   [, bool $secure = false 
     *                   [, bool $httponly = false ]]]]]] )
     */
    public function __construct($options = array() ) {
        foreach( array('expire','path','domain','secure','httponly') as $k ) {
            if( isset($options[$k]) )
                $this->$k = $options[$k];
        }
    }


    /**
     * Set cookie path
     *
     * @param string $path
     */
    public function setPath($path) { $this->path = $path; }

    public function setSecure($secure) { $this->secure = $secure; }



    public function calculateExpireTime($expire) {
        if( is_string($expire) ) {
            // parse from pretty date string
            if( preg_match('#(\d+)\s+(days?|hours?|minutes?|seconds?)#',$expire,$regs) ) {
                $num = (int) $regs[1];
                $length = $regs[2];
                $seconds = 1;
                switch($length) {
                    case 'day':
                    case 'days':
                        $seconds = 3600 * 24;
                        break;
                    case 'hour':
                    case 'hours':
                        $seconds = 3600;
                        break;
                    case 'minute':
                    case 'minutes':
                        $seconds = 60;
                        break;
                    case 'second':
                    case 'seconds':
                    default:
                        $seconds = 1;
                        break;
                }
                return time() + ($seconds * $num);
            } else {
                throw new \Exception('Unknown expire format');
            }
        }
        elseif( $expire < 0 || $expire > 1000000000 ) {
            // expired at (expire time)
            return $expire;
        }
        // incremental expire time (current time + seconds)
        return time() + $expire;
    }

    /**
     * Set expire time
     *
     * Acceptable formats:
     *  
     * - Duration string:
     *    1 hour
     *    3 days
     *    3 minutes
     *
     * - Unix Timestamp
     *    1344085885
     *
     * - Seconds
     *    10
     *    20
     *    30
     *
     * @param string|integer $expire
     *
     */
    public function setExpire($expire) { 
        $this->expire = $this->calculateExpireTime($expire);
    }

    public function setDomain($domain) { 
        $this->domain = $domain; 
    }

    public function remove($name) 
    {
        setcookie($name, NULL, -1);
    }

    public function set($name,$value, $expire = null , $path = null)
    {
        // build setcookie arguments
        $args = array($name,$value);
        if( $expire !== null || $this->expire ) {
            $args[] = $expire ? $this->calculateExpireTime($expire) : $this->expire;
            if( $path || $this->path ) {
                $args[] = $path ? $path : $this->path;
                if( $this->domain ) {
                    $args[] = $this->domain;
                    $args[] = $this->secure;
                    $args[] = $this->httponly;
                }
            }
        }
        // setcookie( $name, $value , $this->expire , $this->path , $this->domain, $this->secure, $this->httponly );
        return @call_user_func_array('setcookie',$args);
    }

    public function __set($name,$value) 
    {
        return $this->set($name,$value);
    }

    public function __get($name) {
        return $this->get($name);
    }

    public function get($name) {
        if( isset($_COOKIE[$name]) ) {
            return $_COOKIE[$name];
        }
    }
}

<?php 
namespace Universal\Http;
use ArrayAccess;
use ArrayIterator;
use IteratorAggregate;
use SplFileInfo;

class FilesParameter extends Parameter
        implements ArrayAccess, IteratorAggregate
{
    public function __construct($hash = null)
    {
        if ($hash) {
            $this->hash = $hash;
        } else if (isset($_FILES)) {
            $this->hash = self::fix_files_array($_FILES);
        }
    }

    public function getIterator()
    {
        return new ArrayIterator($this->hash);
    }
    
    public function offsetSet($name,$value)
    {
        $this->hash[ $name ] = $value;
    }
    
    public function offsetExists($name)
    {
        return isset($this->hash[ $name ]);
    }
    
    public function offsetGet($name)
    {
        return $this->hash[ $name ];
    }
    
    public function offsetUnset($name)
    {
        unset($this->hash[$name]);
    }

    public static function _move_indexes_right($files) {
        if( ! is_array($files['name']) )
            return $files;
        $results = array(); 
        foreach($files['name'] as $index => $name) { 
            $reordered = array( 
                'name' => $files['name'][$index], 
                'tmp_name' => $files['tmp_name'][$index], 
                'size' => $files['size'][$index], 
                'type' => $files['type'][$index], 
                'error' => $files['error'][$index], 
            ); 
            
            // If this is not leaf do it recursivly 
            if (is_array($name))  {
                $reordered = FilesParameter::_move_indexes_right($reordered); 
            }
            $results[$index] = $reordered; 
        } 
        return $results; 
    }

    public static function fix_files_array($files)
    {
        // Multiple values for post-keys indexes 
        if (isset($files['name'], $files['tmp_name'], $files['size'], $files['type'], $files['error'])){ 
            return FilesParameter::_move_indexes_right($files); 
        }
        // Re order pre-keys indexes            
        array_walk($files, function(&$sub) {
            if (is_array($sub)) {
                $sub = FilesParameter::fix_files_array($sub); 
            }
        });
        return $files;
    }
}
<?php 
namespace Universal\Http;
use ArrayAccess;
use Universal\Http\FilesParameter;

/**
 * $req = new HttpRequest;
 * $v = $req->get->varname;
 * $b = $req->post->varname;
 *
 * $username = $req->param('username');
 *
 * $req->files->uploaded->name;
 * $req->files->uploaded->size;
 * $req->files->uploaded->tmp_name;
 * $req->files->uploaded->error;
 */
class HttpRequest
    implements ArrayAccess
{
    protected $_requestBodyFp;

    protected $_parameterBags = [];


    static $httpHeaderMapping = array(
        'HTTP_ACCEPT'                    => 'Accept',
        'HTTP_ACCEPT_CHARSET'            => 'Accept-Charset',
        'HTTP_ACCEPT_ENCODING'           => 'Accept-Encoding',
        'HTTP_ACCEPT_LANGUAGE'           => 'Accept-Language',
        'HTTP_CONNECTION'                => 'Connection',
        'HTTP_CACHE_CONTROL'             => 'Cache-Control',
        'HTTP_UPGRADE_INSECURE_REQUESTS' => 'Upgrade-Insecure-Requests',
        'HTTP_HOST'                      => 'Host',
        'HTTP_REFERER'                   => 'Referer',
        'HTTP_USER_AGENT'                => 'User-Agent',
    );

    /**
     * @var array parameters from $_FILES
     */
    public $files = array();


    /**
     * @var array parameters from $_REQUEST
     */
    public $parameters = array();


    /**
     * @var array parameters parsed from POST request method
     */
    public $bodyParameters = array();

    /**
     * @var array parameters parsed from query string
     */
    public $queryParameters = array();


    public $cookieParameters = array();


    /**
     * @var array parameters created from $_SERVER
     */
    public $serverParameters = array();

    public $sessionParameters = array();


    /**
     * When $parameters is defined, HttpRequest uses $parameters instead of the default $_REQUEST
     * When $files is ignored, HttpRequest uses $_FILES as the default file array.
     *
     * @param array|null $parameters The array of request parameter, usually $_REQUEST
     * @param array|null $files The array of files, usually $_FILES
     */
    public function __construct(array $parameters = null, array $files = null)
    {
        if ($parameters) {
            $this->parameters = $parameters;
        } else if (isset($_REQUEST)) {
            $this->parameters = $_REQUEST;
        }
        if ($files) {
            $this->files = FilesParameter::fix_files_array($files);
        } else if (isset($_FILES)) {
            $this->files = FilesParameter::fix_files_array($_FILES);
        }
    }


    public function openRequestBodyStream()
    {
        $input = 'php://input';
        if (isset($this->serverParameters['phpsgi.input'])) {
            $input = $this->serverParameters['phpsgi.input'];
        }
        return $this->_requestBodyFp = fopen($input);
    }

    public function closeRequestBodyStream()
    {
        if ($this->_requestBodyFp) {
            fclose($this->_requestBodyFp);
        }
    }

    public function getRequestBody()
    {
        $input = 'php://input';
        if (isset($this->serverParameters['phpsgi.input'])) {
            $input = $this->serverParameters['phpsgi.input'];
        }
        return file_get_contents($input);
    }

    /**
     * If request method is defined in $_SERVER, we return the request method
     * respectively, otherwise we return 'GET' by default.
     *
     * @return string the request method string.
     */
    public function getRequestMethod()
    {
        if (isset($this->serverParameters['REQUEST_METHOD'])) {
            return $this->serverParameters['REQUEST_METHOD'];
        }
        return 'GET';
    }

    /**
     * Check if we have the parameter
     *
     * @param string $name parameter name
     * @return boolean
     */
    public function hasParam($name)
    {
        return isset($this->parameters[$name]);
    }

    public function existsParam($name)
    {
        return array_key_exists($name, $this->parameters);
    }


    /**
     * @param string $field parameter field name
     */
    public function param($field)
    {
        if (isset($this->parameters[$field])) {
            return $this->parameters[$field];
        }
    }

    public function getFiles() 
    {
        return $this->files;
    }

    public function file($field)
    {
        if (isset($this->files[$field])) {
            return $this->files[$field];
        }
    }


    /**
     * Get request body if any
     *
     * @return string
     */
    public function getInput()
    {
        return file_get_contents('php://input');
    }


    /**
     * Parse submited body content return parameters
     *
     * @return array parameters
     */
    public function getInputParams()
    {
        $params = array();
        parse_str($this->getInput(), $params);
        return $params;
    }


    public function offsetSet($name,$value)
    {
        $this->parameters[ $name ] = $value;
    }
    
    public function offsetExists($name)
    {
        return isset($this->parameters[ $name ]);
    }
    
    public function offsetGet($name)
    {
        return $this->parameters[ $name ];
    }
    
    public function offsetUnset($name)
    {
        unset($this->paramemters[$name]);
    }

    public function getQueryParameters()
    {
        return $this->queryParameters;
    }

    public function getBodyParameters()
    {
        return $this->bodyParameters;
    }

    public function getParameters()
    {
        return $this->parameters;
    }


    public function __get($key)
    {
        if (isset($_parameterBags[$key])) {
            return $_parameterBags[$key];
        }

        // create parameter bag object and save it in cache
        switch($key)
        {
            case 'files':
                return $this->_parameterBags[$key]  = new FilesParameter($this->files);
            case 'post':
                return $this->_parameterBags[$key]  = new Parameter($this->bodyParameters);
            case 'get':
                return $this->_parameterBags[$key]  = new Parameter($this->queryParameters);
            case 'session':
                return $this->_parameterBags[$key]  = new Parameter($this->sessionParameters);
            case 'server':
                return $this->_parameterBags[$key]  = new Parameter($this->serverParameters);
            case 'request':
                return $this->_parameterBags[$key] = new Parameter($this->parameters);
            case 'cookie':
                return $this->_parameterBags[$key] = new Parameter($this->cookieParameters);
        }
    }



    /**
     * Converts global $_SERVER variables to header values.
     *
     * @return array
     */
    public static function createHeadersFromServerGlobal(array $server)
    {
        $headers = array();
        foreach (self::$httpHeaderMapping as $serverKey => $headerKey) {
            if (isset($server[$serverKey])) {
                $headers[$headerKey] = $server[$serverKey];
            }
        }
        // For extra http header fields
        foreach ($server as $key => $value) {
            if (isset(self::$httpHeaderMapping[$key])) {
                continue;
            }
            if ('HTTP_' === substr($key,0,5)) {
                $headerField = join('-',array_map('ucfirst',explode('_', strtolower(substr($key,5)))));
                $headers[$headerField] = $value;
            }
        }
        return $headers;
    }




    public function __destruct()
    {
        // If the request body stream is opened,
        // We should close it when this request object not needed anymore.
        if ($this->_requestBodyFp) {
            $this->closeRequestBodyStream();
        }
    }


    /**
     * Create request object from superglobal $GLOBALS
     *
     * @param $globals The $GLOBALS
     * @return HttpRequest
     */
    static public function createFromGlobals(array $globals)
    {
        $request = new self;
        if (isset($globals['_POST'])) {
            $request->bodyParameters = $globals['_POST'];
        }
        if (isset($globals['_GET'])) {
            $request->queryParameters = $globals['_GET'];
        }
        if (isset($globals['_REQUEST'])) {
            $request->parameters = $globals['_REQUEST'];
        }
        if (isset($globals['_COOKIE'])) {
            $request->cookieParameters = $globals['_COOKIE'];
        }
        if (isset($globals['_SESSION'])) {
            $request->sessionParameters = $globals['_SESSION'];
        }
        if (isset($globals['_FILES'])) {
            $request->files = FilesParameter::fix_files_array($globals['_FILES']);
        }
        if (isset($globals['_SERVER'])) {
            $request->serverParameters = $globals['_SERVER'];
        }
        return $request;
    }







}

<?php
namespace Universal\Http;

class HttpResponse
{

    /**
     * @var integer
     */
    public $code;


    /**
     * @var string
     */
    public $status; /* status message for Code */


    /**
     * @var string
     */
    public $contentType;


    /**
     * @var string 
     */
    public $cacheControl;

    /**
     * @var integer time
     *
     * Cache-Expires 
     */
    public $expires;


    /**
     * @var string
     */
    public $body;



    /**
     * @param integer $code status code
     * @param string $status status message
     */
    public function __construct($code = 200, $status = 'OK') 
    {
        $this->code = $code;
        $this->status = $status;
    }



    /**
     * Set status code
     *
     * @param string $code set status code.
     */
    public function code($code)
    {
        $this->code = $code;
    }



    /**
     * Set status message
     *
     * @param string $status Status message.
     */
    public function status($status)
    {
        $this->status = $status;
    }


    /**
     * Send location to header
     *
     * @param string $url
     *
     */
    public function location($url)
    {
        header( 'Location: ' . $url );
    }

    /**
     * Redirect to URL (Temporarily)
     *
     * @param string $url
     */
    public function redirect($url) 
    {
        $this->code(302);
        $this->location($url);
    }


    /**
     * Redirect permanently
     *
     * @param string $url
     */
    public function redirectPermanently($url)
    {
        $this->code(301);
        $this->status('Moved Permanently');
        $this->location($url);
    }

    /**
     * Redirect to URL (delayed)
     *  
     * @param string $url
     * @param integer $seconds (default = 1)
     */
    public function redirectLater($url, $seconds = 1) 
    {
        header( "refresh: $seconds; url=$url" );
    }


    /**
     * set content type
     *
     * @param string $contentType eg. text/html
     *
     * @code
     *
     *     $response->contentType('text/html');
     *
     * @endcode
     */
    public function contentType($contentType)
    {
        $this->contentType = $contentType;
    }

    public function body($body)
    {
        $this->body = $body;
    }


    /**
     * Set cache-control to header
     *
     * @param string $desc cache control string
     */
    public function cacheControl($desc) 
    {
        $this->cacheControl = $desc;
    }


    /**
     * Set cache-control to no-cahche
     */
    public function noCache() 
    {
        $this->cacheControl = 'no-cache, must-revalidate';
    }

    /**
     * Set cache expiry time
     *
     * @param integer $seconds
     */
    public function cacheExpiryTime($seconds) 
    {
        $this->expires = time() + $seconds;
    }


    /**
     * HTTP Status Code Helper Methods
     *
     * @link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
     * @link http://restpatterns.org/HTTP_Status_Codes
     *
     * REST Pattern
     * @link http://restpatterns.org/
     */
    public function codeOk() 
    {
        $this->code = 200;
        $this->status = 'OK';
    }

    public function codeCreated()
    {
        $this->code = 201;
        $this->status = 'Created';
    }

    public function codeAccepted()
    {
        $this->code = 202;
        $this->status = 'Accepted';
    }

    public function codeNoContent() 
    {
        $this->code = 204;
        $this->status = 'No Content';
    }

    public function codeBadRequest()
    {
        $this->code = 400;
        $this->status = 'Bad Request';
    }

    public function codeForbidden()
    {
        $this->code = 403;
        $this->status = 'Forbidden';
    }

    public function codeNotFound()
    {
        $this->code = 404;
        $this->status = 'Not found';
    }


    public function finalize()
    {
        if( $this->code ) {
            @header('HTTP/1.1 ' . $this->code . ' ' . $this->status );
        }
        if( $this->contentType ) {
            @header("Content-type: " . $this->contentType );
        }
        if( $this->cacheControl ) {
            @header('Cache-Control: '  . $this->cacheControl); // HTTP/1.1
        }
        if( $this->expires ) {
            $datestr = gmdate(DATE_RFC822, $this->expires );
            // header("Expires: Sat, 26 Jul 1997 05:00:00 GMT"); // Date in the past
            @header( "Expires: $datestr" );
        }
        return $this->body;
    }

    public function __toString() 
    {
        return $this->finalize();
    }

}



<?php 
namespace Universal\Http;
use ArrayAccess;

class Parameter implements ArrayAccess
{
    public $hash = array();

    public function __construct( & $hash = array() )
    {
        $this->hash = $hash;
    }

    public function has( $name )
    {
        return isset( $this->hash[ $name ] );
    }

    public function __isset( $name )
    {
        return isset( $this->hash[ $name ] );
    }

    public function __get( $name )
    {
        if( isset($this->hash[$name]) ) {
            return $this->hash[ $name ];
        }
    }

    public function __set( $name , $value )
    {
        $this->hash[ $name ] = $value;
    }


    public function offsetGet($key)
    {
        return $this->hash[ $key ];
    }

    public function offsetSet($key,$value)
    {
        $this->hash[ $key ] = $value;
    }

    public function offsetExists($key)
    {
        return isset( $this->hash[ $key ] );
    }

    public function offsetUnset($key)
    {
        unset( $this->hash[ $key ] );
    }

}
<?php
namespace Universal\Http;

/**
 * $put = new Universal\Http\Put;
 * $data = $put->read(1024);
 * $put->close();
 *
 * TODO:
 *
 * use SplFileObject
 */
class PutHandle
{
    private $handle;

    function __construct()
    {
        $this->handle = fopen('php://input','r');
    }

    function read($i = 1024)
    {
        return fread($this->handle, $i);
    }

    function close()
    {
        fclose($this->handle);
    }

}
<?php
namespace Universal\Http;

class StreamResponse
{
    public $boundary;


    /**
     * Currently implements MXHR interface
     */
    function __construct() {
        $this->boundary = md5(mt_rand() . time());

        // prevent error reporting
        set_error_handler(function() { return false; });

        header("Content-Type: multipart/mixed; boundary=\"{$this->boundary}\"");

        if( function_exists('apache_setenv') ) {
            apache_setenv('no-gzip', 1);
        }
        ini_set('zlib.output_compression', 0);
        ini_set('implicit_flush', 1);
        set_time_limit(0);


        // close output buffers and flush them
        while( ob_get_level() ) { 
            ob_end_flush(); 
        }
        ob_implicit_flush(1);
        restore_error_handler();
    }


    /**
     * Write content to stream
     *
     *  @param string $content
     *  @param array $headers
     */
    public function write($content, $headers = array() ) {
        echo "--{$this->boundary}\n";

        if( is_array($headers) ) {
            foreach( $headers as $k => $v ) {
                echo $k . ':';
                if( is_array($v) ) {
                    echo join(';',$v);
                } else {
                    echo $v;
                }
                echo "\n\n";
            }
        } else {
            echo $headers;
            echo "\n";
        }
        echo $content;
        echo PHP_EOL;
        flush();
    }

    public function finalize()
    {
        echo "--{$this->boundary}--\n";
    }
}


<?php
namespace Universal\Http;
use Universal\Exception\InvalidUploadFileException;
use Universal\Exception\UploadedFileMoveFailException;
use Universal\Exception\UploadErrorException;
use Exception;
use SplFileObject;
use ArrayAccess;

/**
    $file = new Universal\Http\UploadedFile(array(
        'name' => 'filename',
        'tmp_name' => '/tmp/123fbffef',
        'type' => 'image/jpg',
        'size' => 33300,
        'error' => 0,
    ));
    $file->moveTo( "file_dirs" );
*/
class UploadedFile implements ArrayAccess
{
    /**
     * The original filename in $_FILES
     *
     * @var string
     */
    protected $originalFileName;


    /**
     * The path of tmp file
     *
     * @var string
     */
    protected $tmpName;


    /**
     * Mime type of the file
     *
     * @var string
     */
    protected $type;

    protected $size;

    protected $error;

    protected $savedPath;

    protected $stash = array();

    public function __construct($tmpName, $originalFileName = null, $type = null, $savedPath = null)
    {
        $this->tmpName = $tmpName;
        $this->originalFileName = $originalFileName ?: $this->tmpName;
        $this->type = $type;
        $this->savedPath = $savedPath;
        $file = $this->savedPath ?: $this->tmpName;
        if (file_exists($file)) {
            $this->size = filesize($file);
        }
    }

    static public function createFromArray(array & $stash)
    {
        $file = new self($stash['tmp_name'], $stash['name'], $stash['type']);
        if (isset($stash['saved_path'])) {
            $file->savedPath = $stash['saved_path'];
        }
        $file->setStashedArray($stash);
        return $file;
    }

    protected function setStashedArray(array & $stash)
    {
        $this->stash = $stash;
    }

    protected function getStashedArray()
    {
        return $this->stash;
    }

    public function getSplFileObject()
    {
        $path = $this->getCurrentPath();
        return new SplFileObject($path);
    }

    /**
     * getCurrentPath returns the current target file.
     *
     * Before move_uploaded_file function call, it returns $file->tmp_name
     * After move_uploaded_file  function call, it returns $file->savedPath
     *
     */
    public function getCurrentPath()
    {
        if ($this->savedPath) {
            return $this->savedPath;
        }
        return $this->tmpName;
    }

    public function getOriginalFileName()
    {
        return $this->originalFileName;
    }


    /**
     * Return the temporary file name
     *
     * @return string temporary file name
     */
    public function getTmpName()
    {
        return $this->tmpName;
    }

    /**
     * Return the extension name from originalFileName
     *
     * @return string file extension
     */
    public function getExtension()
    {
        $parts = explode('.',$this->originalFileName);
        return end($parts);
    }

    /**
     * Validate file size by K bytes
     *
     * @param integer $limitSize file size in K bytes
     * @return boolean true if the file size is under the limitSize.
     */
    public function validateSize($limitSize)
    {
        return ($this->size / 1024) < $limitSize;
    }

    public function validateExtension(array $exts)
    {
        $ext = strtolower($this->getExtension());
        return in_array($ext, $exts);
    }

    public function getSavedPath()
    {
        return $this->savedPath;
    }

    public function getType()
    {
        return $this->type;
    }


    /**
     * @return integer file size in bytes
     */
    public function getSize()
    {
        return $this->size;
    }


    /**
     * isMoved checked 'saved_path' param, if the file is already moved, it
     * return true, otherwise it returns falsec:w
     *
     * @return boolean
     */
    public function isMoved()
    {
        return $this->getSavedPath() ? true : false;
    }

    /**
     * isUploadedFile calls is_uploaded_file function to confirm that the file
     * is uploaded through HTTPS? prototol
     *
     * @return boolean
     */
    public function isUploadedFile()
    {
        return is_uploaded_file($this->tmpName);
    }

    /**
     * move method moves file from 'tmp_name' to a new path.
     *
     * move method doesn't modify tmp_name attribute
     * rather than that, we set the saved_path attribute
     * for location of these moved files.
     *
     * Just like moveTo, but instead of passing directory, it only accept
     * filepath.
     *
     * @param string $newPath
     * @param boolean $rename
     * @return path|boolean
     *
     * return FALSE when operation failed.
     *
     * return path string if the operation succeeded.
     */
    public function move($newPath, $rename = false)
    {
        if ($this->savedPath) {
            return $this->savedPath;
        }

        $tmpFile = $this->tmpName;

        // Avoid file name duplication
        /*
        $fileCnt = 1;
        while (file_exists($newPath)) {
            $newPath =
                $targetDir . DIRECTORY_SEPARATOR . 
                    FileUtils::filename_suffix( $newPath , '_' . $fileCnt++ );
        }
        */

        $ret = false;
        if ($rename) {
            $ret = rename($tmpFile, $newPath);
        } else {
            $ret = $this->moveUploadedFile($tmpFile, $newPath );
        }
        $this->savedPath = $this->stash['saved_path'] = $newPath;

        if ($ret === false) {
            return $ret;
        }
        return $newPath;
    }

    /**
     * copy method copies the file from 'tmp_name' to a new path.
     *
     * @return boolean
     */
    public function copy($targetPath)
    {
        return copy($this->tmpName, $targetPath);
    }


    /**
     * copyTo method calls 'copy' method to copy the file.
     *
     * @return boolean
     */
    public function copyTo($targetDir)
    {
        // if targetFilename is not given,
        // we should take the filename from original filename by using basename.
        $targetFileName = basename($this->originalFileName);

        // relative file path.
        $newPath = $targetDir . DIRECTORY_SEPARATOR . $targetFileName;
        return $this->copy($newPath);
    }

    /**
     * moveTo method doesn't modify tmp_name attribute
     * rather than that, we set the saved_path attribute
     * for location of these moved files.
     *
     * @return path|boolean 
     *
     * return FALSE when operation failed.
     *
     * return path string if the operation succeeded.
     */
    public function moveTo($targetDir, $rename = false)
    {
        // if targetFilename is not given,
        // we should take the filename from original filename by using basename.
        $targetFileName = basename($this->originalFileName);

        // relative file path.
        $newPath = $targetDir . DIRECTORY_SEPARATOR . $targetFileName;
        return $this->move($newPath, $rename);
    }

    public function moveUploadedFile($target)
    {
        // if the tmp file is already moved
        if (isset($this->savedPath)) {
            return $this->savedPath;
        }
        if ($this->stash['error'] != 0) {
            throw new UploadErrorException($this->stash,"An error occured when uploading file {$this->tmpName}.", $this->stash['error']);
        }
        if (!is_uploaded_file($this->tmpName)) {
            throw new InvalidUploadFileException($this->stash, "File {$this->tmpName} is not an uploaded file.");
        }
        if (false === move_uploaded_file($this->tmpName, $target)) {
            throw new UploadedFileMoveFailException($this->stash, "File {$this->tmpName} upload failed.");
        }
        // Update stash value
        return $this->savedPath = $this->stash['saved_path'] = $moveTo;
    }

    public function deleteTmp()
    {
        unlink($this->tmpName);
    }

    public function found()
    {
        return $this->name ? true : false;
    }

    public function hasError()
    {
        return $this->error != 0;
    }

    public function getUserErrorMessage()
    {
        // error messages for normal users.
        switch ($this->error) {
            case UPLOAD_ERR_OK:
                return "OK";
            case UPLOAD_ERR_INI_SIZE || UPLOAD_ERR_FORM_SIZE:
                return "The upload file exceeds the limit.";
            case UPLOAD_ERR_PARTIAL:
                return "The uploaded file was only partially uploaded.";
            case UPLOAD_ERR_NO_FILE:
                return "No file was uploaded.";
            case UPLOAD_ERR_CANT_WRITE:
                return "Failed to write file to disk.";
            case UPLOAD_ERR_EXTENSION:
                return "A PHP extension stopped the file upload.";
            default:
                return "Unknown error.";
        }
    }

    /**
     * getSystemErrorMessage returns the system built-in error message.
     *
     * @return string
     */
    public function getSystemErrorMessage()
    {
        // built-in php error description
        switch ($this->error) {
            case UPLOAD_ERR_OK:
                return "There is no error, the file uploaded with success.";
            case UPLOAD_ERR_INI_SIZE:
                return "The uploaded file exceeds the upload_max_filesize directive in php.ini.";
            case UPLOAD_ERR_FORM_SIZE:
                return "The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form.";
            case UPLOAD_ERR_PARTIAL:
                return "The uploaded file was only partially uploaded.";
            case UPLOAD_ERR_NO_FILE:
                return "No file was uploaded.";
            case UPLOAD_ERR_NO_TMP_DIR:
                return "Missing a temporary folder. Introduced in PHP 4.3.10 and PHP 5.0.3.";
            case UPLOAD_ERR_CANT_WRITE:
                return "Failed to write file to disk. Introduced in PHP 5.1.0.";
            case UPLOAD_ERR_EXTENSION:
                return "A PHP extension stopped the file upload. PHP does not provide a way to ascertain which extension caused the file upload to stop; examining the list of loaded extensions with phpinfo() may help. Introduced in PHP 5.2.0.";
            default:
                return "Unknown Error.";
        }
    }


    public function offsetSet($name,$value)
    {
        $this->stash[ $name ] = $value;
    }
    
    public function offsetExists($name)
    {
        return isset($this->stash[ $name ]);
    }
    
    public function offsetGet($name)
    {
        return $this->stash[ $name ];
    }
    
    public function offsetUnset($name)
    {
        unset($this->stash[$name]);
    }

}
<?php 
namespace Universal\Requirement;

use Exception;

class RequirePhpException extends Exception {}
class RequireExtensionException extends Exception {} 
class RequireFunctionException extends Exception {}
class RequireClassException extends Exception {}

/**
 * Requirement check class
 *
 * @code
 *
 * try {
 *      $require = new Universal\Requirement\Requirement;
 *      $require->extensions( 'apc','mbstring' );
 *      $require->classes( 'ClassName' , 'ClassName2' );
 *      $require->functions( 'func1' , 'func2' , 'function3' )
 * }
 * catch( RequireExtensionException $e ) {
 * }
 * catch( RequireFunctionException $e ) {
 * }
 * catch( RequireClassException $e ) {
 * }
 *
 */
class Requirement
{

    /**
     * check php version
     *
     * @param string $version
     */
    function php($version)
    {
        if( version_compare( phpversion() , $version ) < 0 ) {
            throw new RequirePhpException( "PHP Version $version is required." );
        }
        return true;
    }


    /**
     * check extensions
     */
    function extensions()
    {
        $extensions = func_get_args();
        foreach( $extensions as $extensionName ) {
            if( ! extension_loaded( $extensionName ) )
                throw new RequireExtensionException( "Extension $extensionName is required" );
        }
        return true;
    }

    /**
     * check functions
     */
    function functions()
    {
        $functions = func_get_args();
        foreach( $functions as $function ) {
            if( ! function_exists( $function ) )
                throw new RequireFunctionException( "Function $function is required" );
        }
        return true;
    }


    /**
     * check classes
     */
    function classes()
    {
        $classes = func_get_args();
        foreach( $classes as $class ) {
            if( ! class_exists( $class ) )
                throw new RequireClassException( "Class $class is required" );
        }
        return true;
    }

}


<?php

/*
 * This file is part of Pimple.
 *
 * Copyright (c) 2009 Fabien Potencier
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

namespace Pimple;

/**
 * Container main class.
 *
 * @author  Fabien Potencier
 */
class Container implements \ArrayAccess
{
    private $values = array();
    private $factories;
    private $protected;
    private $frozen = array();
    private $raw = array();
    private $keys = array();

    /**
     * Instantiate the container.
     *
     * Objects and parameters can be passed as argument to the constructor.
     *
     * @param array $values The parameters or objects.
     */
    public function __construct(array $values = array())
    {
        $this->factories = new \SplObjectStorage();
        $this->protected = new \SplObjectStorage();

        foreach ($values as $key => $value) {
            $this->offsetSet($key, $value);
        }
    }

    /**
     * Sets a parameter or an object.
     *
     * Objects must be defined as Closures.
     *
     * Allowing any PHP callable leads to difficult to debug problems
     * as function names (strings) are callable (creating a function with
     * the same name as an existing parameter would break your container).
     *
     * @param string $id    The unique identifier for the parameter or object
     * @param mixed  $value The value of the parameter or a closure to define an object
     *
     * @throws \RuntimeException Prevent override of a frozen service
     */
    public function offsetSet($id, $value)
    {
        if (isset($this->frozen[$id])) {
            throw new \RuntimeException(sprintf('Cannot override frozen service "%s".', $id));
        }

        $this->values[$id] = $value;
        $this->keys[$id] = true;
    }

    /**
     * Gets a parameter or an object.
     *
     * @param string $id The unique identifier for the parameter or object
     *
     * @return mixed The value of the parameter or an object
     *
     * @throws \InvalidArgumentException if the identifier is not defined
     */
    public function offsetGet($id)
    {
        if (!isset($this->keys[$id])) {
            throw new \InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id));
        }

        if (
            isset($this->raw[$id])
            || !is_object($this->values[$id])
            || isset($this->protected[$this->values[$id]])
            || !method_exists($this->values[$id], '__invoke')
        ) {
            return $this->values[$id];
        }

        if (isset($this->factories[$this->values[$id]])) {
            return $this->values[$id]($this);
        }

        $raw = $this->values[$id];
        $val = $this->values[$id] = $raw($this);
        $this->raw[$id] = $raw;

        $this->frozen[$id] = true;

        return $val;
    }

    /**
     * Checks if a parameter or an object is set.
     *
     * @param string $id The unique identifier for the parameter or object
     *
     * @return bool
     */
    public function offsetExists($id)
    {
        return isset($this->keys[$id]);
    }

    /**
     * Unsets a parameter or an object.
     *
     * @param string $id The unique identifier for the parameter or object
     */
    public function offsetUnset($id)
    {
        if (isset($this->keys[$id])) {
            if (is_object($this->values[$id])) {
                unset($this->factories[$this->values[$id]], $this->protected[$this->values[$id]]);
            }

            unset($this->values[$id], $this->frozen[$id], $this->raw[$id], $this->keys[$id]);
        }
    }

    /**
     * Marks a callable as being a factory service.
     *
     * @param callable $callable A service definition to be used as a factory
     *
     * @return callable The passed callable
     *
     * @throws \InvalidArgumentException Service definition has to be a closure of an invokable object
     */
    public function factory($callable)
    {
        if (!method_exists($callable, '__invoke')) {
            throw new \InvalidArgumentException('Service definition is not a Closure or invokable object.');
        }

        $this->factories->attach($callable);

        return $callable;
    }

    /**
     * Protects a callable from being interpreted as a service.
     *
     * This is useful when you want to store a callable as a parameter.
     *
     * @param callable $callable A callable to protect from being evaluated
     *
     * @return callable The passed callable
     *
     * @throws \InvalidArgumentException Service definition has to be a closure of an invokable object
     */
    public function protect($callable)
    {
        if (!method_exists($callable, '__invoke')) {
            throw new \InvalidArgumentException('Callable is not a Closure or invokable object.');
        }

        $this->protected->attach($callable);

        return $callable;
    }

    /**
     * Gets a parameter or the closure defining an object.
     *
     * @param string $id The unique identifier for the parameter or object
     *
     * @return mixed The value of the parameter or the closure defining an object
     *
     * @throws \InvalidArgumentException if the identifier is not defined
     */
    public function raw($id)
    {
        if (!isset($this->keys[$id])) {
            throw new \InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id));
        }

        if (isset($this->raw[$id])) {
            return $this->raw[$id];
        }

        return $this->values[$id];
    }

    /**
     * Extends an object definition.
     *
     * Useful when you want to extend an existing object definition,
     * without necessarily loading that object.
     *
     * @param string   $id       The unique identifier for the object
     * @param callable $callable A service definition to extend the original
     *
     * @return callable The wrapped callable
     *
     * @throws \InvalidArgumentException if the identifier is not defined or not a service definition
     */
    public function extend($id, $callable)
    {
        if (!isset($this->keys[$id])) {
            throw new \InvalidArgumentException(sprintf('Identifier "%s" is not defined.', $id));
        }

        if (!is_object($this->values[$id]) || !method_exists($this->values[$id], '__invoke')) {
            throw new \InvalidArgumentException(sprintf('Identifier "%s" does not contain an object definition.', $id));
        }

        if (!is_object($callable) || !method_exists($callable, '__invoke')) {
            throw new \InvalidArgumentException('Extension service definition is not a Closure or invokable object.');
        }

        $factory = $this->values[$id];

        $extended = function ($c) use ($callable, $factory) {
            return $callable($factory($c), $c);
        };

        if (isset($this->factories[$factory])) {
            $this->factories->detach($factory);
            $this->factories->attach($extended);
        }

        return $this[$id] = $extended;
    }

    /**
     * Returns all defined value names.
     *
     * @return array An array of value names
     */
    public function keys()
    {
        return array_keys($this->values);
    }

    /**
     * Registers a service provider.
     *
     * @param ServiceProviderInterface $provider A ServiceProviderInterface instance
     * @param array                    $values   An array of values that customizes the provider
     *
     * @return static
     */
    public function register(ServiceProviderInterface $provider, array $values = array())
    {
        $provider->register($this);

        foreach ($values as $key => $value) {
            $this[$key] = $value;
        }

        return $this;
    }
}
<?php

/*
 * This file is part of Pimple.
 *
 * Copyright (c) 2009 Fabien Potencier
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

namespace Pimple;

/**
 * Pimple service provider interface.
 *
 * @author  Fabien Potencier
 * @author  Dominik Zogg
 */
interface ServiceProviderInterface
{
    /**
     * Registers services on the given container.
     *
     * This method should only be used to configure services and parameters.
     * It should not get services.
     *
     * @param Container $pimple A container instance
     */
    public function register(Container $pimple);
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Adapter;

@trigger_error('The '.__NAMESPACE__.'\AbstractAdapter class is deprecated since version 2.8 and will be removed in 3.0. Use directly the Finder class instead.', E_USER_DEPRECATED);

/**
 * Interface for finder engine implementations.
 *
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0. Use Finder instead.
 */
abstract class AbstractAdapter implements AdapterInterface
{
    protected $followLinks = false;
    protected $mode = 0;
    protected $minDepth = 0;
    protected $maxDepth = PHP_INT_MAX;
    protected $exclude = array();
    protected $names = array();
    protected $notNames = array();
    protected $contains = array();
    protected $notContains = array();
    protected $sizes = array();
    protected $dates = array();
    protected $filters = array();
    protected $sort = false;
    protected $paths = array();
    protected $notPaths = array();
    protected $ignoreUnreadableDirs = false;

    private static $areSupported = array();

    /**
     * {@inheritdoc}
     */
    public function isSupported()
    {
        $name = $this->getName();

        if (!array_key_exists($name, self::$areSupported)) {
            self::$areSupported[$name] = $this->canBeUsed();
        }

        return self::$areSupported[$name];
    }

    /**
     * {@inheritdoc}
     */
    public function setFollowLinks($followLinks)
    {
        $this->followLinks = $followLinks;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setMode($mode)
    {
        $this->mode = $mode;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setDepths(array $depths)
    {
        $this->minDepth = 0;
        $this->maxDepth = PHP_INT_MAX;

        foreach ($depths as $comparator) {
            switch ($comparator->getOperator()) {
                case '>':
                    $this->minDepth = $comparator->getTarget() + 1;
                    break;
                case '>=':
                    $this->minDepth = $comparator->getTarget();
                    break;
                case '<':
                    $this->maxDepth = $comparator->getTarget() - 1;
                    break;
                case '<=':
                    $this->maxDepth = $comparator->getTarget();
                    break;
                default:
                    $this->minDepth = $this->maxDepth = $comparator->getTarget();
            }
        }

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setExclude(array $exclude)
    {
        $this->exclude = $exclude;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setNames(array $names)
    {
        $this->names = $names;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setNotNames(array $notNames)
    {
        $this->notNames = $notNames;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setContains(array $contains)
    {
        $this->contains = $contains;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setNotContains(array $notContains)
    {
        $this->notContains = $notContains;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setSizes(array $sizes)
    {
        $this->sizes = $sizes;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setDates(array $dates)
    {
        $this->dates = $dates;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setFilters(array $filters)
    {
        $this->filters = $filters;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setSort($sort)
    {
        $this->sort = $sort;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setPath(array $paths)
    {
        $this->paths = $paths;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function setNotPath(array $notPaths)
    {
        $this->notPaths = $notPaths;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function ignoreUnreadableDirs($ignore = true)
    {
        $this->ignoreUnreadableDirs = (bool) $ignore;

        return $this;
    }

    /**
     * Returns whether the adapter is supported in the current environment.
     *
     * This method should be implemented in all adapters. Do not implement
     * isSupported in the adapters as the generic implementation provides a cache
     * layer.
     *
     * @see isSupported()
     *
     * @return bool Whether the adapter is supported
     */
    abstract protected function canBeUsed();
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Adapter;

@trigger_error('The '.__NAMESPACE__.'\AbstractFindAdapter class is deprecated since version 2.8 and will be removed in 3.0. Use directly the Finder class instead.', E_USER_DEPRECATED);

use Symfony\Component\Finder\Exception\AccessDeniedException;
use Symfony\Component\Finder\Iterator;
use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Expression\Expression;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Comparator\NumberComparator;
use Symfony\Component\Finder\Comparator\DateComparator;

/**
 * Shell engine implementation using GNU find command.
 *
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0. Use Finder instead.
 */
abstract class AbstractFindAdapter extends AbstractAdapter
{
    /**
     * @var Shell
     */
    protected $shell;

    /**
     * Constructor.
     */
    public function __construct()
    {
        $this->shell = new Shell();
    }

    /**
     * {@inheritdoc}
     */
    public function searchInDirectory($dir)
    {
        // having "/../" in path make find fail
        $dir = realpath($dir);

        // searching directories containing or not containing strings leads to no result
        if (Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES === $this->mode && ($this->contains || $this->notContains)) {
            return new Iterator\FilePathsIterator(array(), $dir);
        }

        $command = Command::create();
        $find = $this->buildFindCommand($command, $dir);

        if ($this->followLinks) {
            $find->add('-follow');
        }

        $find->add('-mindepth')->add($this->minDepth + 1);

        if (PHP_INT_MAX !== $this->maxDepth) {
            $find->add('-maxdepth')->add($this->maxDepth + 1);
        }

        if (Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES === $this->mode) {
            $find->add('-type d');
        } elseif (Iterator\FileTypeFilterIterator::ONLY_FILES === $this->mode) {
            $find->add('-type f');
        }

        $this->buildNamesFiltering($find, $this->names);
        $this->buildNamesFiltering($find, $this->notNames, true);
        $this->buildPathsFiltering($find, $dir, $this->paths);
        $this->buildPathsFiltering($find, $dir, $this->notPaths, true);
        $this->buildSizesFiltering($find, $this->sizes);
        $this->buildDatesFiltering($find, $this->dates);

        $useGrep = $this->shell->testCommand('grep') && $this->shell->testCommand('xargs');
        $useSort = is_int($this->sort) && $this->shell->testCommand('sort') && $this->shell->testCommand('cut');

        if ($useGrep && ($this->contains || $this->notContains)) {
            $grep = $command->ins('grep');
            $this->buildContentFiltering($grep, $this->contains);
            $this->buildContentFiltering($grep, $this->notContains, true);
        }

        if ($useSort) {
            $this->buildSorting($command, $this->sort);
        }

        $command->setErrorHandler(
            $this->ignoreUnreadableDirs
                // If directory is unreadable and finder is set to ignore it, `stderr` is ignored.
                ? function ($stderr) { }
                : function ($stderr) { throw new AccessDeniedException($stderr); }
        );

        $paths = $this->shell->testCommand('uniq') ? $command->add('| uniq')->execute() : array_unique($command->execute());
        $iterator = new Iterator\FilePathsIterator($paths, $dir);

        if ($this->exclude) {
            $iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $this->exclude);
        }

        if (!$useGrep && ($this->contains || $this->notContains)) {
            $iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);
        }

        if ($this->filters) {
            $iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);
        }

        if (!$useSort && $this->sort) {
            $iteratorAggregate = new Iterator\SortableIterator($iterator, $this->sort);
            $iterator = $iteratorAggregate->getIterator();
        }

        return $iterator;
    }

    /**
     * {@inheritdoc}
     */
    protected function canBeUsed()
    {
        return $this->shell->testCommand('find');
    }

    /**
     * @param Command $command
     * @param string  $dir
     *
     * @return Command
     */
    protected function buildFindCommand(Command $command, $dir)
    {
        return $command
            ->ins('find')
            ->add('find ')
            ->arg($dir)
            ->add('-noleaf'); // the -noleaf option is required for filesystems that don't follow the '.' and '..' conventions
    }

    /**
     * @param Command  $command
     * @param string[] $names
     * @param bool     $not
     */
    private function buildNamesFiltering(Command $command, array $names, $not = false)
    {
        if (0 === count($names)) {
            return;
        }

        $command->add($not ? '-not' : null)->cmd('(');

        foreach ($names as $i => $name) {
            $expr = Expression::create($name);

            // Find does not support expandable globs ("*.{a,b}" syntax).
            if ($expr->isGlob() && $expr->getGlob()->isExpandable()) {
                $expr = Expression::create($expr->getGlob()->toRegex(false));
            }

            // Fixes 'not search' and 'full path matching' regex problems.
            // - Jokers '.' are replaced by [^/].
            // - We add '[^/]*' before and after regex (if no ^|$ flags are present).
            if ($expr->isRegex()) {
                $regex = $expr->getRegex();
                $regex->prepend($regex->hasStartFlag() ? '/' : '/[^/]*')
                    ->setStartFlag(false)
                    ->setStartJoker(true)
                    ->replaceJokers('[^/]');
                if (!$regex->hasEndFlag() || $regex->hasEndJoker()) {
                    $regex->setEndJoker(false)->append('[^/]*');
                }
            }

            $command
                ->add($i > 0 ? '-or' : null)
                ->add($expr->isRegex()
                    ? ($expr->isCaseSensitive() ? '-regex' : '-iregex')
                    : ($expr->isCaseSensitive() ? '-name' : '-iname')
                )
                ->arg($expr->renderPattern());
        }

        $command->cmd(')');
    }

    /**
     * @param Command  $command
     * @param string   $dir
     * @param string[] $paths
     * @param bool     $not
     */
    private function buildPathsFiltering(Command $command, $dir, array $paths, $not = false)
    {
        if (0 === count($paths)) {
            return;
        }

        $command->add($not ? '-not' : null)->cmd('(');

        foreach ($paths as $i => $path) {
            $expr = Expression::create($path);

            // Find does not support expandable globs ("*.{a,b}" syntax).
            if ($expr->isGlob() && $expr->getGlob()->isExpandable()) {
                $expr = Expression::create($expr->getGlob()->toRegex(false));
            }

            // Fixes 'not search' regex problems.
            if ($expr->isRegex()) {
                $regex = $expr->getRegex();
                $regex->prepend($regex->hasStartFlag() ? preg_quote($dir).DIRECTORY_SEPARATOR : '.*')->setEndJoker(!$regex->hasEndFlag());
            } else {
                $expr->prepend('*')->append('*');
            }

            $command
                ->add($i > 0 ? '-or' : null)
                ->add($expr->isRegex()
                    ? ($expr->isCaseSensitive() ? '-regex' : '-iregex')
                    : ($expr->isCaseSensitive() ? '-path' : '-ipath')
                )
                ->arg($expr->renderPattern());
        }

        $command->cmd(')');
    }

    /**
     * @param Command            $command
     * @param NumberComparator[] $sizes
     */
    private function buildSizesFiltering(Command $command, array $sizes)
    {
        foreach ($sizes as $i => $size) {
            $command->add($i > 0 ? '-and' : null);

            switch ($size->getOperator()) {
                case '<=':
                    $command->add('-size -'.($size->getTarget() + 1).'c');
                    break;
                case '>=':
                    $command->add('-size +'.($size->getTarget() - 1).'c');
                    break;
                case '>':
                    $command->add('-size +'.$size->getTarget().'c');
                    break;
                case '!=':
                    $command->add('-size -'.$size->getTarget().'c');
                    $command->add('-size +'.$size->getTarget().'c');
                    break;
                case '<':
                default:
                    $command->add('-size -'.$size->getTarget().'c');
            }
        }
    }

    /**
     * @param Command          $command
     * @param DateComparator[] $dates
     */
    private function buildDatesFiltering(Command $command, array $dates)
    {
        foreach ($dates as $i => $date) {
            $command->add($i > 0 ? '-and' : null);

            $mins = (int) round((time() - $date->getTarget()) / 60);

            if (0 > $mins) {
                // mtime is in the future
                $command->add(' -mmin -0');
                // we will have no result so we don't need to continue
                return;
            }

            switch ($date->getOperator()) {
                case '<=':
                    $command->add('-mmin +'.($mins - 1));
                    break;
                case '>=':
                    $command->add('-mmin -'.($mins + 1));
                    break;
                case '>':
                    $command->add('-mmin -'.$mins);
                    break;
                case '!=':
                    $command->add('-mmin +'.$mins.' -or -mmin -'.$mins);
                    break;
                case '<':
                default:
                    $command->add('-mmin +'.$mins);
            }
        }
    }

    /**
     * @param Command $command
     * @param string  $sort
     *
     * @throws \InvalidArgumentException
     */
    private function buildSorting(Command $command, $sort)
    {
        $this->buildFormatSorting($command, $sort);
    }

    /**
     * @param Command $command
     * @param string  $sort
     */
    abstract protected function buildFormatSorting(Command $command, $sort);

    /**
     * @param Command $command
     * @param array   $contains
     * @param bool    $not
     */
    abstract protected function buildContentFiltering(Command $command, array $contains, $not = false);
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Adapter;

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0.
 */
interface AdapterInterface
{
    /**
     * @param bool $followLinks
     *
     * @return AdapterInterface Current instance
     */
    public function setFollowLinks($followLinks);

    /**
     * @param int $mode
     *
     * @return AdapterInterface Current instance
     */
    public function setMode($mode);

    /**
     * @param array $exclude
     *
     * @return AdapterInterface Current instance
     */
    public function setExclude(array $exclude);

    /**
     * @param array $depths
     *
     * @return AdapterInterface Current instance
     */
    public function setDepths(array $depths);

    /**
     * @param array $names
     *
     * @return AdapterInterface Current instance
     */
    public function setNames(array $names);

    /**
     * @param array $notNames
     *
     * @return AdapterInterface Current instance
     */
    public function setNotNames(array $notNames);

    /**
     * @param array $contains
     *
     * @return AdapterInterface Current instance
     */
    public function setContains(array $contains);

    /**
     * @param array $notContains
     *
     * @return AdapterInterface Current instance
     */
    public function setNotContains(array $notContains);

    /**
     * @param array $sizes
     *
     * @return AdapterInterface Current instance
     */
    public function setSizes(array $sizes);

    /**
     * @param array $dates
     *
     * @return AdapterInterface Current instance
     */
    public function setDates(array $dates);

    /**
     * @param array $filters
     *
     * @return AdapterInterface Current instance
     */
    public function setFilters(array $filters);

    /**
     * @param \Closure|int $sort
     *
     * @return AdapterInterface Current instance
     */
    public function setSort($sort);

    /**
     * @param array $paths
     *
     * @return AdapterInterface Current instance
     */
    public function setPath(array $paths);

    /**
     * @param array $notPaths
     *
     * @return AdapterInterface Current instance
     */
    public function setNotPath(array $notPaths);

    /**
     * @param bool $ignore
     *
     * @return AdapterInterface Current instance
     */
    public function ignoreUnreadableDirs($ignore = true);

    /**
     * @param string $dir
     *
     * @return \Iterator Result iterator
     */
    public function searchInDirectory($dir);

    /**
     * Tests adapter support for current platform.
     *
     * @return bool
     */
    public function isSupported();

    /**
     * Returns adapter name.
     *
     * @return string
     */
    public function getName();
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Adapter;

@trigger_error('The '.__NAMESPACE__.'\BsdFindAdapter class is deprecated since version 2.8 and will be removed in 3.0. Use directly the Finder class instead.', E_USER_DEPRECATED);

use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Iterator\SortableIterator;
use Symfony\Component\Finder\Expression\Expression;

/**
 * Shell engine implementation using BSD find command.
 *
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0. Use Finder instead.
 */
class BsdFindAdapter extends AbstractFindAdapter
{
    /**
     * {@inheritdoc}
     */
    public function getName()
    {
        return 'bsd_find';
    }

    /**
     * {@inheritdoc}
     */
    protected function canBeUsed()
    {
        return in_array($this->shell->getType(), array(Shell::TYPE_BSD, Shell::TYPE_DARWIN)) && parent::canBeUsed();
    }

    /**
     * {@inheritdoc}
     */
    protected function buildFormatSorting(Command $command, $sort)
    {
        switch ($sort) {
            case SortableIterator::SORT_BY_NAME:
                $command->ins('sort')->add('| sort');

                return;
            case SortableIterator::SORT_BY_TYPE:
                $format = '%HT';
                break;
            case SortableIterator::SORT_BY_ACCESSED_TIME:
                $format = '%a';
                break;
            case SortableIterator::SORT_BY_CHANGED_TIME:
                $format = '%c';
                break;
            case SortableIterator::SORT_BY_MODIFIED_TIME:
                $format = '%m';
                break;
            default:
                throw new \InvalidArgumentException(sprintf('Unknown sort options: %s.', $sort));
        }

        $command
            ->add('-print0 | xargs -0 stat -f')
            ->arg($format.'%t%N')
            ->add('| sort | cut -f 2');
    }

    /**
     * {@inheritdoc}
     */
    protected function buildFindCommand(Command $command, $dir)
    {
        parent::buildFindCommand($command, $dir)->addAtIndex('-E', 1);

        return $command;
    }

    /**
     * {@inheritdoc}
     */
    protected function buildContentFiltering(Command $command, array $contains, $not = false)
    {
        foreach ($contains as $contain) {
            $expr = Expression::create($contain);

            // todo: avoid forking process for each $pattern by using multiple -e options
            $command
                ->add('| grep -v \'^$\'')
                ->add('| xargs -I{} grep -I')
                ->add($expr->isCaseSensitive() ? null : '-i')
                ->add($not ? '-L' : '-l')
                ->add('-Ee')->arg($expr->renderPattern())
                ->add('{}')
            ;
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Adapter;

@trigger_error('The '.__NAMESPACE__.'\GnuFindAdapter class is deprecated since version 2.8 and will be removed in 3.0. Use directly the Finder class instead.', E_USER_DEPRECATED);

use Symfony\Component\Finder\Shell\Shell;
use Symfony\Component\Finder\Shell\Command;
use Symfony\Component\Finder\Iterator\SortableIterator;
use Symfony\Component\Finder\Expression\Expression;

/**
 * Shell engine implementation using GNU find command.
 *
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0. Use Finder instead.
 */
class GnuFindAdapter extends AbstractFindAdapter
{
    /**
     * {@inheritdoc}
     */
    public function getName()
    {
        return 'gnu_find';
    }

    /**
     * {@inheritdoc}
     */
    protected function buildFormatSorting(Command $command, $sort)
    {
        switch ($sort) {
            case SortableIterator::SORT_BY_NAME:
                $command->ins('sort')->add('| sort');

                return;
            case SortableIterator::SORT_BY_TYPE:
                $format = '%y';
                break;
            case SortableIterator::SORT_BY_ACCESSED_TIME:
                $format = '%A@';
                break;
            case SortableIterator::SORT_BY_CHANGED_TIME:
                $format = '%C@';
                break;
            case SortableIterator::SORT_BY_MODIFIED_TIME:
                $format = '%T@';
                break;
            default:
                throw new \InvalidArgumentException(sprintf('Unknown sort options: %s.', $sort));
        }

        $command
            ->get('find')
            ->add('-printf')
            ->arg($format.' %h/%f\\n')
            ->add('| sort | cut')
            ->arg('-d ')
            ->arg('-f2-')
        ;
    }

    /**
     * {@inheritdoc}
     */
    protected function canBeUsed()
    {
        return $this->shell->getType() === Shell::TYPE_UNIX && parent::canBeUsed();
    }

    /**
     * {@inheritdoc}
     */
    protected function buildFindCommand(Command $command, $dir)
    {
        return parent::buildFindCommand($command, $dir)->add('-regextype posix-extended');
    }

    /**
     * {@inheritdoc}
     */
    protected function buildContentFiltering(Command $command, array $contains, $not = false)
    {
        foreach ($contains as $contain) {
            $expr = Expression::create($contain);

            // todo: avoid forking process for each $pattern by using multiple -e options
            $command
                ->add('| xargs -I{} -r grep -I')
                ->add($expr->isCaseSensitive() ? null : '-i')
                ->add($not ? '-L' : '-l')
                ->add('-Ee')->arg($expr->renderPattern())
                ->add('{}')
            ;
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Adapter;

@trigger_error('The '.__NAMESPACE__.'\PhpAdapter class is deprecated since version 2.8 and will be removed in 3.0. Use directly the Finder class instead.', E_USER_DEPRECATED);

use Symfony\Component\Finder\Iterator;

/**
 * PHP finder engine implementation.
 *
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0. Use Finder instead.
 */
class PhpAdapter extends AbstractAdapter
{
    /**
     * {@inheritdoc}
     */
    public function searchInDirectory($dir)
    {
        $flags = \RecursiveDirectoryIterator::SKIP_DOTS;

        if ($this->followLinks) {
            $flags |= \RecursiveDirectoryIterator::FOLLOW_SYMLINKS;
        }

        $iterator = new Iterator\RecursiveDirectoryIterator($dir, $flags, $this->ignoreUnreadableDirs);

        if ($this->exclude) {
            $iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $this->exclude);
        }

        $iterator = new \RecursiveIteratorIterator($iterator, \RecursiveIteratorIterator::SELF_FIRST);

        if ($this->minDepth > 0 || $this->maxDepth < PHP_INT_MAX) {
            $iterator = new Iterator\DepthRangeFilterIterator($iterator, $this->minDepth, $this->maxDepth);
        }

        if ($this->mode) {
            $iterator = new Iterator\FileTypeFilterIterator($iterator, $this->mode);
        }

        if ($this->names || $this->notNames) {
            $iterator = new Iterator\FilenameFilterIterator($iterator, $this->names, $this->notNames);
        }

        if ($this->contains || $this->notContains) {
            $iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);
        }

        if ($this->sizes) {
            $iterator = new Iterator\SizeRangeFilterIterator($iterator, $this->sizes);
        }

        if ($this->dates) {
            $iterator = new Iterator\DateRangeFilterIterator($iterator, $this->dates);
        }

        if ($this->filters) {
            $iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);
        }

        if ($this->paths || $this->notPaths) {
            $iterator = new Iterator\PathFilterIterator($iterator, $this->paths, $this->notPaths);
        }

        if ($this->sort) {
            $iteratorAggregate = new Iterator\SortableIterator($iterator, $this->sort);
            $iterator = $iteratorAggregate->getIterator();
        }

        return $iterator;
    }

    /**
     * {@inheritdoc}
     */
    public function getName()
    {
        return 'php';
    }

    /**
     * {@inheritdoc}
     */
    protected function canBeUsed()
    {
        return true;
    }
}
CHANGELOG
=========

2.8.0
-----

 * deprecated adapters and related classes

2.5.0
-----
 * added support for GLOB_BRACE in the paths passed to Finder::in()

2.3.0
-----

 * added a way to ignore unreadable directories (via Finder::ignoreUnreadableDirs())
 * unified the way subfolders that are not executable are handled by always throwing an AccessDeniedException exception

2.2.0
-----

 * added Finder::path() and Finder::notPath() methods
 * added finder adapters to improve performance on specific platforms
 * added support for wildcard characters (glob patterns) in the paths passed
   to Finder::in()

2.1.0
-----

 * added Finder::sortByAccessedTime(), Finder::sortByChangedTime(), and
   Finder::sortByModifiedTime()
 * added Countable to Finder
 * added support for an array of directories as an argument to
   Finder::exclude()
 * added searching based on the file content via Finder::contains() and
   Finder::notContains()
 * added support for the != operator in the Comparator
 * [BC BREAK] filter expressions (used for file name and content) are no more
   considered as regexps but glob patterns when they are enclosed in '*' or '?'
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Comparator;

/**
 * Comparator.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Comparator
{
    private $target;
    private $operator = '==';

    /**
     * Gets the target value.
     *
     * @return string The target value
     */
    public function getTarget()
    {
        return $this->target;
    }

    /**
     * Sets the target value.
     *
     * @param string $target The target value
     */
    public function setTarget($target)
    {
        $this->target = $target;
    }

    /**
     * Gets the comparison operator.
     *
     * @return string The operator
     */
    public function getOperator()
    {
        return $this->operator;
    }

    /**
     * Sets the comparison operator.
     *
     * @param string $operator A valid operator
     *
     * @throws \InvalidArgumentException
     */
    public function setOperator($operator)
    {
        if (!$operator) {
            $operator = '==';
        }

        if (!in_array($operator, array('>', '<', '>=', '<=', '==', '!='))) {
            throw new \InvalidArgumentException(sprintf('Invalid operator "%s".', $operator));
        }

        $this->operator = $operator;
    }

    /**
     * Tests against the target.
     *
     * @param mixed $test A test value
     *
     * @return bool
     */
    public function test($test)
    {
        switch ($this->operator) {
            case '>':
                return $test > $this->target;
            case '>=':
                return $test >= $this->target;
            case '<':
                return $test < $this->target;
            case '<=':
                return $test <= $this->target;
            case '!=':
                return $test != $this->target;
        }

        return $test == $this->target;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Comparator;

/**
 * DateCompare compiles date comparisons.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class DateComparator extends Comparator
{
    /**
     * Constructor.
     *
     * @param string $test A comparison string
     *
     * @throws \InvalidArgumentException If the test is not understood
     */
    public function __construct($test)
    {
        if (!preg_match('#^\s*(==|!=|[<>]=?|after|since|before|until)?\s*(.+?)\s*$#i', $test, $matches)) {
            throw new \InvalidArgumentException(sprintf('Don\'t understand "%s" as a date test.', $test));
        }

        try {
            $date = new \DateTime($matches[2]);
            $target = $date->format('U');
        } catch (\Exception $e) {
            throw new \InvalidArgumentException(sprintf('"%s" is not a valid date.', $matches[2]));
        }

        $operator = isset($matches[1]) ? $matches[1] : '==';
        if ('since' === $operator || 'after' === $operator) {
            $operator = '>';
        }

        if ('until' === $operator || 'before' === $operator) {
            $operator = '<';
        }

        $this->setOperator($operator);
        $this->setTarget($target);
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Comparator;

/**
 * NumberComparator compiles a simple comparison to an anonymous
 * subroutine, which you can call with a value to be tested again.
 *
 * Now this would be very pointless, if NumberCompare didn't understand
 * magnitudes.
 *
 * The target value may use magnitudes of kilobytes (k, ki),
 * megabytes (m, mi), or gigabytes (g, gi).  Those suffixed
 * with an i use the appropriate 2**n version in accordance with the
 * IEC standard: http://physics.nist.gov/cuu/Units/binary.html
 *
 * Based on the Perl Number::Compare module.
 *
 * @author    Fabien Potencier <fabien@symfony.com> PHP port
 * @author    Richard Clamp <richardc@unixbeard.net> Perl version
 * @copyright 2004-2005 Fabien Potencier <fabien@symfony.com>
 * @copyright 2002 Richard Clamp <richardc@unixbeard.net>
 *
 * @see http://physics.nist.gov/cuu/Units/binary.html
 */
class NumberComparator extends Comparator
{
    /**
     * Constructor.
     *
     * @param string $test A comparison string
     *
     * @throws \InvalidArgumentException If the test is not understood
     */
    public function __construct($test)
    {
        if (!preg_match('#^\s*(==|!=|[<>]=?)?\s*([0-9\.]+)\s*([kmg]i?)?\s*$#i', $test, $matches)) {
            throw new \InvalidArgumentException(sprintf('Don\'t understand "%s" as a number test.', $test));
        }

        $target = $matches[2];
        if (!is_numeric($target)) {
            throw new \InvalidArgumentException(sprintf('Invalid number "%s".', $target));
        }
        if (isset($matches[3])) {
            // magnitude
            switch (strtolower($matches[3])) {
                case 'k':
                    $target *= 1000;
                    break;
                case 'ki':
                    $target *= 1024;
                    break;
                case 'm':
                    $target *= 1000000;
                    break;
                case 'mi':
                    $target *= 1024 * 1024;
                    break;
                case 'g':
                    $target *= 1000000000;
                    break;
                case 'gi':
                    $target *= 1024 * 1024 * 1024;
                    break;
            }
        }

        $this->setTarget($target);
        $this->setOperator(isset($matches[1]) ? $matches[1] : '==');
    }
}
{
    "name": "symfony/finder",
    "type": "library",
    "description": "Symfony Finder Component",
    "keywords": [],
    "homepage": "https://symfony.com",
    "license": "MIT",
    "authors": [
        {
            "name": "Fabien Potencier",
            "email": "fabien@symfony.com"
        },
        {
            "name": "Symfony Community",
            "homepage": "https://symfony.com/contributors"
        }
    ],
    "require": {
        "php": ">=5.3.9"
    },
    "autoload": {
        "psr-4": { "Symfony\\Component\\Finder\\": "" },
        "exclude-from-classmap": [
            "/Tests/"
        ]
    },
    "minimum-stability": "dev",
    "extra": {
        "branch-alias": {
            "dev-master": "2.8-dev"
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Exception;

/**
 * @author Jean-FranÃ§ois Simon <jeanfrancois.simon@sensiolabs.com>
 */
class AccessDeniedException extends \UnexpectedValueException
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Exception;

@trigger_error('The '.__NAMESPACE__.'\AdapterFailureException class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

use Symfony\Component\Finder\Adapter\AdapterInterface;

/**
 * Base exception for all adapter failures.
 *
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0.
 */
class AdapterFailureException extends \RuntimeException implements ExceptionInterface
{
    /**
     * @var \Symfony\Component\Finder\Adapter\AdapterInterface
     */
    private $adapter;

    /**
     * @param AdapterInterface $adapter
     * @param string|null      $message
     * @param \Exception|null  $previous
     */
    public function __construct(AdapterInterface $adapter, $message = null, \Exception $previous = null)
    {
        $this->adapter = $adapter;
        parent::__construct($message ?: 'Search failed with "'.$adapter->getName().'" adapter.', $previous);
    }

    /**
     * {@inheritdoc}
     */
    public function getAdapter()
    {
        return $this->adapter;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Exception;

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 */
interface ExceptionInterface
{
    /**
     * @return \Symfony\Component\Finder\Adapter\AdapterInterface
     */
    public function getAdapter();
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Exception;

@trigger_error('The '.__NAMESPACE__.'\OperationNotPermitedException class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0.
 */
class OperationNotPermitedException extends AdapterFailureException
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Exception;

@trigger_error('The '.__NAMESPACE__.'\ShellCommandFailureException class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

use Symfony\Component\Finder\Adapter\AdapterInterface;
use Symfony\Component\Finder\Shell\Command;

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0.
 */
class ShellCommandFailureException extends AdapterFailureException
{
    /**
     * @var Command
     */
    private $command;

    /**
     * @param AdapterInterface $adapter
     * @param Command          $command
     * @param \Exception|null  $previous
     */
    public function __construct(AdapterInterface $adapter, Command $command, \Exception $previous = null)
    {
        $this->command = $command;
        parent::__construct($adapter, 'Shell command failed: "'.$command->join().'".', $previous);
    }

    /**
     * @return Command
     */
    public function getCommand()
    {
        return $this->command;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Expression;

@trigger_error('The '.__NAMESPACE__.'\Expression class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 */
class Expression implements ValueInterface
{
    const TYPE_REGEX = 1;
    const TYPE_GLOB = 2;

    /**
     * @var ValueInterface
     */
    private $value;

    /**
     * @param string $expr
     *
     * @return Expression
     */
    public static function create($expr)
    {
        return new self($expr);
    }

    /**
     * @param string $expr
     */
    public function __construct($expr)
    {
        try {
            $this->value = Regex::create($expr);
        } catch (\InvalidArgumentException $e) {
            $this->value = new Glob($expr);
        }
    }

    /**
     * @return string
     */
    public function __toString()
    {
        return $this->render();
    }

    /**
     * {@inheritdoc}
     */
    public function render()
    {
        return $this->value->render();
    }

    /**
     * {@inheritdoc}
     */
    public function renderPattern()
    {
        return $this->value->renderPattern();
    }

    /**
     * @return bool
     */
    public function isCaseSensitive()
    {
        return $this->value->isCaseSensitive();
    }

    /**
     * @return int
     */
    public function getType()
    {
        return $this->value->getType();
    }

    /**
     * {@inheritdoc}
     */
    public function prepend($expr)
    {
        $this->value->prepend($expr);

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function append($expr)
    {
        $this->value->append($expr);

        return $this;
    }

    /**
     * @return bool
     */
    public function isRegex()
    {
        return self::TYPE_REGEX === $this->value->getType();
    }

    /**
     * @return bool
     */
    public function isGlob()
    {
        return self::TYPE_GLOB === $this->value->getType();
    }

    /**
     * @throws \LogicException
     *
     * @return Glob
     */
    public function getGlob()
    {
        if (self::TYPE_GLOB !== $this->value->getType()) {
            throw new \LogicException('Regex can\'t be transformed to glob.');
        }

        return $this->value;
    }

    /**
     * @return Regex
     */
    public function getRegex()
    {
        return self::TYPE_REGEX === $this->value->getType() ? $this->value : $this->value->toRegex();
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Expression;

@trigger_error('The '.__NAMESPACE__.'\Glob class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

use Symfony\Component\Finder\Glob as FinderGlob;

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 */
class Glob implements ValueInterface
{
    /**
     * @var string
     */
    private $pattern;

    /**
     * @param string $pattern
     */
    public function __construct($pattern)
    {
        $this->pattern = $pattern;
    }

    /**
     * {@inheritdoc}
     */
    public function render()
    {
        return $this->pattern;
    }

    /**
     * {@inheritdoc}
     */
    public function renderPattern()
    {
        return $this->pattern;
    }

    /**
     * {@inheritdoc}
     */
    public function getType()
    {
        return Expression::TYPE_GLOB;
    }

    /**
     * {@inheritdoc}
     */
    public function isCaseSensitive()
    {
        return true;
    }

    /**
     * {@inheritdoc}
     */
    public function prepend($expr)
    {
        $this->pattern = $expr.$this->pattern;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function append($expr)
    {
        $this->pattern .= $expr;

        return $this;
    }

    /**
     * Tests if glob is expandable ("*.{a,b}" syntax).
     *
     * @return bool
     */
    public function isExpandable()
    {
        return false !== strpos($this->pattern, '{')
            && false !== strpos($this->pattern, '}');
    }

    /**
     * @param bool $strictLeadingDot
     * @param bool $strictWildcardSlash
     *
     * @return Regex
     */
    public function toRegex($strictLeadingDot = true, $strictWildcardSlash = true)
    {
        $regex = FinderGlob::toRegex($this->pattern, $strictLeadingDot, $strictWildcardSlash, '');

        return new Regex($regex);
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Expression;

@trigger_error('The '.__NAMESPACE__.'\Regex class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 */
class Regex implements ValueInterface
{
    const START_FLAG = '^';
    const END_FLAG = '$';
    const BOUNDARY = '~';
    const JOKER = '.*';
    const ESCAPING = '\\';

    /**
     * @var string
     */
    private $pattern;

    /**
     * @var array
     */
    private $options;

    /**
     * @var bool
     */
    private $startFlag;

    /**
     * @var bool
     */
    private $endFlag;

    /**
     * @var bool
     */
    private $startJoker;

    /**
     * @var bool
     */
    private $endJoker;

    /**
     * @param string $expr
     *
     * @return Regex
     *
     * @throws \InvalidArgumentException
     */
    public static function create($expr)
    {
        if (preg_match('/^(.{3,}?)([imsxuADU]*)$/', $expr, $m)) {
            $start = substr($m[1], 0, 1);
            $end = substr($m[1], -1);

            if (
                ($start === $end && !preg_match('/[*?[:alnum:] \\\\]/', $start))
                || ($start === '{' && $end === '}')
                || ($start === '(' && $end === ')')
            ) {
                return new self(substr($m[1], 1, -1), $m[2], $end);
            }
        }

        throw new \InvalidArgumentException('Given expression is not a regex.');
    }

    /**
     * @param string $pattern
     * @param string $options
     * @param string $delimiter
     */
    public function __construct($pattern, $options = '', $delimiter = null)
    {
        if (null !== $delimiter) {
            // removes delimiter escaping
            $pattern = str_replace('\\'.$delimiter, $delimiter, $pattern);
        }

        $this->parsePattern($pattern);
        $this->options = $options;
    }

    /**
     * @return string
     */
    public function __toString()
    {
        return $this->render();
    }

    /**
     * {@inheritdoc}
     */
    public function render()
    {
        return self::BOUNDARY
            .$this->renderPattern()
            .self::BOUNDARY
            .$this->options;
    }

    /**
     * {@inheritdoc}
     */
    public function renderPattern()
    {
        return ($this->startFlag ? self::START_FLAG : '')
            .($this->startJoker ? self::JOKER : '')
            .str_replace(self::BOUNDARY, '\\'.self::BOUNDARY, $this->pattern)
            .($this->endJoker ? self::JOKER : '')
            .($this->endFlag ? self::END_FLAG : '');
    }

    /**
     * {@inheritdoc}
     */
    public function isCaseSensitive()
    {
        return !$this->hasOption('i');
    }

    /**
     * {@inheritdoc}
     */
    public function getType()
    {
        return Expression::TYPE_REGEX;
    }

    /**
     * {@inheritdoc}
     */
    public function prepend($expr)
    {
        $this->pattern = $expr.$this->pattern;

        return $this;
    }

    /**
     * {@inheritdoc}
     */
    public function append($expr)
    {
        $this->pattern .= $expr;

        return $this;
    }

    /**
     * @param string $option
     *
     * @return bool
     */
    public function hasOption($option)
    {
        return false !== strpos($this->options, $option);
    }

    /**
     * @param string $option
     *
     * @return Regex
     */
    public function addOption($option)
    {
        if (!$this->hasOption($option)) {
            $this->options .= $option;
        }

        return $this;
    }

    /**
     * @param string $option
     *
     * @return Regex
     */
    public function removeOption($option)
    {
        $this->options = str_replace($option, '', $this->options);

        return $this;
    }

    /**
     * @param bool $startFlag
     *
     * @return Regex
     */
    public function setStartFlag($startFlag)
    {
        $this->startFlag = $startFlag;

        return $this;
    }

    /**
     * @return bool
     */
    public function hasStartFlag()
    {
        return $this->startFlag;
    }

    /**
     * @param bool $endFlag
     *
     * @return Regex
     */
    public function setEndFlag($endFlag)
    {
        $this->endFlag = (bool) $endFlag;

        return $this;
    }

    /**
     * @return bool
     */
    public function hasEndFlag()
    {
        return $this->endFlag;
    }

    /**
     * @param bool $startJoker
     *
     * @return Regex
     */
    public function setStartJoker($startJoker)
    {
        $this->startJoker = $startJoker;

        return $this;
    }

    /**
     * @return bool
     */
    public function hasStartJoker()
    {
        return $this->startJoker;
    }

    /**
     * @param bool $endJoker
     *
     * @return Regex
     */
    public function setEndJoker($endJoker)
    {
        $this->endJoker = (bool) $endJoker;

        return $this;
    }

    /**
     * @return bool
     */
    public function hasEndJoker()
    {
        return $this->endJoker;
    }

    /**
     * @param array $replacement
     *
     * @return Regex
     */
    public function replaceJokers($replacement)
    {
        $replace = function ($subject) use ($replacement) {
            $subject = $subject[0];
            $replace = 0 === substr_count($subject, '\\') % 2;

            return $replace ? str_replace('.', $replacement, $subject) : $subject;
        };

        $this->pattern = preg_replace_callback('~[\\\\]*\\.~', $replace, $this->pattern);

        return $this;
    }

    /**
     * @param string $pattern
     */
    private function parsePattern($pattern)
    {
        if ($this->startFlag = self::START_FLAG === substr($pattern, 0, 1)) {
            $pattern = substr($pattern, 1);
        }

        if ($this->startJoker = self::JOKER === substr($pattern, 0, 2)) {
            $pattern = substr($pattern, 2);
        }

        if ($this->endFlag = (self::END_FLAG === substr($pattern, -1) && self::ESCAPING !== substr($pattern, -2, -1))) {
            $pattern = substr($pattern, 0, -1);
        }

        if ($this->endJoker = (self::JOKER === substr($pattern, -2) && self::ESCAPING !== substr($pattern, -3, -2))) {
            $pattern = substr($pattern, 0, -2);
        }

        $this->pattern = $pattern;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Expression;

@trigger_error('The '.__NAMESPACE__.'\ValueInterface interface is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 */
interface ValueInterface
{
    /**
     * Renders string representation of expression.
     *
     * @return string
     */
    public function render();

    /**
     * Renders string representation of pattern.
     *
     * @return string
     */
    public function renderPattern();

    /**
     * Returns value case sensitivity.
     *
     * @return bool
     */
    public function isCaseSensitive();

    /**
     * Returns expression type.
     *
     * @return int
     */
    public function getType();

    /**
     * @param string $expr
     *
     * @return ValueInterface
     */
    public function prepend($expr);

    /**
     * @param string $expr
     *
     * @return ValueInterface
     */
    public function append($expr);
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder;

use Symfony\Component\Finder\Adapter\AdapterInterface;
use Symfony\Component\Finder\Adapter\GnuFindAdapter;
use Symfony\Component\Finder\Adapter\BsdFindAdapter;
use Symfony\Component\Finder\Adapter\PhpAdapter;
use Symfony\Component\Finder\Comparator\DateComparator;
use Symfony\Component\Finder\Comparator\NumberComparator;
use Symfony\Component\Finder\Exception\ExceptionInterface;
use Symfony\Component\Finder\Iterator\CustomFilterIterator;
use Symfony\Component\Finder\Iterator\DateRangeFilterIterator;
use Symfony\Component\Finder\Iterator\DepthRangeFilterIterator;
use Symfony\Component\Finder\Iterator\ExcludeDirectoryFilterIterator;
use Symfony\Component\Finder\Iterator\FilecontentFilterIterator;
use Symfony\Component\Finder\Iterator\FilenameFilterIterator;
use Symfony\Component\Finder\Iterator\SizeRangeFilterIterator;
use Symfony\Component\Finder\Iterator\SortableIterator;

/**
 * Finder allows to build rules to find files and directories.
 *
 * It is a thin wrapper around several specialized iterator classes.
 *
 * All rules may be invoked several times.
 *
 * All methods return the current Finder object to allow easy chaining:
 *
 * $finder = Finder::create()->files()->name('*.php')->in(__DIR__);
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Finder implements \IteratorAggregate, \Countable
{
    const IGNORE_VCS_FILES = 1;
    const IGNORE_DOT_FILES = 2;

    private $mode = 0;
    private $names = array();
    private $notNames = array();
    private $exclude = array();
    private $filters = array();
    private $depths = array();
    private $sizes = array();
    private $followLinks = false;
    private $sort = false;
    private $ignore = 0;
    private $dirs = array();
    private $dates = array();
    private $iterators = array();
    private $contains = array();
    private $notContains = array();
    private $adapters = null;
    private $paths = array();
    private $notPaths = array();
    private $ignoreUnreadableDirs = false;

    private static $vcsPatterns = array('.svn', '_svn', 'CVS', '_darcs', '.arch-params', '.monotone', '.bzr', '.git', '.hg');

    /**
     * Constructor.
     */
    public function __construct()
    {
        $this->ignore = static::IGNORE_VCS_FILES | static::IGNORE_DOT_FILES;
    }

    /**
     * Creates a new Finder.
     *
     * @return Finder A new Finder instance
     */
    public static function create()
    {
        return new static();
    }

    /**
     * Registers a finder engine implementation.
     *
     * @param AdapterInterface $adapter  An adapter instance
     * @param int              $priority Highest is selected first
     *
     * @return Finder The current Finder instance
     *
     * @deprecated since 2.8, to be removed in 3.0.
     */
    public function addAdapter(AdapterInterface $adapter, $priority = 0)
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

        $this->initDefaultAdapters();

        $this->adapters[$adapter->getName()] = array(
            'adapter' => $adapter,
            'priority' => $priority,
            'selected' => false,
        );

        return $this->sortAdapters();
    }

    /**
     * Sets the selected adapter to the best one according to the current platform the code is run on.
     *
     * @return Finder The current Finder instance
     *
     * @deprecated since 2.8, to be removed in 3.0.
     */
    public function useBestAdapter()
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

        $this->initDefaultAdapters();

        $this->resetAdapterSelection();

        return $this->sortAdapters();
    }

    /**
     * Selects the adapter to use.
     *
     * @param string $name
     *
     * @throws \InvalidArgumentException
     *
     * @return Finder The current Finder instance
     *
     * @deprecated since 2.8, to be removed in 3.0.
     */
    public function setAdapter($name)
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

        $this->initDefaultAdapters();

        if (!isset($this->adapters[$name])) {
            throw new \InvalidArgumentException(sprintf('Adapter "%s" does not exist.', $name));
        }

        $this->resetAdapterSelection();
        $this->adapters[$name]['selected'] = true;

        return $this->sortAdapters();
    }

    /**
     * Removes all adapters registered in the finder.
     *
     * @return Finder The current Finder instance
     *
     * @deprecated since 2.8, to be removed in 3.0.
     */
    public function removeAdapters()
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

        $this->adapters = array();

        return $this;
    }

    /**
     * Returns registered adapters ordered by priority without extra information.
     *
     * @return AdapterInterface[]
     *
     * @deprecated since 2.8, to be removed in 3.0.
     */
    public function getAdapters()
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

        $this->initDefaultAdapters();

        return array_values(array_map(function (array $adapter) {
            return $adapter['adapter'];
        }, $this->adapters));
    }

    /**
     * Restricts the matching to directories only.
     *
     * @return Finder The current Finder instance
     */
    public function directories()
    {
        $this->mode = Iterator\FileTypeFilterIterator::ONLY_DIRECTORIES;

        return $this;
    }

    /**
     * Restricts the matching to files only.
     *
     * @return Finder The current Finder instance
     */
    public function files()
    {
        $this->mode = Iterator\FileTypeFilterIterator::ONLY_FILES;

        return $this;
    }

    /**
     * Adds tests for the directory depth.
     *
     * Usage:
     *
     *   $finder->depth('> 1') // the Finder will start matching at level 1.
     *   $finder->depth('< 3') // the Finder will descend at most 3 levels of directories below the starting point.
     *
     * @param int $level The depth level expression
     *
     * @return Finder The current Finder instance
     *
     * @see DepthRangeFilterIterator
     * @see NumberComparator
     */
    public function depth($level)
    {
        $this->depths[] = new Comparator\NumberComparator($level);

        return $this;
    }

    /**
     * Adds tests for file dates (last modified).
     *
     * The date must be something that strtotime() is able to parse:
     *
     *   $finder->date('since yesterday');
     *   $finder->date('until 2 days ago');
     *   $finder->date('> now - 2 hours');
     *   $finder->date('>= 2005-10-15');
     *
     * @param string $date A date range string
     *
     * @return Finder The current Finder instance
     *
     * @see strtotime
     * @see DateRangeFilterIterator
     * @see DateComparator
     */
    public function date($date)
    {
        $this->dates[] = new Comparator\DateComparator($date);

        return $this;
    }

    /**
     * Adds rules that files must match.
     *
     * You can use patterns (delimited with / sign), globs or simple strings.
     *
     * $finder->name('*.php')
     * $finder->name('/\.php$/') // same as above
     * $finder->name('test.php')
     *
     * @param string $pattern A pattern (a regexp, a glob, or a string)
     *
     * @return Finder The current Finder instance
     *
     * @see FilenameFilterIterator
     */
    public function name($pattern)
    {
        $this->names[] = $pattern;

        return $this;
    }

    /**
     * Adds rules that files must not match.
     *
     * @param string $pattern A pattern (a regexp, a glob, or a string)
     *
     * @return Finder The current Finder instance
     *
     * @see FilenameFilterIterator
     */
    public function notName($pattern)
    {
        $this->notNames[] = $pattern;

        return $this;
    }

    /**
     * Adds tests that file contents must match.
     *
     * Strings or PCRE patterns can be used:
     *
     * $finder->contains('Lorem ipsum')
     * $finder->contains('/Lorem ipsum/i')
     *
     * @param string $pattern A pattern (string or regexp)
     *
     * @return Finder The current Finder instance
     *
     * @see FilecontentFilterIterator
     */
    public function contains($pattern)
    {
        $this->contains[] = $pattern;

        return $this;
    }

    /**
     * Adds tests that file contents must not match.
     *
     * Strings or PCRE patterns can be used:
     *
     * $finder->notContains('Lorem ipsum')
     * $finder->notContains('/Lorem ipsum/i')
     *
     * @param string $pattern A pattern (string or regexp)
     *
     * @return Finder The current Finder instance
     *
     * @see FilecontentFilterIterator
     */
    public function notContains($pattern)
    {
        $this->notContains[] = $pattern;

        return $this;
    }

    /**
     * Adds rules that filenames must match.
     *
     * You can use patterns (delimited with / sign) or simple strings.
     *
     * $finder->path('some/special/dir')
     * $finder->path('/some\/special\/dir/') // same as above
     *
     * Use only / as dirname separator.
     *
     * @param string $pattern A pattern (a regexp or a string)
     *
     * @return Finder The current Finder instance
     *
     * @see FilenameFilterIterator
     */
    public function path($pattern)
    {
        $this->paths[] = $pattern;

        return $this;
    }

    /**
     * Adds rules that filenames must not match.
     *
     * You can use patterns (delimited with / sign) or simple strings.
     *
     * $finder->notPath('some/special/dir')
     * $finder->notPath('/some\/special\/dir/') // same as above
     *
     * Use only / as dirname separator.
     *
     * @param string $pattern A pattern (a regexp or a string)
     *
     * @return Finder The current Finder instance
     *
     * @see FilenameFilterIterator
     */
    public function notPath($pattern)
    {
        $this->notPaths[] = $pattern;

        return $this;
    }

    /**
     * Adds tests for file sizes.
     *
     * $finder->size('> 10K');
     * $finder->size('<= 1Ki');
     * $finder->size(4);
     *
     * @param string $size A size range string
     *
     * @return Finder The current Finder instance
     *
     * @see SizeRangeFilterIterator
     * @see NumberComparator
     */
    public function size($size)
    {
        $this->sizes[] = new Comparator\NumberComparator($size);

        return $this;
    }

    /**
     * Excludes directories.
     *
     * @param string|array $dirs A directory path or an array of directories
     *
     * @return Finder The current Finder instance
     *
     * @see ExcludeDirectoryFilterIterator
     */
    public function exclude($dirs)
    {
        $this->exclude = array_merge($this->exclude, (array) $dirs);

        return $this;
    }

    /**
     * Excludes "hidden" directories and files (starting with a dot).
     *
     * @param bool $ignoreDotFiles Whether to exclude "hidden" files or not
     *
     * @return Finder The current Finder instance
     *
     * @see ExcludeDirectoryFilterIterator
     */
    public function ignoreDotFiles($ignoreDotFiles)
    {
        if ($ignoreDotFiles) {
            $this->ignore |= static::IGNORE_DOT_FILES;
        } else {
            $this->ignore &= ~static::IGNORE_DOT_FILES;
        }

        return $this;
    }

    /**
     * Forces the finder to ignore version control directories.
     *
     * @param bool $ignoreVCS Whether to exclude VCS files or not
     *
     * @return Finder The current Finder instance
     *
     * @see ExcludeDirectoryFilterIterator
     */
    public function ignoreVCS($ignoreVCS)
    {
        if ($ignoreVCS) {
            $this->ignore |= static::IGNORE_VCS_FILES;
        } else {
            $this->ignore &= ~static::IGNORE_VCS_FILES;
        }

        return $this;
    }

    /**
     * Adds VCS patterns.
     *
     * @see ignoreVCS()
     *
     * @param string|string[] $pattern VCS patterns to ignore
     */
    public static function addVCSPattern($pattern)
    {
        foreach ((array) $pattern as $p) {
            self::$vcsPatterns[] = $p;
        }

        self::$vcsPatterns = array_unique(self::$vcsPatterns);
    }

    /**
     * Sorts files and directories by an anonymous function.
     *
     * The anonymous function receives two \SplFileInfo instances to compare.
     *
     * This can be slow as all the matching files and directories must be retrieved for comparison.
     *
     * @param \Closure $closure An anonymous function
     *
     * @return Finder The current Finder instance
     *
     * @see SortableIterator
     */
    public function sort(\Closure $closure)
    {
        $this->sort = $closure;

        return $this;
    }

    /**
     * Sorts files and directories by name.
     *
     * This can be slow as all the matching files and directories must be retrieved for comparison.
     *
     * @return Finder The current Finder instance
     *
     * @see SortableIterator
     */
    public function sortByName()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_NAME;

        return $this;
    }

    /**
     * Sorts files and directories by type (directories before files), then by name.
     *
     * This can be slow as all the matching files and directories must be retrieved for comparison.
     *
     * @return Finder The current Finder instance
     *
     * @see SortableIterator
     */
    public function sortByType()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_TYPE;

        return $this;
    }

    /**
     * Sorts files and directories by the last accessed time.
     *
     * This is the time that the file was last accessed, read or written to.
     *
     * This can be slow as all the matching files and directories must be retrieved for comparison.
     *
     * @return Finder The current Finder instance
     *
     * @see SortableIterator
     */
    public function sortByAccessedTime()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_ACCESSED_TIME;

        return $this;
    }

    /**
     * Sorts files and directories by the last inode changed time.
     *
     * This is the time that the inode information was last modified (permissions, owner, group or other metadata).
     *
     * On Windows, since inode is not available, changed time is actually the file creation time.
     *
     * This can be slow as all the matching files and directories must be retrieved for comparison.
     *
     * @return Finder The current Finder instance
     *
     * @see SortableIterator
     */
    public function sortByChangedTime()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_CHANGED_TIME;

        return $this;
    }

    /**
     * Sorts files and directories by the last modified time.
     *
     * This is the last time the actual contents of the file were last modified.
     *
     * This can be slow as all the matching files and directories must be retrieved for comparison.
     *
     * @return Finder The current Finder instance
     *
     * @see SortableIterator
     */
    public function sortByModifiedTime()
    {
        $this->sort = Iterator\SortableIterator::SORT_BY_MODIFIED_TIME;

        return $this;
    }

    /**
     * Filters the iterator with an anonymous function.
     *
     * The anonymous function receives a \SplFileInfo and must return false
     * to remove files.
     *
     * @param \Closure $closure An anonymous function
     *
     * @return Finder The current Finder instance
     *
     * @see CustomFilterIterator
     */
    public function filter(\Closure $closure)
    {
        $this->filters[] = $closure;

        return $this;
    }

    /**
     * Forces the following of symlinks.
     *
     * @return Finder The current Finder instance
     */
    public function followLinks()
    {
        $this->followLinks = true;

        return $this;
    }

    /**
     * Tells finder to ignore unreadable directories.
     *
     * By default, scanning unreadable directories content throws an AccessDeniedException.
     *
     * @param bool $ignore
     *
     * @return Finder The current Finder instance
     */
    public function ignoreUnreadableDirs($ignore = true)
    {
        $this->ignoreUnreadableDirs = (bool) $ignore;

        return $this;
    }

    /**
     * Searches files and directories which match defined rules.
     *
     * @param string|array $dirs A directory path or an array of directories
     *
     * @return Finder The current Finder instance
     *
     * @throws \InvalidArgumentException if one of the directories does not exist
     */
    public function in($dirs)
    {
        $resolvedDirs = array();

        foreach ((array) $dirs as $dir) {
            if (is_dir($dir)) {
                $resolvedDirs[] = $dir;
            } elseif ($glob = glob($dir, (defined('GLOB_BRACE') ? GLOB_BRACE : 0) | GLOB_ONLYDIR)) {
                $resolvedDirs = array_merge($resolvedDirs, $glob);
            } else {
                throw new \InvalidArgumentException(sprintf('The "%s" directory does not exist.', $dir));
            }
        }

        $this->dirs = array_merge($this->dirs, $resolvedDirs);

        return $this;
    }

    /**
     * Returns an Iterator for the current Finder configuration.
     *
     * This method implements the IteratorAggregate interface.
     *
     * @return \Iterator An iterator
     *
     * @throws \LogicException if the in() method has not been called
     */
    public function getIterator()
    {
        if (0 === count($this->dirs) && 0 === count($this->iterators)) {
            throw new \LogicException('You must call one of in() or append() methods before iterating over a Finder.');
        }

        if (1 === count($this->dirs) && 0 === count($this->iterators)) {
            return $this->searchInDirectory($this->dirs[0]);
        }

        $iterator = new \AppendIterator();
        foreach ($this->dirs as $dir) {
            $iterator->append($this->searchInDirectory($dir));
        }

        foreach ($this->iterators as $it) {
            $iterator->append($it);
        }

        return $iterator;
    }

    /**
     * Appends an existing set of files/directories to the finder.
     *
     * The set can be another Finder, an Iterator, an IteratorAggregate, or even a plain array.
     *
     * @param mixed $iterator
     *
     * @return Finder The finder
     *
     * @throws \InvalidArgumentException When the given argument is not iterable.
     */
    public function append($iterator)
    {
        if ($iterator instanceof \IteratorAggregate) {
            $this->iterators[] = $iterator->getIterator();
        } elseif ($iterator instanceof \Iterator) {
            $this->iterators[] = $iterator;
        } elseif ($iterator instanceof \Traversable || is_array($iterator)) {
            $it = new \ArrayIterator();
            foreach ($iterator as $file) {
                $it->append($file instanceof \SplFileInfo ? $file : new \SplFileInfo($file));
            }
            $this->iterators[] = $it;
        } else {
            throw new \InvalidArgumentException('Finder::append() method wrong argument type.');
        }

        return $this;
    }

    /**
     * Counts all the results collected by the iterators.
     *
     * @return int
     */
    public function count()
    {
        return iterator_count($this->getIterator());
    }

    /**
     * @return Finder The current Finder instance
     */
    private function sortAdapters()
    {
        uasort($this->adapters, function (array $a, array $b) {
            if ($a['selected'] || $b['selected']) {
                return $a['selected'] ? -1 : 1;
            }

            return $a['priority'] > $b['priority'] ? -1 : 1;
        });

        return $this;
    }

    /**
     * @param $dir
     *
     * @return \Iterator
     */
    private function searchInDirectory($dir)
    {
        if (static::IGNORE_VCS_FILES === (static::IGNORE_VCS_FILES & $this->ignore)) {
            $this->exclude = array_merge($this->exclude, self::$vcsPatterns);
        }

        if (static::IGNORE_DOT_FILES === (static::IGNORE_DOT_FILES & $this->ignore)) {
            $this->notPaths[] = '#(^|/)\..+(/|$)#';
        }

        if ($this->adapters) {
            foreach ($this->adapters as $adapter) {
                if ($adapter['adapter']->isSupported()) {
                    try {
                        return $this
                            ->buildAdapter($adapter['adapter'])
                            ->searchInDirectory($dir);
                    } catch (ExceptionInterface $e) {
                    }
                }
            }
        }

        $minDepth = 0;
        $maxDepth = PHP_INT_MAX;

        foreach ($this->depths as $comparator) {
            switch ($comparator->getOperator()) {
                case '>':
                    $minDepth = $comparator->getTarget() + 1;
                    break;
                case '>=':
                    $minDepth = $comparator->getTarget();
                    break;
                case '<':
                    $maxDepth = $comparator->getTarget() - 1;
                    break;
                case '<=':
                    $maxDepth = $comparator->getTarget();
                    break;
                default:
                    $minDepth = $maxDepth = $comparator->getTarget();
            }
        }

        $flags = \RecursiveDirectoryIterator::SKIP_DOTS;

        if ($this->followLinks) {
            $flags |= \RecursiveDirectoryIterator::FOLLOW_SYMLINKS;
        }

        $iterator = new Iterator\RecursiveDirectoryIterator($dir, $flags, $this->ignoreUnreadableDirs);

        if ($this->exclude) {
            $iterator = new Iterator\ExcludeDirectoryFilterIterator($iterator, $this->exclude);
        }

        $iterator = new \RecursiveIteratorIterator($iterator, \RecursiveIteratorIterator::SELF_FIRST);

        if ($minDepth > 0 || $maxDepth < PHP_INT_MAX) {
            $iterator = new Iterator\DepthRangeFilterIterator($iterator, $minDepth, $maxDepth);
        }

        if ($this->mode) {
            $iterator = new Iterator\FileTypeFilterIterator($iterator, $this->mode);
        }

        if ($this->names || $this->notNames) {
            $iterator = new Iterator\FilenameFilterIterator($iterator, $this->names, $this->notNames);
        }

        if ($this->contains || $this->notContains) {
            $iterator = new Iterator\FilecontentFilterIterator($iterator, $this->contains, $this->notContains);
        }

        if ($this->sizes) {
            $iterator = new Iterator\SizeRangeFilterIterator($iterator, $this->sizes);
        }

        if ($this->dates) {
            $iterator = new Iterator\DateRangeFilterIterator($iterator, $this->dates);
        }

        if ($this->filters) {
            $iterator = new Iterator\CustomFilterIterator($iterator, $this->filters);
        }

        if ($this->paths || $this->notPaths) {
            $iterator = new Iterator\PathFilterIterator($iterator, $this->paths, $this->notPaths);
        }

        if ($this->sort) {
            $iteratorAggregate = new Iterator\SortableIterator($iterator, $this->sort);
            $iterator = $iteratorAggregate->getIterator();
        }

        return $iterator;
    }

    /**
     * @param AdapterInterface $adapter
     *
     * @return AdapterInterface
     */
    private function buildAdapter(AdapterInterface $adapter)
    {
        return $adapter
            ->setFollowLinks($this->followLinks)
            ->setDepths($this->depths)
            ->setMode($this->mode)
            ->setExclude($this->exclude)
            ->setNames($this->names)
            ->setNotNames($this->notNames)
            ->setContains($this->contains)
            ->setNotContains($this->notContains)
            ->setSizes($this->sizes)
            ->setDates($this->dates)
            ->setFilters($this->filters)
            ->setSort($this->sort)
            ->setPath($this->paths)
            ->setNotPath($this->notPaths)
            ->ignoreUnreadableDirs($this->ignoreUnreadableDirs);
    }

    /**
     * Unselects all adapters.
     */
    private function resetAdapterSelection()
    {
        $this->adapters = array_map(function (array $properties) {
            $properties['selected'] = false;

            return $properties;
        }, $this->adapters);
    }

    private function initDefaultAdapters()
    {
        if (null === $this->adapters) {
            $this->adapters = array();
            $this
                ->addAdapter(new GnuFindAdapter())
                ->addAdapter(new BsdFindAdapter())
                ->addAdapter(new PhpAdapter(), -50)
                ->setAdapter('php')
            ;
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder;

/**
 * Glob matches globbing patterns against text.
 *
 *   if match_glob("foo.*", "foo.bar") echo "matched\n";
 *
 * // prints foo.bar and foo.baz
 * $regex = glob_to_regex("foo.*");
 * for (array('foo.bar', 'foo.baz', 'foo', 'bar') as $t)
 * {
 *   if (/$regex/) echo "matched: $car\n";
 * }
 *
 * Glob implements glob(3) style matching that can be used to match
 * against text, rather than fetching names from a filesystem.
 *
 * Based on the Perl Text::Glob module.
 *
 * @author Fabien Potencier <fabien@symfony.com> PHP port
 * @author     Richard Clamp <richardc@unixbeard.net> Perl version
 * @copyright  2004-2005 Fabien Potencier <fabien@symfony.com>
 * @copyright  2002 Richard Clamp <richardc@unixbeard.net>
 */
class Glob
{
    /**
     * Returns a regexp which is the equivalent of the glob pattern.
     *
     * @param string $glob                The glob pattern
     * @param bool   $strictLeadingDot
     * @param bool   $strictWildcardSlash
     * @param string $delimiter           Optional delimiter
     *
     * @return string regex The regexp
     */
    public static function toRegex($glob, $strictLeadingDot = true, $strictWildcardSlash = true, $delimiter = '#')
    {
        $firstByte = true;
        $escaping = false;
        $inCurlies = 0;
        $regex = '';
        $sizeGlob = strlen($glob);
        for ($i = 0; $i < $sizeGlob; ++$i) {
            $car = $glob[$i];
            if ($firstByte) {
                if ($strictLeadingDot && '.' !== $car) {
                    $regex .= '(?=[^\.])';
                }

                $firstByte = false;
            }

            if ('/' === $car) {
                $firstByte = true;
            }

            if ($delimiter === $car || '.' === $car || '(' === $car || ')' === $car || '|' === $car || '+' === $car || '^' === $car || '$' === $car) {
                $regex .= "\\$car";
            } elseif ('*' === $car) {
                $regex .= $escaping ? '\\*' : ($strictWildcardSlash ? '[^/]*' : '.*');
            } elseif ('?' === $car) {
                $regex .= $escaping ? '\\?' : ($strictWildcardSlash ? '[^/]' : '.');
            } elseif ('{' === $car) {
                $regex .= $escaping ? '\\{' : '(';
                if (!$escaping) {
                    ++$inCurlies;
                }
            } elseif ('}' === $car && $inCurlies) {
                $regex .= $escaping ? '}' : ')';
                if (!$escaping) {
                    --$inCurlies;
                }
            } elseif (',' === $car && $inCurlies) {
                $regex .= $escaping ? ',' : '|';
            } elseif ('\\' === $car) {
                if ($escaping) {
                    $regex .= '\\\\';
                    $escaping = false;
                } else {
                    $escaping = true;
                }

                continue;
            } else {
                $regex .= $car;
            }
            $escaping = false;
        }

        return $delimiter.'^'.$regex.'$'.$delimiter;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * CustomFilterIterator filters files by applying anonymous functions.
 *
 * The anonymous function receives a \SplFileInfo and must return false
 * to remove files.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class CustomFilterIterator extends FilterIterator
{
    private $filters = array();

    /**
     * Constructor.
     *
     * @param \Iterator  $iterator The Iterator to filter
     * @param callable[] $filters  An array of PHP callbacks
     *
     * @throws \InvalidArgumentException
     */
    public function __construct(\Iterator $iterator, array $filters)
    {
        foreach ($filters as $filter) {
            if (!is_callable($filter)) {
                throw new \InvalidArgumentException('Invalid PHP callback.');
            }
        }
        $this->filters = $filters;

        parent::__construct($iterator);
    }

    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        $fileinfo = $this->current();

        foreach ($this->filters as $filter) {
            if (false === call_user_func($filter, $fileinfo)) {
                return false;
            }
        }

        return true;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Comparator\DateComparator;

/**
 * DateRangeFilterIterator filters out files that are not in the given date range (last modified dates).
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class DateRangeFilterIterator extends FilterIterator
{
    private $comparators = array();

    /**
     * Constructor.
     *
     * @param \Iterator        $iterator    The Iterator to filter
     * @param DateComparator[] $comparators An array of DateComparator instances
     */
    public function __construct(\Iterator $iterator, array $comparators)
    {
        $this->comparators = $comparators;

        parent::__construct($iterator);
    }

    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        $fileinfo = $this->current();

        if (!file_exists($fileinfo->getRealPath())) {
            return false;
        }

        $filedate = $fileinfo->getMTime();
        foreach ($this->comparators as $compare) {
            if (!$compare->test($filedate)) {
                return false;
            }
        }

        return true;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * DepthRangeFilterIterator limits the directory depth.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class DepthRangeFilterIterator extends FilterIterator
{
    private $minDepth = 0;

    /**
     * Constructor.
     *
     * @param \RecursiveIteratorIterator $iterator The Iterator to filter
     * @param int                        $minDepth The min depth
     * @param int                        $maxDepth The max depth
     */
    public function __construct(\RecursiveIteratorIterator $iterator, $minDepth = 0, $maxDepth = PHP_INT_MAX)
    {
        $this->minDepth = $minDepth;
        $iterator->setMaxDepth(PHP_INT_MAX === $maxDepth ? -1 : $maxDepth);

        parent::__construct($iterator);
    }

    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        return $this->getInnerIterator()->getDepth() >= $this->minDepth;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * ExcludeDirectoryFilterIterator filters out directories.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class ExcludeDirectoryFilterIterator extends FilterIterator implements \RecursiveIterator
{
    private $iterator;
    private $isRecursive;
    private $excludedDirs = array();
    private $excludedPattern;

    /**
     * Constructor.
     *
     * @param \Iterator $iterator    The Iterator to filter
     * @param array     $directories An array of directories to exclude
     */
    public function __construct(\Iterator $iterator, array $directories)
    {
        $this->iterator = $iterator;
        $this->isRecursive = $iterator instanceof \RecursiveIterator;
        $patterns = array();
        foreach ($directories as $directory) {
            if (!$this->isRecursive || false !== strpos($directory, '/')) {
                $patterns[] = preg_quote($directory, '#');
            } else {
                $this->excludedDirs[$directory] = true;
            }
        }
        if ($patterns) {
            $this->excludedPattern = '#(?:^|/)(?:'.implode('|', $patterns).')(?:/|$)#';
        }

        parent::__construct($iterator);
    }

    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        if ($this->isRecursive && isset($this->excludedDirs[$this->getFilename()]) && $this->isDir()) {
            return false;
        }

        if ($this->excludedPattern) {
            $path = $this->isDir() ? $this->current()->getRelativePathname() : $this->current()->getRelativePath();
            $path = str_replace('\\', '/', $path);

            return !preg_match($this->excludedPattern, $path);
        }

        return true;
    }

    public function hasChildren()
    {
        return $this->isRecursive && $this->iterator->hasChildren();
    }

    public function getChildren()
    {
        $children = new self($this->iterator->getChildren(), array());
        $children->excludedDirs = $this->excludedDirs;
        $children->excludedPattern = $this->excludedPattern;

        return $children;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * FilecontentFilterIterator filters files by their contents using patterns (regexps or strings).
 *
 * @author Fabien Potencier  <fabien@symfony.com>
 * @author WÅ‚odzimierz Gajda <gajdaw@gajdaw.pl>
 */
class FilecontentFilterIterator extends MultiplePcreFilterIterator
{
    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        if (!$this->matchRegexps && !$this->noMatchRegexps) {
            return true;
        }

        $fileinfo = $this->current();

        if ($fileinfo->isDir() || !$fileinfo->isReadable()) {
            return false;
        }

        $content = $fileinfo->getContents();
        if (!$content) {
            return false;
        }

        return $this->isAccepted($content);
    }

    /**
     * Converts string to regexp if necessary.
     *
     * @param string $str Pattern: string or regexp
     *
     * @return string regexp corresponding to a given string or regexp
     */
    protected function toRegex($str)
    {
        return $this->isRegex($str) ? $str : '/'.preg_quote($str, '/').'/';
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Glob;

/**
 * FilenameFilterIterator filters files by patterns (a regexp, a glob, or a string).
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class FilenameFilterIterator extends MultiplePcreFilterIterator
{
    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        return $this->isAccepted($this->current()->getFilename());
    }

    /**
     * Converts glob to regexp.
     *
     * PCRE patterns are left unchanged.
     * Glob strings are transformed with Glob::toRegex().
     *
     * @param string $str Pattern: glob or regexp
     *
     * @return string regexp corresponding to a given glob or regexp
     */
    protected function toRegex($str)
    {
        return $this->isRegex($str) ? $str : Glob::toRegex($str);
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

@trigger_error('The '.__NAMESPACE__.'\FilePathsIterator class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

use Symfony\Component\Finder\SplFileInfo;

/**
 * Iterate over shell command result.
 *
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0.
 */
class FilePathsIterator extends \ArrayIterator
{
    /**
     * @var string
     */
    private $baseDir;

    /**
     * @var int
     */
    private $baseDirLength;

    /**
     * @var string
     */
    private $subPath;

    /**
     * @var string
     */
    private $subPathname;

    /**
     * @var SplFileInfo
     */
    private $current;

    /**
     * @param array  $paths   List of paths returned by shell command
     * @param string $baseDir Base dir for relative path building
     */
    public function __construct(array $paths, $baseDir)
    {
        $this->baseDir = $baseDir;
        $this->baseDirLength = strlen($baseDir);

        parent::__construct($paths);
    }

    /**
     * @param string $name
     * @param array  $arguments
     *
     * @return mixed
     */
    public function __call($name, array $arguments)
    {
        return call_user_func_array(array($this->current(), $name), $arguments);
    }

    /**
     * Return an instance of SplFileInfo with support for relative paths.
     *
     * @return SplFileInfo File information
     */
    public function current()
    {
        return $this->current;
    }

    /**
     * @return string
     */
    public function key()
    {
        return $this->current->getPathname();
    }

    public function next()
    {
        parent::next();
        $this->buildProperties();
    }

    public function rewind()
    {
        parent::rewind();
        $this->buildProperties();
    }

    /**
     * @return string
     */
    public function getSubPath()
    {
        return $this->subPath;
    }

    /**
     * @return string
     */
    public function getSubPathname()
    {
        return $this->subPathname;
    }

    private function buildProperties()
    {
        $absolutePath = parent::current();

        if ($this->baseDir === substr($absolutePath, 0, $this->baseDirLength)) {
            $this->subPathname = ltrim(substr($absolutePath, $this->baseDirLength), '/\\');
            $dir = dirname($this->subPathname);
            $this->subPath = '.' === $dir ? '' : $dir;
        } else {
            $this->subPath = $this->subPathname = '';
        }

        $this->current = new SplFileInfo(parent::current(), $this->subPath, $this->subPathname);
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * FileTypeFilterIterator only keeps files, directories, or both.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class FileTypeFilterIterator extends FilterIterator
{
    const ONLY_FILES = 1;
    const ONLY_DIRECTORIES = 2;

    private $mode;

    /**
     * Constructor.
     *
     * @param \Iterator $iterator The Iterator to filter
     * @param int       $mode     The mode (self::ONLY_FILES or self::ONLY_DIRECTORIES)
     */
    public function __construct(\Iterator $iterator, $mode)
    {
        $this->mode = $mode;

        parent::__construct($iterator);
    }

    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        $fileinfo = $this->current();
        if (self::ONLY_DIRECTORIES === (self::ONLY_DIRECTORIES & $this->mode) && $fileinfo->isFile()) {
            return false;
        } elseif (self::ONLY_FILES === (self::ONLY_FILES & $this->mode) && $fileinfo->isDir()) {
            return false;
        }

        return true;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * This iterator just overrides the rewind method in order to correct a PHP bug,
 * which existed before version 5.5.23/5.6.7.
 *
 * @see https://bugs.php.net/68557
 *
 * @author Alex Bogomazov
 */
abstract class FilterIterator extends \FilterIterator
{
    /**
     * This is a workaround for the problem with \FilterIterator leaving inner \FilesystemIterator in wrong state after
     * rewind in some cases.
     *
     * @see FilterIterator::rewind()
     */
    public function rewind()
    {
        if (PHP_VERSION_ID > 50607 || (PHP_VERSION_ID > 50523 && PHP_VERSION_ID < 50600)) {
            parent::rewind();

            return;
        }

        $iterator = $this;
        while ($iterator instanceof \OuterIterator) {
            $innerIterator = $iterator->getInnerIterator();

            if ($innerIterator instanceof \FilesystemIterator) {
                $innerIterator->next();
                $innerIterator->rewind();
            }
            $iterator = $iterator->getInnerIterator();
        }

        parent::rewind();
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * MultiplePcreFilterIterator filters files using patterns (regexps, globs or strings).
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
abstract class MultiplePcreFilterIterator extends FilterIterator
{
    protected $matchRegexps = array();
    protected $noMatchRegexps = array();

    /**
     * Constructor.
     *
     * @param \Iterator $iterator        The Iterator to filter
     * @param array     $matchPatterns   An array of patterns that need to match
     * @param array     $noMatchPatterns An array of patterns that need to not match
     */
    public function __construct(\Iterator $iterator, array $matchPatterns, array $noMatchPatterns)
    {
        foreach ($matchPatterns as $pattern) {
            $this->matchRegexps[] = $this->toRegex($pattern);
        }

        foreach ($noMatchPatterns as $pattern) {
            $this->noMatchRegexps[] = $this->toRegex($pattern);
        }

        parent::__construct($iterator);
    }

    /**
     * Checks whether the string is accepted by the regex filters.
     *
     * If there is no regexps defined in the class, this method will accept the string.
     * Such case can be handled by child classes before calling the method if they want to
     * apply a different behavior.
     *
     * @param string $string The string to be matched against filters
     *
     * @return bool
     */
    protected function isAccepted($string)
    {
        // should at least not match one rule to exclude
        foreach ($this->noMatchRegexps as $regex) {
            if (preg_match($regex, $string)) {
                return false;
            }
        }

        // should at least match one rule
        if ($this->matchRegexps) {
            foreach ($this->matchRegexps as $regex) {
                if (preg_match($regex, $string)) {
                    return true;
                }
            }

            return false;
        }

        // If there is no match rules, the file is accepted
        return true;
    }

    /**
     * Checks whether the string is a regex.
     *
     * @param string $str
     *
     * @return bool Whether the given string is a regex
     */
    protected function isRegex($str)
    {
        if (preg_match('/^(.{3,}?)[imsxuADU]*$/', $str, $m)) {
            $start = substr($m[1], 0, 1);
            $end = substr($m[1], -1);

            if ($start === $end) {
                return !preg_match('/[*?[:alnum:] \\\\]/', $start);
            }

            foreach (array(array('{', '}'), array('(', ')'), array('[', ']'), array('<', '>')) as $delimiters) {
                if ($start === $delimiters[0] && $end === $delimiters[1]) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Converts string into regexp.
     *
     * @param string $str Pattern
     *
     * @return string regexp corresponding to a given string
     */
    abstract protected function toRegex($str);
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * PathFilterIterator filters files by path patterns (e.g. some/special/dir).
 *
 * @author Fabien Potencier  <fabien@symfony.com>
 * @author WÅ‚odzimierz Gajda <gajdaw@gajdaw.pl>
 */
class PathFilterIterator extends MultiplePcreFilterIterator
{
    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        $filename = $this->current()->getRelativePathname();

        if ('\\' === DIRECTORY_SEPARATOR) {
            $filename = str_replace('\\', '/', $filename);
        }

        return $this->isAccepted($filename);
    }

    /**
     * Converts strings to regexp.
     *
     * PCRE patterns are left unchanged.
     *
     * Default conversion:
     *     'lorem/ipsum/dolor' ==>  'lorem\/ipsum\/dolor/'
     *
     * Use only / as directory separator (on Windows also).
     *
     * @param string $str Pattern: regexp or dirname.
     *
     * @return string regexp corresponding to a given string or regexp
     */
    protected function toRegex($str)
    {
        return $this->isRegex($str) ? $str : '/'.preg_quote($str, '/').'/';
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Exception\AccessDeniedException;
use Symfony\Component\Finder\SplFileInfo;

/**
 * Extends the \RecursiveDirectoryIterator to support relative paths.
 *
 * @author Victor Berchet <victor@suumit.com>
 */
class RecursiveDirectoryIterator extends \RecursiveDirectoryIterator
{
    /**
     * @var bool
     */
    private $ignoreUnreadableDirs;

    /**
     * @var bool
     */
    private $rewindable;

    // these 3 properties take part of the performance optimization to avoid redoing the same work in all iterations
    private $rootPath;
    private $subPath;
    private $directorySeparator = '/';

    /**
     * Constructor.
     *
     * @param string $path
     * @param int    $flags
     * @param bool   $ignoreUnreadableDirs
     *
     * @throws \RuntimeException
     */
    public function __construct($path, $flags, $ignoreUnreadableDirs = false)
    {
        if ($flags & (self::CURRENT_AS_PATHNAME | self::CURRENT_AS_SELF)) {
            throw new \RuntimeException('This iterator only support returning current as fileinfo.');
        }

        parent::__construct($path, $flags);
        $this->ignoreUnreadableDirs = $ignoreUnreadableDirs;
        $this->rootPath = (string) $path;
        if ('/' !== DIRECTORY_SEPARATOR && !($flags & self::UNIX_PATHS)) {
            $this->directorySeparator = DIRECTORY_SEPARATOR;
        }
    }

    /**
     * Return an instance of SplFileInfo with support for relative paths.
     *
     * @return SplFileInfo File information
     */
    public function current()
    {
        // the logic here avoids redoing the same work in all iterations

        if (null === $subPathname = $this->subPath) {
            $subPathname = $this->subPath = (string) $this->getSubPath();
        }
        if ('' !== $subPathname) {
            $subPathname .= $this->directorySeparator;
        }
        $subPathname .= $this->getFilename();

        return new SplFileInfo($this->rootPath.$this->directorySeparator.$subPathname, $this->subPath, $subPathname);
    }

    /**
     * @return \RecursiveIterator
     *
     * @throws AccessDeniedException
     */
    public function getChildren()
    {
        try {
            $children = parent::getChildren();

            if ($children instanceof self) {
                // parent method will call the constructor with default arguments, so unreadable dirs won't be ignored anymore
                $children->ignoreUnreadableDirs = $this->ignoreUnreadableDirs;

                // performance optimization to avoid redoing the same work in all children
                $children->rewindable = &$this->rewindable;
                $children->rootPath = $this->rootPath;
            }

            return $children;
        } catch (\UnexpectedValueException $e) {
            if ($this->ignoreUnreadableDirs) {
                // If directory is unreadable and finder is set to ignore it, a fake empty content is returned.
                return new \RecursiveArrayIterator(array());
            } else {
                throw new AccessDeniedException($e->getMessage(), $e->getCode(), $e);
            }
        }
    }

    /**
     * Do nothing for non rewindable stream.
     */
    public function rewind()
    {
        if (false === $this->isRewindable()) {
            return;
        }

        // @see https://bugs.php.net/68557
        if (PHP_VERSION_ID < 50523 || PHP_VERSION_ID >= 50600 && PHP_VERSION_ID < 50607) {
            parent::next();
        }

        parent::rewind();
    }

    /**
     * Checks if the stream is rewindable.
     *
     * @return bool true when the stream is rewindable, false otherwise
     */
    public function isRewindable()
    {
        if (null !== $this->rewindable) {
            return $this->rewindable;
        }

        if (false !== $stream = @opendir($this->getPath())) {
            $infos = stream_get_meta_data($stream);
            closedir($stream);

            if ($infos['seekable']) {
                return $this->rewindable = true;
            }
        }

        return $this->rewindable = false;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

use Symfony\Component\Finder\Comparator\NumberComparator;

/**
 * SizeRangeFilterIterator filters out files that are not in the given size range.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class SizeRangeFilterIterator extends FilterIterator
{
    private $comparators = array();

    /**
     * Constructor.
     *
     * @param \Iterator          $iterator    The Iterator to filter
     * @param NumberComparator[] $comparators An array of NumberComparator instances
     */
    public function __construct(\Iterator $iterator, array $comparators)
    {
        $this->comparators = $comparators;

        parent::__construct($iterator);
    }

    /**
     * Filters the iterator values.
     *
     * @return bool true if the value should be kept, false otherwise
     */
    public function accept()
    {
        $fileinfo = $this->current();
        if (!$fileinfo->isFile()) {
            return true;
        }

        $filesize = $fileinfo->getSize();
        foreach ($this->comparators as $compare) {
            if (!$compare->test($filesize)) {
                return false;
            }
        }

        return true;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Iterator;

/**
 * SortableIterator applies a sort on a given Iterator.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class SortableIterator implements \IteratorAggregate
{
    const SORT_BY_NAME = 1;
    const SORT_BY_TYPE = 2;
    const SORT_BY_ACCESSED_TIME = 3;
    const SORT_BY_CHANGED_TIME = 4;
    const SORT_BY_MODIFIED_TIME = 5;

    private $iterator;
    private $sort;

    /**
     * Constructor.
     *
     * @param \Traversable $iterator The Iterator to filter
     * @param int|callable $sort     The sort type (SORT_BY_NAME, SORT_BY_TYPE, or a PHP callback)
     *
     * @throws \InvalidArgumentException
     */
    public function __construct(\Traversable $iterator, $sort)
    {
        $this->iterator = $iterator;

        if (self::SORT_BY_NAME === $sort) {
            $this->sort = function ($a, $b) {
                return strcmp($a->getRealpath(), $b->getRealpath());
            };
        } elseif (self::SORT_BY_TYPE === $sort) {
            $this->sort = function ($a, $b) {
                if ($a->isDir() && $b->isFile()) {
                    return -1;
                } elseif ($a->isFile() && $b->isDir()) {
                    return 1;
                }

                return strcmp($a->getRealpath(), $b->getRealpath());
            };
        } elseif (self::SORT_BY_ACCESSED_TIME === $sort) {
            $this->sort = function ($a, $b) {
                return $a->getATime() - $b->getATime();
            };
        } elseif (self::SORT_BY_CHANGED_TIME === $sort) {
            $this->sort = function ($a, $b) {
                return $a->getCTime() - $b->getCTime();
            };
        } elseif (self::SORT_BY_MODIFIED_TIME === $sort) {
            $this->sort = function ($a, $b) {
                return $a->getMTime() - $b->getMTime();
            };
        } elseif (is_callable($sort)) {
            $this->sort = $sort;
        } else {
            throw new \InvalidArgumentException('The SortableIterator takes a PHP callable or a valid built-in sort algorithm as an argument.');
        }
    }

    public function getIterator()
    {
        $array = iterator_to_array($this->iterator, true);
        uasort($array, $this->sort);

        return new \ArrayIterator($array);
    }
}
Copyright (c) 2004-2016 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?xml version="1.0" encoding="UTF-8"?>

<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="vendor/autoload.php"
>
    <php>
        <ini name="error_reporting" value="-1" />
    </php>

    <testsuites>
        <testsuite name="Symfony Finder Component Test Suite">
            <directory>./Tests/</directory>
        </testsuite>
    </testsuites>

    <filter>
        <whitelist>
            <directory>./</directory>
            <exclude>
                <directory>./Tests</directory>
                <directory>./vendor</directory>
            </exclude>
        </whitelist>
    </filter>
</phpunit>
Finder Component
================

Finder finds files and directories via an intuitive fluent interface.

```php
use Symfony\Component\Finder\Finder;

$finder = new Finder();

$iterator = $finder
  ->files()
  ->name('*.php')
  ->depth(0)
  ->size('>= 1K')
  ->in(__DIR__);

foreach ($iterator as $file) {
    print $file->getRealpath()."\n";
}
```

The iterator returns instances of [Symfony\Component\Finder\SplFileInfo\SplFileInfo][1].
Besides the build-in methods inherited from [\SplFileInfo][2] (`getPerms()`, `getSize()`, ...),
you can also use `getRelativePath()` and `getRelativePathname()`. Read the
[official documentation][3] for more information.

But you can also use it to find files stored remotely like in this example where
we are looking for files on Amazon S3:

```php
$s3 = new \Zend_Service_Amazon_S3($key, $secret);
$s3->registerStreamWrapper("s3");

$finder = new Finder();
$finder->name('photos*')->size('< 100K')->date('since 1 hour ago');
foreach ($finder->in('s3://bucket-name') as $file) {
    print $file->getFilename()."\n";
}
```

Resources
---------

You can run the unit tests with the following command:

    $ cd path/to/Symfony/Component/Finder/
    $ composer install
    $ phpunit

[1]: http://api.symfony.com/2.5/Symfony/Component/Finder/SplFileInfo.html
[2]: http://php.net/splfileinfo
[3]: https://symfony.com/doc/current/components/finder.html#usage
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Shell;

@trigger_error('The '.__NAMESPACE__.'\Command class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0.
 */
class Command
{
    /**
     * @var Command|null
     */
    private $parent;

    /**
     * @var array
     */
    private $bits = array();

    /**
     * @var array
     */
    private $labels = array();

    /**
     * @var \Closure|null
     */
    private $errorHandler;

    /**
     * Constructor.
     *
     * @param Command|null $parent Parent command
     */
    public function __construct(Command $parent = null)
    {
        $this->parent = $parent;
    }

    /**
     * Returns command as string.
     *
     * @return string
     */
    public function __toString()
    {
        return $this->join();
    }

    /**
     * Creates a new Command instance.
     *
     * @param Command|null $parent Parent command
     *
     * @return Command New Command instance
     */
    public static function create(Command $parent = null)
    {
        return new self($parent);
    }

    /**
     * Escapes special chars from input.
     *
     * @param string $input A string to escape
     *
     * @return string The escaped string
     */
    public static function escape($input)
    {
        return escapeshellcmd($input);
    }

    /**
     * Quotes input.
     *
     * @param string $input An argument string
     *
     * @return string The quoted string
     */
    public static function quote($input)
    {
        return escapeshellarg($input);
    }

    /**
     * Appends a string or a Command instance.
     *
     * @param string|Command $bit
     *
     * @return Command The current Command instance
     */
    public function add($bit)
    {
        $this->bits[] = $bit;

        return $this;
    }

    /**
     * Prepends a string or a command instance.
     *
     * @param string|Command $bit
     *
     * @return Command The current Command instance
     */
    public function top($bit)
    {
        array_unshift($this->bits, $bit);

        foreach ($this->labels as $label => $index) {
            $this->labels[$label] += 1;
        }

        return $this;
    }

    /**
     * Appends an argument, will be quoted.
     *
     * @param string $arg
     *
     * @return Command The current Command instance
     */
    public function arg($arg)
    {
        $this->bits[] = self::quote($arg);

        return $this;
    }

    /**
     * Appends escaped special command chars.
     *
     * @param string $esc
     *
     * @return Command The current Command instance
     */
    public function cmd($esc)
    {
        $this->bits[] = self::escape($esc);

        return $this;
    }

    /**
     * Inserts a labeled command to feed later.
     *
     * @param string $label The unique label
     *
     * @return Command The current Command instance
     *
     * @throws \RuntimeException If label already exists
     */
    public function ins($label)
    {
        if (isset($this->labels[$label])) {
            throw new \RuntimeException(sprintf('Label "%s" already exists.', $label));
        }

        $this->bits[] = self::create($this);
        $this->labels[$label] = count($this->bits) - 1;

        return $this->bits[$this->labels[$label]];
    }

    /**
     * Retrieves a previously labeled command.
     *
     * @param string $label
     *
     * @return Command The labeled command
     *
     * @throws \RuntimeException
     */
    public function get($label)
    {
        if (!isset($this->labels[$label])) {
            throw new \RuntimeException(sprintf('Label "%s" does not exist.', $label));
        }

        return $this->bits[$this->labels[$label]];
    }

    /**
     * Returns parent command (if any).
     *
     * @return Command Parent command
     *
     * @throws \RuntimeException If command has no parent
     */
    public function end()
    {
        if (null === $this->parent) {
            throw new \RuntimeException('Calling end on root command doesn\'t make sense.');
        }

        return $this->parent;
    }

    /**
     * Counts bits stored in command.
     *
     * @return int The bits count
     */
    public function length()
    {
        return count($this->bits);
    }

    /**
     * @param \Closure $errorHandler
     *
     * @return Command
     */
    public function setErrorHandler(\Closure $errorHandler)
    {
        $this->errorHandler = $errorHandler;

        return $this;
    }

    /**
     * @return \Closure|null
     */
    public function getErrorHandler()
    {
        return $this->errorHandler;
    }

    /**
     * Executes current command.
     *
     * @return array The command result
     *
     * @throws \RuntimeException
     */
    public function execute()
    {
        if (null === $errorHandler = $this->errorHandler) {
            exec($this->join(), $output);
        } else {
            $process = proc_open($this->join(), array(0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'w')), $pipes);
            $output = preg_split('~(\r\n|\r|\n)~', stream_get_contents($pipes[1]), -1, PREG_SPLIT_NO_EMPTY);

            if ($error = stream_get_contents($pipes[2])) {
                $errorHandler($error);
            }

            proc_close($process);
        }

        return $output ?: array();
    }

    /**
     * Joins bits.
     *
     * @return string
     */
    public function join()
    {
        return implode(' ', array_filter(
            array_map(function ($bit) {
                return $bit instanceof Command ? $bit->join() : ($bit ?: null);
            }, $this->bits),
            function ($bit) { return null !== $bit; }
        ));
    }

    /**
     * Insert a string or a Command instance before the bit at given position $index (index starts from 0).
     *
     * @param string|Command $bit
     * @param int            $index
     *
     * @return Command The current Command instance
     */
    public function addAtIndex($bit, $index)
    {
        array_splice($this->bits, $index, 0, $bit instanceof self ? array($bit) : $bit);

        return $this;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder\Shell;

@trigger_error('The '.__NAMESPACE__.'\Shell class is deprecated since version 2.8 and will be removed in 3.0.', E_USER_DEPRECATED);

/**
 * @author Jean-FranÃ§ois Simon <contact@jfsimon.fr>
 *
 * @deprecated since 2.8, to be removed in 3.0.
 */
class Shell
{
    const TYPE_UNIX = 1;
    const TYPE_DARWIN = 2;
    const TYPE_CYGWIN = 3;
    const TYPE_WINDOWS = 4;
    const TYPE_BSD = 5;

    /**
     * @var string|null
     */
    private $type;

    /**
     * Returns guessed OS type.
     *
     * @return int
     */
    public function getType()
    {
        if (null === $this->type) {
            $this->type = $this->guessType();
        }

        return $this->type;
    }

    /**
     * Tests if a command is available.
     *
     * @param string $command
     *
     * @return bool
     */
    public function testCommand($command)
    {
        if (!function_exists('exec')) {
            return false;
        }

        // todo: find a better way (command could not be available)
        $testCommand = 'which ';
        if (self::TYPE_WINDOWS === $this->type) {
            $testCommand = 'where ';
        }

        $command = escapeshellcmd($command);

        exec($testCommand.$command, $output, $code);

        return 0 === $code && count($output) > 0;
    }

    /**
     * Guesses OS type.
     *
     * @return int
     */
    private function guessType()
    {
        $os = strtolower(PHP_OS);

        if (false !== strpos($os, 'cygwin')) {
            return self::TYPE_CYGWIN;
        }

        if (false !== strpos($os, 'darwin')) {
            return self::TYPE_DARWIN;
        }

        if (false !== strpos($os, 'bsd')) {
            return self::TYPE_BSD;
        }

        if (0 === strpos($os, 'win')) {
            return self::TYPE_WINDOWS;
        }

        return self::TYPE_UNIX;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Finder;

/**
 * Extends \SplFileInfo to support relative paths.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class SplFileInfo extends \SplFileInfo
{
    private $relativePath;
    private $relativePathname;

    /**
     * Constructor.
     *
     * @param string $file             The file name
     * @param string $relativePath     The relative path
     * @param string $relativePathname The relative path name
     */
    public function __construct($file, $relativePath, $relativePathname)
    {
        parent::__construct($file);
        $this->relativePath = $relativePath;
        $this->relativePathname = $relativePathname;
    }

    /**
     * Returns the relative path.
     *
     * This path does not contain the file name.
     *
     * @return string the relative path
     */
    public function getRelativePath()
    {
        return $this->relativePath;
    }

    /**
     * Returns the relative path name.
     *
     * This path contains the file name.
     *
     * @return string the relative path name
     */
    public function getRelativePathname()
    {
        return $this->relativePathname;
    }

    /**
     * Returns the contents of the file.
     *
     * @return string the contents of the file
     *
     * @throws \RuntimeException
     */
    public function getContents()
    {
        $level = error_reporting(0);
        $content = file_get_contents($this->getPathname());
        error_reporting($level);
        if (false === $content) {
            $error = error_get_last();
            throw new \RuntimeException($error['message']);
        }

        return $content;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

if (!extension_loaded('apc')) {
    return;
}

if (!function_exists('apcu_add')) {
    function apcu_add($key, $var = null, $ttl = 0) { return apc_add($key, $var, $ttl); }
    function apcu_cache_info($limited = false) { return apc_cache_info('user', $limited); }
    function apcu_cas($key, $old, $new) { return apc_cas($key, $old, $new); }
    function apcu_clear_cache() { return apc_clear_cache('user'); }
    function apcu_dec($key, $step = 1, &$success = false) { return apc_dec($key, $step, $success); }
    function apcu_delete($key) { return apc_delete($key); }
    function apcu_exists($keys) { return apc_exists($keys); }
    function apcu_fetch($key, &$success = false) { return apc_fetch($key, $success); }
    function apcu_inc($key, $step = 1, &$success = false) { return apc_inc($key, $step, $success); }
    function apcu_sma_info($limited = false) { return apc_sma_info($limited); }
    function apcu_store($key, $var = null, $ttl = 0) { return apc_store($key, $var, $ttl); }
}

if (!class_exists('APCUIterator', false) && class_exists('APCIterator', false)) {
    class APCUIterator extends APCIterator
    {
        public function __construct($search = null, $format = APC_ITER_ALL, $chunk_size = 100, $list = APC_LIST_ACTIVE)
        {
            parent::__construct('user', $search, $format, $chunk_size, $list);
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

/**
 * ApcClassLoader implements a wrapping autoloader cached in APC for PHP 5.3.
 *
 * It expects an object implementing a findFile method to find the file. This
 * allows using it as a wrapper around the other loaders of the component (the
 * ClassLoader and the UniversalClassLoader for instance) but also around any
 * other autoloaders following this convention (the Composer one for instance).
 *
 *     // with a Symfony autoloader
 *     use Symfony\Component\ClassLoader\ClassLoader;
 *
 *     $loader = new ClassLoader();
 *     $loader->addPrefix('Symfony\Component', __DIR__.'/component');
 *     $loader->addPrefix('Symfony',           __DIR__.'/framework');
 *
 *     // or with a Composer autoloader
 *     use Composer\Autoload\ClassLoader;
 *
 *     $loader = new ClassLoader();
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     $cachedLoader = new ApcClassLoader('my_prefix', $loader);
 *
 *     // activate the cached autoloader
 *     $cachedLoader->register();
 *
 *     // eventually deactivate the non-cached loader if it was registered previously
 *     // to be sure to use the cached one.
 *     $loader->unregister();
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Kris Wallsmith <kris@symfony.com>
 */
class ApcClassLoader
{
    private $prefix;

    /**
     * A class loader object that implements the findFile() method.
     *
     * @var object
     */
    protected $decorated;

    /**
     * Constructor.
     *
     * @param string $prefix    The APC namespace prefix to use.
     * @param object $decorated A class loader object that implements the findFile() method.
     *
     * @throws \RuntimeException
     * @throws \InvalidArgumentException
     */
    public function __construct($prefix, $decorated)
    {
        if (!function_exists('apcu_fetch')) {
            throw new \RuntimeException('Unable to use ApcClassLoader as APC is not installed.');
        }

        if (!method_exists($decorated, 'findFile')) {
            throw new \InvalidArgumentException('The class finder must implement a "findFile" method.');
        }

        $this->prefix = $prefix;
        $this->decorated = $decorated;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Unregisters this instance as an autoloader.
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

    /**
     * Loads the given class or interface.
     *
     * @param string $class The name of the class
     *
     * @return bool|null True, if loaded
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            require $file;

            return true;
        }
    }

    /**
     * Finds a file by class name while caching lookups to APC.
     *
     * @param string $class A class name to resolve to file
     *
     * @return string|null
     */
    public function findFile($class)
    {
        if (false === $file = apcu_fetch($this->prefix.$class)) {
            apcu_store($this->prefix.$class, $file = $this->decorated->findFile($class));
        }

        return $file;
    }

    /**
     * Passes through all unknown calls onto the decorated object.
     */
    public function __call($method, $args)
    {
        return call_user_func_array(array($this->decorated, $method), $args);
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

@trigger_error('The '.__NAMESPACE__.'\ApcUniversalClassLoader class is deprecated since version 2.7 and will be removed in 3.0. Use the Symfony\Component\ClassLoader\ApcClassLoader class instead.', E_USER_DEPRECATED);

/**
 * ApcUniversalClassLoader implements a "universal" autoloader cached in APC for PHP 5.3.
 *
 * It is able to load classes that use either:
 *
 *  * The technical interoperability standards for PHP 5.3 namespaces and
 *    class names (https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md);
 *
 *  * The PEAR naming convention for classes (http://pear.php.net/).
 *
 * Classes from a sub-namespace or a sub-hierarchy of PEAR classes can be
 * looked for in a list of locations to ease the vendoring of a sub-set of
 * classes for large projects.
 *
 * Example usage:
 *
 *     require 'vendor/symfony/src/Symfony/Component/ClassLoader/UniversalClassLoader.php';
 *     require 'vendor/symfony/src/Symfony/Component/ClassLoader/ApcUniversalClassLoader.php';
 *
 *     use Symfony\Component\ClassLoader\ApcUniversalClassLoader;
 *
 *     $loader = new ApcUniversalClassLoader('apc.prefix.');
 *
 *     // register classes with namespaces
 *     $loader->registerNamespaces(array(
 *         'Symfony\Component' => __DIR__.'/component',
 *         'Symfony' => __DIR__.'/framework',
 *         'Sensio' => array(__DIR__.'/src', __DIR__.'/vendor'),
 *     ));
 *
 *     // register a library using the PEAR naming convention
 *     $loader->registerPrefixes(array(
 *         'Swift_' => __DIR__.'/Swift',
 *     ));
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Kris Wallsmith <kris@symfony.com>
 *
 * @deprecated since version 2.4, to be removed in 3.0.
 *             Use the {@link ClassLoader} class instead.
 */
class ApcUniversalClassLoader extends UniversalClassLoader
{
    private $prefix;

    /**
     * Constructor.
     *
     * @param string $prefix A prefix to create a namespace in APC
     *
     * @throws \RuntimeException
     */
    public function __construct($prefix)
    {
        if (!function_exists('apcu_fetch')) {
            throw new \RuntimeException('Unable to use ApcUniversalClassLoader as APC is not enabled.');
        }

        $this->prefix = $prefix;
    }

    /**
     * Finds a file by class name while caching lookups to APC.
     *
     * @param string $class A class name to resolve to file
     *
     * @return string|null The path, if found
     */
    public function findFile($class)
    {
        if (false === $file = apcu_fetch($this->prefix.$class)) {
            apcu_store($this->prefix.$class, $file = parent::findFile($class));
        }

        return $file;
    }
}
CHANGELOG
=========

2.4.0
-----

 * deprecated the UniversalClassLoader in favor of the ClassLoader class instead
 * deprecated the ApcUniversalClassLoader in favor of the ApcClassLoader class instead
 * deprecated the DebugUniversalClassLoader in favor of the DebugClassLoader class from the Debug component
 * deprecated the DebugClassLoader as it has been moved to the Debug component instead

2.3.0
-----

 * added a WinCacheClassLoader for WinCache

2.1.0
-----

 * added a DebugClassLoader able to wrap any autoloader providing a findFile
   method
 * added a new ApcClassLoader and XcacheClassLoader using composition to wrap
   other loaders
 * added a new ClassLoader which does not distinguish between namespaced and
   pear-like classes (as the PEAR convention is a subset of PSR-0) and
   supports using Composer's namespace maps
 * added a class map generator
 * added support for loading globally-installed PEAR packages
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

/**
 * ClassCollectionLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class ClassCollectionLoader
{
    private static $loaded;
    private static $seen;
    private static $useTokenizer = true;

    /**
     * Loads a list of classes and caches them in one big file.
     *
     * @param array  $classes    An array of classes to load
     * @param string $cacheDir   A cache directory
     * @param string $name       The cache name prefix
     * @param bool   $autoReload Whether to flush the cache when the cache is stale or not
     * @param bool   $adaptive   Whether to remove already declared classes or not
     * @param string $extension  File extension of the resulting file
     *
     * @throws \InvalidArgumentException When class can't be loaded
     */
    public static function load($classes, $cacheDir, $name, $autoReload, $adaptive = false, $extension = '.php')
    {
        // each $name can only be loaded once per PHP process
        if (isset(self::$loaded[$name])) {
            return;
        }

        self::$loaded[$name] = true;

        $declared = array_merge(get_declared_classes(), get_declared_interfaces());
        if (function_exists('get_declared_traits')) {
            $declared = array_merge($declared, get_declared_traits());
        }

        if ($adaptive) {
            // don't include already declared classes
            $classes = array_diff($classes, $declared);

            // the cache is different depending on which classes are already declared
            $name = $name.'-'.substr(hash('sha256', implode('|', $classes)), 0, 5);
        }

        $classes = array_unique($classes);

        $cache = $cacheDir.'/'.$name.$extension;

        // auto-reload
        $reload = false;
        if ($autoReload) {
            $metadata = $cache.'.meta';
            if (!is_file($metadata) || !is_file($cache)) {
                $reload = true;
            } else {
                $time = filemtime($cache);
                $meta = unserialize(file_get_contents($metadata));

                sort($meta[1]);
                sort($classes);

                if ($meta[1] != $classes) {
                    $reload = true;
                } else {
                    foreach ($meta[0] as $resource) {
                        if (!is_file($resource) || filemtime($resource) > $time) {
                            $reload = true;

                            break;
                        }
                    }
                }
            }
        }

        if (!$reload && is_file($cache)) {
            require_once $cache;

            return;
        }

        $files = array();
        $content = '';
        foreach (self::getOrderedClasses($classes) as $class) {
            if (in_array($class->getName(), $declared)) {
                continue;
            }

            $files[] = $class->getFileName();

            $c = preg_replace(array('/^\s*<\?php/', '/\?>\s*$/'), '', file_get_contents($class->getFileName()));

            // fakes namespace declaration for global code
            if (!$class->inNamespace()) {
                $c = "\nnamespace\n{\n".$c."\n}\n";
            }

            $c = self::fixNamespaceDeclarations('<?php '.$c);
            $c = preg_replace('/^\s*<\?php/', '', $c);

            $content .= $c;
        }

        // cache the core classes
        if (!is_dir($cacheDir) && !@mkdir($cacheDir, 0777, true) && !is_dir($cacheDir)) {
            throw new \RuntimeException(sprintf('Class Collection Loader was not able to create directory "%s"', $cacheDir));
        }
        self::writeCacheFile($cache, '<?php '.$content);

        if ($autoReload) {
            // save the resources
            self::writeCacheFile($metadata, serialize(array($files, $classes)));
        }
    }

    /**
     * Adds brackets around each namespace if it's not already the case.
     *
     * @param string $source Namespace string
     *
     * @return string Namespaces with brackets
     */
    public static function fixNamespaceDeclarations($source)
    {
        if (!function_exists('token_get_all') || !self::$useTokenizer) {
            if (preg_match('/(^|\s)namespace(.*?)\s*;/', $source)) {
                $source = preg_replace('/(^|\s)namespace(.*?)\s*;/', "$1namespace$2\n{", $source)."}\n";
            }

            return $source;
        }

        $rawChunk = '';
        $output = '';
        $inNamespace = false;
        $tokens = token_get_all($source);

        for ($i = 0; isset($tokens[$i]); ++$i) {
            $token = $tokens[$i];
            if (!isset($token[1]) || 'b"' === $token) {
                $rawChunk .= $token;
            } elseif (in_array($token[0], array(T_COMMENT, T_DOC_COMMENT))) {
                // strip comments
                continue;
            } elseif (T_NAMESPACE === $token[0]) {
                if ($inNamespace) {
                    $rawChunk .= "}\n";
                }
                $rawChunk .= $token[1];

                // namespace name and whitespaces
                while (isset($tokens[++$i][1]) && in_array($tokens[$i][0], array(T_WHITESPACE, T_NS_SEPARATOR, T_STRING))) {
                    $rawChunk .= $tokens[$i][1];
                }
                if ('{' === $tokens[$i]) {
                    $inNamespace = false;
                    --$i;
                } else {
                    $rawChunk = rtrim($rawChunk)."\n{";
                    $inNamespace = true;
                }
            } elseif (T_START_HEREDOC === $token[0]) {
                $output .= self::compressCode($rawChunk).$token[1];
                do {
                    $token = $tokens[++$i];
                    $output .= isset($token[1]) && 'b"' !== $token ? $token[1] : $token;
                } while ($token[0] !== T_END_HEREDOC);
                $output .= "\n";
                $rawChunk = '';
            } elseif (T_CONSTANT_ENCAPSED_STRING === $token[0]) {
                $output .= self::compressCode($rawChunk).$token[1];
                $rawChunk = '';
            } else {
                $rawChunk .= $token[1];
            }
        }

        if ($inNamespace) {
            $rawChunk .= "}\n";
        }

        $output .= self::compressCode($rawChunk);

        if (PHP_VERSION_ID >= 70000) {
            // PHP 7 memory manager will not release after token_get_all(), see https://bugs.php.net/70098
            unset($tokens, $rawChunk);
            gc_mem_caches();
        }

        return $output;
    }

    /**
     * This method is only useful for testing.
     */
    public static function enableTokenizer($bool)
    {
        self::$useTokenizer = (bool) $bool;
    }

    /**
     * Strips leading & trailing ws, multiple EOL, multiple ws.
     *
     * @param string $code Original PHP code
     *
     * @return string compressed code
     */
    private static function compressCode($code)
    {
        return preg_replace(
            array('/^\s+/m', '/\s+$/m', '/([\n\r]+ *[\n\r]+)+/', '/[ \t]+/'),
            array('', '', "\n", ' '),
            $code
        );
    }

    /**
     * Writes a cache file.
     *
     * @param string $file    Filename
     * @param string $content Temporary file content
     *
     * @throws \RuntimeException when a cache file cannot be written
     */
    private static function writeCacheFile($file, $content)
    {
        $tmpFile = tempnam(dirname($file), basename($file));
        if (false !== @file_put_contents($tmpFile, $content) && @rename($tmpFile, $file)) {
            @chmod($file, 0666 & ~umask());

            return;
        }

        throw new \RuntimeException(sprintf('Failed to write cache file "%s".', $file));
    }

    /**
     * Gets an ordered array of passed classes including all their dependencies.
     *
     * @param array $classes
     *
     * @return \ReflectionClass[] An array of sorted \ReflectionClass instances (dependencies added if needed)
     *
     * @throws \InvalidArgumentException When a class can't be loaded
     */
    private static function getOrderedClasses(array $classes)
    {
        $map = array();
        self::$seen = array();
        foreach ($classes as $class) {
            try {
                $reflectionClass = new \ReflectionClass($class);
            } catch (\ReflectionException $e) {
                throw new \InvalidArgumentException(sprintf('Unable to load class "%s"', $class));
            }

            $map = array_merge($map, self::getClassHierarchy($reflectionClass));
        }

        return $map;
    }

    private static function getClassHierarchy(\ReflectionClass $class)
    {
        if (isset(self::$seen[$class->getName()])) {
            return array();
        }

        self::$seen[$class->getName()] = true;

        $classes = array($class);
        $parent = $class;
        while (($parent = $parent->getParentClass()) && $parent->isUserDefined() && !isset(self::$seen[$parent->getName()])) {
            self::$seen[$parent->getName()] = true;

            array_unshift($classes, $parent);
        }

        $traits = array();

        if (method_exists('ReflectionClass', 'getTraits')) {
            foreach ($classes as $c) {
                foreach (self::resolveDependencies(self::computeTraitDeps($c), $c) as $trait) {
                    if ($trait !== $c) {
                        $traits[] = $trait;
                    }
                }
            }
        }

        return array_merge(self::getInterfaces($class), $traits, $classes);
    }

    private static function getInterfaces(\ReflectionClass $class)
    {
        $classes = array();

        foreach ($class->getInterfaces() as $interface) {
            $classes = array_merge($classes, self::getInterfaces($interface));
        }

        if ($class->isUserDefined() && $class->isInterface() && !isset(self::$seen[$class->getName()])) {
            self::$seen[$class->getName()] = true;

            $classes[] = $class;
        }

        return $classes;
    }

    private static function computeTraitDeps(\ReflectionClass $class)
    {
        $traits = $class->getTraits();
        $deps = array($class->getName() => $traits);
        while ($trait = array_pop($traits)) {
            if ($trait->isUserDefined() && !isset(self::$seen[$trait->getName()])) {
                self::$seen[$trait->getName()] = true;
                $traitDeps = $trait->getTraits();
                $deps[$trait->getName()] = $traitDeps;
                $traits = array_merge($traits, $traitDeps);
            }
        }

        return $deps;
    }

    /**
     * Dependencies resolution.
     *
     * This function does not check for circular dependencies as it should never
     * occur with PHP traits.
     *
     * @param array            $tree       The dependency tree
     * @param \ReflectionClass $node       The node
     * @param \ArrayObject     $resolved   An array of already resolved dependencies
     * @param \ArrayObject     $unresolved An array of dependencies to be resolved
     *
     * @return \ArrayObject The dependencies for the given node
     *
     * @throws \RuntimeException if a circular dependency is detected
     */
    private static function resolveDependencies(array $tree, $node, \ArrayObject $resolved = null, \ArrayObject $unresolved = null)
    {
        if (null === $resolved) {
            $resolved = new \ArrayObject();
        }
        if (null === $unresolved) {
            $unresolved = new \ArrayObject();
        }
        $nodeName = $node->getName();

        if (isset($tree[$nodeName])) {
            $unresolved[$nodeName] = $node;
            foreach ($tree[$nodeName] as $dependency) {
                if (!$resolved->offsetExists($dependency->getName())) {
                    self::resolveDependencies($tree, $dependency, $resolved, $unresolved);
                }
            }
            $resolved[$nodeName] = $node;
            unset($unresolved[$nodeName]);
        }

        return $resolved;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

/**
 * ClassLoader implements an PSR-0 class loader.
 *
 * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md
 *
 *     $loader = new ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->addPrefix('Symfony\Component', __DIR__.'/component');
 *     $loader->addPrefix('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (e.g. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 */
class ClassLoader
{
    private $prefixes = array();
    private $fallbackDirs = array();
    private $useIncludePath = false;

    /**
     * Returns prefixes.
     *
     * @return array
     */
    public function getPrefixes()
    {
        return $this->prefixes;
    }

    /**
     * Returns fallback directories.
     *
     * @return array
     */
    public function getFallbackDirs()
    {
        return $this->fallbackDirs;
    }

    /**
     * Adds prefixes.
     *
     * @param array $prefixes Prefixes to add
     */
    public function addPrefixes(array $prefixes)
    {
        foreach ($prefixes as $prefix => $path) {
            $this->addPrefix($prefix, $path);
        }
    }

    /**
     * Registers a set of classes.
     *
     * @param string       $prefix The classes prefix
     * @param array|string $paths  The location(s) of the classes
     */
    public function addPrefix($prefix, $paths)
    {
        if (!$prefix) {
            foreach ((array) $paths as $path) {
                $this->fallbackDirs[] = $path;
            }

            return;
        }
        if (isset($this->prefixes[$prefix])) {
            if (is_array($paths)) {
                $this->prefixes[$prefix] = array_unique(array_merge(
                    $this->prefixes[$prefix],
                    $paths
                ));
            } elseif (!in_array($paths, $this->prefixes[$prefix])) {
                $this->prefixes[$prefix][] = $paths;
            }
        } else {
            $this->prefixes[$prefix] = array_unique((array) $paths);
        }
    }

    /**
     * Turns on searching the include for class files.
     *
     * @param bool $useIncludePath
     */
    public function setUseIncludePath($useIncludePath)
    {
        $this->useIncludePath = (bool) $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Unregisters this instance as an autoloader.
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

    /**
     * Loads the given class or interface.
     *
     * @param string $class The name of the class
     *
     * @return bool|null True, if loaded
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            require $file;

            return true;
        }
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|null The path, if found
     */
    public function findFile($class)
    {
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $classPath = str_replace('\\', DIRECTORY_SEPARATOR, substr($class, 0, $pos)).DIRECTORY_SEPARATOR;
            $className = substr($class, $pos + 1);
        } else {
            // PEAR-like class name
            $classPath = null;
            $className = $class;
        }

        $classPath .= str_replace('_', DIRECTORY_SEPARATOR, $className).'.php';

        foreach ($this->prefixes as $prefix => $dirs) {
            if ($class === strstr($class, $prefix)) {
                foreach ($dirs as $dir) {
                    if (file_exists($dir.DIRECTORY_SEPARATOR.$classPath)) {
                        return $dir.DIRECTORY_SEPARATOR.$classPath;
                    }
                }
            }
        }

        foreach ($this->fallbackDirs as $dir) {
            if (file_exists($dir.DIRECTORY_SEPARATOR.$classPath)) {
                return $dir.DIRECTORY_SEPARATOR.$classPath;
            }
        }

        if ($this->useIncludePath && $file = stream_resolve_include_path($classPath)) {
            return $file;
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

if (!defined('SYMFONY_TRAIT')) {
    if (PHP_VERSION_ID >= 50400) {
        define('SYMFONY_TRAIT', T_TRAIT);
    } else {
        define('SYMFONY_TRAIT', 0);
    }
}

/**
 * ClassMapGenerator.
 *
 * @author Gyula Sallai <salla016@gmail.com>
 */
class ClassMapGenerator
{
    /**
     * Generate a class map file.
     *
     * @param array|string $dirs Directories or a single path to search in
     * @param string       $file The name of the class map file
     */
    public static function dump($dirs, $file)
    {
        $dirs = (array) $dirs;
        $maps = array();

        foreach ($dirs as $dir) {
            $maps = array_merge($maps, static::createMap($dir));
        }

        file_put_contents($file, sprintf('<?php return %s;', var_export($maps, true)));
    }

    /**
     * Iterate over all files in the given directory searching for classes.
     *
     * @param \Iterator|string $dir The directory to search in or an iterator
     *
     * @return array A class map array
     */
    public static function createMap($dir)
    {
        if (is_string($dir)) {
            $dir = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($dir));
        }

        $map = array();

        foreach ($dir as $file) {
            if (!$file->isFile()) {
                continue;
            }

            $path = $file->getRealPath();

            if (pathinfo($path, PATHINFO_EXTENSION) !== 'php') {
                continue;
            }

            $classes = self::findClasses($path);

            if (PHP_VERSION_ID >= 70000) {
                // PHP 7 memory manager will not release after token_get_all(), see https://bugs.php.net/70098
                gc_mem_caches();
            }

            foreach ($classes as $class) {
                $map[$class] = $path;
            }
        }

        return $map;
    }

    /**
     * Extract the classes in the given file.
     *
     * @param string $path The file to check
     *
     * @return array The found classes
     */
    private static function findClasses($path)
    {
        $contents = file_get_contents($path);
        $tokens = token_get_all($contents);

        $classes = array();

        $namespace = '';
        for ($i = 0; isset($tokens[$i]); ++$i) {
            $token = $tokens[$i];

            if (!isset($token[1])) {
                continue;
            }

            $class = '';

            switch ($token[0]) {
                case T_NAMESPACE:
                    $namespace = '';
                    // If there is a namespace, extract it
                    while (isset($tokens[++$i][1])) {
                        if (in_array($tokens[$i][0], array(T_STRING, T_NS_SEPARATOR))) {
                            $namespace .= $tokens[$i][1];
                        }
                    }
                    $namespace .= '\\';
                    break;
                case T_CLASS:
                case T_INTERFACE:
                case SYMFONY_TRAIT:
                    // Skip usage of ::class constant
                    $isClassConstant = false;
                    for ($j = $i - 1; $j > 0; --$j) {
                        if (!isset($tokens[$j][1])) {
                            break;
                        }

                        if (T_DOUBLE_COLON === $tokens[$j][0]) {
                            $isClassConstant = true;
                            break;
                        } elseif (!in_array($tokens[$j][0], array(T_WHITESPACE, T_DOC_COMMENT, T_COMMENT))) {
                            break;
                        }
                    }

                    if ($isClassConstant) {
                        break;
                    }

                    // Find the classname
                    while (isset($tokens[++$i][1])) {
                        $t = $tokens[$i];
                        if (T_STRING === $t[0]) {
                            $class .= $t[1];
                        } elseif ('' !== $class && T_WHITESPACE === $t[0]) {
                            break;
                        }
                    }

                    $classes[] = ltrim($namespace.$class, '\\');
                    break;
                default:
                    break;
            }
        }

        return $classes;
    }
}
{
    "name": "symfony/class-loader",
    "type": "library",
    "description": "Symfony ClassLoader Component",
    "keywords": [],
    "homepage": "https://symfony.com",
    "license": "MIT",
    "authors": [
        {
            "name": "Fabien Potencier",
            "email": "fabien@symfony.com"
        },
        {
            "name": "Symfony Community",
            "homepage": "https://symfony.com/contributors"
        }
    ],
    "minimum-stability": "dev",
    "require": {
        "php": ">=5.3.9",
        "symfony/polyfill-apcu": "~1.1"
    },
    "require-dev": {
        "symfony/finder": "~2.0,>=2.0.5|~3.0.0"
    },
    "autoload": {
        "psr-4": { "Symfony\\Component\\ClassLoader\\": "" },
        "exclude-from-classmap": [
            "/Tests/"
        ]
    },
    "extra": {
        "branch-alias": {
            "dev-master": "2.8-dev"
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

@trigger_error('The '.__NAMESPACE__.'\DebugClassLoader class is deprecated since version 2.4 and will be removed in 3.0. Use the Symfony\Component\Debug\DebugClassLoader class instead.', E_USER_DEPRECATED);

/**
 * Autoloader checking if the class is really defined in the file found.
 *
 * The DebugClassLoader will wrap all registered autoloaders providing a
 * findFile method and will throw an exception if a file is found but does
 * not declare the class.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Christophe Coevoet <stof@notk.org>
 *
 * @deprecated since version 2.4, to be removed in 3.0.
 *             Use {@link \Symfony\Component\Debug\DebugClassLoader} instead.
 */
class DebugClassLoader
{
    private $classFinder;

    /**
     * Constructor.
     *
     * @param object $classFinder
     */
    public function __construct($classFinder)
    {
        $this->classFinder = $classFinder;
    }

    /**
     * Gets the wrapped class loader.
     *
     * @return object a class loader instance
     */
    public function getClassLoader()
    {
        return $this->classFinder;
    }

    /**
     * Replaces all autoloaders implementing a findFile method by a DebugClassLoader wrapper.
     */
    public static function enable()
    {
        if (!is_array($functions = spl_autoload_functions())) {
            return;
        }

        foreach ($functions as $function) {
            spl_autoload_unregister($function);
        }

        foreach ($functions as $function) {
            if (is_array($function) && !$function[0] instanceof self && method_exists($function[0], 'findFile')) {
                $function = array(new static($function[0]), 'loadClass');
            }

            spl_autoload_register($function);
        }
    }

    /**
     * Unregisters this instance as an autoloader.
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

    /**
     * Finds a file by class name.
     *
     * @param string $class A class name to resolve to file
     *
     * @return string|null
     */
    public function findFile($class)
    {
        return $this->classFinder->findFile($class);
    }

    /**
     * Loads the given class or interface.
     *
     * @param string $class The name of the class
     *
     * @return bool|null True, if loaded
     *
     * @throws \RuntimeException
     */
    public function loadClass($class)
    {
        if ($file = $this->classFinder->findFile($class)) {
            require $file;

            if (!class_exists($class, false) && !interface_exists($class, false) && (!function_exists('trait_exists') || !trait_exists($class, false))) {
                if (false !== strpos($class, '/')) {
                    throw new \RuntimeException(sprintf('Trying to autoload a class with an invalid name "%s". Be careful that the namespace separator is "\" in PHP, not "/".', $class));
                }

                throw new \RuntimeException(sprintf('The autoloader expected class "%s" to be defined in file "%s". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));
            }

            return true;
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

@trigger_error('The '.__NAMESPACE__.'\DebugUniversalClassLoader class is deprecated since version 2.4 and will be removed in 3.0. Use the Symfony\Component\Debug\DebugClassLoader class instead.', E_USER_DEPRECATED);

/**
 * Checks that the class is actually declared in the included file.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since version 2.4, to be removed in 3.0.
 *             Use the {@link \Symfony\Component\Debug\DebugClassLoader} class instead.
 */
class DebugUniversalClassLoader extends UniversalClassLoader
{
    /**
     * Replaces all regular UniversalClassLoader instances by a DebugUniversalClassLoader ones.
     */
    public static function enable()
    {
        if (!is_array($functions = spl_autoload_functions())) {
            return;
        }

        foreach ($functions as $function) {
            spl_autoload_unregister($function);
        }

        foreach ($functions as $function) {
            if (is_array($function) && $function[0] instanceof UniversalClassLoader) {
                $loader = new static();
                $loader->registerNamespaceFallbacks($function[0]->getNamespaceFallbacks());
                $loader->registerPrefixFallbacks($function[0]->getPrefixFallbacks());
                $loader->registerNamespaces($function[0]->getNamespaces());
                $loader->registerPrefixes($function[0]->getPrefixes());
                $loader->useIncludePath($function[0]->getUseIncludePath());

                $function[0] = $loader;
            }

            spl_autoload_register($function);
        }
    }

    /**
     * {@inheritdoc}
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            require $file;

            if (!class_exists($class, false) && !interface_exists($class, false) && (!function_exists('trait_exists') || !trait_exists($class, false))) {
                throw new \RuntimeException(sprintf('The autoloader expected class "%s" to be defined in file "%s". The file was found but the class was not in it, the class name or namespace probably has a typo.', $class, $file));
            }
        }
    }
}
Copyright (c) 2004-2016 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

/**
 * A class loader that uses a mapping file to look up paths.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class MapClassLoader
{
    private $map = array();

    /**
     * Constructor.
     *
     * @param array $map A map where keys are classes and values the absolute file path
     */
    public function __construct(array $map)
    {
        $this->map = $map;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Loads the given class or interface.
     *
     * @param string $class The name of the class
     */
    public function loadClass($class)
    {
        if (isset($this->map[$class])) {
            require $this->map[$class];
        }
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|null The path, if found
     */
    public function findFile($class)
    {
        if (isset($this->map[$class])) {
            return $this->map[$class];
        }
    }
}
<?xml version="1.0" encoding="UTF-8"?>

<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="vendor/autoload.php"
>
    <php>
        <ini name="error_reporting" value="-1" />
    </php>

    <testsuites>
        <testsuite name="Symfony ClassLoader Component Test Suite">
            <directory>./Tests/</directory>
        </testsuite>
    </testsuites>

    <filter>
        <whitelist>
            <directory>./</directory>
            <exclude>
                <directory>./Resources</directory>
                <directory>./Tests</directory>
                <directory>./vendor</directory>
            </exclude>
        </whitelist>
    </filter>
</phpunit>
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

/**
 * A PSR-4 compatible class loader.
 *
 * See http://www.php-fig.org/psr/psr-4/
 *
 * @author Alexander M. Turek <me@derrabus.de>
 */
class Psr4ClassLoader
{
    /**
     * @var array
     */
    private $prefixes = array();

    /**
     * @param string $prefix
     * @param string $baseDir
     */
    public function addPrefix($prefix, $baseDir)
    {
        $prefix = trim($prefix, '\\').'\\';
        $baseDir = rtrim($baseDir, DIRECTORY_SEPARATOR).DIRECTORY_SEPARATOR;
        $this->prefixes[] = array($prefix, $baseDir);
    }

    /**
     * @param string $class
     *
     * @return string|null
     */
    public function findFile($class)
    {
        $class = ltrim($class, '\\');

        foreach ($this->prefixes as $current) {
            list($currentPrefix, $currentBaseDir) = $current;
            if (0 === strpos($class, $currentPrefix)) {
                $classWithoutPrefix = substr($class, strlen($currentPrefix));
                $file = $currentBaseDir.str_replace('\\', DIRECTORY_SEPARATOR, $classWithoutPrefix).'.php';
                if (file_exists($file)) {
                    return $file;
                }
            }
        }
    }

    /**
     * @param string $class
     *
     * @return bool
     */
    public function loadClass($class)
    {
        $file = $this->findFile($class);
        if (null !== $file) {
            require $file;

            return true;
        }

        return false;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Removes this instance from the registered autoloaders.
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }
}
ClassLoader Component
=====================

ClassLoader loads your project classes automatically if they follow some
standard PHP conventions.

The ClassLoader object is able to autoload classes that implement the PSR-0
standard or the PEAR naming convention.

First, register the autoloader:

```php
require_once __DIR__.'/src/Symfony/Component/ClassLoader/ClassLoader.php';

use Symfony\Component\ClassLoader\ClassLoader;

$loader = new ClassLoader();
$loader->register();
```

Then, register some namespaces with the `addPrefix()` method:

```php
$loader->addPrefix('Symfony', __DIR__.'/src');
$loader->addPrefix('Monolog', __DIR__.'/vendor/monolog/src');
```

The `addPrefix()` method takes a namespace prefix and a path where to
look for the classes as arguments.

You can also register a sub-namespaces:

```php
$loader->addPrefix('Doctrine\\Common', __DIR__.'/vendor/doctrine-common/lib');
```

The order of registration is significant and the first registered namespace
takes precedence over later registered one.

You can also register more than one path for a given namespace:

```php
$loader->addPrefix('Symfony', array(__DIR__.'/src', __DIR__.'/symfony/src'));
```

Alternatively, you can use the `addPrefixes()` method to register more
than one namespace at once:

```php
$loader->addPrefixes(array(
    'Symfony' => array(__DIR__.'/src', __DIR__.'/symfony/src'),
    'Doctrine\\Common' => __DIR__.'/vendor/doctrine-common/lib',
    'Doctrine' => __DIR__.'/vendor/doctrine/lib',
    'Monolog' => __DIR__.'/vendor/monolog/src',
));
```

For better performance, you can use the APC class loader:

```php
require_once __DIR__.'/src/Symfony/Component/ClassLoader/ClassLoader.php';
require_once __DIR__.'/src/Symfony/Component/ClassLoader/ApcClassLoader.php';

use Symfony\Component\ClassLoader\ClassLoader;
use Symfony\Component\ClassLoader\ApcClassLoader;

$loader = new ClassLoader();
$loader->addPrefix('Symfony', __DIR__.'/src');

$loader = new ApcClassLoader('apc.prefix.', $loader);
$loader->register();
```

Furthermore, the component provides tools to aggregate classes into a single
file, which is especially useful to improve performance on servers that do not
provide byte caches.

Resources
---------

You can run the unit tests with the following command:

    $ cd path/to/Symfony/Component/ClassLoader/
    $ composer install
    $ phpunit
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

@trigger_error('The '.__NAMESPACE__.'\UniversalClassLoader class is deprecated since version 2.7 and will be removed in 3.0. Use the Symfony\Component\ClassLoader\ClassLoader class instead.', E_USER_DEPRECATED);

/**
 * UniversalClassLoader implements a "universal" autoloader for PHP 5.3.
 *
 * It is able to load classes that use either:
 *
 *  * The technical interoperability standards for PHP 5.3 namespaces and
 *    class names (https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md);
 *
 *  * The PEAR naming convention for classes (http://pear.php.net/).
 *
 * Classes from a sub-namespace or a sub-hierarchy of PEAR classes can be
 * looked for in a list of locations to ease the vendoring of a sub-set of
 * classes for large projects.
 *
 * Example usage:
 *
 *     $loader = new UniversalClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->registerNamespaces(array(
 *         'Symfony\Component' => __DIR__.'/component',
 *         'Symfony' => __DIR__.'/framework',
 *         'Sensio' => array(__DIR__.'/src', __DIR__.'/vendor'),
 *     ));
 *
 *     // register a library using the PEAR naming convention
 *     $loader->registerPrefixes(array(
 *         'Swift_' => __DIR__.'/Swift',
 *     ));
 *
 *
 *     // to enable searching the include path (e.g. for PEAR packages)
 *     $loader->useIncludePath(true);
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 *
 * @deprecated since version 2.4, to be removed in 3.0.
 *             Use the {@link ClassLoader} class instead.
 */
class UniversalClassLoader
{
    private $namespaces = array();
    private $prefixes = array();
    private $namespaceFallbacks = array();
    private $prefixFallbacks = array();
    private $useIncludePath = false;

    /**
     * Turns on searching the include for class files. Allows easy loading
     * of installed PEAR packages.
     *
     * @param bool $useIncludePath
     */
    public function useIncludePath($useIncludePath)
    {
        $this->useIncludePath = (bool) $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Gets the configured namespaces.
     *
     * @return array A hash with namespaces as keys and directories as values
     */
    public function getNamespaces()
    {
        return $this->namespaces;
    }

    /**
     * Gets the configured class prefixes.
     *
     * @return array A hash with class prefixes as keys and directories as values
     */
    public function getPrefixes()
    {
        return $this->prefixes;
    }

    /**
     * Gets the directory(ies) to use as a fallback for namespaces.
     *
     * @return array An array of directories
     */
    public function getNamespaceFallbacks()
    {
        return $this->namespaceFallbacks;
    }

    /**
     * Gets the directory(ies) to use as a fallback for class prefixes.
     *
     * @return array An array of directories
     */
    public function getPrefixFallbacks()
    {
        return $this->prefixFallbacks;
    }

    /**
     * Registers the directory to use as a fallback for namespaces.
     *
     * @param array $dirs An array of directories
     */
    public function registerNamespaceFallbacks(array $dirs)
    {
        $this->namespaceFallbacks = $dirs;
    }

    /**
     * Registers a directory to use as a fallback for namespaces.
     *
     * @param string $dir A directory
     */
    public function registerNamespaceFallback($dir)
    {
        $this->namespaceFallbacks[] = $dir;
    }

    /**
     * Registers directories to use as a fallback for class prefixes.
     *
     * @param array $dirs An array of directories
     */
    public function registerPrefixFallbacks(array $dirs)
    {
        $this->prefixFallbacks = $dirs;
    }

    /**
     * Registers a directory to use as a fallback for class prefixes.
     *
     * @param string $dir A directory
     */
    public function registerPrefixFallback($dir)
    {
        $this->prefixFallbacks[] = $dir;
    }

    /**
     * Registers an array of namespaces.
     *
     * @param array $namespaces An array of namespaces (namespaces as keys and locations as values)
     */
    public function registerNamespaces(array $namespaces)
    {
        foreach ($namespaces as $namespace => $locations) {
            $this->namespaces[$namespace] = (array) $locations;
        }
    }

    /**
     * Registers a namespace.
     *
     * @param string       $namespace The namespace
     * @param array|string $paths     The location(s) of the namespace
     */
    public function registerNamespace($namespace, $paths)
    {
        $this->namespaces[$namespace] = (array) $paths;
    }

    /**
     * Registers an array of classes using the PEAR naming convention.
     *
     * @param array $classes An array of classes (prefixes as keys and locations as values)
     */
    public function registerPrefixes(array $classes)
    {
        foreach ($classes as $prefix => $locations) {
            $this->prefixes[$prefix] = (array) $locations;
        }
    }

    /**
     * Registers a set of classes using the PEAR naming convention.
     *
     * @param string       $prefix The classes prefix
     * @param array|string $paths  The location(s) of the classes
     */
    public function registerPrefix($prefix, $paths)
    {
        $this->prefixes[$prefix] = (array) $paths;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Loads the given class or interface.
     *
     * @param string $class The name of the class
     *
     * @return bool|null True, if loaded
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            require $file;

            return true;
        }
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|null The path, if found
     */
    public function findFile($class)
    {
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $namespace = substr($class, 0, $pos);
            $className = substr($class, $pos + 1);
            $normalizedClass = str_replace('\\', DIRECTORY_SEPARATOR, $namespace).DIRECTORY_SEPARATOR.str_replace('_', DIRECTORY_SEPARATOR, $className).'.php';
            foreach ($this->namespaces as $ns => $dirs) {
                if (0 !== strpos($namespace, $ns)) {
                    continue;
                }

                foreach ($dirs as $dir) {
                    $file = $dir.DIRECTORY_SEPARATOR.$normalizedClass;
                    if (is_file($file)) {
                        return $file;
                    }
                }
            }

            foreach ($this->namespaceFallbacks as $dir) {
                $file = $dir.DIRECTORY_SEPARATOR.$normalizedClass;
                if (is_file($file)) {
                    return $file;
                }
            }
        } else {
            // PEAR-like class name
            $normalizedClass = str_replace('_', DIRECTORY_SEPARATOR, $class).'.php';
            foreach ($this->prefixes as $prefix => $dirs) {
                if (0 !== strpos($class, $prefix)) {
                    continue;
                }

                foreach ($dirs as $dir) {
                    $file = $dir.DIRECTORY_SEPARATOR.$normalizedClass;
                    if (is_file($file)) {
                        return $file;
                    }
                }
            }

            foreach ($this->prefixFallbacks as $dir) {
                $file = $dir.DIRECTORY_SEPARATOR.$normalizedClass;
                if (is_file($file)) {
                    return $file;
                }
            }
        }

        if ($this->useIncludePath && $file = stream_resolve_include_path($normalizedClass)) {
            return $file;
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

/**
 * WinCacheClassLoader implements a wrapping autoloader cached in WinCache.
 *
 * It expects an object implementing a findFile method to find the file. This
 * allow using it as a wrapper around the other loaders of the component (the
 * ClassLoader and the UniversalClassLoader for instance) but also around any
 * other autoloaders following this convention (the Composer one for instance).
 *
 *     // with a Symfony autoloader
 *     use Symfony\Component\ClassLoader\ClassLoader;
 *
 *     $loader = new ClassLoader();
 *     $loader->addPrefix('Symfony\Component', __DIR__.'/component');
 *     $loader->addPrefix('Symfony',           __DIR__.'/framework');
 *
 *     // or with a Composer autoloader
 *     use Composer\Autoload\ClassLoader;
 *
 *     $loader = new ClassLoader();
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     $cachedLoader = new WinCacheClassLoader('my_prefix', $loader);
 *
 *     // activate the cached autoloader
 *     $cachedLoader->register();
 *
 *     // eventually deactivate the non-cached loader if it was registered previously
 *     // to be sure to use the cached one.
 *     $loader->unregister();
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Kris Wallsmith <kris@symfony.com>
 * @author Artem Ryzhkov <artem@smart-core.org>
 */
class WinCacheClassLoader
{
    private $prefix;

    /**
     * A class loader object that implements the findFile() method.
     *
     * @var object
     */
    protected $decorated;

    /**
     * Constructor.
     *
     * @param string $prefix    The WinCache namespace prefix to use.
     * @param object $decorated A class loader object that implements the findFile() method.
     *
     * @throws \RuntimeException
     * @throws \InvalidArgumentException
     */
    public function __construct($prefix, $decorated)
    {
        if (!extension_loaded('wincache')) {
            throw new \RuntimeException('Unable to use WinCacheClassLoader as WinCache is not enabled.');
        }

        if (!method_exists($decorated, 'findFile')) {
            throw new \InvalidArgumentException('The class finder must implement a "findFile" method.');
        }

        $this->prefix = $prefix;
        $this->decorated = $decorated;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Unregisters this instance as an autoloader.
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

    /**
     * Loads the given class or interface.
     *
     * @param string $class The name of the class
     *
     * @return bool|null True, if loaded
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            require $file;

            return true;
        }
    }

    /**
     * Finds a file by class name while caching lookups to WinCache.
     *
     * @param string $class A class name to resolve to file
     *
     * @return string|null
     */
    public function findFile($class)
    {
        if (false === $file = wincache_ucache_get($this->prefix.$class)) {
            wincache_ucache_set($this->prefix.$class, $file = $this->decorated->findFile($class), 0);
        }

        return $file;
    }

    /**
     * Passes through all unknown calls onto the decorated object.
     */
    public function __call($method, $args)
    {
        return call_user_func_array(array($this->decorated, $method), $args);
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\ClassLoader;

/**
 * XcacheClassLoader implements a wrapping autoloader cached in XCache for PHP 5.3.
 *
 * It expects an object implementing a findFile method to find the file. This
 * allows using it as a wrapper around the other loaders of the component (the
 * ClassLoader and the UniversalClassLoader for instance) but also around any
 * other autoloaders following this convention (the Composer one for instance).
 *
 *     // with a Symfony autoloader
 *     use Symfony\Component\ClassLoader\ClassLoader;
 *
 *     $loader = new ClassLoader();
 *     $loader->addPrefix('Symfony\Component', __DIR__.'/component');
 *     $loader->addPrefix('Symfony',           __DIR__.'/framework');
 *
 *     // or with a Composer autoloader
 *     use Composer\Autoload\ClassLoader;
 *
 *     $loader = new ClassLoader();
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     $cachedLoader = new XcacheClassLoader('my_prefix', $loader);
 *
 *     // activate the cached autoloader
 *     $cachedLoader->register();
 *
 *     // eventually deactivate the non-cached loader if it was registered previously
 *     // to be sure to use the cached one.
 *     $loader->unregister();
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Kris Wallsmith <kris@symfony.com>
 * @author Kim HemsÃ¸ Rasmussen <kimhemsoe@gmail.com>
 */
class XcacheClassLoader
{
    private $prefix;

    /**
     * A class loader object that implements the findFile() method.
     *
     * @var object
     */
    private $decorated;

    /**
     * Constructor.
     *
     * @param string $prefix    The XCache namespace prefix to use.
     * @param object $decorated A class loader object that implements the findFile() method.
     *
     * @throws \RuntimeException
     * @throws \InvalidArgumentException
     */
    public function __construct($prefix, $decorated)
    {
        if (!extension_loaded('xcache')) {
            throw new \RuntimeException('Unable to use XcacheClassLoader as XCache is not enabled.');
        }

        if (!method_exists($decorated, 'findFile')) {
            throw new \InvalidArgumentException('The class finder must implement a "findFile" method.');
        }

        $this->prefix = $prefix;
        $this->decorated = $decorated;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * Unregisters this instance as an autoloader.
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));
    }

    /**
     * Loads the given class or interface.
     *
     * @param string $class The name of the class
     *
     * @return bool|null True, if loaded
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            require $file;

            return true;
        }
    }

    /**
     * Finds a file by class name while caching lookups to Xcache.
     *
     * @param string $class A class name to resolve to file
     *
     * @return string|null
     */
    public function findFile($class)
    {
        if (xcache_isset($this->prefix.$class)) {
            $file = xcache_get($this->prefix.$class);
        } else {
            $file = $this->decorated->findFile($class);
            xcache_set($this->prefix.$class, $file);
        }

        return $file;
    }

    /**
     * Passes through all unknown calls onto the decorated object.
     */
    public function __call($method, $args)
    {
        return call_user_func_array(array($this->decorated, $method), $args);
    }
}
<?php

namespace CLIFramework\Ansi;

use InvalidArgumentException;

/**
 * ANSI Color definitions.
 *
 * @author Yo-An Lin <yoanlin93@gmail.com>
 */
class Colors
{
    const CODE_PATTERN = '#\033\[\d{0,1}[,;]?\d*(?:;\d2)?m#x';

    protected static $foregroundColors = array(
        'black' => '0;30',
        'dark_gray' => '1;30',
        'blue' => '0;34',
        'light_blue' => '1;34',
        'green' => '0;32',
        'light_green' => '1;32',
        'cyan' => '0;36',
        'light_cyan' => '1;36',
        'red' => '0;31',
        'light_red' => '1;31',
        'purple' => '0;35',
        'light_purple' => '1;35',
        'brown' => '0;33',
        'yellow' => '1;33',
        'light_gray' => '0;37',
        'white' => '1;37',
    );

    protected static $backgroundColors = array(
        'black' => '40',
        'red' => '41',
        'green' => '42',
        'yellow' => '43',
        'blue' => '44',
        'magenta' => '45',
        'cyan' => '46',
        'light_gray' => '47',
    );

    protected static $attributes = array(
        'bold' => 1,
        'dim' => 2,
        'underline' => 4,
        'blink' => 5,
        'reverse' => 7,
        'hidden' => 8,
    );

    public static function stripAnsiEscapeCode($str)
    {
        return preg_replace(self::CODE_PATTERN, '', $str);
    }

    public static function strlenWithoutAnsiEscapeCode($str)
    {
        $plain = preg_replace(self::CODE_PATTERN, '', $str);

        return mb_strlen($plain);
    }

    public static function reset()
    {
        return "\033[0m";
    }

    public static function attribute($text, $attribute)
    {
        if (!isset(self::$attributes[$attribute])) {
            throw new InvalidArgumentException("Undefined attribute $attribute");
        }
        $str = "\033[".self::$attributes[$attribute].'m';
        $str .= $text;
        $str = "\033[0m";

        return $str;
    }

    // Returns colored string
    public static function decorate($string, $fg = null, $bg = null, $attribute = null)
    {
        $coloredString = '';

        // Check if given foreground color found
        if ($fg && isset(self::$foregroundColors[$fg])) {
            $coloredString .= "\033[".self::$foregroundColors[$fg].'m';
        }
        // Check if given background color found
        if ($bg && isset(self::$backgroundColors[$bg])) {
            $coloredString .= "\033[".self::$backgroundColors[$bg].'m';
        }

        if ($attribute) {
            $coloredString .= "\033[".self::$attributes[$attribute].'m';
        }

        // Add string and end coloring
        $coloredString .=  $string;

        if ($fg || $bg) {
            $coloredString .= "\033[0m";
        }

        return $coloredString;
    }

    // Returns all foreground color names
    public static function getForegroundColors()
    {
        return array_keys(self::$foregroundColors);
    }

    // Returns all background color names
    public static function getBackgroundColors()
    {
        return array_keys(self::$backgroundColors);
    }
}
<?php

namespace CLIFramework\Ansi;

/**
 * @codeCoverageIgnore
 */
class CursorControl
{
    protected $fd;

    public function __construct($fd = null)
    {
        $this->fd = $fd ?: fopen('php://stderr', 'w');
    }

    /**
     * Sets the cursor position where subsequent text will begin. If no 
     * row/column parameters are provided (ie. <ESC>[H), the cursor will move 
     * to the home position, at the upper left of the screen.
     */
    public function home($row, $col)
    {
        fwrite($this->fd, "\e[{$row};{$column}H");
    }

    public function up($count = 1)
    {
        fwrite($this->fd, "\e[{$count}A");
    }

    public function down($count = 1)
    {
        fwrite($this->fd, "\e[{$count}B");
    }

    public function forward($count = 1)
    {
        fwrite($this->fd, "\e[{$count}C");
    }

    public function backward($count = 1)
    {
        fwrite($this->fd, "\e[{$count}D");
    }

    /**
     * Force Cursor Position.
     *
     * Identical to Cursor Home.
     */
    public function position($row, $column)
    {
        fwrite($this->fd, "\e[{$row},{$column}f");
    }

    /**
     * Save Cursor & Attrs.
     *
     * Save current cursor position.
     */
    public function save($attrs = true)
    {
        if ($attrs) {
            fwrite($this->fd, "\e7");
        }
        fwrite($this->fd, "\e[s");
    }

    /**
     * Restore Cursor & Attrs.
     *
     * Restores cursor position after a Save Cursor.
     */
    public function restore($attrs = true)
    {
        if ($attrs) {
            fwrite($this->fd, "\e8");
        }
        fwrite($this->fd, "\e[u");
    }

    public function hide()
    {
        fwrite($this->fd, "\e[?25l");
    }

    public function show()
    {
        fwrite($this->fd, "\e[?25h");
    }
}
<?php
/*
 * This file is part of the {{ }} package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace CLIFramework;
use GetOptionKit\ContinuousOptionParser;
use GetOptionKit\OptionCollection;

use CLIFramework\CommandLoader;
use CLIFramework\CommandBase;
use CLIFramework\Logger;
use CLIFramework\CommandInterface;
use CLIFramework\Prompter;
use CLIFramework\CommandGroup;
use CLIFramework\Formatter;
use CLIFramework\Corrector;
use CLIFramework\ServiceContainer;
use CLIFramework\Exception\CommandNotFoundException;
use CLIFramework\Exception\CommandArgumentNotEnoughException;
use CLIFramework\Exception\ExecuteMethodNotDefinedException;
use Pimple\Container;

use CLIFramework\ExceptionPrinter\ProductionExceptionPrinter;
use CLIFramework\ExceptionPrinter\DevelopmentExceptionPrinter;

use Exception;
use ReflectionClass;
use InvalidArgumentException;
use BadMethodCallException;

class Application extends CommandBase
    implements CommandInterface
{
    const CORE_VERSION = '2.5.4';
    const VERSION = "2.8.1";
    const NAME = 'CLIFramework';


    /**
     * timestamp when started
     */
    public $startedAt;


    public $supportReadline;


    public $showAppSignature = true;


    /**
     *
     */
    public $topics = array();

    /**
     * @var CLIFramework\Formatter
     */
    public $formatter;

    /**
     * Command message logger.
     *
     * (This should be deprecated since we use service container from now on).
     *
     * @var CLIFramework\Logger
     */
    public $logger;


    public $programName;


    

    /**
     * @var CLIFramework\ServiceContainer
     */
    protected $serviceContainer;


    /**
     * @var Unviersal\Event\PhpEvent
     */
    protected $eventService;


    /**
     * cliframework global config
     */
    protected $globalConfig;


    /** @var bool */
    protected $commandAutoloadEnabled = false;

    public function __construct(Container $container = null, CommandBase $parent = null)
    {
        parent::__construct($parent);

        $this->serviceContainer = $container ?: ServiceContainer::getInstance();

        if (isset($this->serviceContainer['event'])) {
            $this->eventService = $this->serviceContainer['event'];
        } else {
            $this->eventService = PhpEvent::getInstance();
        }

        // initliaze command loader
        // TODO: if the service is not defined, we should create them with default settings.
        $this->loader    = $this->serviceContainer['command_loader'];
        $this->logger    = $this->serviceContainer['logger'];
        $this->formatter = $this->serviceContainer['formatter'];
        $this->globalConfig = $this->serviceContainer['config'];

        // get current class namespace, add {App}\Command\ to loader
        $appRefClass = new ReflectionClass($this);
        $appNs = $appRefClass->getNamespaceName();
        $this->loader->addNamespace( '\\' . $appNs . '\\Command' );
        $this->loader->addNamespace( array('\\CLIFramework\\Command' ));

        $this->supportReadline = extension_loaded('readline');
    }


    /**
     * @return Pimple\Container
     */
    public function getService()
    {
        return $this->serviceContainer;
    }

    public function getEventService()
    {
        return $this->eventService;
    }

    /**
     * Enable command autoload feature.
     *
     * @return void
     */
    public function enableCommandAutoload()
    {
        $this->commandAutoloadEnabled = true;
    }

    /**
     * Disable command autoload feature.
     *
     * @return void
     */
    public function disableCommandAutoload()
    {
        $this->commandAutoloadEnabled = false;
    }

    /**
     * Use ReflectionClass to get the namespace of the current running app.
     * (not CLIFramework\Application itself)
     *
     * @return string classname
     */
    public function getCurrentAppNamespace() {
        $refClass = new ReflectionClass($this);
        return $refClass->getNamespaceName();
    }


    /**
     * @return string brief of this application
     */
    public function brief()
    {
        return 'application brief';
    }

    public function usage()
    {
    }

    /**
     * Register application option specs to the parser
     */
    public function options($opts)
    {
        $opts->add('v|verbose','Print verbose message.');
        $opts->add('d|debug'  ,'Print debug message.');
        $opts->add('q|quiet'  ,'Be quiet.');
        $opts->add('h|help'   ,'Show help.');
        $opts->add('version'  ,'Show version.');

        $opts->add('p|profile','Display timing and memory usage information.');
        $opts->add('log-path?', 'The path of a log file.');
        // Un-implemented options
        $opts->add('no-interact','Do not ask any interactive question.');
        // $opts->add('no-ansi', 'Disable ANSI output.');
    }

    public function topics(array $topics) 
    {
        foreach($topics as $key => $val) {
            if (is_numeric($key)) {
                $this->topics[$val] = $this->loadTopic($val);
            } else {
                $this->topics[$key] = $this->loadTopic($val);
            }
        }
    }

    public function topic($topicId, $topicClass = null) 
    {
        $this->topics[$topicId] = $topicClass ? new $topicClass: $this->loadTopic($topicId);
    }

    public function getTopic($topicId) 
    {
        if (isset($this->topics[$topicId])) {
            return $this->topics[$topicId];
        }
    }

    public function loadTopic($topicId) 
    {
        // existing class name or full-qualified class name
        if (class_exists($topicId, true)) {
            return new $topicId;
        }
        if (!preg_match('/Topic$/', $topicId)) {
            $className = ucfirst($topicId) . 'Topic';
        } else {
            $className = ucfirst($topicId);
        }
        $possibleNs = array($this->getCurrentAppNamespace(), 'CLIFramework');
        foreach($possibleNs as $ns) {
            $class = $ns . '\\' . 'Topic' . '\\' . $className;
            if (class_exists($class, true)) {
                return new $class;
            }
        }
        throw new InvalidArgumentException("Topic $topicId not found.");
    }

    /*
     * init application,
     *
     * users register command mapping here. (command to class name)
     */
    public function init()
    {
        // $this->addCommand('list','CLIFramework\\Command\\ListCommand');
        parent::init();
        $this->command('help','CLIFramework\\Command\\HelpCommand');
        $this->commandGroup("Development Commands", array(
            'zsh'                 => 'CLIFramework\\Command\\ZshCompletionCommand',
            'bash'                => 'CLIFramework\\Command\\BashCompletionCommand',
            'meta'                => 'CLIFramework\\Command\\MetaCommand',
            'compile'             => 'CLIFramework\\Command\\CompileCommand',
            'archive'             => 'CLIFramework\\Command\\ArchiveCommand',
            'github:build-topics' => 'CLIFramework\\Command\\BuildGitHubWikiTopicsCommand',
        ))->setId('dev');
    }

    /**
     * Execute `run` method with a default try & catch block to catch the exception.
     *
     * @param array $argv
     *
     * @return bool return true for success, false for failure. the returned
     *              state will be reflected to the exit code of the process.
     */
    public function runWithTry(array $argv)
    {
        try {
            return $this->run($argv);
        } catch (CommandArgumentNotEnoughException $e) {
            $this->logger->error( $e->getMessage() );
            $this->logger->writeln("Expected argument prototypes:");
            foreach($e->getCommand()->getAllCommandPrototype() as $p) {
                $this->logger->writeln("\t" . $p);
            }
            $this->logger->newline();
        } catch (CommandNotFoundException $e) {
            $this->logger->error( $e->getMessage() . " available commands are: " . join(', ', $e->getCommand()->getVisibleCommandList())  );
            $this->logger->newline();

            $this->logger->writeln("Please try the command below to see the details:");
            $this->logger->newline();
            $this->logger->writeln("\t" . $this->getProgramName() . ' help ' );
            $this->logger->newline();
        } catch (BadMethodCallException $e) {

            $this->logger->error($e->getMessage());
            $this->logger->error("Seems like an application logic error, please contact the developer.");

        } catch (Exception $e) {

            if ($this->options && $this->options->debug) {
                $printer = new DevelopmentExceptionPrinter($this->getLogger());
                $printer->dump($e);
            } else {
                $printer = new ProductionExceptionPrinter($this->getLogger());
                $printer->dump($e);
            }
        }

        return false;
    }

    /**
     * Run application with
     * list argv
     *
     * @param Array $argv
     *
     * @return bool return true for success, false for failure. the returned
     *              state will be reflected to the exit code of the process.
     * */
    public function run(Array $argv)
    {
        $this->setProgramName($argv[0]);

        $currentCmd = $this;

        // init application,
        // before parsing options, we have to known the registered commands.
        $currentCmd->_init();

        // use getoption kit to parse application options
        $getopt = new ContinuousOptionParser($currentCmd->optionSpecs);

        // parse the first part options (options after script name)
        // option parser should stop before next command name.
        //
        //    $ app.php -v -d next
        //                  |
        //                  |->> parser
        //
        //
        $appOptions = $getopt->parse( $argv );
        $currentCmd->setOptions($appOptions);
        if (false === $currentCmd->prepare()) {
            return false;
        }


        $command_stack = array();
        $arguments = array();

        // get command list from application self
        while ( ! $getopt->isEnd() ) {
            $a = $getopt->getCurrentArgument();

            // if current command is in subcommand list.

            if ($currentCmd->hasCommands()) {
                $a = $getopt->getCurrentArgument();

                if (!$currentCmd->hasCommand($a) ) {
                    if (!$appOptions->noInteract && ($guess = $currentCmd->guessCommand($a)) !== NULL) {
                        $a = $guess;
                    } else {
                        throw new CommandNotFoundException($currentCmd, $a);
                    }
                }

                $getopt->advance(); // advance position

                // get command object
                $currentCmd = $currentCmd->getCommand($a);
                $getopt->setSpecs($currentCmd->optionSpecs);

                // parse options for command.
                $currentCmd->setOptions($getopt->continueParse());
                $command_stack[] = $currentCmd; // save command object into the stack

            } else {
                $a = $getopt->advance();
                $arguments[] = $a;
            }
        }

        foreach ($command_stack as $cmd) {
            if (false === $cmd->prepare()) {
                return false;
            }
        }

        // get last command and run
        if ( $last_cmd = array_pop( $command_stack ) ) {
            $return = $last_cmd->executeWrapper( $arguments );
            $last_cmd->finish();
            while ( $cmd = array_pop( $command_stack ) ) {
                // call finish stage.. of every command.
                $cmd->finish();
            }
        } else {
            // no command specified.
            return $this->executeWrapper( $arguments );
        }
        $currentCmd->finish();
        $this->finish();
        return true;
    }

    /**
     * This is a `before` trigger of an app. when the application is getting
     * started, we run `prepare` method to prepare the settings.
     */
    public function prepare()
    {
        $this->startedAt = microtime(true);
        $options = $this->getOptions();
        $config = $this->getGlobalConfig();

        if ($options->debug || $options->verbose || $options->quiet) {

            if ($options->debug) {
                $this->getLogger()->setDebug();
            } else if ($options->verbose) {
                $this->getLogger()->setVerbose();
            } else if ($options->quiet) {
                $this->getLogger()->setLevel(2);
            }

        } else {

            if ($config->isDebug()) {
                $this->getLogger()->setDebug();
            } else if ($config->isVerbose()) {
                $this->getLogger()->setVerbose();
            }

        }

        return true;
    }

    public function finish() {
        if ($this->options->profile) {
            $this->logger->info(
                sprintf('Memory usage: %.2fMB (peak: %.2fMB), time: %.4fs',
                    memory_get_usage(true) / (1024 * 1024),
                    memory_get_peak_usage(true) / (1024 * 1024),
                    (microtime(true) - $this->startedAt)
                )
            );
        }
    }

    public function getCoreVersion()
    {
        if ( defined('static::core_version') ) {
            return static::core_version;
        }
        if ( defined('static::CORE_VERSION') ) {
            return static::CORE_VERSION;
        }
    }

    public function getVersion()
    {
        if ( defined('static::VERSION') ) {
            return static::VERSION;
        }
        if ( defined('static::version') ) {
            return static::version;
        }
    }

    public function setProgramName($programName) {
        $this->programName = $programName;
    }

    public function getProgramName() {
        return $this->programName;
    }

    public function getName()
    {
        if ( defined('static::NAME') ) {
            return static::NAME;
        }
        if ( defined('static::name') ) {
            return static::name;
        }
    }

    /**
     * This method is the top logic of an application. when there is no
     * argument provided, we show help content by default.
     *
     * @return bool return true if success
     */
    public function execute()
    {
        $options = $this->getOptions();
        if ($options->version) {
            $this->logger->writeln($this->getName() . ' - ' . $this->getVersion());
            $this->logger->writeln("cliframework core: " . $this->getCoreVersion());
            return true;
        }

        $arguments = func_get_args();

        // show list and help by default
        $help = $this->getCommand('help');
        $help->setOptions($options);
        if ($help || $options->help) {
            $help->executeWrapper($arguments);
            return true;
        }
        throw new CommandNotFoundException($this, 'help');
    }

    public function getFormatter()
    {
        return $this->formatter;
    }

    public function getLogger()
    {
        return $this->logger;
    }

    public function getGlobalConfig()
    {
        return $this->globalConfig;
    }


    /**
     * A quick helper for accessing service
     */
    public function __get($name) 
    {
        if (isset($this->serviceContainer[$name])) {
            return $this->serviceContainer[$name];
        }
        throw new InvalidArgumentException("Application class doesn't have `$name` service or property.");
    }

    public static function getInstance()
    {
        static $app;
        if( $app )
            return $app;
        return $app = new static;
    }
    

}
<?php
namespace CLIFramework;
use CLIFramework\ValueCollection;

class ArgInfo
{
    public $name;

    public $isa;

    public $optional;

    public $multiple;

    public $suggestions;

    public $validValues;

    protected $validator;

    /* file/path glob pattern */
    public $glob;

    public function __construct($name, $desc = null)
    {
        $this->name = $name;
        if ($desc) {
            $this->desc = $desc;
        }
    }

    public function isa($isa) {
        $this->isa = $isa;
        return $this;
    }

    public function desc($desc) {
        $this->desc = $desc;
        return $this;
    }

    public function optional($optional = true) {
        $this->optional = $optional;
        return $this;
    }

    public function multiple($a = true) {
        $this->multiple = $a;
        return $this;
    }

    public function validValues($val) {
        $this->validValues = $val;
        return $this;
    }

    public function validator($cb) {
        $this->validator = $cb;
        return $this;
    }

    /**
     * Assign suggestions
     *
     * @param string[]|string|Closure $value
     *
     * $value can be an array of strings, or a closure
     *
     * If $value is string, the prefix "zsh:" will be translated into zsh function call.
     */
    public function suggestions($values) {
        $this->suggestions = $values;
        return $this;
    }


    /**
     * Specify argument glob pattern
     */
    public function glob($g) {
        $this->glob = $g;
        return $this;
    }


    public function getSuggestions() {
        if ($this->suggestions) {
            if (is_callable($this->suggestions)) {
                return call_user_func($this->suggestions);
            }
            return $this->suggestions;
        }
    }


    public function getValidValues() {
        if ($this->validValues) {
            if (is_callable($this->validValues)) {
                return call_user_func($this->validValues);
            }
            return $this->validValues;
        }
    }

    /**
     * Test a value if it match the spec
     */
    public function validate($value) {
        if ($this->isa) {
            switch($this->isa) {
            case "number":
                return is_numeric($value);
            case "boolean":
                return is_bool($value);
            case "string":
                return is_string($value);
            }
        }
        $validValues = $this->getValidValues();
        if ($validValues && $validValues instanceof ValueCollection) {
            return $validValues->containsValue($value);
        } elseif ( is_array($validValues) ) {
            return in_array($value, $validValues);
        }
        if ($this->validator) {
            return call_user_func($this->validator);
        }
        return true;
    }

}


<?php
namespace CLIFramework;
use ArrayAccess;
use IteratorAggregate;
use Countable;
use ArrayIterator;
use ArrayObject;

class ArgInfoList extends ArrayObject {

    public function add($name) {
        $arginfo = new ArgInfo($name);
        $this->append($arginfo);
        return $arginfo;
    }

}




<?php

namespace CLIFramework\ArgumentEditor;

class ArgumentEditor
{
    public $args = array();

    public function __construct($args = array())
    {
        $this->args = $args;
    }

    public function append($arg)
    {
        $args = func_get_args();
        foreach ($args as $arg) {
            $this->args[] = trim($arg);
        }

        return $this;
    }

    public function remove($arg)
    {
        $p = 0;
        $removed = 0;
        while ($p !== false) {
            // search next
            $p = array_search($arg, $this->args);
            if ($p !== false) {
                array_splice($this->args, $p);
                ++$removed;
            }
        }

        return $removed;
    }

    public function replace($needle, $newarg)
    {
        $p = array_search($needle, $this->args);
        if ($p !== false) {
            $spliced = array_splice($this->args, $p, 1, $newarg);

            return $spliced[0];
        }

        return false;
    }

    public function replaceRegExp($regexp, $newarg)
    {
        $regexp = '/'.preg_quote($regexp, '/').'/';
        $this->args = preg_replace($regexp, $newarg, $this->args);
    }

    /**
     * Remove arguments by regular expression pattern.
     *
     * @param string $regexp
     */
    public function removeRegExp($regexp)
    {
        $regexp = '/'.preg_quote($regexp, '/').'/';
        $this->args = preg_grep($regexp, $this->args, PREG_GREP_INVERT);
    }

    /**
     * Filter all arguments through a closure.
     *
     * @param Closue 
     */
    public function filter($callback)
    {
        $this->args = array_map($callback, $this->args);

        return $this;
    }

    /**
     * Run escape fitler to current arguments.
     */
    public function escape()
    {
        $this->args = array_map(function ($arg) {
            return escapeshellarg($arg);
        }, $this->args);
    }

    /**
     * Output current argument to string.
     */
    public function __toString()
    {
        return implode(' ', $this->args);
    }
}
<?php

namespace CLIFramework\Autoload;

use RuntimeException;
use CodeGen\Expr\NewObjectExpr;
use CodeGen\Block;
use CodeGen\Statement\UseStatement;
use CodeGen\Statement\AssignStatement;
use CodeGen\Statement\MethodCallStatement;
use CodeGen\Statement\RequireStatement;
use Symfony\Component\Finder\Finder;
use Symfony\Component\ClassLoader\ClassMapGenerator;
use CLIFramework\Logger;

class ComposerAutoloadGenerator
{
    /**
     * @var array[ package name ] = composer config array
     */
    protected $packages = array();

    protected $workingDir = '';

    protected $vendorDir = 'vendor';

    protected $logger;

    protected $includeDevDependencies = false;

    public function __construct(Logger $logger)
    {
        $this->workingDir = getcwd(); // by default workingDir is current directory.
        $this->logger = $logger;
    }

    public function setWorkingDir($workingDir)
    {
        $this->workingDir = $workingDir;
    }

    public function setVendorDir($vendorDir)
    {
        $this->vendorDir = $vendorDir;
    }

    public function traceAutoloadsWithComposerJson($composerJson = 'composer.json', $isRoot = false)
    {
        $json = file_get_contents($composerJson);
        $config = json_decode($json, true);
        if ($isRoot) {
            $config['root'] = true;
        }
        if (isset($config['name'])) {
            $this->packages[ $config['name'] ] = $config;
        }

        return $this->traceAutoloads($config, $isRoot);
    }

    public function traceAutoloadsWithRequirements(array $config, array $requirements = array())
    {
        $this->logger->debug('Tracing autoload from package: '.@$config['name']);

        $autoloads = array();
        foreach ($requirements as $packageName => $requirement) {
            if (in_array($packageName, array('php', 'hhvm'))) {
                continue;
            } elseif (preg_match('/^(?:ext|lib)-/', $packageName)) {
                continue;
            }

            // get config from composer.json
            if (isset($config['name']) && $config['name'] === $packageName) {
                $packageComposerJson = $this->workingDir.DIRECTORY_SEPARATOR.'composer.json';
            } else {
                $packageComposerJson = $this->workingDir.DIRECTORY_SEPARATOR.$this->vendorDir.DIRECTORY_SEPARATOR.$packageName.DIRECTORY_SEPARATOR.'composer.json';
            }

            if (file_exists($packageComposerJson)) {
                $packageAutoloads = $this->traceAutoloadsWithComposerJson($packageComposerJson, false); // don't include require-dev for dependencies
                $autoloads = array_merge($autoloads, $packageAutoloads);
            } elseif (isset($this->packages[ $packageName ])) {
                $config = $this->packages[ $packageName ];
                $autoloads = array_merge($autoloads, $this->traceAutoloads($config, false));
            } else {
                // if (!file_exists($packageComposerJson)) {
                throw new RuntimeException("Missing composer.json file: $packageComposerJson");
            }
        }

        return $autoloads;
    }

    public function traceAutoloads(array $config, $isRoot = false)
    {
        $autoloads = array();

        // @see https://getcomposer.org/doc/02-libraries.md#platform-packages
        if (isset($config['require'])) {
            $this->logger->debug('Tracing package autoload from "require" section');
            $autoloads = array_merge($autoloads, $this->traceAutoloadsWithRequirements($config, $config['require']));
        }
        if ($isRoot && $this->includeDevDependencies && isset($config['require-dev'])) {
            $this->logger->debug('Tracing package autoload from "require-dev" section');
            $autoloads = array_merge($autoloads, $this->traceAutoloadsWithRequirements($config, $config['require-dev']));
        }

        if (isset($config['autoload'])) {
            if ($isRoot) {
                $baseDir = $this->workingDir;
            } else {
                $baseDir = $this->workingDir.DIRECTORY_SEPARATOR.$this->vendorDir.DIRECTORY_SEPARATOR.$config['name'];
            }

            // target-dir is deprecated, but somehow we need to support some
            // psr-0 class loader with target-dir
            // @see https://getcomposer.org/doc/04-schema.md#target-dir
            if (isset($config['target-dir'])) {
                $this->logger->warn("Found deprecated property 'target-dir' in package ".$config['name']);

                $baseDir = $config['target-dir'];
                $autoloads[$config['name']] = $this->prependAutoloadPathPrefix($config['autoload'], $config['target-dir']);
            }

            if (isset($config['autoload']['classmap'])) {

                // Expand and replace classmap array
                $map = array();
                foreach ($config['autoload']['classmap'] as $path) {
                    $this->logger->debug("Scanning classmap in $path");
                    $map = array_merge($map, ClassMapGenerator::createMap($baseDir.DIRECTORY_SEPARATOR.$path));
                }

                // Strip paths with working directory:
                // ClassMapGenerator returns class map with files in absolute paths,
                // We need them to be relative paths.
                foreach ($map as $k => $filepath) {
                    $map[$k] = str_replace($baseDir.DIRECTORY_SEPARATOR, '', $filepath);
                }

                $config['autoload']['classmap'] = $map;
            }

            $autoloads[$config['name'] ] = $config;
        }

        return $autoloads;
    }

    /**
     * Prepend a prefix for the structure in 'autoload' property. 
     * e.g., { 'psr-0': ... 'psr-4': ...  }.
     */
    public function prependAutoloadPathPrefix(array $autoloads, $prefix)
    {
        $newAutoloads = array();
        foreach ($autoloads as $autoloadType => &$autoloadConfig) {
            $newConfig = array();
            foreach ($autoloadConfig as $ns => $path) {
                if (is_array($path)) {
                    $newConfig[ $ns ] = array_map($path, function ($p) use ($prefix) {
                        return $prefix.$p;
                    });
                } else {
                    $newConfig[ $ns ] = $prefix.$path;
                }
            }
            $newAutoloads[ $autoloadType ] = $newConfig;
        }

        return $newAutoloads;
    }

    public function scanComposerJsonFiles()
    {
        // Find composer.json files that are not in their corresponding package directory
        $finder = new Finder();
        $finder->name('composer.json');
        $finder->in($this->workingDir.DIRECTORY_SEPARATOR.$this->vendorDir);
        foreach ($finder as $file) {
            $config = json_decode(file_get_contents($file), true);
            if (isset($config['name'])) {
                $this->packages[ $config['name'] ] = $config;
            }
        }
    }

    public function generate($composerConfigFile, $pharFile = 'output.phar')
    {
        $pharMap = 'phar://'.$pharFile.'/';
        $autoloads = $this->traceAutoloadsWithComposerJson($composerConfigFile, $this->vendorDir, true);

        $psr0 = array();
        $psr4 = array();
        $files = array();
        $map = array();

        foreach ($autoloads as $packageName => $config) {
            $autoload = $config['autoload'];

            // The returned autoload paths are relative paths in their packages
            // We need to prepend the package base dir path
            if (!isset($config['root'])) {
                $autoload = $this->prependAutoloadPathPrefix($autoload, $pharMap.$this->vendorDir.DIRECTORY_SEPARATOR.$packageName.DIRECTORY_SEPARATOR);
            } else {
                $autoload = $this->prependAutoloadPathPrefix($autoload, $pharMap);
            }

            if (isset($autoload['psr-4'])) {
                $psr4 = array_merge($psr4, $autoload['psr-4']);
            }
            if (isset($autoload['psr-0'])) {
                $psr0 = array_merge($psr0, $autoload['psr-0']);
            }
            if (isset($autoload['files'])) {
                $files = array_merge($files, $autoload['files']);
            }
            if (isset($autoload['classmap'])) {

                // the classmap here is an expanded classmap associative array
                $map = array_merge($map, $autoload['classmap']);
            }
        }

        $this->logger->debug('Generating class loader code...');

        // Generate classloader initialization code
        $block = new Block();
        $block[] = new UseStatement('Universal\\ClassLoader\\Psr0ClassLoader');
        $block[] = new UseStatement('Universal\\ClassLoader\\Psr4ClassLoader');
        $block[] = new UseStatement('Universal\\ClassLoader\\MapClassLoader');

        if (!empty($files)) {
            foreach ($files as $file) {
                $block[] = new RequireStatement($file);
            }
        }

        if (!empty($map)) {
            $this->logger->debug('Found classmap autoload, adding MapClassLoader...');

            $block[] = new AssignStatement('$map', new NewObjectExpr('MapClassLoader', array($map)));
            $block[] = new MethodCallStatement('$map', 'register', array(false));
        }

        if (!empty($psr4)) {
            $this->logger->debug('Found PSR-4 autoload, adding Psr4ClassLoader...');

            // translate psr-4 mapping for Psr4ClassLoader
            $arg = array();
            foreach ($psr4 as $prefix => $paths) {
                $arg[] = array($prefix, $paths);
            }
            $block[] = new AssignStatement('$psr4', new NewObjectExpr('Psr4ClassLoader', array($arg)));
            $block[] = new MethodCallStatement('$psr4', 'register', array(false));
        }

        if (!empty($psr0)) {
            $this->logger->debug('Found PSR-0 autoload, adding Psr0ClassLoader...');

            $arg = array();
            foreach ($psr0 as $prefix => $paths) {
                $arg[$prefix] = (array) $paths;
            }
            $block[] = new AssignStatement('$psr0', new NewObjectExpr('Psr0ClassLoader', array($arg)));
            $block[] = new MethodCallStatement('$psr0', 'register', array(false));
        }

        $this->logger->debug('Rendering code using CodeGen...');

        return $block->render();
    }
}
<?php
namespace CLIFramework;

// TODO: refactoring this to a standalone package.

class Buffer {
    public $content = '';

    public $indent = 0;

    protected $indentCache = '';

    public $indentChar = '  ';

    public $format;

    const FORMAT_UNIX = 0;
    const FORMAT_DOS = 1;

    public $newline = "\n";

    public function __construct($content = '') {
        $this->content = $content;
        $this->format = self::FORMAT_UNIX;
    }

    public function indent() {
        $this->indent++;
        $this->_updateIndentCache();
    }

    /**
     * Set indent level
     *
     * @param integer $indent
     */
    public function setIndent($indent) {
        $this->indent = $indent;
        $this->_updateIndentCache();
    }

    /**
     * Get current indent level
     *
     * @return integer
     */
    public function getIndent() {
        return $this->indent;
    }

    public function setIndentChar($char) {
        $this->indentChar = $char;
    }

    public function getIndentChar() {
        return $this->indentChar;
    }

    public function unindent() {
        if ($this->indent > 0) {
            $this->indent--;
            $this->_updateIndentCache();
        }
    }

    public function _updateIndentCache() {
        $this->indentCache = str_repeat($this->indentChar, $this->indent);
    }

    public function makeIndent($level) {
        return str_repeat($this->indentChar, $level);
    }

    /**
     * Append a text to the buffer
     */
    public function append($text)
    {
        $this->content .= $text;
    }


    /**
     * Append a line with indent to the buffer
     *
     * @param string $line
     * @param integer $indent
     */
    public function appendLine($line, $indent = 0) {
        $this->content .= ($indent ? $this->makeIndent($indent) : $this->indentCache) . $line . $this->newline;
    }


    /**
     * Append multiple lines with indent to the buffer
     *
     * @param string[] $lines
     * @param integer $indent
     */
    public function appendLines($lines, $indent = 0) {
        foreach($lines as $line) {
            $this->appendLine($line, $indent);
        }
    }

    /**
     * Append a string and escape with charlist
     *
     * @param string $line
     * @param string $charlist
     */
    public function appendEscape($line, $charlist) {
        $this->content .= addcslashes($line, $charlist);
    }

    /**
     * Append a string with addslashes function to the buffer
     *
     * @param string $line
     */
    public function appendEscapeSlash($line) {
        $this->content .= addslashes($line);
    }

    /**
     * Append a string with double quotes 
     *
     * @param string $str
     */
    public function appendQuoteString($str) {
        $this->content .= '"' . addcslashes($str , '"') . '"';
    }


    /**
     * Append a string with single quotes
     *
     * @param string $str
     */
    public function appendSingleQuoteString($str) {
        $this->content .= "'" . addslashes($str) . "'";
    }


    /**
     * Append a new line to the buffer
     */
    public function newLine() {
        $this->content .= $this->newline;
    }


    /**
     * Set line format
     *
     * @param integer $format Buffer::FORMAT_UNIX or Buffer::FORMAT_DOS
     */
    public function setFormat($format) {
        $this->format = $format;
        if ($this->format == self::FORMAT_UNIX) {
            $this->newline = "\n";
        } elseif ($this->format == self::FORMAT_DOS) {
            $this->newline = "\r\n";
        }
    }


    /**
     * Append a string block (multilines)
     *
     * @param string $block
     * @param integer $indent = 0
     */
    public function appendBlock($block, $indent = 0) {
        $lines = explode("\n", $block);
        foreach($lines as $line) {
            $this->appendLine($line, $indent);
        }
    }


    /**
     * Append a buffer object
     *
     * @param Buffer $buf
     * @param integer $indent = 0
     */
    public function appendBuffer(Buffer $buf, $indent = 0) {
        if ( $indent ) {
            $this->setIndent($indent);
            $lines = $buf->lines();
            foreach( $lines as $line ) {
                $this->appendLine($line);
            }
        } else {
            $this->content .= $buf->__toString();
        }
    }


    /**
     * Split buffer content into lines
     *
     * @return string[] lines
     */
    public function lines() {
        return $this->explode($this->newline, $this->content);
    }

    /**
     * Output the buffer as a string
     */
    public function __toString() {
        return $this->content;
    }
}

<?php
namespace CLIFramework;
use CLIFramework\Command;



/**
 * A ChainedCommand contains multiple commands together,
 *
 * Subcommands of a chained command use the same options,
 * same logger, same application and are executed by sequence.
 */
class ChainedCommand extends Command
{
    /**
     * @var array Command class names
     */
    public $commands = array();

    public function options($opts) 
    {
        $cmds = $this->getChainedCommands();
        foreach($cmds as $cmd)
            $cmd->options($opts);
    }

    public function getChainedCommands() 
    {
        $cmds = array();
        foreach( $this->commands as $command ) {
            $cmd = new $command($this->application);
            $cmd->logger = $this->logger;
            $cmd->parent = $this;
            $cmds[] = $cmd;
        }
        return $cmds;
    }

    public function execute() 
    {
        $this->logger->info('Executing chained commands: ' . join(',', $this->commands ));
        $args = func_get_args();
        $cmds = $this->getChainedCommands();
        foreach( $cmds as $cmd ) {
            $cmd->options = $this->options;
            $cmd->executeWrapper($args);
        }
        $this->logger->info('Done');
    }
}

<?php
namespace CLIFramework;
use CLIFramework\Formatter;

/**
 * Prompter class
 *
 *
 *
 */
class Chooser
{

    public $style;
    public $formatter;

    public function __construct()
    {
        $this->formatter = new Formatter;
    }

    /**
     * set prompt style
     */
    public function setStyle($style)
    {
        return $this->style = $style;
    }

    /**
     *
     *
     */
    public function choose($prompt, $choices )
    {
        echo $prompt . ": \n";

        $choicesMap = array();

        // Not an indexed array
        if (! isset($choices[0])) {
            $i = 0;
            foreach ($choices as $choice => $value) {
                $i++;
                $choicesMap[ $i ] = $value;
                echo "\t" . ($i) . "  $choice\n";
            }
        } else {
            foreach ($choices as $choice => $desc) {
                $choicesMap[$choice] = $choice;
                echo "\t$choice: $desc\n";
            }
        }

        if ($this->style) {
            echo $this->formatter->getStartMark( $this->style );
        }

        $completionItems = array_keys($choicesMap);
        $choosePrompt = "Please Choose 1-$i > ";
        while (1) {
            if (extension_loaded('readline')) {
                $success = readline_completion_function(function($string, $index) use ($completionItems) { 
                    return $completionItems;
                });
                $answer = readline($choosePrompt);
                readline_add_history($answer);
            } else {
                echo $choosePrompt;
                $answer = rtrim( fgets( STDIN ), "\n" );
            }

            $answer = (int) trim( $answer );
            if (is_integer($answer)) {
                if ( isset( $choicesMap[$answer] ) ) {
                    if( $this->style )
                        echo $this->formatter->getClearMark();

                    return $choicesMap[$answer];
                } else {
                    continue;
                }
            }
            break;
        }
    }

}
<?php

namespace CLIFramework\Command;

use CLIFramework\Command;
use CLIFramework\Autoload\ComposerAutoloadGenerator;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use FilesystemIterator;
use RuntimeException;
use Exception;
use Phar;
use CodeGen\Block;
use CodeGen\Expr\NewObjectExpr;
use CodeGen\Statement\AssignStatement;
use CodeGen\Statement\MethodCallStatement;
use CodeGen\Statement\RequireStatement;
use CLIFramework\PharKit\PharGenerator;
use CLIFramework\PharKit\PharURI;
use CLIFramework\Utils;
use ReflectionClass;
use ReflectionObject;
use SplFileInfo;

/**
 * Archive: build phar file from composer.json.
 *
 * Debug commands:
 *
 *    php example/demo --debug archive --no-compress --composer ../AssetKit/composer.json --bootstrap ../AssetKit/scripts/assetkit.php app.phar && php app.phar
 *
 *    php example/demo --debug archive
 */
class ArchiveCommand extends Command
{
    public function brief()
    {
        return 'Build executable phar file from composer.json';
    }

    public function options($opts)
    {
        $opts->add('d|working-dir:', 'If specified, use the given directory as working directory.')
            ->isa('dir')
            ;

        $opts->add('c|composer:', 'The composer.json file. If --working-dir is ignored, dirname of the composer.json will be used.')
            ->isa('file')
            ->defaultValue('composer.json')
            ;

        $opts->add('vendor:', 'Vendor directory name')
            ->defaultValue('vendor')
            ;

        // append executable (bootstrap scripts, if it's not defined, it's just a library phar file.
        $opts->add('bootstrap?', 'bootstrap or executable php file')
            ->multiple()
            ->isa('file')
            ;

        $opts->add('executable', 'make the phar file executable')
            ->isa('boolean')
            ->defaultValue(true)
            ;

        $opts->add('c|compress?', 'compress type: gz, bz2')
            ->defaultValue('gz')
            ->validValues(array('gz', 'bz2'))
            ;

        $opts->add('no-compress', 'do not compress phar file.');

        $opts->add('add+', 'add a path respectively');

        $opts->add('exclude+', 'exclude pattern');

        $opts->add('no-classloader', 'do not embed a built-in classloader in the generated phar file.')
            ;

        $opts->add('app-bootstrap', 'Include CLIFramework bootstrap script.');

        /*
        $opts->add('lib+','library path');
        $opts->add('output:','output');
         */
    }

    public function arguments($args)
    {
        $args->add('phar-file');
    }

    public function aliases()
    {
        return array('a', 'ar');
    }

    public function execute($pharFile = 'output.phar')
    {
        if (!extension_loaded('json')) {
            throw new RuntimeException('json extension is required.');
        }

        // $composerConfigFile is a SplFileInfo object since wuse ->isa('file')
        $composerConfigFile = $this->options->{'composer'} ?: 'composer.json';
        if (!file_exists($composerConfigFile)) {
            throw new Exception("composer config '$composerConfigFile' doesn't exist.");
        }
        $composerConfigFile = new SplFileInfo(realpath($composerConfigFile));
        $this->logger->debug("Found composer config at $composerConfigFile");

        // workingDir is a SplFileInfo object since we use ->isa('Dir')
        $workingDir = $this->options->{'working-dir'} ?: new SplFileInfo($composerConfigFile->getPath());
        if (!file_exists($workingDir)) {
            throw new Exception("working directory '$workingDir' doesn't exist.");
        }
        $this->logger->debug('Working directory: '.$workingDir->getPathname());

        $vendorDirName = $this->options->vendor ?: 'vendor';

        $pharGenerator = new PharGenerator($this->logger, $this->options, $pharFile);
        $phar = $pharGenerator->getPhar();
        ini_set('phar.readonly', 0);
        $this->logger->info("Creating phar file $pharFile...");

        $phar->startBuffering();

        $stubs = new Block();
        if ($this->options->executable) {
            $this->logger->debug('Adding shell bang...');
            $stubs[] = '#!/usr/bin/env php';
        }
        // prepend open tag
        $stubs[] = '<?php';

        $this->logger->info('Setting up stub...');
        $stubs[] = "Phar::mapPhar('$pharFile');";

        // $workingDir = dirname(realpath($composerConfigFile));


        // Get class paths by ReflectionClass, they should be relative path.
        // However the class path might be in another directory because the
        // classes are loaded from vendor/autoload.php
        $classPaths = array(
            Utils::getClassPath('Universal\\ClassLoader\\ClassLoader'),
            Utils::getClassPath('Universal\\ClassLoader\\Psr0ClassLoader'),
            Utils::getClassPath('Universal\\ClassLoader\\Psr4ClassLoader'),
            Utils::getClassPath('Universal\\ClassLoader\\MapClassLoader'),
        );

        // Generate class loader stub
        $this->logger->debug('Adding class loader files...');
        foreach ($classPaths as $classPath) {
            $phar->addFile($classPath, basename($classPath));
        }

        /*
        $classDir = dirname($classPaths[0]);
        $phar->buildFromIterator(
            new RecursiveIteratorIterator(new RecursiveDirectoryIterator($classDir)),
            $workingDir
        );
         */
        foreach ($classPaths as $classPath) {
            $this->logger->debug('Adding require statment for class loader: '.basename($classPath));
            $stubs[] = new RequireStatement(new PharURI($pharFile, basename($classPath)));
        }

        if (!$this->options->{'no-classloader'}) {
            $this->logger->info('Generating classLoader stubs');
            $autoloadGenerator = new ComposerAutoloadGenerator($this->logger);
            $autoloadGenerator->setVendorDir('vendor');
            $autoloadGenerator->setWorkingDir($workingDir->getPathname());
            $autoloadGenerator->scanComposerJsonFiles($workingDir.DIRECTORY_SEPARATOR.$vendorDirName);

            $autoloads = $autoloadGenerator->traceAutoloadsWithComposerJson($composerConfigFile, $workingDir.DIRECTORY_SEPARATOR.$vendorDirName, true);
            foreach ($autoloads as $packageName => $config) {
                if (!isset($config['autoload'])) {
                    continue;
                }

                $autoload = $config['autoload'];

                if (!isset($config['root'])) {
                    $autoload = $autoloadGenerator->prependAutoloadPathPrefix($autoload, $vendorDirName.DIRECTORY_SEPARATOR.$packageName.DIRECTORY_SEPARATOR);
                }

                foreach ($autoload as $type => $map) {
                    foreach ($map as $mapPaths) {
                        $paths = (array) $mapPaths;
                        foreach ($paths as $path) {
                            $absolutePath = $workingDir.DIRECTORY_SEPARATOR.$path;

                            if (is_dir($absolutePath)) {
                                $this->logger->debug("Add files from directory $absolutePath under $workingDir");

                                $it = new RecursiveIteratorIterator(
                                    new RecursiveDirectoryIterator($absolutePath, FilesystemIterator::SKIP_DOTS)
                                );

                                foreach ($it as $fileinfo) {
                                    $pathName = $fileinfo->getPathname();
                                    if (preg_match('/(\.(?:git|svn|hg)|Tests|Test\.php)/', $pathName)) {
                                        continue;
                                    }
                                    $localPath = str_replace($workingDir.DIRECTORY_SEPARATOR, '', $pathName);
                                    $this->logger->debug("Adding $localPath");
                                    $phar->addFile($pathName, $localPath);
                                }

                                /*
                                $builtFiles = $phar->buildFromIterator(
                                    new RecursiveIteratorIterator(
                                        new RecursiveDirectoryIterator($absolutePath, FilesystemIterator::SKIP_DOTS)
                                    ),
                                    $workingDir
                                );
                                */
                            } elseif (is_file($absolutePath)) {
                                $this->logger->debug("Add file $absolutePath under $path");
                                $phar->addFile($absolutePath, $path);
                            } else {
                                $this->logger->error("File '$absolutePath' is not found.");
                            }
                        }
                    }
                }
            }
            $classloaderStub = $autoloadGenerator->generate($composerConfigFile, $pharFile);
            $this->logger->debug('ClassLoader stub:');
            $this->logger->debug($classloaderStub);
            $stubs[] = $autoloadGenerator->generate($composerConfigFile, $pharFile);
        }

        if ($bootstraps = $this->options->bootstrap) {
            foreach ($bootstraps as $bootstrap) {
                $this->logger->info("Adding bootstrap: $bootstrap");
                $content = php_strip_whitespace($bootstrap);
                $content = preg_replace('{^#!/usr/bin/env\s+php\s*}', '', $content);

                $localPath = str_replace($workingDir->getPathname(), '', $bootstrap->getRealPath());

                $phar->addFromString($localPath, $content);

                $stubs[] = new RequireStatement(new PharURI($pharFile, $localPath));
            }
        }

        if ($this->options->{'app-bootstrap'}) {
            $app = $this->getApplication();
            $refObject = new ReflectionObject($app);
            $appClassName = $refObject->getName();

            $block = new Block();
            $block[] = new AssignStatement('$app', new NewObjectExpr($appClassName));
            $block[] = new MethodCallStatement('$app', 'run', array('$argv'));
            $stubs[] = $block;
        }

        $stubs[] = '__HALT_COMPILER();';

        $stubstr = $stubs->render();
        $this->logger->debug($stubstr);
        $phar->setStub($stubstr);

        // Add some extra files in phar's root
        if ($adds = $this->options->add) {
            foreach ($adds as $add) {
                $phar->buildFromIterator(
                    new RecursiveIteratorIterator(new RecursiveDirectoryIterator($add)),
                    $workingDir
                );
            }
        }

        $pharGenerator->generate();

        $this->logger->info('Done');
    }
}
<?php

/*
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */

namespace CLIFramework\Command;

use CLIFramework\Command;
use CLIFramework\CommandInterface;
use CLIFramework\Completion\BashGenerator;

class BashCompletionCommand extends Command implements CommandInterface
{
    public function brief()
    {
        return 'This command generate a bash completion script automatically';
    }

    public function options($opts)
    {
        $opts->add('bind:', 'bind complete to command');
        $opts->add('program:', 'programe name');
    }

    public function execute()
    {
        $programName = $this->options->program ?: $this->getApplication()->getProgramName();
        $bind = $this->options->bind ?: $programName;
        $compName = '_'.preg_replace('#\W+#', '_', $programName);
        $generator = new BashGenerator($this->getApplication(), $programName, $bind, $compName);
        echo $generator->output();
    }
}
<?php

namespace CLIFramework\Command;

use CLIFramework\Command;
use CodeGen\Block;
use ClassTemplate\TemplateClassFile;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use Exception;

class BuildGitHubWikiTopicsCommand extends Command
{
    public function brief()
    {
        return 'Build topic classes from the wiki of a GitHub Project.';
    }

    public function options($opts)
    {
        $opts->add('ns:', 'Class namespace');
        $opts->add('dir:', 'Output directory')
            ;
        $opts->add('update', 'Update wiki repository');
    }

    public function arguments($args)
    {
        $args->add('user')->desc('GitHub Account');
        $args->add('repo')->desc('GitHub Repository');
    }

    public function execute($user, $repo)
    {
        $ns = '';
        if ($appNs = $this->options->ns) {
            $ns = rtrim(str_replace(':', '\\', $appNs), '\\').'\\';
        } elseif ($appNs = $this->getApplication()->getCurrentAppNamespace()) {
            $ns = $appNs.'\\Topic\\';
        } else {
            $this->logger->notice('Namespace is defined.');
        }

        // Use git to clone the wiki
        $wikiGitURI = "https://github.com/$user/$repo.wiki.git";
        $wikiBaseUrl = "https://github.com/$user/$repo/wiki";
        $localRepoPath = "tmp/$repo.wiki";

        $currentDir = getcwd();

        if (is_dir($localRepoPath)) {
            if ($this->options->update) {
                $this->logger->info("Fetching $wikiGitURI...");
                system("git -C $localRepoPath pull origin", $retval);
                if ($retval != 0) {
                    return $this->logger->error("Can't clone wiki repository");
                }
            }
        } else {
            $dirname = dirname($localRepoPath);
            if (!file_exists($dirname)) {
                mkdir($dirname, 0755, true);
            }

            $this->logger->info("Cloning $wikiGitURI...");
            system("git clone $wikiGitURI $localRepoPath", $retval);
            if ($retval != 0) {
                return $this->logger->error("Can't clone wiki repository");
            }
        }

        // Build classes
        $this->logger->info('Building topic classes from GitHub pages...');

        $outputDir = $this->options->dir ?: '.';

        $directory = new RecursiveDirectoryIterator($localRepoPath);
        $iterator = new RecursiveIteratorIterator($directory);

        $topics = array();
        foreach ($iterator as $file) {
            if (preg_match('/\.git/', $file->getPathName())) {
                continue;
            }
            if (preg_match('/\.md$/', $file->getPathName())) {
                $topicRemoteUrl = $wikiBaseUrl.'/'.$file->getFileName();

                // Used from command-line, to invoke the topic
                // $topicId = strtolower(preg_replace(array('/.md$/'),array(''),$file->getFileName()));

                // The readable topic title
                // TODO: Support non-ascii characters 
                $entryName = preg_replace('/.md$/', '', $file->getFileName());
                $entryNameNonEnChars = trim(preg_replace('/[^a-zA-Z0-9-\s]/', '', $entryName));
                $topicClassName = implode('', array_map('ucfirst', explode('-', str_replace(' ', '', $entryNameNonEnChars)))).'Topic';
                $topicId = strtolower(preg_replace('/\s+/', '-', $entryNameNonEnChars));
                $topicTitle = preg_replace('/-/', ' ', $entryName);
                $topicFullClassName = $ns.$topicClassName;

                $topics[ $topicId ] = $topicFullClassName;

                $classFile = $outputDir.DIRECTORY_SEPARATOR.str_replace('\\', DIRECTORY_SEPARATOR, $topicFullClassName).'.php';

                $cTemplate = new TemplateClassFile($topicFullClassName, array(
                    'template' => 'Class.php.twig',
                ));

                $cTemplate->addProperty('id',  $topicId);
                $cTemplate->addProperty('url', $topicRemoteUrl);
                $cTemplate->addProperty('title', $topicTitle);

                $cTemplate->extendClass('\\CLIFramework\\Topic\\GitHubTopic');

                $cTemplate->addMethod('public', 'getRemoteUrl', array(), 'return $this->remoteUrl;');
                $cTemplate->addMethod('public', 'getId', array(), 'return $this->id;');

                $content = file_get_contents($file);
                $cTemplate->addMethod('public', 'getContent', array(), 'return '.var_export($content, true).';', array(), false);

                $classDir = dirname($classFile);
                if (!file_exists($classDir)) {
                    mkdir($classDir, 0755, true);
                }
                $this->logger->info("Creating $classFile");
                if (false === file_put_contents($classFile, $cTemplate->render())) {
                    throw new Exception("Can't write file $classFile.");
                }
            }
        }

        $this->logger->info(wordwrap("You may now copy the below content to the 'init' method in your application class:"));

        $this->logger->writeln('-------');
        $block = new Block();
        $block->appendLine('$this->topics('.var_export($topics, true).');');
        $this->logger->write($block->render());
        $this->logger->writeln('-------');

        chdir($currentDir);
        $this->logger->info('Done');
    }
}
<?php

namespace CLIFramework\Command;

use CLIFramework\Command;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use Phar;

/**
 * Compile package to phar file.
 *
 * phar file structure
 *
 * {{Stub}}
 *    {{ClassLoader}}
 *    {{Bin or Executable or Bootstrap}}
 * {{Halt Compiler}}
 * {{Content Section}}
 */
class CompileCommand extends Command
{
    public function options($opts)
    {
        // optional classloader script (use Universal ClassLoader by default 
        $opts->add('classloader?', 'embed classloader source file');

        // append executable (bootstrap scripts, if it's not defined, it's just a library phar file.
        $opts->add('bootstrap?', 'bootstrap or executable source file');

        $opts->add('executable', 'is a executable script ?');

        $opts->add('lib+', 'library path');

        $opts->add('include+', 'include path');

        $opts->add('exclude+', 'exclude pattern');

        $opts->add('output:', 'output');

        $opts->add('c|compress?', 'phar file compress type: gz, bz2');

        $opts->add('no-compress', 'do not compress phar file.');
    }

    public function brief()
    {
        return 'compile current source into Phar format library file.';
    }

    public function execute()
    {
        ini_set('phar.readonly', 0);

        $options = $this->options;
        $logger = $this->logger;

        $bootstrap = null;
        $lib_dirs = array('src'); // current package source, TODO: we should read the roles from package.ini
        $output = 'output.phar';
        $classloader = null;

        if ($options->bootstrap) {
            $bootstrap = $options->bootstrap;
        }

        if ($options->lib) {
            $lib_dirs = $options->lib;
        }

        if ($options->output) {
            $output = $options->output;
        }

        $logger->info('Compiling Phar...');

        $pharFile = $output;
        $src_dirs = $lib_dirs;

        $logger->debug2("Creating phar file $pharFile...");

        $phar = new Phar($pharFile, 0, $pharFile);
        $phar->setSignatureAlgorithm(Phar::SHA1);
        $phar->startBuffering();

        $excludePatterns = $this->options->exclude ? $options->exclude : null;
        if ($this->options->include) {
            foreach ($options->include as $include) {
                $phar->buildFromIterator(
                    new RecursiveIteratorIterator(
                        new RecursiveDirectoryIterator($include)),
                    getcwd()
                );
            }
        }

        // archive library directories into phar file.
        foreach ($lib_dirs as $src_dir) {
            if (!file_exists($src_dir)) {
                die("$src_dir does not exist.");
            }

            $src_dir = realpath($src_dir);
            $iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($src_dir),
                                    RecursiveIteratorIterator::CHILD_FIRST);

            // compile php file only (currently)
            foreach ($iterator as $path) {
                if ($path->isFile()) {
                    $rel_path = substr($path->getPathname(), strlen($src_dir) + 1);

                    if ($excludePatterns) {
                        $exclude = false;
                        foreach ($excludePatterns as $pattern) {
                            if (preg_match('#'.$pattern.'#', $rel_path)) {
                                $exclude = true;
                                break;
                            }
                        }
                        if ($exclude) {
                            $logger->debug2('exclude '.$rel_path);
                            continue;
                        }
                    }

                    // if it's php file.
                    if (preg_match('/\.php$/', $path->getFilename())) {
                        $content = php_strip_whitespace($path->getRealPath());
                        # echo $path->getPathname() . "\n";
                        $logger->debug2('add '.$rel_path);
                        $phar->addFromString($rel_path, $content);
                    } else {
                        $logger->debug2('add '.$rel_path);
                        $phar->addFile($path->getPathname(), $rel_path);
                    }
                }
            }
        }

        // Including bootstrap file
        if ($bootstrap) {
            $logger->info2("Compile $bootstrap");
            $content = php_strip_whitespace($bootstrap);
            $content = preg_replace('{^#!/usr/bin/env\s+php\s*}', '', $content);
            $phar->addFromString($bootstrap, $content);
        }

        $stub = '';
        if ($options->executable) {
            $logger->debug2('Adding shell bang...');
            $stub .= "#!/usr/bin/env php\n";
        }

        $logger->info2('Setting up stub...');
        $stub .= <<<"EOT"
<?php
Phar::mapPhar('$pharFile');
EOT;

        // use stream to resolve Universal\ClassLoader\Autoloader;
        if ($options->has('classloader')) {
            $logger->info2('Adding classloader...');

            if (is_string($options->classloader) && file_exists($options->classloader)) {
                $classloader_file = $options->classloader;
                $content = php_strip_whitespace($classloader_file);
                $phar->addFromString($classloader_file, $content);
                $stub .= <<<"EOT"
require 'phar://$pharFile/$classloader_file';
EOT;
            } else {
                $classloader_interface = 'Universal/ClassLoader/ClassLoader.php';
                $classloader_file = 'Universal/ClassLoader/SplClassLoader.php';
                $stub .= <<<"EOT"
require 'phar://$pharFile/$classloader_interface';
require 'phar://$pharFile/$classloader_file';
\$classLoader = new \\Universal\\ClassLoader\\SplClassLoader;
\$classLoader->addFallback( 'phar://$pharFile' );
\$classLoader->register(true);
EOT;
            }
        }

        if ($bootstrap) {
            $logger->info2('Adding bootstrap script...');
            $stub .= <<<"EOT"
require 'phar://$pharFile/$bootstrap';
EOT;
        }

        $stub .= <<<"EOT"
__HALT_COMPILER();
EOT;

        $phar->setStub($stub);
        $phar->stopBuffering();

        $compress_type = Phar::GZ;
        if ($options->{'no-compress'}) {
            $compress_type = null;
        } elseif ($options->compress) {
            switch ($v = $options->compress) {
            case 'gz':
                $compress_type = Phar::GZ;
                break;
            case 'bz2':
                $compress_type = Phar::BZ2;
                break;
            default:
                throw new Exception("Compress type: $v is not supported, valids are gz, bz2");
                break;
            }
        }

        if ($compress_type) {
            $logger->info('Compressing phar ...');
            $phar->compressFiles($compress_type);
        }

        $logger->info('Done');
    }
}
<?php

/*
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */

namespace CLIFramework\Command;

use CLIFramework\Command;
use CLIFramework\CommandInterface;
use CLIFramework\OptionPrinter;
use CLIFramework\Corrector;

class HelpCommand extends Command implements CommandInterface
{
    /**
     * one line description.
     */
    public function brief()
    {
        return 'Show help message of a command';
    }

    public function options($opts)
    {
        $opts->add('dev', 'Show development commands');
    }

    public function displayTopic($topic)
    {
        $this->logger->write($this->formatter->format('TOPIC', 'strong_white')."\n");
        $this->logger->write("\t".$topic->getTitle()."\n\n");
        $this->logger->write($this->formatter->format('DESCRIPTION', 'strong_white')."\n");
        $this->logger->write($topic->getContent()."\n\n");

        if ($footer = $topic->getFooter()) {
            $this->logger->write($this->formatter->format('MORE', 'strong_white')."\n");
            $this->logger->write($footer."\n");
        }
    }

    public function calculateColumnWidth($words, $min = 0)
    {
        $maxWidth = $min;
        foreach ($words as $word) {
            if (strlen($word) > $maxWidth) {
                $maxWidth = strlen($word);
            }
        }

        return $maxWidth;
    }

    public function layoutCommands($commands, $indent = 4)
    {
        $cmdNames = array_filter(array_keys($commands), function ($n) {
            return !preg_match('#^_#', $n);
        });
        $maxWidth = $this->calculateColumnWidth($cmdNames, 12);
        foreach ($commands as $name => $class) {
            $cmd = new $class();
            $brief = $cmd->brief();
            $this->logger->writeln(str_repeat(' ', $indent)
                .sprintf('%'.($maxWidth + $indent).'s    %s',
                    $name,
                    $brief
                ));
        }
        $this->logger->newline();
    }

    /**
     * Show command help message.
     *
     * @param string $subcommand command name
     */
    public function execute()
    {
        $logger = $this->logger;
        $app = $this->getApplication();
        $progname = basename($app->getProgramName());

        $printer = new OptionPrinter();
        $formatter = $this->getFormatter();

        // if there is no subcommand to render help, show all available commands.
        $commandNames = func_get_args();

        if (count($commandNames) == 1) {
            // Check topic
            if ($topic = $app->getTopic($commandNames[0])) {
                return $this->displayTopic($topic);
            } elseif (!$app->hasCommand($commandNames[0])) {
                $corrector = new Corrector(array_keys($app->topics));
                if ($match = $corrector->correct($commandNames[0])) {
                    return $this->displayTopic($app->topics[$match]);
                }

                return;
            }
        }

        if (count($commandNames)) {
            $subcommand = $commandNames[0];
            $cmd = $app;
            for ($i = 0; $cmd && $i < count($commandNames); ++$i) {
                $cmd = $cmd->getCommand($commandNames[$i]);
            }
            if (!$cmd) {
                throw new Exception('Command entry '.implode(' ', $commandNames).' not found');
            }

            $usage = $cmd->usage();

            if ($brief = $cmd->brief()) {
                $logger->write($formatter->format('NAME', 'strong_white')."\n");
                $logger->write("\t".$formatter->format($cmd->getName(), 'strong_white').' - '.$brief."\n\n");
            }

            if ($aliases = $cmd->aliases()) {
                $logger->write($formatter->format('ALIASES', 'strong_white')."\n");
                $logger->write("\t".$formatter->format(implode(', ', $aliases), 'strong_white')."\n\n");
            }

            if ($usage = trim($cmd->usage())) {
                $logger->write($formatter->format('USAGE', 'strong_white')."\n");
                $logger->write("\t".$usage);
                $logger->write("\n\n");
            }

            $logger->write($formatter->format('SYNOPSIS', 'strong_white')."\n");
            $prototypes = $cmd->getAllCommandPrototype();
            foreach ($prototypes as $prototype) {
                $logger->writeln("\t".' '.$prototype);
            }
            $logger->write("\n");

            if ($optionLines = $printer->render($cmd->optionSpecs)) {
                $logger->write($formatter->format('OPTIONS', 'strong_white')."\n");
                $logger->write($optionLines);
                $logger->write("\n");
            }

            $logger->write($cmd->getFormattedHelpText());
        } else {
            $cmd = $this->parent;
            $logger->write($formatter->format(ucfirst($cmd->brief()), 'strong_white')."\n\n");

            if ($usage = trim($cmd->usage())) {
                $logger->write($formatter->format('USAGE', 'strong_white')."\n");
                $logger->write($usage);
                $logger->write("\n\n");
            }

            $logger->write($formatter->format('SYNOPSIS', 'strong_white')."\n");
            $logger->write("\t".$progname);
            if (!empty($cmd->getOptionCollection()->options)) {
                $logger->write(' [options]');
            }

            if ($cmd->hasCommands()) {
                $logger->write(' <command>');
            } else {
                $argInfos = $cmd->getArgInfoList();
                foreach ($argInfos as $argInfo) {
                    $logger->write(' <'.$argInfo->name.'>');
                }
            }

            $logger->write("\n\n");

            // print application options
            $logger->write($formatter->format('OPTIONS', 'strong_white')."\n");
            $logger->write($printer->render($cmd->optionSpecs));
            $logger->write("\n\n");

            // get command list, Command classes should be preloaded.
            $classes = get_declared_classes();
            $command_classes = array();
            foreach ($classes as $class) {
                if (version_compare(phpversion(), '5.3.9') >= 0) {
                    if (is_subclass_of($class, 'CLIFramework\\Command', true)) {
                        $command_classes[] = $class;
                    }
                } else {
                    if (is_subclass_of($class, 'CLIFramework\\Command')) {
                        $command_classes[] = $class;
                    }
                }
            }

            $logger->write($formatter->format("COMMANDS\n", 'strong_white'));
            $ret = $app->aggregate();

            // show "General commands" title if there are more than one groups
            if (count($ret['groups']) > 1 || $this->options->dev) {
                $this->logger->writeln('  '.$formatter->format('General Commands', 'strong_white'));
            }
            $this->layoutCommands($ret['commands']);

            foreach ($ret['groups'] as $group) {
                if (!$this->options->dev && $group->getId() == 'dev') {
                    continue;
                }
                $this->logger->writeln('  '.$formatter->format($group->getName(), 'strong_white'));
                $this->layoutCommands($group->getCommands());
            }

            $this->logger->write($this->getFormattedHelpText());

            if ($app->topics) {
                $logger->write($formatter->format("TOPICS\n", 'strong_white'));
                $maxWidth = $this->calculateColumnWidth(array_keys($app->topics), 8);
                foreach ($app->topics as $topicId => $topic) {
                    printf('%'.($maxWidth + 8)."s    %s\n", $topicId, $topic->getTitle());
                }
                $logger->newline();
            }

            $logger->write($formatter->format("HELP\n", 'strong_white'));
            $this->logger->writeln(wordwrap(
                "\t'$progname help' lists available subcommands and some".
                " topics. See '$progname help <command>' or '$progname help <topic>'".
                " to read about a specific subcommand or $progname.", 70, "\n\t"));
        }

        if ($app->showAppSignature) {
            $logger->newline();
            $logger->write($formatter->format("{$app->getName()} {$app->getVersion()}", 'gray'));
            $logger->writeln($formatter->format("\t\tpowered by https://github.com/c9s/CLIFramework", 'gray'));
        }

        return true;
    }
}
<?php

namespace CLIFramework\Command;

use CLIFramework\Command;
use CLIFramework\Zsh;
use CLIFramework\ValueCollection;
use CLIFramework\Buffer;
use CLIFramework\CommandBase;
use GetOptionKit\OptionCollection;
use GetOptionKit\OptionResult;
use Exception;
use InvalidArgumentException;

class UnsupportedShellException extends Exception
{
}

class UndefinedArgumentException extends Exception
{
}

class UndefinedOptionException extends Exception
{
    public $options;
    public $command;

    public function __construct($message, CommandBase $command, OptionCollection $options)
    {
        $this->command = $command;
        $this->options = $options;
        parent::__construct($message);
    }
}

function output($str, OptionResult $opts = null)
{
    echo $str;
}

function array_escape_space(array $array)
{
    return array_map(function ($c) {
        return addcslashes($c, ' ');
    }, $array);
}

function is_indexed_array(array $array)
{
    $keys = array_keys($array);
    $numericKey = true;
    foreach ($keys as $key) {
        if (!is_numeric($key)) {
            $numericKey = false;
        }
    }

    return $numericKey;
}

function is_assoc_array(array $array)
{
    if (empty($array)) {
        return false;
    }
    $keys = array_keys($array);
    $numericKey = true;
    foreach ($keys as $key) {
        if (!is_numeric($key)) {
            $numericKey = false;
        }
    }

    return !$numericKey;
}

function as_shell_string($str)
{
    return '"'.addcslashes($str, '"').'"';
}

/**
 * currenty it supports zsh format encode "label:desc".
 */
function encode_array_as_shell_string($array)
{
    if (is_assoc_array($array)) {
        $output = array();
        foreach ($array as $key => $val) {
            $output[] = $key.':'.addcslashes($val, ': ');
        }

        return '"'.addcslashes(implode(' ', $output), '"').'"';
    } else {
        $output = array();
        foreach ($array as $val) {
            $output[] = addcslashes($val, ': ');
        }

        return '"'.addcslashes(implode(' ', $output), '"').'"';
    }
}

class MetaCommand extends Command
{
    public function brief()
    {
        return 'Return the meta data of a commands.';
    }

    public function options($opts)
    {
        $opts->add('flat', 'flat list format. work for both zsh and bash.');
        $opts->add('zsh', 'output for zsh');
        $opts->add('bash', 'output for bash');
        $opts->add('json', 'output in JSON format (un-implemented)');
    }

    /**
     * Enable a way to get meta information of argument or option from a command.
     *
     *     app meta sub1.sub2.sub3 arg 1 valid-values
     *     app meta sub1.sub2.sub3 arg 1 suggestions
     *     app meta sub1.sub2.sub3 opt email valid-values
     */
    public function execute($commandlist, $type, $arg = null, $attr = null)
    {
        $commandNames = explode('.', $commandlist);
        // lookup commands
        $app = $this->getApplication();

        $cmd = $app;

        if ($commandNames[0] === 'app') {
            array_shift($commandNames);
        }

        $this->logger->debug('Finding command '.get_class($cmd));

        while (!empty($commandNames) && $cmd->hasCommands()) {
            $commandName = array_shift($commandNames);
            $this->logger->debug('Finding command '.$commandName);
            $cmd = $cmd->getCommand($commandName);
            $this->logger->debug('Found command class '.get_class($cmd));
        }

        // 'arg' or 'opt' require the argument name and attribute type
        if (in_array($type, array('arg', 'opt')) && $arg === null || $attr === null) {
            throw new InvalidArgumentException("'arg' or 'opt' require the attribute type.");
        }

        try {
            if (!$cmd) {
                throw new Exception('Can not find command.');
            }

            switch ($type) {
            case 'arg':
                $idx = intval($arg);
                $arginfos = $cmd->getArgInfoList();

                if (!isset($arginfos[ $idx ])) {
                    throw new UndefinedArgumentException("Undefined argument at $idx");
                }

                $argInfo = $arginfos[$idx];

                switch ($attr) {
                case 'suggestions':
                    if ($values = $argInfo->getSuggestions()) {
                        return $this->outputValues($values, $this->options);
                    }
                    break;

                case 'valid-values':
                    if ($values = $argInfo->getValidValues()) {
                        return $this->outputValues($values, $this->options);
                    }
                    break;
                }
                break;
            case 'opts':
                $options = $cmd->getOptionCollection();
                $values = array();
                foreach ($options as $opt) {
                    if ($opt->short) {
                        $values[] = '-'.$opt->short;
                    } elseif ($opt->long) {
                        $values[] = '--'.$opt->long;
                    }
                }
                echo implode(' ', $values) , "\n";

                return;
                break;
            case 'opt':
                $options = $cmd->getOptionCollection();
                $option = $options->find($arg);
                if (!$option) {
                    throw new UndefinedOptionException("Option '$arg' not found", $cmd, $options);
                }
                switch ($attr) {
                case 'isa':
                    return output($option->isa);
                    break;
                case 'valid-values':
                    if ($values = $option->getValidValues()) {
                        return $this->outputValues($values, $this->options);
                    }
                    break;
                case 'suggestions':
                    if ($values = $option->getSuggestions()) {
                        return $this->outputValues($values, $this->options);
                    }
                    break;
                }
                break;
            default:
                throw new Exception("Invalid type '$type', valid types are 'arg', 'opt', 'opts'");
                break;
            }
        } catch (UnsupportedShellException $e) {
            fwrite(STDERR, $e->getMessage()."\n");
            fwrite(STDERR, "Supported shells: zsh, bash\n");
        } catch (UndefinedOptionException $e) {
            fwrite(STDERR, $e->command->getSignature()."\n");
            fwrite(STDERR, $e->getMessage()."\n");
            fwrite(STDERR, "Valid options:\n");
            foreach ($e->options as $opt) {
                if ($opt->short && $opt->long) {
                    fwrite(STDERR, ' '.$opt->short.'|'.$opt->long);
                } elseif ($opt->short) {
                    fwrite(STDERR,  ' '.$opt->short);
                } elseif ($opt->long) {
                    fwrite(STDERR,  ' '.$opt->long);
                }
                fwrite(STDERR, "\n");
            }
        }
    }

    public function outputValues($values, OptionResult $opts)
    {
        // indexed array
        if (is_array($values) && empty($values)) {
            return;
        }

        // encode complex data structure to shell
        if ($values instanceof ValueCollection) {

            // this output format works both in zsh & bash
            if ($opts->flat) {
                $buf = new Buffer();
                $buf->appendLine('#flat');
                foreach ($values as $groupId => $groupValues) {
                    foreach ($groupValues as $val) {
                        $buf->appendLine($val);
                    }
                }
                $this->logger->write($buf);
            } elseif ($opts->zsh || $opts->bash) {
                $buf = new Buffer();
                $buf->appendLine('#groups');
                $buf->appendLine('declare -A groups');
                $buf->appendLine('declare -A labels');

                // zsh and bash only supports one dimensional array, so we can only output values in string and separate these values with space.
                foreach ($values as $groupId => $groupValues) {
                    $buf->appendLine("groups[$groupId]=".encode_array_as_shell_string($groupValues));
                }
                foreach ($values->getGroupLabels() as $groupId => $label) {
                    $buf->appendLine("labels[$groupId]=".as_shell_string($label));
                }
                $this->logger->write($buf);
            } elseif ($opts->json) {
                $this->logger->write($values->toJson());
            } else {
                throw new UnsupportedShellException();
            }

            return;
        }

        // for assoc array in indexed array
        if (is_array($values) && is_indexed_array($values) && is_array(end($values))) {
            $this->logger->writeln('#descriptions');
            if ($opts->zsh) {
                // for zsh, we output the first line as the label
                foreach ($values as $value) {
                    list($key, $val) = $value;
                    $this->logger->writeln("$key:".addcslashes($val, ':'));
                }
            } else {
                foreach ($values as $value) {
                    $this->logger->writeln($value[0]);
                }
            }
        } elseif (is_array($values) && is_indexed_array($values)) { // indexed array is a list.
            $this->logger->writeln('#values');
            $this->logger->writeln(implode("\n", $values));
        } else { // associative array
            $this->logger->writeln('#descriptions');
            if ($opts->zsh) {
                foreach ($values as $key => $desc) {
                    $this->logger->writeln("$key:".addcslashes($desc, ':'));
                }
            } else {
                foreach ($values as $key => $desc) {
                    $this->logger->writeln($key);
                }
            }
        }
    }
}
<?php

/*
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */

namespace CLIFramework\Command;

use CLIFramework\Command;
use CLIFramework\CommandInterface;
use CLIFramework\Completion\ZshGenerator;

class ZshCompletionCommand extends Command implements CommandInterface
{
    public function brief()
    {
        return 'This function generate a zsh-completion script automatically';
    }

    public function options($opts)
    {
        $opts->add('bind:', 'bind complete to command');
        $opts->add('program:', 'programe name');
    }

    public function execute()
    {
        $programName = $this->options->program ?: $this->getApplication()->getProgramName();
        $bind = $this->options->bind ?: $programName;
        $compName = '_'.preg_replace('#\W+#', '_', $programName);
        $generator = new ZshGenerator($this->getApplication(), $programName, $bind, $compName);
        echo $generator->output();
    }
}
<?php
/**
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace CLIFramework;
use Exception;
use CLIFramework\CommandInterface;
use CLIFramework\Exception\CommandClassNotFoundException;
use CLIFramework\Application;

/**
 * abstract command class
 *
 */
abstract class Command extends CommandBase
    implements CommandInterface
{
    /**
     * @var CLIFramework\Application Application object.
     */
    public $application;

    public $name;

    public function __construct(CommandBase $parent = null)
    {
        parent::__construct($parent);
    }

    public function setApplication(Application $application)
    {
        $this->application = $application;
    }


    /**
     * Get the main application object from parents
     *
     * @return Application
     */
    public function getApplication() {
        if ($this->application) {
            return $this->application;
        }
        $p = $this->parent;
        while (true) {
            if ( ! $p ) {
                return null;
            }
            if ($p instanceof Application) {
                return $p;
            }
            $p = $p->parent;
        }
    }

    public function hasApplication() {
        return $this->getApplication() !== null;
    }

    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * Translate current class name to command name.
     *
     * @return string command name
     */
    public function getName()
    {
        if ($this->name) {
            return $this->name;
        }

        // Extract command name from the class name.
        $class = get_class($this);
        // strip command suffix
        $parts = explode('\\',$class);
        $class = end($parts);
        $class = preg_replace( '/Command$/','', $class );
        return strtolower( preg_replace( '/(?<=[a-z])([A-Z])/', '-\1' , $class ) );
    }


    /**
     * Returns logger object.
     *
     * @return CLIFramework\Logger
     */
    public function getLogger()
    {
        return $this->getApplication()->getLogger();
    }



    /**
     * Returns text style formatter.
     *
     * @return CLIFramework\Formatter
     */
    public function getFormatter()
    {
        return $this->getApplication()->getFormatter();
    }

    /**
     * User may register their aliases
     */
    public function aliases() {
        return array();
    }



    /**
     * Provide a shorthand property for retrieving logger object.
     *
     * @param string $k property name
     */
    public function __get($k)
    {
        if ($k === 'logger') {
            return $this->getLogger();
        }
        elseif( $k === 'formatter' ) {
            return $this->getFormatter();
        }
        throw new Exception( "$k is not defined." );
    }

}
<?php
namespace CLIFramework;

/**
 * This class tries to autoload a CommandBase's all sub-commands
 *
 * @method __construct
 * @method autoload
 */
class CommandAutoloader
{
    /** @var \CLIFramework\CommandBase */
    private $parent;

    /**
     * Constructor.
     *
     * @param \CLIFramework\CommandBase $parent object we want to load its
     *     commands/subcommands
     */
    public function __construct(CommandBase $parent)
    {
        $this->parent = $parent;
    }
    
    /**
     * Add all commands in a directory to parent command
     *
     * @param string|null $path if string is given, add the commands in given
     *     path. If null is given, use current command's path.
     * @return void
     */
    public function autoload($path = null)
    {
        if (is_null($path))
            $path = $this->getCurrentCommandDirectory();
        $commands = $this->scanCommandsInPath($path);
        $this->addCommandsForParent($commands);
    }
    
    private function getCurrentCommandDirectory()
    {
        $reflector = new \ReflectionClass(get_class($this->parent));
        $classDir = dirname($reflector->getFileName());

        /*
         * Commands to be autoloaded must located at specific directory.
         * If parent is Application, commands must be whthin App/Command/ directory.
         * If parent is another command named FooCommand, sub-commands must
         *     within App/Command/FooCommand/ directory.
         */
        $commandDirectoryBase= $this->parent->isApplication()
            ? 'Command'
            : $reflector->getShortName();
        return $classDir . DIRECTORY_SEPARATOR . $commandDirectoryBase;
    }
    
    private function scanCommandsInPath($path)
    {
        if (!is_dir($path))
            return array();
        $files = scandir($path);
        return $this->translateFileNamesToCommands($files);
    }

    private function translateFileNamesToCommands(array $fileNames)
    {
        $commands = array_map(
            array($this, 'translateFileNameToCommand'),
            $fileNames
        );
        return array_filter(
            $commands,
            function ($command) { return $command !== false; }
        );
    }

    private function translateFileNameToCommand($fileName)
    {
        $extensions = explode(',', spl_autoload_extensions());
        $isCommandClassFile = ($fileName[0] !== '.'
            and preg_match('/(^.*Command)(\..*)$/', $fileName, $matches) === 1
            and in_array($matches[2], $extensions));
        return $isCommandClassFile
            ? $this->parent->getLoader()->inverseTranslate($matches[1])
            : false;
    }

    private function addCommandsForParent($commands)
    {
        foreach ($commands as $command)
            $this->parent->addCommand($command);
    }
}
<?php
/*
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace CLIFramework;
use Exception;
use LogicException;
use InvalidArgumentException;
use ReflectionObject;
use ArrayAccess;
use IteratorAggregate;
use GetOptionKit\OptionCollection;
use GetOptionKit\OptionResult;
use CLIFramework\Prompter;
use CLIFramework\Application;
use CLIFramework\Chooser;
use CLIFramework\CommandLoader;
use CLIFramework\CommandGroup;
use CLIFramework\Exception\CommandNotFoundException;
use CLIFramework\Exception\InvalidCommandArgumentException;
use CLIFramework\Exception\CommandArgumentNotEnoughException;
use CLIFramework\Exception\CommandClassNotFoundException;
use CLIFramework\Exception\ExecuteMethodNotDefinedException;
use CLIFramework\Exception\ExtensionException;
use CLIFramework\ArgInfo;
use CLIFramework\ArgInfoList;
use CLIFramework\Corrector;
use CLIFramework\Extension\Extension;
use CLIFramework\Extension\ExtensionBase;
use CLIFramework\Extension\CommandExtension;
use CLIFramework\Extension\ApplicationExtension;

/**
 * Command based class (application & subcommands inherit from this class)
 *
 * register subcommands.
 */
abstract class CommandBase
    implements ArrayAccess, IteratorAggregate, CommandInterface
{



    /**
     * @var application commands
     *
     * which is an associative array, contains command class mapping info
     *
     *     command name => command class name
     *
     * */
    protected $commands = array();


    /**
     * @var CommandGroup[]
     */
    protected $commandGroups = array();

    protected $aliases = array();

    /**
     * @var \GetOptionKit\OptionResult parsed options
     */
    public $options;

    /**
     * Parent commmand object. (the command caller)
     *
     * @var \CLIFramework\CommandBase or CLIFramework\Application
     */
    public $parent;

    public $optionSpecs;

    protected $argInfos = array();

    protected $extensions = array();

    public function __construct(CommandBase $parent = null) 
    {
        // this variable is optional (for backward compatibility)
        if ($parent) {
            $this->setParent($parent);
        }
    }


    /**
     * Returns one line brief for this command.
     *
     * @return string brief
     */
    public function brief()
    {
        return 'awesome brief for your app.';
    }

    /**
     * Usage string  (one-line)
     *
     * @return string usage
     */
    public function usage()
    {
    
    }

    /**
     * Detailed help text
     *
     * @return string helpText
     */
    public function help()
    {
        return '';
    }


    /**
     * Method for users to define alias.
     *
     * @return string[]
     */
    public function aliases() 
    { 
    }





    /**
     * Register and bind the extension
     *
     * @param CLIFramework\Extension\ExtensionBase
     */
    public function addExtension(ExtensionBase $extension)
    {
        if (!$extension->isAvailable()) {
            throw new ExtensionException("Extension " . get_class($extension) . " is not available", $extension);
        }
        $this->bindExtension($extension);
        $this->extensions[] = $extension;
    }

    /**
     * method `extension` is an alias of addExtension
     *
     * @param CLIFramework\Extension\ExtensionBase
     */
    public function extension($extension)
    {
        if (is_string($extension)) {
            $extension = new $extension;
        } else if (! $extension instanceof ExtensionBase) {
            throw new LogicException("Not an extension object or an extension class name.");
        }
        return $this->addExtension($extension);
    }


    protected function bindExtension(ExtensionBase $extension)
    {
        if ($extension instanceof CommandExtension) {
            $extension->bindCommand($this);
        } else if ($extension instanceof ApplicationExtension) {
            $extension->bindApplication($this->getApplication());
        }
    }

    protected function initExtensions()
    {
        foreach ($this->extensions as $extension) {

        }
    }

    /**
     * Add a command group and register the commands automatically
     *
     * @param string $groupName The group name
     * @param array  $commands  Command array combines indexed command names or command class assoc array.
     * @return CommandGroup
     */
    public function addCommandGroup($groupName, $commands = array() ) {
        $group = new CommandGroup($groupName);
        foreach($commands as $key => $val) {
            $name = $val;
            if (is_numeric($key)) {
                $cmd = $this->addCommand($val);
            } else {
                $cmd = $this->addCommand($key, $val);
                $name = $key;
            }
            $group->addCommand($name, $cmd);
        }
        $this->commandGroups[] = $group;
        return $group;
    }

    public function getCommandGroups() {
        return $this->commandGroups;
    }

    public function isApplication() {
        return $this instanceof Application;
    }

    /**
     * Returns help message text of a command object.
     *
     */
    public function getFormattedHelpText()
    {
        $text = $this->help();

        // format text styles
        $formatter = $this->getFormatter();
        $text = preg_replace_callback( '#<(\w+)>(.*?)</\1>#i', function($matches) use ($formatter) {
            $style = $matches[1];
            $text = $matches[2];

            switch ($style) {
                case 'b': $style = 'bold'; break;
                case 'u': $style = 'underline'; break;
            }

            if ( $formatter->hasStyle($style) ) {
                return $formatter->format( $text , $style );
            }

            return $matches[0];
        }, $text );

        // support simple markdown style
        $text = preg_replace_callback( '#[*]([^*]*?)[*]#' , function($matches) use ($formatter) {
            return $formatter->format( $matches[1] , 'bold' );
        } , $text );

        $text = preg_replace_callback( '#[_]([^_]*?)[_]#' , function($matches) use ($formatter) {
            return $formatter->format( $matches[1] , 'underline' );
        } , $text );

        return $text;
    }

    /**
     * Subcommand can override this method to define its option spec here
     *
     * @code
     *
     *      function options($opts) {
     *          $opts->add('v|verbose','Verbose messages');
     *          $opts->add('d|debug',  'Debug messages');
     *          $opts->add('level:',  'Level takes a value.');
     *      }
     *
     * @param GetOptionKit\OptionCollection Spec collection object.
     *
     * @see GetOptionKit\OptionCollection
     */
    public function options($getopt)
    {

    }

    /**
     * Default init function.
     *
     * Register custom subcommand here.
     */
    public function init()
    {
        if ($this->isCommandAutoloadEnabled())
            $this->autoloadCommands();
    }


    public function isCommandAutoloadEnabled()
    {
        return $this->isApplication()
            ? $this->commandAutoloadEnabled
            : $this->getApplication()->commandAutoloadEnabled;
    }

    /**
     * Get the main application object from parents or the object itself.
     *
     * @return CLIFramework\Application
     */
    public function getApplication() {
        if ($this instanceof Application) {
            return $this;
        }

        $p = $this->parent;
        while ($p) {
            if ($p instanceof Application) {
                return $p;
            }
            $p = $p->parent;
        }
    }


    /**
     * Autoload comands/subcommands in a given directory
     *
     * @param string|null $path path of directory commands placed at.
     * @return void
     */
    protected function autoloadCommands($path = null)
    {
        $autoloader = new CommandAutoloader($this);
        $autoloader->autoload($path);
    }


    public function _init() 
    {
        // get option parser, init specs from the command.
        $this->optionSpecs = new OptionCollection;

        // create an empty option result, please note this result object will
        // be replaced with the parsed option result.
        $this->options = new OptionResult;

        // init application options
        $this->options($this->optionSpecs);


        // build argument info list 
        $args = new ArgInfoList;
        $this->arguments($args);
        if (count($args) > 0) {
            $this->argInfos = $args;
        } else {
            $this->argInfos = $this->getArgInfoListByReflection();
        }


        $this->init();
        $this->initExtensions();
    }



    /**
     * A short alias for registerCommand method
     *
     * @param string $command
     * @param string $class
     */
    public function registerCommand($command, $class = null)
    {
        $trace = debug_backtrace(false, 2);
        $call = $trace[0]['file'].':'.$trace[0]['line'];
        trigger_error("'registerCommand' method is deprecated, please use 'addCommand' instead. Called on $call\n");
        return $this->addCommand($command, $class);
    }

    public function setParent(CommandBase $parent)
    {
        $this->parent = $parent;
    }

    public function getParent() 
    {
        return $this->parent;
    }

    /**
     * Returns command loader object.
     */
    public function getLoader() 
    {
        return CommandLoader::getInstance();
    }


    /**
     * Register commands into group
     *
     * @param string $groupName The group name
     * @param string|array $commands The command names. when given string, it must be space-separated.
     *
     * @return CLIFramework\CommandGroup
     */
    public function commandGroup($groupName, $commands = array())
    {
        if (is_string($commands)) {
            $commands = explode(' ',$commands);
        }
        return $this->addCommandGroup($groupName, $commands);
    }


    /**
     * Register command
     *
     * @param string $command The command name
     * @param string $class   (optional) The command class. if this argument is
     *                        ignroed, the class name is automatically detected.
     */
    public function command($command, $class = null) 
    {
        return $this->addCommand($command, $class);
    }

    /**
     * Register a command to application, in init() method stage,
     * we save command classes in property `commands`.
     *
     * When command is needed, get the command from property `commands`, and
     * initialize the command object.
     *
     * class name could be full-qualified or subclass name (under App\Command\ )
     *
     * @param  string $command Command name or subcommand name
     * @param  string $class   Full-qualified Class name
     * @return string Loaded class name
     * @throws CommandClassNotFoundException
     */
    public function addCommand($command,$class = null)
    {
        // try to load the class/subclass,
        // or generate command class name automatically.
        if ($class) {
            if ($this->getLoader()->loadClass($class) === false )
                throw CommandClassNotFoundException("Command class $class not found.");
        } else {
            if ($this->parent) {
                // get class name by subcommand rules.
                $class = $this->getLoader()->loadSubcommand($command,$this);
            } else {
                // get class name by command rules.
                $class = $this->getLoader()->load($command);
            }
        }
        if (! $class) {
            throw new CommandClassNotFoundException("command class $class for command $command not found");
        }
        // register command to table
        $cmd = $this->createCommand($class);
        $this->connectCommand($command, $cmd);
        return $cmd;
    }



    /**
     * getAllCommandPrototype() method is used for returning command prototype in string.
     *
     * Very useful when user entered command with wrong argument or format.
     *
     * @return string
     */
    public function getAllCommandPrototype() {
        $lines = array();

        if (method_exists($this,'execute')) {
            $lines[] = $this->getCommandPrototype();
        }
        if ($this->hasCommands()) {
            foreach( $this->commands as $name => $subcmd) {
                $lines[] = $subcmd->getCommandPrototype();
            }
        }
        return $lines;
    }

    public function getCommandPrototype() {
        $out = array();

        $out[] = $this->getApplication()->getProgramName();

        // $out[] = $this->getName();
        foreach($this->getCommandNameTraceArray() as $n) {
            $out[] = $n;
        }

        if (! empty($this->getOptionCollection()->options) ) {
            $out[] = "[options]";
        }
        if ($this->hasCommands() ) {
            $out[] = "<subcommand>";
        } else {
            $argInfos = $this->getArgInfoList();
            foreach( $argInfos as $argInfo ) {
                $out[] = "<" . $argInfo->name . ">";
            }
        }
        return join(" ",$out);
    }



    /**
     * connectCommand connects a command name with a command object.
     *
     * @param string $name
     * @param CLIFramework\CommandBase $cmd
     */
    protected function connectCommand($name, CommandBase $cmd) {
        $cmd->setName($name);
        $this->commands[$name] = $cmd;

        // regsiter command aliases to the alias table.
        $aliases = $cmd->aliases();
        if (is_string($aliases)) {
            $aliases = preg_split('/\s+/', $aliases);
        }
        if (!is_array($aliases)) {
            throw new InvalidArgumentException("Aliases needs to be an array or a space-separated string.");
        }
        foreach( $aliases as $alias) {
            $this->aliases[$alias] = $cmd;
        }
    }



    /**
     * Aggregate command info
     */
    public function aggregate() {
        $groups = array();
        $commands = array();
        foreach($this->getVisibleCommands() as $name => $cmd) {
            $commands[ $name ] = $cmd;
        }

        foreach($this->commandGroups as $g) {
            if ($g->isHidden) {
                continue;
            }
            foreach($g->getCommands() as $name => $cmd) {
                unset($commands[$name]);
            }
        }

        uasort($this->commandGroups, function($a, $b) { 
            if ($a->getId() == "dev") return 1;
            return 0;
        });

        return array(
            'groups' => $this->commandGroups,
            'commands' => $commands,
        );
    }


    /**
     * Return true if this command has subcommands.
     *
     * @return boolean
     */
    public function hasCommands() {
        return ! empty($this->commands);
    }

    /**
     * Check if a command name is registered in this application / command object.
     *
     * @param string $command command name
     *
     * @return CLIFramework\Command
     */
    public function hasCommand($command)
    {
        return isset($this->commands[$command]) || isset($this->aliases[$command]);
    }

    /**
     * Get command name list
     *
     * @return Array command name list
     */
    public function getCommandList()
    {
        return array_keys( $this->commands );
    }



    /**
     * Some commands are not visible. when user runs 'help', we should just
     * show them these visible commands
     *
     * @return array[string]CommandBase command map
     */
    public function getVisibleCommands() 
    {
        $cmds = array();
        foreach( $this->getVisibleCommandList() as $name ) {
            $cmds[ $name ] = $this->commands[ $name ];
        }
        return $cmds;
    }



    /**
     * Command names start with understore are hidden command. we ignore the
     * commands.
     *
     * @return CommandBase[]
     */
    public function getVisibleCommandList() 
    {
        return array_filter(array_keys($this->commands), function($name) {
            return !preg_match('#^_#', $name);
        });
    }


    /**
     * Return the command name stack
     *
     * @return string[]
     */
    public function getCommandNameTraceArray() {
        $cmdStacks = array( $this->getName() );
        $p = $this->parent;
        while($p) {
            if (! $p instanceof Application) {
                $cmdStacks[] = $p->getName();
            }
            $p = $p->parent;
        }
        return array_reverse($cmdStacks);
    }

    public function getSignature() {
        return join('.', $this->getCommandNameTraceArray());
    }


    /**
     * Return the objects of all sub commands.
     *
     * @return Command[]
     */
    public function getCommands() 
    {
        return $this->commands;
    }

    /*
     * Get subcommand object from current command
     * by command name.
     *
     * @param string $command
     *
     * @return Command initialized command object.
     */
    public function getCommand($commandName)
    {
        if ( isset($this->aliases[$commandName]) ) {
            return $this->aliases[$commandName];
        }
        if ( isset($this->commands[ $commandName ]) ) {
            return $this->commands[ $commandName ];
        }
        throw new CommandNotFoundException($this, $commandName);
    }

    public function guessCommand($commandName) {
        // array of words to check against
        $words = array_keys($this->commands);
        $correction = new Corrector($words);
        return $correction->correct($commandName);
    }



    /**
     * Create and initialize command object.
     *
     * @param  string  $commandClass Command class.
     * @return Command command object.
     */
    public function createCommand($commandClass)
    {
        $cmd = new $commandClass($this);
        $cmd->_init();
        return $cmd;
    }

    /**
     * Get Option Results
     *
     * @return GetOptionKit\OptionCollection command options object (parsed, and a option results)
     */
    public function getOptions()
    {
        return $this->options;
    }

    /**
     * Set option results
     *
     * @param GetOptionKit\OptionResult $options
     */
    public function setOptions(OptionResult $options)
    {
        $this->options = $options;
    }

    /**
     * Get Command-line Option spec
     *
     * @return GetOptionKit\OptionCollection
     */
    public function getOptionCollection()
    {
        return $this->optionSpecs;
    }

    /**
     * Prepare stage method 
     */
    public function prepare()
    {
        foreach ($this->extensions as $extension) { 
            $extension->prepare();
        }
    }

    /**
     * Finalize stage method
     */
    public function finish() 
    {
        foreach ($this->extensions as $extension) { 
            $extension->finish();
        }
    }

    /**
     * abstract method let user define their own argument info.
     *
     * @param CLIFramework\ArgInfoList
     */
    public function arguments($args) { }

    public function getArgInfoList() 
    {
        return $this->argInfos;
    }

    /**
     * The default behaviour: get argument info from method parameters
     */
    public function getArgInfoListByReflection() { 
        $argInfo = new ArgInfoList;

        $ro = new ReflectionObject($this);
        if (!method_exists($this,'execute')) {
            throw new ExecuteMethodNotDefinedException($this);
        }

        $method = $ro->getMethod('execute');
        $requiredNumber = $method->getNumberOfRequiredParameters();
        $parameters = $method->getParameters();
        foreach ($parameters as $param) {
            // TODO: add description to the argument
            $a = new ArgInfo($param->getName());
            if ($param->isOptional()) {
                $a->optional(true);
            }
            $argInfo->append($a);
        }
        return $argInfo;
    }


    /**
     * Execute command object, this is a wrapper method for execution.
     *
     * In this method, we check the command arguments by the Reflection feature
     * provided by PHP.
     *
     * @param  array $args command argument list (not associative array).
     * @return mixed the value of execution result.
     */
    public function executeWrapper(array $args)
    {
        // Validating arguments
        $argInfos = $this->getArgInfoList();

        for ($i = 0; $i < count($argInfos); $i++ ) {
            $argInfo = $argInfos[$i];
            if (isset($args[$i])) {
                $arg = $args[$i];

                $valid = false;
                $message = NULL;
                $ret = $argInfo->validate($arg);

                if (is_array($ret)) {
                    $valid = $ret[0];
                    $message = $ret[1];
                } elseif (is_bool($ret)) {
                    $valid = $ret;
                }

                if ($valid === FALSE) {
                    $this->logger->error($message ?: "Invalid argument $arg");
                    return;
                }
            }
        }


        // call_user_func_array(  );
        $refl = new ReflectionObject($this);
        if (!method_exists( $this,'execute' )) {
            throw new ExecuteMethodNotDefinedException($this);
        }

        $reflMethod = $refl->getMethod('execute');
        $requiredNumber = $reflMethod->getNumberOfRequiredParameters();
        if ( count($args) < $requiredNumber ) {
            throw new CommandArgumentNotEnoughException($this, count($args), $requiredNumber);
        }

        $event = $this->getApplication()->getEventService();

        // runs the global triggers
        $event->trigger('execute.before');

        $event->trigger('execute');
        foreach ($this->extensions as $extension) { 
            $extension->execute();
        }

        $ret = call_user_func_array(array($this,'execute'), $args);

        $event->trigger('execute.after');


        return $ret;
    }

    /**
     * Show prompt with message, you can provide valid options
     * for the simple validation.
     *
     * TODO: let user register their custom prompt handler.
     *
     * @param string $prompt       Prompt message.
     * @param array  $validAnswers an array of valid values (optional)
     *
     * @return string user input value
     */
    public function ask($prompt, $validAnswers = null )
    {
        $prompter = new Prompter;
        $prompter->setStyle('ask');
        return $prompter->ask( $prompt , $validAnswers );
    }

    /**
     * Provide a simple console menu for choices,
     * which gives values an index number for user to choose items.
     *
     * @code
     *
     *      $val = $app->choose('Your versions' , array(
     *          'php-5.4.0' => '5.4.0',
     *          'php-5.4.1' => '5.4.1',
     *          'system' => '5.3.0',
     *      ));
     *      var_dump($val);
     *
     * @code
     *
     * @param  string $prompt  Prompt message
     * @param  array  $choices
     * @return mixed  value
     */
    public function choose($prompt, $choices)
    {
        $chooser = new Chooser;
        $chooser->setStyle('choose');
        return $chooser->choose( $prompt, $choices );
    }

    public function offsetExists($key)
    {
        return isset($this->commands[$key]);
    }

    public function offsetSet($key,$value)
    {
        $this->commands[$key] = $value;
    }

    public function offsetGet($key)
    {
        return $this->commands[$key];
    }

    public function offsetUnset($key)
    {
        unset($this->commands[$key]);
    }

    public function getIterator()
    {
        return new ArrayIterator($this->commands);
    }

}
<?php
namespace CLIFramework;
use Exception;

class CommandException extends Exception { }
<?php
namespace CLIFramework;
use CLIFramework\Command;
use CLIFramework\CommandBase;

class CommandGroup
{
    public $id;

    public $name;

    public $desc;

    public $commands = array();

    public $isHidden = false;

    public function __construct($groupName, $commands = array())
    {
        $this->name = $groupName;
        $this->commands = $commands;
    }

    public function setId($id)
    {
        $this->id = $id;
        return $this;
    }

    public function getId()
    {
        return $this->id ?: $this->getName();
    }

    public function getName() {
        return $this->name;
    }

    public function addCommand($name, CommandBase $command) {
        $this->commands[$name] = $command;
        return $this;
    }

    public function getCommands() {
        return $this->commands;
    }

    public function getCommandNames() {
        return array_keys($this->commands);
    }

    /**
     * Set group description
     *
     * @param string $desc
     * @return CommandGroup
     */
    public function setDesc($desc)
    {
        $this->desc = $desc;
        return $this;
    }

    /**
     * Get the group description
     */
    public function getDesc() {
        return $this->desc;
    }

    public function hidden() {
        $this->isHidden = true;
        return $this;
    }
}


<?php
/*
 * This file is part of the {{ }} package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace CLIFramework;

interface CommandInterface
{
    public function getLogger();
    public function getFormatter();
}
<?php
/*
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace CLIFramework;
use CLIFramework\Exception\CommandClassNotFoundException;
use Exception;

class CommandLoader
{
    public $namespaces = array();

    public function addNamespace( $ns )
    {
        $nss = (array) $ns;
        foreach ($nss as $n) {
            $this->namespaces[] = $n;
        }
    }

    /**
     * Translate command name to class name.
     *
     * This method convert "foo-bar" to "FooBar", so if you have command name like "foo-bar",
     * this method returns FooBar class. e.g.,
     *
     *    list => ListCommand
     *    list-all => ListAllCommand
     *
     * @param string $command command name.
     * @return string class name.
     */
    public function translate($command)
    {
        $args = explode('-',$command);
        foreach($args as & $a) {
            $a = ucfirst($a);
        }
        return join('',$args) . 'Command';
    }

    /**
     * Translate class name to command name
     *
     * This method is inverse of self::translate()
     *
     *     HelpCommand => help
     *     SuchALongCommand => such-a-long
     *
     * @param string $className class name.
     * @return string translated command name.
     */
    public function inverseTranslate($className)
    {
        if (substr($className, -7) !== 'Command')
            throw new \InvalidArgumentException("Command class name need to end with 'Command'");
        // remove the suffix 'Command', then lower case the first letter
        $className = lcfirst(substr($className, 0, -7));
        return preg_replace_callback(
            '/[A-Z]/',
            function ($matches) { return '-' . strtolower($matches[0]); },
            $className
        );
    }

    /**
     * load command class:
     *
     * @param  string  $command command name
     * @return boolean
     **/
    public function load($command)
    {
        $subclass = $this->translate($command);
        return $this->loadClass( $subclass );
    }

    /**
     * Load command class/subclass
     *
     * @param string $class
     * @return string loaded class name
     */
    public function loadClass($class)
    {
        if (class_exists($class)) {
            return $class;
        }

        // for subcommand class name (under any subcommand namespace)
        // has application command class ?
        foreach ($this->namespaces as $ns) {
            $fullclass = $ns . '\\' . $class;
            if (class_exists($fullclass)) {
                return $fullclass;
            }
        }
        throw new CommandClassNotFoundException($class, $this->namespaces);
    }


    /**
     * load subcommand class from command name
     *
     * @param $command
     * @param $parent parent command class
     *
     * */
    public function loadSubcommand($subcommand, $parent)
    {
        $parent_class = get_class($parent);
        $class = '\\' . $parent_class . '\\' . $this->translate($subcommand);
        return $this->loadClass($class);
    }

    static public function getInstance() {
        static $instance;
        if ( $instance ) {
            return $instance;
        }
        return $instance = new self;
    }

}
<?php
namespace CLIFramework\Completion;
use CLIFramework\Buffer;
use Exception;
use CLIFramework\Application;
use CLIFramework\ArgInfo;
use CLIFramework\CommandBase;

/**
 * The Gentoo documentation shows the bash completion variables:
 *
 * @see https://devmanual.gentoo.org/tasks-reference/completion/index.html
 */
function array_to_bash(array $array) {
    $out = '(';
    foreach($array as $key => $value) {
        $out .= '["' . addcslashes($key, '"') . '"]="' . addcslashes($value,'"') . '"';
        $out .= ' ';
    }
    $out .= ')';
    return $out;
}

function set_bash_array($name, array $array)
{
    return $name . '=' . array_to_bash($array);
}

function set_bash_var($name, $value) 
{
    return $name . '=' . $value;
}

function local_bash_var($name, $value) 
{
    return 'local ' . $name . '=' . $value;
}

function command_signature_suffix(CommandBase $command) {
    return $command->getSignature();
    // return str_replace('.','_', $command->getSignature());
}

class BashGenerator
{
    public $app;

    /**
     * @var string $program
     */
    public $programName;

    /**
     * @var string $compName
     */
    public $compName;

    /**
     * @var string $bindName
     */
    public $bindName;

    public $buffer;

    public function __construct(Application $app, $programName, $bindName, $compName)
    {
        $this->app = $app;
        $this->programName = $programName;
        $this->compName = $compName;
        $this->bindName = $bindName;
        $this->buffer = new Buffer;
    }

    public function output() {
        return $this->complete_application();
    }

    public function visible_commands(array $cmds) {
        $visible = array();
        foreach ($cmds as $name => $cmd) {
            if ( ! preg_match('#^_#', $name) ) {
                $visible[$name] = $cmd;
            }
        }
        return $visible;
    }

    public function render_argument_completion_values(ArgInfo $a) {
        if ($a->validValues || $a->suggestions) {
            $values = array();
            if ($a->validValues) {
                $values = $a->getValidValues();
            } elseif ($a->suggestions ) {
                $values = $a->getSuggestions();
            }
            return join(" ", $values);
        }
        return '';
    }

    public function complete_application() {
        $bindName = $this->bindName;
        $compName = $this->compName;

        $compPrefix = "__" . $compName;

        $buf = new Buffer;
        $buf->appendLines(array(
            "#!/bin/bash",
            "# bash completion script generated by CLIFramework",
            "# Web: http://github.com/c9s/php-CLIFramework",
            "# THIS IS AN AUTO-GENERATED FILE, PLEASE DON'T MODIFY THIS FILE DIRECTLY.",
        ));
        $buf->append('
# This function can be used to access a tokenized list of words
# on the command line:
#
#   __demo_reassemble_comp_words_by_ref \'=:\'
#   if test "${words_[cword_-1]}" = -w
#   then
#       ...
#   fi
#
# The argument should be a collection of characters from the list of
# word completion separators (COMP_WORDBREAKS) to treat as ordinary
# characters.
#
# This is roughly equivalent to going back in time and setting
# COMP_WORDBREAKS to exclude those characters.  The intent is to
# make option types like --date=<type> and <rev>:<path> easy to
# recognize by treating each shell word as a single token.
#
# It is best not to set COMP_WORDBREAKS directly because the value is
# shared with other completion scripts.  By the time the completion
# function gets called, COMP_WORDS has already been populated so local
# changes to COMP_WORDBREAKS have no effect.
#
# Output: words_, cword_, cur_.

__demo_reassemble_comp_words_by_ref()
{
    local exclude i j first
    # Which word separators to exclude?
    exclude="${1//[^$COMP_WORDBREAKS]}"
    cword_=$COMP_CWORD
    if [ -z "$exclude" ]; then
        words_=("${COMP_WORDS[@]}")
        return
    fi
    # List of word completion separators has shrunk;
    # re-assemble words to complete.
    for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++)); do
        # Append each nonempty word consisting of just
        # word separator characters to the current word.
        first=t
        while
            [ $i -gt 0 ] &&
            [ -n "${COMP_WORDS[$i]}" ] &&
            # word consists of excluded word separators
            [ "${COMP_WORDS[$i]//[^$exclude]}" = "${COMP_WORDS[$i]}" ]
        do
            # Attach to the previous token,
            # unless the previous token is the command name.
            if [ $j -ge 2 ] && [ -n "$first" ]; then
                ((j--))
            fi
            first=
            words_[$j]=${words_[j]}${COMP_WORDS[i]}
            if [ $i = $COMP_CWORD ]; then
                cword_=$j
            fi
            if (($i < ${#COMP_WORDS[@]} - 1)); then
                ((i++))
            else
                # Done.
                return
            fi
        done
        words_[$j]=${words_[j]}${COMP_WORDS[i]}
        if [ $i = $COMP_CWORD ]; then
            cword_=$j
        fi
    done
}

if ! type _get_comp_words_by_ref >/dev/null 2>&1; then
_get_comp_words_by_ref ()
{
    local exclude cur_ words_ cword_
    if [ "$1" = "-n" ]; then
        exclude=$2
        shift 2
    fi
    __demo_reassemble_comp_words_by_ref "$exclude"
    cur_=${words_[cword_]}
    while [ $# -gt 0 ]; do
        case "$1" in
        cur)
            cur=$cur_
            ;;
        prev)
            prev=${words_[$cword_-1]}
            ;;
        words)
            words=("${words_[@]}")
            ;;
        cword)
            cword=$cword_
            ;;
        esac
        shift
    done
}
fi


# Generates completion reply, appending a space to possible completion words,
# if necessary.
# It accepts 1 to 4 arguments:
# 1: List of possible completion words.
# 2: A prefix to be added to each possible completion word (optional).
# 3: Generate possible completion matches for this word (optional).
# 4: A suffix to be appended to each possible completion word (optional).
__mycomp ()
{
	local cur_="${3-$cur}"

	case "$cur_" in
	--*=)
		;;
	*)
		local c i=0 IFS=$\' \t\n\'
		for c in $1; do
			c="$c${4-}"
			if [[ $c == "$cur_"* ]]; then
				case $c in
				--*=*|*.) ;;
				*) c="$c " ;;
				esac
				COMPREPLY[i++]="${2-}$c"
			fi
		done
		;;
	esac
}

__mycompappend ()
{
	local i=${#COMPREPLY[@]}
	for x in $1; do
		if [[ "$x" == "$3"* ]]; then
			COMPREPLY[i++]="$2$x$4"
		fi
	done
}
');

        $completeMeta =<<<"BASH"
__complete_meta ()
{
    local app="{$this->programName}"
    local command_signature=\$1
    local complete_for=\$2
    local arg=\$3  # could be "--dir", 0 for argument index
    local complete_type=\$4
    local IFS=\$'\n'

    # When completing argument valid values, we need to eval
    lines=(\$(\$app meta --bash --flat \$command_signature \$complete_for \$arg \$complete_type))

    # Get the first line to return the compreply
    # Complete the rest lines as words
    COMPREPLY=(\$(compgen -W "\${lines[*]:1}" -- \$cur))
}


BASH;
        $buf->append($completeMeta);

        $this->generateCommandCompletionRecursively($buf, $this->app, $compPrefix);

        $funcSuffix = command_signature_suffix($this->app);

        $buf->append("
{$compPrefix}_main_wrapper()
{
    {$compPrefix}_complete_{$funcSuffix} \"app\" 0
}
complete -o bashdefault -o default -o nospace -F {$compPrefix}_main_wrapper {$bindName} 2>/dev/null
");
        return $buf->__toString();
    }

    public function generateCompleteFunction(Buffer $buf, CommandBase $cmd, $compPrefix)
    {
        $funcSuffix = command_signature_suffix($cmd);
        $buf->appendLine("{$compPrefix}_complete_{$funcSuffix} ()");
        $buf->appendLine("{");
        $buf->appendLine(local_bash_var('comp_prefix',$compPrefix));
        $buf->append('
        local cur words cword prev
        _get_comp_words_by_ref -n =: cur words cword prev

        local command_signature=$1
        local command_index=$2

        ((command_index++))

        # Output application command alias mapping 
        # aliases[ alias ] = command
        declare -A subcommand_alias

        # Define the command names
        declare -A subcommands

        declare -A subcommand_signs

        # option names defines the available options of this command
        declare -A options
        # options_require_value: defines the required completion type for each
        # option that requires a value.
        declare -A options_require_value
        ');


        $subcommands = $cmd->getCommands();
        $subcommandAliasMap = array();
        $subcommandDescMap = array();
        $commandOptionMap = array();
        $commandOptionRequireValueMap = array();
        $commandSignMap = array();
        foreach($subcommands as $subcommand) {
            foreach( $subcommand->aliases() as $alias) {
                $subcommandAliasMap[$alias] = $subcommand->getName();
            }
            $subcommandDescMap[ $subcommand->getName() ] = $subcommand->brief();
            $commandSignMap[ $subcommand->getName() ] = command_signature_suffix($subcommand);
        }

        // Command signature is used for fetching meta information from the meta command.
        // And a command description map
        //
        //      subcommands=(["add"]="command to add" ["commit"]="command to commit")
        //      subcommand_alias=(["a"]="add" ["c"]="commit")
        //
        $buf->appendLine(set_bash_array('subcommands',$subcommandDescMap));
        $buf->appendLine(set_bash_array('subcommand_alias',$subcommandAliasMap));
        $buf->appendLine(set_bash_array('subcommand_signs', $commandSignMap));

        // Generate the bash array for command options
        //
        //      options=(["--debug"]=1 ["--verbose"]=1 ["--log-dir"]=1)
        //
        $options = $cmd->getOptionCollection();
        foreach($options as $option) {
            if ($option->short) {
                $commandOptionMap[ '-' . $option->short ] = 1;
            }
            if ($option->long) {
                $commandOptionMap[ '--' . $option->long ] = 1;
            }

            if ($option->required || $option->multiple) {
                if ($option->short ) {
                    $commandOptionRequireValueMap[ '-' . $option->short ] = 1;
                }
                if ($option->long ) {
                    $commandOptionRequireValueMap[ '--' . $option->long ] = 1;
                }
            }
        }
        $buf->appendLine(set_bash_array('options',$commandOptionMap));

        //  options_require_value=(["--log-dir"]="__complete_directory")
        $buf->appendLine(set_bash_array('options_require_value', $commandOptionRequireValueMap));


        // local argument_min_length=0
        $argInfos = $cmd->getArgInfoList();
        // $buf->appendLine("local argument_min_length=" . count($argInfos));
        $buf->appendLine(local_bash_var('argument_min_length', count($argInfos)));


        $buf->append('
    # Get the command name chain of the current input, e.g.
    # 
    #     app asset install [arg1] [arg2] [arg3]
    #     app commit add
    #  
    # The subcommand dispatch should be done in the command complete function,
    # not in the root completion function. 
    # We should pass the argument index to the complete function.

    # command_index=1 start from the first argument, not the application name
    # Find the command position
    local argument_index=0
    local i
    local command
    local found_options=0

    # echo "[DEBUG] command_index: [$command_signature] [$command_index]"

    while [ $command_index -lt $cword ]; do
        i="${words[command_index]}"
        case "$i" in
            # Ignore options
            --=*) found_options=1 ;;
            --*) found_options=1 ;;
            -*) found_options=1 ;;
            *)
                # looks like my command, that\'s break the loop and dispatch to the next complete function
                if [[ -n "$i" && -n "${subcommands[$i]}" ]] ; then
                    command="$i"
                    break
                elif [[ -n "$i" && -n "${subcommand_alias[$i]}" ]] ; then
                    command="$i"
                    break
                elif [[ $command_index -gt 1 ]] ; then
                    # If the command is not found, check if the previous argument is an option expecting a value
                    # or it is an argument

                    # the previous argument (might be)
                    p="${words[command_index-1]}"

                    # not an option value, push to the argument list
                    if [[ -z "${options_require_value[$p]}" ]] ; then
                        # echo "[DEBUG] argument_index++ because of [$i]"
                        ((argument_index++))
                    fi
                fi
            ;;
        esac
        ((command_index++))
    done
');

        $buf->append('
    # If the first command name is not found, we do complete...
    if [[ -z "$command" ]] ; then
        case "$cur" in
            # If the current argument $cur looks like an option, then we should complete
            -*)
                __mycomp "${!options[*]}"
                return
            ;;
            *)
                # The argument here can be an option value. e.g. --output-dir /tmp
                # The the previous one...
                if [[ -n "$prev" && -n "${options_require_value[$prev]}" ]] ; then
                    # TODO: local complete_type="${options_require_value[$prev]"}
        ');
        $buf->appendLine('          __complete_meta "$command_signature" "opt" "${prev##*(-)}" "valid-values"');
        $buf->appendLine('          return');
        $buf->appendLine('      fi');
        $buf->appendLine('      # If the command requires at least $argument_min_length to run, we check the argument');

        if (count($argInfos) > 0) {
            $buf->appendLine('if [[ $argument_min_length > 0 ]] ; then');

            // $buf->appendLine('echo argument_index: [$argument_index]');
            // $buf->appendLine('echo cur: [$cur]');

            // expand the argument case
            $buf->appendLine('  case $argument_index in');
            foreach($argInfos as $index => $a) {
                // TODO: when $a->multiple is enabled, we will use "*" for the case pattern.
                $pattern = $index;
                if ($a->multiple) {
                    $pattern = '*';
                }
                $buf->appendLine("      $pattern)");
                // $buf->appendLine('echo argument_index matched: [$argument_index]');
                if ($a->validValues || $a->suggestions) {
                    $values = array();
                    if ($a->validValues) {
                        if (is_callable($a->validValues)) {
                            $buf->appendLine("      __complete_meta \"\$command_signature\" \"arg\" $index \"valid-values\"");
                            $buf->appendLine('      return');
                        } elseif ($values = $a->getValidValues()) {
                            $buf->appendLine('      COMPREPLY=( $(compgen -W "' . join("\n",$values) . '" -- $cur) )');
                            $buf->appendLine('      return');
                        }
                    } elseif ($a->suggestions) {
                        if (is_callable($a->suggestions)) {
                            $buf->appendLine("      __complete_meta \"\$command_signature\" \"arg\" $index \"suggestions\"");
                            $buf->appendLine('      return');
                        } elseif ($values = $a->getSuggestions()) {
                            $buf->appendLine('      COMPREPLY=( $(compgen -W "' . join("\n", $values) . '" -- $cur) )');
                            $buf->appendLine('      return');
                        }
                    }
                } elseif (in_array($a->isa,array('file','path','dir'))) {
                    $compopt = '';
                    switch($a->isa) {
                        case "file":
                            $compopt .= ' -A file';
                            // $buf->appendLine('COMPREPLY=($(compgen -A file -- $cur))');
                            break;
                        case "path":
                            $compopt .= ' -A file';
                            break;
                        case "command":
                            $compopt .= ' -A command';
                            break;
                        case "user":
                            $compopt .= ' -A user';
                            break;
                        case "service":
                            $compopt .= ' -A service';
                            break;
                        case "hostname":
                            $compopt .= ' -A hostname';
                            break;
                        case "job":
                            $compopt .= ' -A job';
                            break;
                        case "dir":
                        case "directory":
                            $compopt .= ' -A directory';
                            break;
                    }
                    // If the glob is specified, bash does not support for both -A with -G
                    if ($a->glob) {
                        $compopt = " -G \"{$a->glob}\"";
                    }
                    $buf->appendLine("COMPREPLY=(\$(compgen $compopt -- \$cur))");
                    $buf->appendLine("return");
                }


                $buf->appendLine("      ;;");
            }
            $buf->appendLine('  esac');
            $buf->appendLine('  fi');
        }

        $buf->append('
                # If there is no argument support, then user is supposed to give a subcommand name or an option
                __mycomp "${!options[*]} ${!subcommands[*]} ${!subcommand_alias[*]}"
                return
            ;;
        esac
');
        // Dispatch
        $buf->append('
    else
        # We just found the first command, we are going to dispatch the completion handler to the next level...
        # Rewrite command alias to command name to get the correct response
        if [[ -n "${subcommand_alias[$command]}" ]] ; then
            command="${subcommand_alias[$command]}"
        fi

        if [[ -n "${subcommand_signs[$command]}" ]] ; then
            local suffix="${subcommand_signs[$command]}"
            local completion_func="${comp_prefix}_complete_${suffix//-/_}"

            # Declare the completion function name and dispatch rest arguments to the complete function
            command_signature="${command_signature}.${command}"
            declare -f $completion_func >/dev/null && \
                $completion_func $command_signature $command_index && return
        else
            echo "Command \'$command\' not found"
        fi
    fi
');
        // Epilog
        $buf->appendLine("};");
    }


    public function generateCommandCompletionRecursively(Buffer $buf, $command, $compPrefix) {
        foreach($command->getCommands() as $subcommand) {
            if ($subcommand->hasCommands()) {
                $this->generateCommandCompletionRecursively($buf, $subcommand, $compPrefix);
            }
            $this->generateCompleteFunction($buf, $subcommand, $compPrefix);
        }
        $this->generateCompleteFunction($buf, $command, $compPrefix);
    }





}


<?php
namespace CLIFramework\Completion;

class Utils
{

    static public function qq($str) {
        return '"' . addcslashes($str , '"') . '"';
    }

    static public function q($str) {
        return "'" . addcslashes($str, "'") . "'";
    }

    static public function array_qq(array $array) {
        return array_map("CLIFramework\\Completion\\Utils::qq", $array);
    }

    static public function array_q(array $array) {
        return array_map("CLIFramework\\Completion\\Utils::q", $array);
    }

    static public function array_escape_space(array $array)
    {
        return array_map(function($a) { return addcslashes($a, ' '); }, $array);
    }

    static public function array_indent(array $lines, $level = 1) 
    {
        $space = str_repeat('  ', $level);
        return array_map(function($line) use ($space) {
            return $space . $line;
        }, $lines);
    }
}




<?php
namespace CLIFramework\Completion;
use CLIFramework\Buffer;
use CLIFramework\Application;
use CLIFramework\ArgInfo;
use CLIFramework\CommandBase;
use CLIFramework\Command;
use CLIFramework\Completion\Utils;
use GetOptionKit\Option;
use Exception;

function indent($level) {
    return str_repeat('  ', $level);
}

function str_indent($content, $level = 1) {
    $space = str_repeat('  ', $level);
    $lines = explode("\n", $content);
    $lines = array_map(function($line) use ($space) { return $space . $line; }, $lines);
    return join("\n", $lines);
}

function array_indent(array $lines, $level = 1) {
    $space = str_repeat('  ', $level);
    return array_map(function($line) use ($space) {
        return $space . $line;
    }, $lines);
}

function join_indent(array $lines, $level = 1) {
    return join("\n",array_indent($lines, $level));
}

/**
 * wrap zsh code with function
 */
function zsh_comp_function($name, $code , $guard = false) {
    $buf = new Buffer;
    if ($guard) {
        $buf->appendLine("(( \$+functions[$name] )) ||");
    }
    $buf->appendLine("$name () {");
    $buf->indent();
    $buf->appendBuffer($code);
    $buf->unindent();
    $buf->appendLine("}");
    return $buf;
}

function case_in($name, $code) {
    return "case $name in\n"
        . str_indent($code, 1) . "\n"
        . "esac\n"
        ;
}


function case_case($pattern, $code) {
    return "($pattern)\n"
        . str_indent($code, 1) . "\n"
        . ";;\n"
        ;
}

function zsh_comp_desc_array(array $array) {
    $out = new Buffer;
    $out->appendLine('(');
    $out->indent();
    foreach($array as $item => $desc) {
        $out->appendLine("'" . addslashes("$item:$desc") . "'");
    }
    $out->unindent();
    $out->appendLine(')');
    return $out;
}


class ZshGenerator
{
    public $app;

    /**
     * @var string $program
     */
    public $programName;

    /**
     * @var string $compName
     */
    public $compName;

    /**
     * @var string $bindName
     */
    public $bindName;

    public $buffer;

    public function __construct(Application $app, $programName, $bindName, $compName)
    {
        $this->app = $app;
        $this->programName = $programName;
        $this->compName = $compName;
        $this->bindName = $bindName;
        $this->buffer = new Buffer;
    }


    public function output() {
        return $this->complete_application();
    }

    public function visible_commands(array $cmds) {
        $visible = array();
        foreach ($cmds as $name => $cmd) {
            if (! preg_match('#^_#', $name) ) {
                $visible[$name] = $cmd;
            }
        }
        return $visible;
    }

    public function command_desc_array(array $cmds) {
        $args = array();
        foreach ( $cmds as $name => $cmd ) {
            if ( preg_match('#^_#', $name) ) {
                continue;
            }
            $args[] = "$name:" . Utils::q($cmd->brief());
        }
        return $args;
    }


    public function describe_commands(array $cmds, $level = 0) {
        $buf = new Buffer;
        $buf->setIndent($level);
        $buf->appendLine("local commands; commands=(");
        $buf->indent();
        $buf->appendLines($this->command_desc_array($cmds));
        $buf->unindent();
        $buf->appendLine(")");
        $buf->appendLine("_describe -t commands 'command' commands && ret=0");
        return $buf;
    }



    /**
    *
    *
    * Generate an zsh option format like this:
   
    '(-v --invert-match)'{-v,--invert-match}'[invert match: select non-matching lines]'
    
    Or:
    
    '-gcflags[flags for 5g/6g/8g]:flags'
    '-p[number of parallel builds]:number'

    '--cleanup=[specify how the commit message should be cleaned up]:mode:((verbatim\:"do not change the commit message at all"
                                                                            whitespace\:"remove leading and trailing whitespace lines"
                                                                            strip\:"remove both whitespace and commentary lines"
                                                                            default\:"act as '\''strip'\'' if the message is to be edited and as '\''whitespace'\'' otherwise"))' \
    */
    public function option_flag_item(Option $opt, $cmdSignature) {
        // TODO: Check conflict options
        $str = "";

        $optspec = $opt->flag || $opt->optional ? '' : '=';
        $optName = $opt->long ? $opt->long : $opt->short;

        if ($opt->short && $opt->long) {
            if (!$opt->multiple) {
                $str .= "'(-" . $opt->short . " --" . $opt->long . ")'"; // conflict options
            }
            $str .= "{-" . $opt->short . ',' . '--' . $opt->long . $optspec . "}";
            $str .= "'";
        } else if ($opt->long) {
            $str .= "'--" . $opt->long . $optspec;
        } else if ($opt->short) {
            $str .= "'-" . $opt->short . $optspec;
        } else {
            throw new Exception('undefined option type');
        }

        // output description
        $str .= "[" . addcslashes($opt->desc,'[]:') . "]";

        $placeholder = ($opt->valueName) ? $opt->valueName : $opt->isa ? $opt->isa : null;

        // has anything to complete
        if ($opt->validValues || $opt->suggestions || $opt->isa) {

            $str .= ':'; // for the value name

            if ($placeholder) {
                $str .= $placeholder;
            }

            if ($opt->validValues || $opt->suggestions) {
                if ($opt->validValues) {
                    if ( is_callable($opt->validValues) ) {
                        $str .= ':{' . join(' ', array($this->meta_command_name(), Utils::qq($placeholder), $cmdSignature, 'opt', $optName, 'valid-values')) . '}';
                    } elseif ($values = $opt->getValidValues()) {
                        // not callable, generate static array
                        $str .= ':(' . join(' ', Utils::array_qq($values)) . ')';
                    }
                } elseif ($opt->suggestions) {
                    if ( is_callable($opt->suggestions) ) {
                        $str .= ':{' . join(' ', array($this->meta_command_name(), Utils::qq($placeholder), $cmdSignature, 'opt', $optName, 'suggestions') ) . '}';
                    } elseif ($values = $opt->getSuggestions()) {
                        // not callable, generate static array
                        $str .= ':(' . join(' ', Utils::array_qq($values)) . ')';
                    }
                }

            } elseif ( in_array($opt->isa, array('file', 'dir', 'path')) ) {
                switch($opt->isa) {
                    case 'file':
                        $str .= ':_files';
                    break;
                    case 'dir':
                        $str .= ':_directories';
                    break;
                    case 'path':
                        $str .= ':_path_files';
                    break;
                }
                if ( isset($opt->glob) ) {
                    $str .= ' -g "' . $opt->glob . '"';
                }
            }
        }


        $str .= "'"; // close quote
        return $str;
    }


    /**
    * Return args as a alternative
    *
    *  "*:args:{ _alternative ':importpaths:__go_list' ':files:_path_files -g \"*.go\"' }"
    */
    public function command_args(CommandBase $cmd, $cmdSignature) {
        $args = array();
        $arginfos = $cmd->getArgInfoList();

        // for command that does not define an argument, we just complete the argument by file paths.
        if (empty($arginfos)) {
            return array("*:default:_files");
        }

        $idx = 0;
        foreach($arginfos as $a) {
            $comp = '';

            if ($a->multiple) {
                $comp .= '*:' . $a->name;
            } else {
                $comp .= ':' . $a->name;
            }

            if ($a->validValues || $a->suggestions) {
                $values = array();
                if ($a->validValues) {
                    if (is_callable($a->validValues)) {
                        $comp .= ':{' . join(' ', array($this->meta_command_name(), Utils::qq($a->name), $cmdSignature, 'arg', $idx, 'valid-values')) . '}';
                    } elseif ($values = $a->getValidValues()) {
                        $comp .= ':(' . join(" ", Utils::array_qq($values)) . ')';
                    }
                } elseif ($a->suggestions ) {
                    if (is_callable($a->suggestions)) {
                        $comp .= ':{' . join(' ', array($this->meta_command_name(), Utils::qq($a->name), $cmdSignature, 'arg', $idx, 'suggestions')) . '}';
                    } elseif ($values = $a->getSuggestions()) {
                        $comp .= ':(' . join(" ", Utils::array_qq($values)) . ')';
                    }
                }
            } elseif (in_array($a->isa,array('file','path','dir'))) {
                switch($a->isa) {
                    case "file":
                        $comp .= ":_files";
                        break;
                    case "path":
                        $comp .= ":_path_files";
                        break;
                    case "dir":
                        $comp .= ":_directories";
                        break;
                }
                if ($a->glob) {
                    $comp .= " -g \"{$a->glob}\"";
                }
            }
            $args[] = Utils::q($comp);
            $idx++;
        }
        return empty($args) ? NULL : $args;
    }


    /**
     * Complete commands with options and its arguments (without subcommands)
     */
    public function complete_command_options_arguments(CommandBase $subcmd, $level = 1) {
        $cmdSignature = $subcmd->getSignature();


        $buf = new Buffer;
        $buf->setIndent($level);

        $args  = $this->command_args($subcmd, $cmdSignature);
        $flags = $this->command_flags($subcmd, $cmdSignature);

        if ( $flags || $args ) {
            $buf->appendLine("_arguments -w -S -s \\");
            $buf->indent();

            if ($flags) {
                foreach($flags as $line) {
                    $buf->appendLine($line . " \\");
                }
            }
            if ($args) {
                foreach($args as $line) {
                    $buf->appendLine($line . " \\");
                }
            }
            $buf->appendLine(" && ret=0");
            $buf->unindent();
        }
        return $buf->__toString();
    }

    public function render_argument_completion_handler(ArgInfo $a) {
        $comp = '';
        switch($a->isa) {
            case "file":
                $comp .= "_files";
                break;
            case "path":
                $comp .= "_path_files";
                break;
            case "dir":
                $comp .= "_directories";
                break;
        }
        if ($a->glob) {
            $comp .= " -g \"{$a->glob}\"";
        }
        return $comp;
    }



    public function render_argument_completion_values(ArgInfo $a) {
        if ($a->validValues || $a->suggestions) {
            $values = array();
            if ($a->validValues) {
                $values = $a->getValidValues();
            } elseif ($a->suggestions ) {
                $values = $a->getSuggestions();
            }
            return join(" ", $values);
        }
        return '';
    }




    /**
     * complete argument cases
     */
    public function command_args_case(CommandBase $cmd) {
        $buf = new Buffer;
        $arginfos = $cmd->getArgInfoList();
        $buf->appendLine("case \$state in");

        foreach($arginfos as $a) {
            $buf->appendLine("({$a->name})");

            if ($a->validValues || $a->suggestions) {
                $buf->appendLine("_values " . $this->render_argument_completion_values($a) . ' && ret=0');
            } elseif (in_array($a->isa,array('file','path','dir'))) {
                $buf->appendLine($this->render_argument_completion_handler($a) . ' && ret=0');
            }
            $buf->appendLine(";;");
        }
        $buf->appendLine("esac");
        return $buf->__toString();
    }

    /**
     * Return the zsh array code of the flags of a command.
     *
     * @return string[]
     */
    public function command_flags(CommandBase $cmd, $cmdSignature) {
        $args = array();
        $specs = $cmd->getOptionCollection();
        /*
        '(- 1 *)--version[display version and copyright information]' \
        '(- 1 *)--help[print a short help statement]' \
        */
        foreach ($specs->options as $opt ) {
            $args[] = $this->option_flag_item($opt, $cmdSignature);
        }
        return empty($args) ? NULL : $args;
    }


    /**
     * Return subcommand completion status as an array of string
     *
     * @param Command $cmd The command object
     *
     * @return string[]
     */
    public function command_subcommand_states(CommandBase $cmd) {
        $args = array();
        $cmds = $this->visible_commands($cmd->getCommands());
        foreach($cmds as $c) {
            $args[] = sprintf("'%s:->%s'", $c->getName(), $c->getName()); // generate argument states
        }
        return $args;
    }

    public function commandmeta_function() {
        $buf = new Buffer;
        $buf->indent();
        $buf->appendLine("local curcontext=\$curcontext state line ret=1");
        $buf->appendLine("typeset -A opt_args");
        $buf->appendLine("typeset -A val_args");

        $buf->appendLine("declare -a lines");
        $buf->appendLine("declare -a args");

        $buf->appendLine("local ret=1");
        $buf->appendLine("local desc=\$1");
        $buf->appendLine("local cmdsig=\$2");
        $buf->appendLine("local valtype=\$3");
        $buf->appendLine("local pos=\$4");
        $buf->appendLine("local completion=\$5");

        $metaCommand = array($this->programName, 'meta', '--zsh', '$cmdsig', '$valtype', '$pos', '$completion');

        $buf->appendLine('output=$(' . join(" ",$metaCommand) . ')');

        // zsh: split lines into array
        // lines=("${(@f)output}") ; echo ${lines[1]}
        // ${(@f)$( )} expand lines to array
        $buf->appendLine('lines=("${(@f)output}")');
        $buf->appendLine('output_type=${lines[1]}');

        // TODO: support title
        $buf->appendLine('if [[ $lines[1] == "#groups" ]] ; then');

        $buf->appendLine('    eval $output');
        $buf->appendLine('    for tag in ${(k)groups} ; do');
        $buf->appendLine('        complete_values=(${(z)${groups[$tag]}})');
        $buf->appendLine('        label=${labels[$tag]}');
        $buf->appendLine('        if [[ -z $label ]] ; then');
        $buf->appendLine('            label=$tag');
        $buf->appendLine('        fi');
        $buf->appendLine('        _describe -t $tag $label complete_values && ret=0');
        $buf->appendLine('    done');

        $buf->appendLine('elif [[ $lines[1] == "#values" ]] ; then');
        $buf->appendLine('    args=(${lines:1})');
        $buf->appendLine('   _values "$desc" ${=args} && ret=0');
        $buf->appendLine('elif [[ $lines[1] == "#descriptions" ]] ; then');
        $buf->appendLine('    args=(${lines:1})');
        $buf->appendLine('    _describe "$desc" args && ret=0');
        $buf->appendLine('else');
        $buf->appendLine('   _values "$desc" ${=lines} && ret=0');
        $buf->appendLine('fi');
        // $buf->appendLine('_values $desc ${=values} && ret=0'); // expand value array as arguments
        $buf->appendLine('return ret');
        return zsh_comp_function($this->meta_command_name(), $buf);
    }

    public function meta_command_name() {
        return '__' . preg_replace('/\W/','_',$this->compName) . 'meta';
    }


    /**
     * Zsh function usage
     *
     * example/demo meta commit arg 1 valid-values
     * appName meta sub1.sub2.sub3 opt email valid-values
     */
    public function commandmeta_callback_function(CommandBase $cmd) {
        $cmdSignature = $cmd->getSignature();
        
        
        $buf = new Buffer;
        $buf->indent();

        $buf->appendLine("local curcontext=\$curcontext state line ret=1");
        $buf->appendLine("declare -A opt_args");
        $buf->appendLine("declare -A values");
        $buf->appendLine("local ret=1");

        /*
        values=$(example/demo meta commit arg 1 valid-values)
        _values "description" ${=values} && ret=0
        return ret
        */
        $buf->appendLine("local desc=\$1");
        $buf->appendLine("local valtype=\$3");
        $buf->appendLine("local pos=\$4");
        $buf->appendLine("local completion=\$5");

        $metaCommand = array($this->programName,'meta', $cmdSignature, '$valtype', '$pos', '$completion');
        $buf->appendLine('$(' . join(" ",$metaCommand) . ')');
        $buf->appendLine('_values $desc ${=values} && ret=0'); // expand value array as arguments
        $buf->appendLine('return ret');

        $funcName = $this->command_function_name($cmdSignature);
        return zsh_comp_function($funcName, $buf);
    }

    public function commandmeta_callback_functions(CommandBase $cmd) {
        $cmdSignature = $cmd->getSignature();
        


        $buf = new Buffer;
        $subcmds = $this->visible_commands($cmd->getCommands());
        foreach($subcmds as $subcmd) {
            $buf->append($this->commandmeta_callback_function($subcmd));

            if ($subcmd->hasCommands()) {
                $buf->appendBuffer( $this->commandmeta_callback_functions($subcmd) );
            }
        }
        return $buf;
    }

    public function complete_application() {
        $buf = new Buffer;
        $buf->appendLines(array(
            "# {$this->programName} zsh completion script generated by CLIFramework",
            "# Web: http://github.com/c9s/php-CLIFramework",
            "# THIS IS AN AUTO-GENERATED FILE, PLEASE DON'T MODIFY THIS FILE DIRECTLY.",
        ));

        $metaName = '_' . $this->programName . 'meta';

        $buf->append( $this->commandmeta_function() );

        $buf->appendLines(array(
            "{$this->compName}() {",
            "local curcontext=\$curcontext state line",
            "typeset -A opt_args",
            "local ret=1",
            $this->complete_with_subcommands($this->app), // create an empty command name stack and 1 level indent
            "return ret",
            "}",
            "compdef {$this->compName} {$this->bindName}"
        ));
        return $buf->__toString();
    }


    /**
     * Convert command signature "foo.bar-top" into zsh function name "__foo_bar_top"
     *
     * @param string $sig
     */
    public function command_function_name($signature) {
        return '__' . $this->compName . '_' . preg_replace('#\W#','_', $signature);
    }


    public function complete_with_subcommands(CommandBase $cmd, $level = 1) {
        $cmdSignature = $cmd->getSignature();

        $buf = new Buffer;
        $buf->setIndent($level);

        $subcmds = $this->visible_commands($cmd->getCommands());
        $descsBuf  = $this->describe_commands($subcmds, $level);

        $code = array();

        // $code[] = 'echo $words[$CURRENT-1]';

        $buf->appendLine("_arguments -C \\");
        $buf->indent();

        if ($args = $this->command_flags($cmd, $cmdSignature)) {
            foreach ($args as $arg) {
                $buf->appendLine($arg . " \\");
            }
        }
        $buf->appendLine("': :->cmds' \\");
        $buf->appendLine("'*:: :->option-or-argument' \\");
        $buf->appendLine(" && return");
        $buf->unindent();

        $buf->appendLine("case \$state in");
        $buf->indent();

        $buf->appendLine("(cmds)");
        $buf->appendBuffer($descsBuf);
        $buf->appendLine(";;");

        $buf->appendLine("(option-or-argument)");

        // $code[] = "  curcontext=\${curcontext%:*:*}:$programName-\$words[1]:";
        // $code[] = "  case \$words[1] in";

        $buf->indent();
        $buf->appendLine("curcontext=\${curcontext%:*}-\$line[1]:");
        $buf->appendLine("case \$line[1] in");
        $buf->indent();
        foreach ($subcmds as $k => $subcmd) {
            // TODO: support alias
            $buf->appendLine("($k)");

            if ($subcmd->hasCommands()) {
                $buf->appendBlock($this->complete_with_subcommands($subcmd, $level + 1));
            } else {
                $buf->appendBlock($this->complete_command_options_arguments($subcmd, $level + 1));
            }
            $buf->appendLine(";;");
        }
        $buf->unindent();
        $buf->appendLine("esac");
        $buf->appendLine(";;");
        $buf->unindent();
        $buf->appendLine("esac");
        return $buf->__toString();
    }
}


<?php
namespace CLIFramework;

class CompletionUtils
{
    public static function split_words($line) {
        return preg_split("#\s+#", trim($line));
    }

    public static function paths($dir) {
        $names = scandir($dir);
        return array_filter($names, function($n) {
            return $n != '.' && $n != '..';
        });
    }

    public static function classnames($pattern = null) {
        $classes = get_declared_classes();
        if ($pattern) {
            return array_filter($classes, function($class) use ($pattern) {
                return preg_match($pattern, $class);
            });
        }
        return $classes;
    }

}


<?php
namespace CLIFramework\Component\Progress;

class ETACalculator
{
    static public function calculateRemainingSeconds($proceeded, $total, $start, $now)
    {
        $secondDiff = ($now - $start);
        $speed = $secondDiff > 0 ? $proceeded / $secondDiff : 0;
        $remaining = $total - $proceeded;
        if ($speed > 0) {
            $remainingSeconds = $remaining / $speed;
            return $remainingSeconds;
        }
    }

    static public function calculateEstimatedPeriod($proceeded, $total, $start, $now)
    {
        $str = '--';
        if ($remainingSeconds = self::calculateRemainingSeconds($proceeded, $total, $start, $now)) {
            $str = '';

            $days = 0;
            $hours = 0;
            $minutes = 0;
            if ($remainingSeconds > (3600 * 24)) {
                $days = ceil($remainingSeconds / (3600 * 24));
                $remainingSeconds = $remainingSeconds % (3600 * 24);
            }

            if ($remainingSeconds > 3600) {
                $hours = ceil($remainingSeconds / 3600);
                $remainingSeconds = $remainingSeconds % 3600;
            }

            if ($remainingSeconds > 60) {
                $minutes = ceil($remainingSeconds / 60);
                $remainingSeconds = $remainingSeconds % 60;
            }

            if ($days > 0) {
                $str .= $days . 'd'; 
            }
            if ($hours) {
                $str .= $hours . 'h';
            }
            if ($minutes) {
                $str .= $minutes . 'm';
            }
            if ($remainingSeconds > 0) {
                $str .= intval($remainingSeconds) . 's';
            }
        }
        return $str;
    }

    static public function calculateEstimatedTime($proceeded, $total, $start, $now)
    {
        if ($remainingSeconds = self::calculateRemainingSeconds($proceeded, $total, $start, $now)) {
            return $now + $remainingSeconds;
        }
    }
}




<?php
namespace CLIFramework\Component\Progress;
use Exception;
use CLIFramework\Formatter;
use CLIFramework\ConsoleInfo\EnvConsoleInfo;
use CLIFramework\ConsoleInfo\ConsoleInfoFactory;
use CLIFramework\Component\Progress\ETACalculator;
use CLIFramework\Ansi\Colors;

class LaserProgressBarStyle extends ProgressBarStyle
{
    public $leftDecorator = "â°";

    public $rightDecorator = "â±";

    public $barCharacter = '#';
}

class ProgressBar implements ProgressReporter
{
    protected $terminalWidth = 78;

    protected $formatter;

    protected $stream;

    protected $console;

    // protected $leftDecorator = "â°";
    protected $leftDecorator = "[";

    // protected $rightDecorator = "â±";
    protected $rightDecorator = "]";

    protected $columnDecorator = " | ";

    protected $barCharacter = '#';

    protected $descFormat = '%finished%/%total% %unit% | %percentage% | %eta_period%';

    protected $unit;

    protected $title;

    protected $start;

    protected $etaTime = '--:--';

    protected $etaPeriod = '--';

    public function __construct($stream, $container = null)
    {
        $this->stream = $stream;

        if ($container) {
            $this->formatter = $container['formatter'];
            if (isset($container['consoleInfo'])) {
                $this->console = $container['consoleInfo'];
            }
        } else {
            $this->formatter = new Formatter;
            $this->console = ConsoleInfoFactory::create();
            $this->updateLayout();
        }
    }

    public function updateLayout()
    {
        if ($this->console) {
            $this->terminalWidth = $this->console->getColumns();
        }
    }

    public function setTitle($title)
    {
        $this->title = $title;
    }

    public function setUnit($unit)
    {
        $this->unit = $unit;
    }

    public function start($title = null)
    {
        if ($title) {
            $this->setTitle($title);
        }
        $this->start = microtime(true);
    }

    public function update($finished, $total)
    {
        $percentage = $total > 0 ? round($finished / $total, 2) : 0.0;
        $trigger = $finished % 3;

        if ($trigger) {
            $this->etaTime = date('H:i',ETACalculator::calculateEstimatedTime($finished, $total, $this->start, microtime(true)));
            $this->etaPeriod = ETACalculator::calculateEstimatedPeriod($finished, $total, $this->start, microtime(true));
        }
        $desc = str_replace([
            '%finished%', '%total%', '%unit%', '%percentage%', '%eta_time%', '%eta_period%',
        ], [
            $finished,
            $total,
            $this->unit,
            ($percentage * 100) . '%',
            'ETA: ' . $this->etaTime,
            'ETA: ' . $this->etaPeriod,
        ], $this->descFormat);

        $barSize = $this->terminalWidth 
            - mb_strlen($desc) 
            - mb_strlen($this->leftDecorator) 
            - mb_strlen($this->rightDecorator)
            - mb_strlen($this->columnDecorator)
            ;

        if ($this->title) {
            $barSize -= (mb_strlen($this->title) + mb_strlen($this->columnDecorator));
        }

        $sharps = ceil($barSize * $percentage);

        fwrite($this->stream, "\r"
            . ( $this->title ? $this->title . $this->columnDecorator : "")
            . Colors::decorate($this->leftDecorator, $trigger ? 'purple' : 'light_purple')
            . Colors::decorate(str_repeat($this->barCharacter, $sharps), $trigger ? 'purple' : 'light_purple')
            . str_repeat(' ', max($barSize - $sharps,0))
            . Colors::decorate($this->rightDecorator, $trigger ? 'purple' : 'light_purple')
            . $this->columnDecorator 
            . Colors::decorate($desc, $trigger ? 'light_gray' : 'white')
            );

        // hide cursor
        // fputs($this->stream, "\033[?25l");

        // show cursor
        // fputs($this->stream, "\033[?25h");
    }

    public function finish($title = null)
    {
        if ($title) {
            $this->setTitle($title);
        }
        fwrite($this->stream, PHP_EOL);
    }

}

<?php
namespace CLIFramework\Component\Progress;
use Exception;
use CLIFramework\Formatter;
use CLIFramework\ConsoleInfo\EnvConsoleInfo;
use CLIFramework\ConsoleInfo\ConsoleInfoFactory;

class ProgressBarStyle
{
    public $leftDecorator = "|";

    public $rightDecorator = "|";

    public $barCharacter = '#';
}
<?php
namespace CLIFramework\Component\Progress;

interface ProgressReporter
{
    public function update($finishedValue, $totalValue);
}

<?php
namespace CLIFramework\Component\Progress;

class ProgressStar implements ProgressReporter
{
    public $stars = array('-','\\','|','/');

    public $i = 0;

    public $url;

    public $done = false;

    public function prettySize($bytes)
    {
        if ($bytes > 1000000) {
            return round( $bytes / 1000000, 2) . 'M';
        }
        elseif ($bytes > 1000) {
            return round($bytes / 1000, 2) . 'K';
        }
        return round($bytes,2) . 'B';
    }

    public function reset() {
        $this->done = false;
    }

    public function setUrl($url)
    {
        $this->url = $url;
    }

    public function curlCallback($ch, $downloadSize, $downloaded, $uploadSize, $uploaded)
    {
        /* 4kb */
        if ($this->done || $downloadSize == 0) {
            return;
        }

        // printf("%s % 4d%%", $s , $percent );
        if ($downloadSize != 0 && $downloadSize === $downloaded) {
            $this->done = true;
            printf("\r\t%-60s                           \n",$this->url);
        } else {
            $percent = ($downloaded > 0 ? (float) ($downloaded / $downloadSize) : 0.0 );
            if( ++$this->i > 3 )
                $this->i = 0;

            /* 8 + 1 + 60 + 1 + 1 + 1 + 6 = */
            printf("\r\tFetching %-60s %s % -3.1f%% %s", $this->url,
                $this->stars[ $this->i ], 
                $percent * 100, $this->prettySize($downloaded) );
        }
    }
}


<?php
namespace CLIFramework\Component\Progress;
use Exception;
use CLIFramework\Formatter;
use CLIFramework\ConsoleInfo\EnvConsoleInfo;
use CLIFramework\ConsoleInfo\ConsoleInfoFactory;

class SharpProgressBarStyle extends ProgressBarStyle
{
    public $leftDecorator = "[";

    public $rightDecorator = "]";

    public $barCharacter = '#';
}
<?php
namespace CLIFramework\Component\Table;

class BorderlessTableStyle extends TableStyle
{
    public $cellPadding = 1;

    public $cellPaddingChar = ' ';

    public $verticalBorderChar = ' ';

    public $drawTableBorder = false;

    public $drawRowSeparator = false;

    public $rowSeparatorCrossChar = ' ';

    public $rowSeparatorBorderChar = ' ';

    public $rowSeparatorLeftmostCrossChar = ' ';

    public $rowSeparatorRightmostCrossChar = ' ';
}

<?php
namespace CLIFramework\Component\Table;
use CLIFramework\Ansi\Colors;

class CellAttribute { 

    const ALIGN_RIGHT = 1;

    const ALIGN_LEFT = 2;

    const ALIGN_CENTER = 3;

    const WRAP = 1;

    const CLIP = 2;

    const ELLIPSIS = 3;

    protected $alignment = 2;

    protected $formatter;

    protected $textOverflow = CellAttribute::WRAP;

    protected $backgroundColor;

    protected $foregroundColor;


    /*
    protected $style;

    public function __construct(TableStyle $style) 
    {
        $this->style = $style;
    }

    public function setStyle(TableStyle $style)
    {
        $this->style = $style;
    }
    */

    public function setAlignment($alignment) 
    {
        $this->alignment = $alignment;
    }

    public function setFormatter($formatter)
    {
        $this->formatter = $formatter;
    }

    public function getFormatter()
    {
        return $this->formatter;
    }

    public function setTextOverflow($overflowType)
    {
        $this->textOverflow = $overflowType;
    }

    /**
     * The default cell text formatter
     */
    public function format($cell) { 
        if ($this->formatter) {
            return call_user_func($this->formatter, $cell);
        }
        return $cell;
    }

    public function setBackgroundColor($color) {
        $this->backgroundColor = $color;
    }

    public function setForegroundColor($color) {
        $this->foregroundColor = $color;
    }

    public function getForegroundColor() 
    {
        return $this->foregroundColor; // TODO: fallback to table style
    }

    public function getBackgroundColor() 
    {
        return $this->backgroundColor; // TODO: fallback to table style
    }

    /**
     * When inserting rows, we pre-explode the lines to extra rows from Table
     * hence this method is separated for pre-processing..
     */
    public function handleTextOverflow($cell, $maxWidth)
    {
        $lines = explode("\n",$cell);
        if ($this->textOverflow == self::WRAP) {
            $maxLineWidth = max(array_map('mb_strlen', $lines));
            if ($maxLineWidth > $maxWidth) {
                $cell = wordwrap($cell, $maxWidth, "\n");
                // Re-explode the lines
                $lines = explode("\n",$cell);
            }
        } elseif ($this->textOverflow == self::ELLIPSIS) {
            if (mb_strlen($lines[0]) > $maxWidth) {
                $lines = array(mb_substr($lines[0], 0, $maxWidth - 2) . '..');
            }
        } elseif ($this->textOverflow == self::CLIP) {
            if (mb_strlen($lines[0]) > $maxWidth) {
                $lines = array(mb_substr($lines[0], 0, $maxWidth));
            }
        }
        return $lines;
    }

    public function renderCell($cell, $width, $style)
    {
        $out = '';
        $out .= str_repeat($style->cellPaddingChar, $style->cellPadding);
        /*
        if ($this->backgroundColor || $this->foregroundColor) {
            $decoratedCell = Colors::decorate($cell, $this->foregroundColor, $this->backgroundColor);
            $width += mb_strlen($decoratedCell) - mb_strlen($cell);
            $cell = $decoratedCell;
        }
        */

        if ($this->alignment === CellAttribute::ALIGN_LEFT) {
            $out .= str_pad($cell, $width, ' '); // default alignment = LEFT
        } elseif ($this->alignment === CellAttribute::ALIGN_RIGHT) {
            $out .= str_pad($cell, $width, ' ', STR_PAD_LEFT);
        } elseif ($this->alignment === CellAttribute::ALIGN_CENTER) {
            $out .= str_pad($cell, $width, ' ', STR_PAD_BOTH);
        } else {
            $out .= str_pad($cell, $width, ' '); // default alignment
        }

        $out .= str_repeat($style->cellPaddingChar, $style->cellPadding);

        if ($this->backgroundColor || $this->foregroundColor) {
            return Colors::decorate($out, $this->foregroundColor, $this->backgroundColor);
        }
        return $out;
    }
}

<?php
namespace CLIFramework\Component\Table;

class CompactTableStyle extends TableStyle
{
    public $cellPadding = 1;

    public $cellPaddingChar = ' ';

    public $verticalBorderChar = ' ';

    public $drawTableBorder = false;

    public $drawRowSeparator = false;

    public $rowSeparatorCrossChar = '-';

    public $rowSeparatorBorderChar = '-';

    public $rowSeparatorLeftmostCrossChar = '-';

    public $rowSeparatorRightmostCrossChar = '-';
}

<?php
namespace CLIFramework\Component\Table;
use CLIFramework\Component\Table\CellAttribute;
use NumberFormatter;

class CurrencyFormatCell extends NumberFormatCell
{
    protected $currency;

    public function __construct($locale, $currency) {
        parent::__construct($locale);
        $this->currency = $currency;
    }

    public function format($cell) {
        return $this->formatter->formatCurrency($cell, $this->currency);
    }
}


<?php
namespace CLIFramework\Component\Table;
use CLIFramework\Component\Table\CellAttribute;
use NumberFormatter;
use IntlDateFormatter;
use DateTime;

class DateFormatCell extends NumberFormatCell
{

    /**
     * IntlDateFormatter::FULL (integer)
        Completely specified style (Tuesday, April 12, 1952 AD or 3:30:42pm PST)
     * IntlDateFormatter::LONG (integer)
        Long style (January 12, 1952 or 3:30:32pm)
     * IntlDateFormatter::MEDIUM (integer)
        Medium style (Jan 12, 1952)
     * IntlDateFormatter::SHORT (integer)
        Most abbreviated style, only essential data (12/13/52 or 3:30pm)
     */
    public function __construct($locale, $datetype = IntlDateFormatter::FULL, $timetype = IntlDateFormatter::FULL, $timezone = NULL, $calendar = IntlDateFormatter::GREGORIAN, $pattern = "")
    {
        $this->locale = $locale;
        $this->formatter = new IntlDateFormatter($locale , $datetype, $timetype, $timezone, $calendar);
    }

    public function format($cell) {
        if ($cell instanceof DateTime) {
            return $this->formatter->formatObject($cell);
        }
        return $this->formatter->format($cell);
    }
}


<?php
namespace CLIFramework\Component\Table;
use CLIFramework\Component\Table\CellAttribute;
use NumberFormatter;

class DurationFormatCell extends NumberFormatCell
{
    public function __construct($locale) {
        $this->locale = $locale;
        $this->formatter = new NumberFormatter($locale, NumberFormatter::DURATION); 
    }
}


<?php
namespace CLIFramework\Component\Table;

class MarkdownTableStyle extends TableStyle
{
    public $cellPadding = 1;

    public $cellPaddingChar = ' ';

    public $verticalBorderChar = '|';

    public $rowSeparatorCrossChar = '|';

    public $rowSeparatorBorderChar = '-';

    public $rowSeparatorLeftmostCrossChar = '|';

    public $rowSeparatorRightmostCrossChar = '|';

    public $drawTableBorder = false;
}

<?php
namespace CLIFramework\Component\Table;
use CLIFramework\Component\Table\CellAttribute;
use NumberFormatter;

class NumberFormatCell extends CellAttribute
{
    protected $locale;

    protected $formatter;

    public function __construct($locale) {
        $this->locale = $locale;
        $this->formatter = new NumberFormatter($locale, NumberFormatter::DECIMAL); 
    }

    public function format($cell) {
        if (is_numeric($cell)) {
            return $this->formatter->format($cell);
        }
        return $cell;
    }
}


<?php
namespace CLIFramework\Component\Table;
use CLIFramework\Component\Table\CellAttribute;
use NumberFormatter;

class DurationFormatCell extends NumberFormatCell
{
    public function __construct($locale) {
        $this->locale = $locale;
        $this->formatter = new NumberFormatter($locale, NumberFormatter::PERCENT); 
    }
}


<?php
namespace CLIFramework\Component\Table;
use CLIFramework\Component\Table\CellAttribute;
use NumberFormatter;

class SpellOutNumberFormatCell extends NumberFormatCell
{
    public function __construct($locale) {
        $this->locale = $locale;
        $this->formatter = new NumberFormatter($locale, NumberFormatter::SPELLOUT); 
        $this->formatter->setTextAttribute(NumberFormatter::DEFAULT_RULESET, "%financial");
    }
}


<?php
namespace CLIFramework\Component\Table;
use InvalidArgumentException;

use CLIFramework\Component\Table\TableStyle;
use CLIFramework\Component\Table\MarkdownTableStyle;
use CLIFramework\Component\Table\CellAttribute;

interface Separator { }

/**
 * RowSeparator is a slight separator for separating distinct rows...
 */
class RowSeparator implements Separator { }

/**
 * TableSeparator is more likely a section separator, the style is customizable.
 */
class TableSeparator implements Separator { }

/**
 * Feature:
 * 
 * - Support column wrapping if the cell text is too long.
 * - Table style
 */
class Table
{



    /**
     * @var string[] the rows are expanded by lines
     */
    protected $rows = array();

    /**
     * @var inteager[] contains the real row index
     */
    protected $rowIndex = array();

    protected $columnWidths = array();

    protected $headers = array();

    protected $style;

    protected $numberOfColumns;

    protected $maxColumnWidth = 50;

    protected $predefinedStyles = array();

    /**
     * Save the mapping of column index => cell attributes
     *
     * [ column index => cell attributes, ... ]
     */
    protected $columnCellAttributes = array();


    /**
     * The default cell attribute
     */
    protected $defaultCellAttribute;


    /**
     * @var bool strip the white spaces from the begining of a 
     * string and the end of a string.
     */
    protected $trimSpaces = true;

    protected $trimLeadingSpaces = false;

    protected $trimTrailingSpaces = false;

    protected $footer;

    public function __construct() {
        $this->style = new TableStyle;
        $this->defaultCellAttribute = new CellAttribute;
    }

    public function setHeaders(array $headers) {
        $this->headers = $headers;
        return $this;
    }

    public function setFooter($footer)
    {
        $this->footer = $footer;
        return $this;
    }

    public function setColumnCellAttribute($colIndex, CellAttribute $cellAttribute)
    {
        $this->columnCellAttributes[$colIndex] = $cellAttribute;
    }

    public function getColumnCellAttribute($colIndex)
    {
        if (isset($this->columnCellAttributes[$colIndex])) {
            return $this->columnCellAttributes[$colIndex];
        }
    }

    public function getDefaultCellAttribute()
    {
        return $this->defaultCellAttribute;
    }

    public function setMaxColumnWidth($width)
    {
        $this->maxColumnWidth = $width;
    }

    /**
     * Gets number of columns for this table.
     *
     * @return int
     */
    private function getNumberOfColumns()
    {
        if (null !== $this->numberOfColumns) {
            return $this->numberOfColumns;
        }

        $columns = array(count($this->headers));
        foreach ($this->rows as $row) {
            $columns[] = count($row);
        }
        return $this->numberOfColumns = max($columns);
    }

    public function addRow($row) {
        $this->rows[] = $row;

        if ($row instanceof RowSeparator) {
            return $this;
        }

        // $keys = array_keys($this->rows);
        $lastRowIdx = count($this->rows) - 1;

        $this->rowIndex[$lastRowIdx] = 1;

        $cells = array_values($row);
        foreach ($cells as $col => $cell) {
            $attribute = $this->defaultCellAttribute;

            $expandAttribute = false;
            if (is_array($cell)) {
                if ($cell[0] instanceof CellAttribute) {
                    $attribute = array_shift($cell);
                    $expandAttribute = true;
                }
                $cell = join("\n", $cell);
            } elseif (isset($this->columnCellAttributes[$col])) {
                $attribute = $this->columnCellAttributes[$col];
            }

            $lines = $attribute->handleTextOverflow($cell, $this->maxColumnWidth);

            if (count($lines) == 1) {
                $lines[0] = $attribute->format($lines[0]);
            }

            // Handle extra lines
            $extraRowIdx = $lastRowIdx;
            foreach($lines as $line) {
                // trim the leading space
                if ($this->trimSpaces) {
                    $line = trim($line);
                } else {
                    if ($this->trimLeadingSpaces) {
                        $line = ltrim($line);
                    }
                    if ($this->trimTrailingSpaces) {
                        $line = rtrim($line);
                    }
                }

                if (isset($this->rows[$extraRowIdx])) {
                    $this->rows[$extraRowIdx][ $col ] = $expandAttribute ? array($attribute, $line) : $line;
                } else {
                    $this->rows[$extraRowIdx] = array($col => $expandAttribute ? array($attribute, $line) : $line);
                }
                $extraRowIdx++;
            }
        }
        return $this;
    }

    public function getColumnWidth($col)
    {
        $lengths = array();
        foreach($this->rows as $row) {
            if ($row instanceof RowSeparator) {
                continue;
            }
            if (isset($row[$col])) {
                if (is_array($row[$col])) {
                    if (!isset($row[$col][1])) {
                        throw new InvalidArgumentException('Incorrect cell structure. Expecting [attribute, text].');
                    }
                    $lengths[] = mb_strlen(preg_replace('/\033.*?m/','',$row[$col][1]));
                } else {
                    $lengths[] = mb_strlen(preg_replace('/\033.*?m/','',$row[$col]));
                }
            }
        }

        $headerColumnWidth = isset($this->headers[$col]) ? mb_strlen($this->headers[$col]) : 0;
        $maxContentWidth = max($lengths);;

        if (empty($lengths) || $headerColumnWidth > $maxContentWidth) {
            return $this->columnWidth[$col] = $headerColumnWidth;
        }
        return $this->columnWidth[$col] = max($lengths);
    }

    public function renderRow($rowIndex, $row) {
        $out = $this->style->verticalBorderChar;
        $columnNumber = $this->getNumberOfColumns();
        for ($c = 0 ; $c < $columnNumber ; $c++) {
            if (isset($row[$c])) {
                $cell = $row[$c];
            } else {
                $cell = '';
            }
            $out .= $this->renderCell($c, $cell);
            $out .= $this->style->verticalBorderChar;

        }
        if ($rowIndex > 0 && isset($this->rowIndex[$rowIndex]) && $this->style->drawRowSeparator) {
            return $this->renderSeparator() . $out . "\n";
        } else {
            return $out . "\n";
        }
    }

    public function setStyle($style)
    {
        if (is_string($style)) {
            if (isset($this->predefinedStyles[$style])) {
                $this->style = $this->predefinedStyles[$style];
            } else {
                throw new InvalidArgumentException("Undefined style $style");
            }
        } else {
            $this->style = $style;
        }
        return $this;
    }

    public function renderSeparator() {
        $columnNumber = $this->getNumberOfColumns();
        $out = $this->style->rowSeparatorLeftmostCrossChar;
        for ($c = 0 ; $c < $columnNumber ; $c++) {
            $columnWidth = $this->getColumnWidth($c);
            $out .= str_repeat($this->style->rowSeparatorBorderChar, $columnWidth + $this->style->cellPadding * 2);

            if ($c + 1 < $columnNumber) {
                $out .= $this->style->rowSeparatorCrossChar;
            } else {
                $out .= $this->style->rowSeparatorRightmostCrossChar;
            }
        }
        return $out . "\n";
    }

    public function renderHeader() {
        $out = '';

        if ($this->style->drawTableBorder) {
            $out .= $this->renderSeparator();
        }

        $out .= $this->style->verticalBorderChar;
        $columnNumber = $this->getNumberOfColumns();
        for ($c = 0 ; $c < $columnNumber ; $c++) {
            if (isset($this->headers[$c])) {
                $cell = $this->headers[$c];
            } else {
                $cell = '';
            }
            $out .= $this->renderCell($c, $cell);
            $out .= $this->style->verticalBorderChar;
        }
        $out .= "\n";
        $out .= $this->renderSeparator();
        return $out;
    }


    public function getTableInnerWidth() 
    {
        $columnNumber = $this->getNumberOfColumns();
        $width = 0;
        for ($c = 0 ; $c < $columnNumber ; $c++) {
            $width += $this->getColumnWidth($c) + $this->style->cellPadding * 2 + 1;
        }
        return $width - 1;
    }

    public function renderCell($cellIndex, $cell)
    {
        $attribute = $this->defaultCellAttribute;

        if (is_array($cell)) {
            if ($cell[0] instanceof CellAttribute) {
                $attribute = array_shift($cell);
            }
            $cell = join("\n", $cell);
        } elseif (isset($this->columnCellAttributes[$cellIndex])) {
            $attribute = $this->columnCellAttributes[$cellIndex];
        }

        $width = $this->getColumnWidth($cellIndex);
        if (function_exists('mb_strlen') && false !== $encoding = mb_detect_encoding($cell)) {
            $width += strlen($cell) - mb_strlen($cell, $encoding);
        }
        return $attribute->renderCell($cell, $width, $this->style);
    }

    public function renderFooter()
    {
        if (!is_array($this->footer)) {
            $columnNumber = $this->getNumberOfColumns();
            $out = '';
            $width = $this->getTableInnerWidth();
            $out .= $this->renderSeparator();
            $out .= $this->style->verticalBorderChar 
                . str_repeat($this->style->cellPaddingChar, $this->style->cellPadding)
                . str_pad($this->footer, $width - $this->style->cellPadding * 2) 
                . str_repeat($this->style->cellPaddingChar, $this->style->cellPadding)
                . $this->style->verticalBorderChar . "\n";

            if ($this->style->drawTableBorder) {
                $out .= $this->style->rowSeparatorLeftmostCrossChar . str_repeat($this->style->rowSeparatorBorderChar, $width) 
                    . $this->style->rowSeparatorRightmostCrossChar . "\n";
            }
            return $out;
        }

        $out = '';


        $out .= $this->style->verticalBorderChar;
        $columnNumber = $this->getNumberOfColumns();
        for ($c = 0 ; $c < $columnNumber ; $c++) {
            if (isset($this->footer[$c])) {
                $cell = $this->footer[$c];
            } else {
                $cell = '';
            }
            $out .= $this->renderCell($c, $cell);
            $out .= $this->style->verticalBorderChar;
        }
        $out .= "\n";

        if ($this->style->drawTableBorder) {
            $out .= $this->renderSeparator();
        }
        return $out;
    }

    public function render() {
        $out = '';

        if (!empty($this->headers)) {
            $out .= $this->renderHeader();
        } else {
            $out .= $this->renderSeparator();
        }

        foreach($this->rows as $rowIndex => $row) {
            if ($row instanceof RowSeparator) {
                $out .= $this->renderSeparator();
            } else {
                $out .= $this->renderRow($rowIndex, $row);
            }
        }

        // Markdown table does not support footer
        if ($this->style && ! $this->style instanceof MarkdownTableStyle) {
            if (!empty($this->footer)) {
                $out .= $this->renderFooter();
            } else {
                $out .= $this->renderSeparator();
            }
        }
        return $out;
    }

}




<?php
namespace CLIFramework\Component\Table;

class TableStyle
{
    public $cellPadding = 1;

    public $cellPaddingChar = ' ';

    public $verticalBorderChar = '|';


    public $rowSeparatorBorderChar = '-';

    public $rowSeparatorCrossChar = '+';

    public $rowSeparatorLeftmostCrossChar = '+';

    public $rowSeparatorRightmostCrossChar = '+';

    public $drawTableBorder = true;

    public $drawRowSeparator = false;

    public function setCellPadding($padding) 
    {
        $this->cellPadding = $padding;
    }

    public function setCellPaddingChar($c) 
    {
        $this->cellPaddingChar = $c;
    }

    public function setVerticalBorderChar($c) 
    {
        $this->verticalBorderChar = $c;
    }

    public function setRowSeparatorCrossChar($c)
    {
        $this->rowSeparatorCrossChar = $c;
    }

    public function setRowSeparatorRightmostCrossChar($c)
    {
        $this->rowSeparatorRightmostCrossChar = $c;
    }

    public function setRowSeparatorLeftmostCrossChar($c)
    {
        $this->rowSeparatorLeftmostCrossChar = $c;
    }

    public function setRowSeparatorBorderChar($c) {
        $this->rowSeparatorBorderChar = $c;
    }

}
<?php
namespace CLIFramework\Config;

class GlobalConfig
{
    /**
     * @var array
     */
    private $config;

    /**
     * @var boolean
     */
    private $isVerbose = false;

    /**
     * @var boolean
     */
    private $isDebug = false;

    /**
     * @var string
     */
    private $pidDir;

    public function __construct($config)
    {
        $this->config = $config;
    }

    /**
     * Returns true if verbose option is enabled.
     * @return boolean
     */
    public function isVerbose()
    {
        if (isset($this->config['core']['verbose'])) {
            $this->isVerbose = $this->config['core']['verbose'] === '1';
        }
        return $this->isVerbose;
    }

    /**
     * Returns true if debug option is enabled.
     * @return boolean
     */
    public function isDebug()
    {
        if (isset($this->config['core']['debug'])) {
            $this->isDebug = $this->config['core']['debug'] === '1';
        }
        return $this->isDebug;
    }

    /**
     * Returns the directory of pid files.
     */
    public function getPidDirectory()
    {
        if (isset($this->config['core']['pid_dir'])) {
            $this->pidDir = $this->config['core']['pid_dir'];
        }
        return $this->pidDir;
    }
}
<?php
namespace CLIFramework\ConsoleInfo;
use CLIFramework\ConsoleInfo\EnvConsoleInfo;
use CLIFramework\ConsoleInfo\TputConsoleInfo;

class ConsoleInfoFactory
{

    static public function create()
    {
        if (EnvConsoleInfo::hasSupport()) {
            return new EnvConsoleInfo;
        } else if (TputConsoleInfo::hasSupport()) {
            return new TputConsoleInfo;
        }
    }


}



<?php
namespace CLIFramework\ConsoleInfo;

interface ConsoleInfoInterface
{
    public function getColumns();
    public function getRows();
    static public function hasSupport();
}


<?php
namespace CLIFramework\ConsoleInfo;

class EnvConsoleInfo implements ConsoleInfoInterface
{
    public function getColumns() 
    {
        return intval(getenv('COLUMNS'));
    }

    public function getRows() 
    {
        return intval(getenv('LINES'));
    }

    static public function hasSupport()
    {
        return getenv('COLUMNS') && getenv('LINES');
    }
}



<?php
namespace CLIFramework\ConsoleInfo;

class TputConsoleInfo implements ConsoleInfoInterface
{
    public function getColumns() 
    {
        return intval(exec('tput cols'));
    }

    public function getRows() 
    {
        return intval(exec('tput lines'));
    }

    static public function hasSupport()
    {
        $paths = explode(':',getenv('PATH'));
        foreach($paths as $path) {
            $bin = $path . DIRECTORY_SEPARATOR . 'tput';
            if (file_exists($bin) && is_executable($bin)) {
                return true;
            }
        }
        return false;
    }

}



<?php
namespace CLIFramework;

/**
 * Try to correct/suggest user's input
 *
 * @method __construct
 * @method guess
 * @method match
 */
class Corrector
{
    protected $possibleTokens = array();

    /**
     * Constructor.
     *
     * @param string[] $possibleTokens candidates of the suggestion
     */
    public function __construct(array $possibleTokens = array())
    {
        $this->possibleTokens = $possibleTokens;
    }

    /**
     * Given user's input, ask user to correct it.
     *
     * @param string $input user's input
     * @return string corrected input
     */
    public function correct($input) {
        $guess = $this->match($input);
        if ($guess === $input)
            return $guess;
        else
            return $this->askForGuess($guess) ? $guess : $input;
    }

    /**
     * Given user's input, return the best match among candidates.
     *
     * @param string $input @see self::correct()
     * @return string best matched string or raw input if no candidates provided
     */
    public function match($input)
    {
        if (empty($this->possibleTokens))
            return $input;

        $bestSimilarity = -1;
        $bestGuess = $input;
        foreach ($this->possibleTokens as $possibleToken) {
            similar_text($input, $possibleToken, $similarity);
            if ($similarity > $bestSimilarity) {
                $bestSimilarity = $similarity;
                $bestGuess = $possibleToken;
            }
        }
        return $bestGuess;
    }

    private function askForGuess($guess)
    {
        $prompter = new Prompter;
        $answer = $prompter->ask("Did you mean '$guess'?", array('Y','n'), 'Y');
        return !$answer || strtolower($answer) == 'y';
    }

}
<?php
namespace CLIFramework\Debug;
use CLIFramework\Component\Table\Table;
use CLIFramework\Component\Table\TableStyle;
use CLIFramework\Component\Table\CompactTableStyle;
use CLIFramework\Component\Table\MarkdownTableStyle;
use CLIFramework\Component\Table\CellAttribute;
use CLIFramework\Component\Table\NumberFormatCell;
use CLIFramework\Component\Table\CurrencyCellAttribute;
use CLIFramework\Component\Table\SpellOutNumberFormatCell;
use CLIFramework\Component\Table\RowSeparator;
use LazyRecord\BaseCollection;
use Exception;

class ConsoleDebug
{
    static public function dumpException(Exception $e)
    {
        $indicator = new LineIndicator;
        $output = [];
        $output[] = '[' . get_class($e) . '] was thrown with "' . $e->getMessage() . '".';
        $output[] = $indicator->indicateFile($e->getFile(), $e->getLine());

        $output[] = "Exception Stack Trace";
        $output[] = "=====================";
        $output[] = "";
        $output[] = $e->getTraceAsString();
        return join(PHP_EOL, $output);
    }


    /**
     * Dump Record Collection
     */
    static public function dumpCollection(BaseCollection $collection, array $options = array())
    {
        return self::dumpRows($collection->toArray(), $options);
    }


    static public function dumpRows(array $array, array $options = array())
    {
        $table = new Table;

        $keys = null;
        if (isset($options['keys'])) {
            $keys = $options['keys'];
        } else if (isset($array[0])) {
            $keys = array_keys($array[0]);
        }

        if ($keys) {
            $table->setHeaders($keys);
        }

        if (empty($array)) {
            return '0 rows.' . PHP_EOL;
        }

        foreach ($array as $item) {
            $values = [];
            foreach ($keys as $key) {
                $values[] = $item[$key];
            }
            $table->addRow($values);
        }
        return $table->render() . PHP_EOL
            . count($array) . ' rows.' . PHP_EOL;
    }
}



<?php
namespace CLIFramework\Debug;

class LineIndicator
{
    protected $contextLines = 4;

    protected $indicatedLineFormat = "> % 4d| %s";
    
    protected $contextLineFormat = "  % 4d| %s";

    public function __construct()
    {

    }

    /**
     *
     * @param string $file
     * @param integer|integer[] $line
     */
    public function indicateFile($file, $line)
    {
        $lines = file($file);
        $fromIndex = max($line - 1 - $this->contextLines, 0);
        $toIndex = min($line - 1 + $this->contextLines, count($lines));

        if ($fromIndex === $toIndex) {
            $indexRange = [ $fromIndex ];
        } else {
            $indexRange = range($fromIndex, $toIndex);
        }

        $output = [];
        $output[] = "$file @ line " . join(',', (array) $line);
        $output[] = str_repeat('=', strlen($output[0]) );
        foreach($indexRange as $index) {
            if ((is_integer($line) && $index + 1 == $line) ||  (is_array($line) && in_array($index + 1, $line) ) ) {
                $output[] = sprintf($this->indicatedLineFormat, $index + 1, rtrim($lines[$index]));
            } else {
                $output[] = sprintf($this->contextLineFormat, $index + 1, rtrim($lines[$index]));
            }
        }
        return join(PHP_EOL, $output) . PHP_EOL;
    }
}





<?php
namespace CLIFramework\Exception;
use Exception;
use CLIFramework\CommandBase;

class CommandArgumentNotEnoughException extends CommandBaseException
{
    public $given;

    public $required;

    public function __construct(CommandBase $command, $given, $required) {
        $this->given = $given;
        $this->required = $required;
        parent::__construct($command, "Insufficient arguments for command '{$command->getName()}', which requires $required arguments, $given given.");
    }


}
<?php
namespace CLIFramework\Exception;
use Exception;
use CLIFramework\CommandBase;

class CommandBaseException extends Exception
{
    public $command;

    public function __construct(CommandBase $command, $message = "", $code = 0, $previous = NULL) {
        $this->command = $command;
        parent::__construct($message, $code, $previous);
    }

    public function getCommand() {
        return $this->command;
    }
}



<?php
namespace CLIFramework\Exception;
use Exception;

class CommandClassNotFoundException extends Exception
{
    public $class;

    public $registeredNamespaces = array();

    public $possibleClasses = array();

    public function __construct($class, $registeredNamespaces = array()) {
        $this->class = $class;
        $this->registeredNamespaces = $registeredNamespaces;

        $this->possibleClasses[] = $class;
        foreach( $registeredNamespaces as $ns ) {
            $this->possibleClasses[] = $ns . '\\' . ltrim($class, '\\');
        }

        $desc = "Command $class not found.";
        if (!empty($this->registeredNamespaces)) {
            $desc .= "\nRegistered namespaces: [" . join(',', $this->registeredNamespaces) . "]";
        }
        if (!empty($this->possibleClasses)) {
            $desc .= "\nPossible classnames: [" . join(',', $this->possibleClasses) . "]";
        }
        parent::__construct($desc);
    }

    public function getRegisteredNamespaces() {
        return $this->registeredNamespaces;
    }

    public function getPossibleClasses() {
        return $this->possibleClasses;
    }
}


<?php
namespace CLIFramework\Exception;
use Exception;
use CLIFramework\CommandBase;
use CLIFramework\Exception\CommandBaseException;

class CommandNotFoundException extends CommandBaseException
{
    public $name;

    public function __construct(CommandBase $command, $name) {
        $this->name = $name;
        parent::__construct($command, "Command $name not found.");
    }
}


<?php
namespace CLIFramework\Exception;
use Exception;

class ExecuteMethodNotDefinedException extends CommandBaseException { }





<?php
namespace CLIFramework\Exception;
use CLIFramework\Extension\ExtensionBase;
use Exception;

class ExtensionException extends \Exception
{
    protected $extension;

    public function __construct($message, ExtensionBase $extension = null)
    {
        parent::__construct($message);

        $this->extension = $extension;
    }

    public function getExtension()
    {
        return $this->extension;
    }
}
<?php
namespace CLIFramework\Exception;
use Exception;
use CLIFramework\Exception\CommandBaseException;
use CLIFramework\CommandBase;

class InvalidCommandArgumentException extends CommandBaseException
{
    public $arg;

    public $argIndex;

    public function __construct(CommandBase $command, $argIndex, $arg) {
        $this->argIndex = $argIndex;
        $this->arg = $arg;
        parent::__construct($command, "Invalid '{$command->getName()}' command argument '$arg' at position $argIndex");
    }
}

<?php
namespace CLIFramework\ExceptionPrinter;
use Exception;
use CLIFramework\ServiceContainer;
use CLIFramework\Logger;

function is_assoc_array(array $a) {
    return ! is_indexed_array($a);
}

function is_indexed_array(array $a) {
    $keys = array_keys($a);
    $indexes = array_filter($keys, 'is_numeric');
    return count($indexes) ? True : False;
}

function output_var($a) {
    if (is_array($a)) {
        if (is_indexed_array($a)) {
            $out = array();
            foreach ($a as $i) {
                $out[] = output_var($i);
            }
            return '[' . join(', ',$out) . ']';
        } else {

            $out = '[';
            foreach ($a as $k => $i) {
                $out .= $k . ' => ' . output_var($i);
            }
            $out .= ']';
            return $out;

        }
    } else if (is_scalar($a)) {

        return var_export($a, true);

    } else if (is_object($a)) {

        if (method_exists($a, '__toString')) {
            return $a->__toString();
        } else {
            return get_class($a);
        }

    } else {
        return '...';
    }
}

class DevelopmentExceptionPrinter
{
    public $reportUrl;

    public $logger;

    public function __construct(Logger $logger)
    {
        $this->logger = $logger;
    }

    public function dumpVar($var)
    {
        return output_var($var);
    }

    public function dumpArgs(array $args)
    {
        if (empty($args)) {
            return '';
        }

        $desc = array();
        foreach($args as $a) {
            $desc[] = output_var($a);
        }
        return join(', ', $desc);
    }

    public function dumpTraceInPhar(Exception $e)
    {
        $this->logger->info("Trace:\n");
        $trace = $e->getTrace();
        foreach($trace as $idx => $entry) {
            $argDesc = $this->dumpArgs($entry['args']);
            $this->logger->info(sprintf("    %d) %s%s%s(%s)", $idx, @$entry['class'], @$entry['type'], $entry['function'], $argDesc));
        }
        $this->logger->newline();
    }

    public function dumpTrace(Exception $e)
    {
        $this->logger->info("Trace:\n");
        $trace = $e->getTrace();
        foreach($trace as $idx => $entry) {

            $argDesc = $this->dumpArgs($entry['args']);

            $this->logger->info(sprintf("    %d) %s%s%s(%s)", $idx, @$entry['class'], @$entry['type'], $entry['function'], $argDesc));
            $this->logger->info(sprintf("        from %s: %d", $entry['file'], $entry['line']));
            $this->logger->newline();
        }
        $this->logger->newline();
    }

    public function dumpCodeBlock(Exception $e)
    {
        $line = $e->getLine();
        $file = $e->getFile();
        $this->logger->info("Thrown from $file at line $line:\n");

        $lines = file($file);
        $indexRange = range(max($line - 4, 0), min($line + 3, count($lines)));
        foreach($indexRange as $index) {
            if ($index == ($line - 1)) {
                $this->logger->warn(sprintf("> % 3d", $index + 1) . rtrim($lines[$index]));
            } else {
                $this->logger->info(sprintf("  % 3d", $index + 1) . rtrim($lines[$index]));
            }
        }

        $this->logger->newline();
    }

    public function dumpBrief(Exception $e)
    {
        $logger = $this->logger;
        $code = $e->getCode();
        $message = $e->getMessage();

        $file = $e->getFile();
        $line = $e->getLine();

        $class = get_class($e);

        if ($code) {
            $logger->error("$class: ($code) $message");
        } else {
            $logger->error("$class: $message");
        }
    }

    public function dump(Exception $e) 
    {
        $this->dumpBrief($e);
        $this->dumpCodeBlock($e);
        $this->dumpTrace($e);
    }
}




<?php
namespace CLIFramework\ExceptionPrinter;
use Exception;
use CLIFramework\ServiceContainer;
use CLIFramework\Logger;

class ProductionExceptionPrinter extends DevelopmentExceptionPrinter
{
    public $reportUrl;

    public function dump(Exception $e) 
    {
        $this->dumpBrief($e);
        $this->dumpTraceInPhar($e);
    }
}




<?php
namespace CLIFramework\Extension;
use CLIFramework\Application;

interface ApplicationExtension extends Extension {

    public function bindApplication(Application $app);

}

<?php
namespace CLIFramework\Extension;
use CLIFramework\Command;
use CLIFramework\Extension\Extension;
use CLIFramework\Extension\ExtensionBase;

abstract class CommandExtension extends ExtensionBase
{
    protected $config;

    protected $command;

    public function bindCommand(Command $command)
    {
        $this->command = $command;
        $this->options($command->getOptionCollection());
        // $this->arguments( );

        $this->config = $command->getApplication()->getGlobalConfig();
        $this->setServiceContainer($command->getApplication()->getService());
        $this->init();
    }

}
<?php
namespace CLIFramework\Extension;
use CLIFramework\ServiceContainer;
use CLIFramework\Command;
use CLIFramework\CommandBase;
use CLIFramework\Logger;
use CLIFramework\Exception\ExtensionException;
use CLIFramework\Extension\CommandExtension;
use CLIFramework\IO\StreamWriter;
use GetOptionKit\OptionCollection;

class DaemonExtension extends CommandExtension
{
    protected $logger;

    /**
     * @var boolean Detach from shell.
     */
    protected $detach = false;

    protected $chdir = false;

    public function isAvailable()
    {
        return function_exists('pcntl_fork');
    }


    static public function isSupported()
    {
        return function_exists('pcntl_fork');
    }


    public function finish()
    {
        $pidFile = $this->getPidFilePath();
        if (file_exists($pidFile)) {
            @unlink($pidFile);
        }
    }

    public function execute()
    {
        if (!$this->isAvailable()) {
            throw new ExtensionException("pcntl_fork() is not supported.");
        }
        $this->prepareLogger();
        $logger = $this->getLogger();
        $this->daemonize();
        // $logger->debug('PidFilePath = ' . $this->getPidFilePath());
    }

    /**
     * Call this method if you don't want to close STDIN, STDOUT and STDERR on making a daemon process.
     */
    public function detach()
    {
        $this->detach = true;
    }

    /**
     * Call this method if you want to change the current directory on making a daemon process.
     */
    protected function changeDirectory()
    {
        $this->chdir = true;
    }

    public function getPidFilePath()
    {
        if ($this->getCommandOptions() && $this->getCommandOptions()->{'pid-file'}) {
            return $this->getCommandOptions()->{'pid-file'};
        }
        $pid = getmypid();
        $pidFile = $this->command ? $this->command->getName() : $pid;
        return $this->config->getPidDirectory() . "/$pidFile.pid";
    }

    public function options($opts)
    {
        $opts->add('pid-file?', '(daemon) Path of pid file.');
        $opts->add('log-path?', '(daemon) Path of log file when running with daemon extension.');
        $opts->add('detach', '(daemon) Detach from the shell.');
    }

    protected function prepareLogger()
    {
        $logPath = $this->getLogPath();
        $logger = $this->getLogger();

        if (!$logPath || !$logger) {
            return;
        }

        $resource = fopen($logPath, "a+");
        if ($resource === false) {
            throw new ExtensionException("Can't open file: $logPath", $this);
        }

        // TODO change logging style
        $logger->setWriter(new StreamWriter($resource));
    }

    protected function daemonize()
    {
        if ($this->detach || $this->command->options->{'detach'}) {
            $this->command->logger->debug('forking process to background..');
            // The return value of pcntl_fork: 
            //
            // On success, the PID of the child process is returned in the parent's
            // thread of execution, and a 0 is returned in the child's thread of
            // execution. On failure, a -1 will be returned in the parent's
            // context, no child process will be created, and a PHP error is
            // raised.
            switch (pcntl_fork()) {
            case -1:
                throw new ExtensionException("pcntl_fork() failed");

            // child process
            case 0:
                break;

            // exit parent process
            default:
                if (!fclose(STDIN)) {
                    throw new ExtensionException("fclose(STDIN) failed");
                }

                if (!fclose(STDOUT)) {
                    throw new ExtensionException("fclose(STDOUT) failed");
                }

                if (!fclose(STDERR)) {
                    throw new ExtensionException("fclose(STDERR) failed");
                }
                exit(0);
            }
        }

        // The execution here runs in child process
        if ($this->savePid() === false) {
            throw new ExtensionException("pid file create failed");
        }

        if ($this->chdir) {
            $this->chdir();
        }
    }

    private function chdir()
    {
        if ($this->chdir && !chdir("/")) {
            throw new ExtensionException("chdir failed");
        }
    }

    protected function savePid()
    {
        $pidFile = $this->getPidFilePath();
        $pid = getmypid();
        $this->command->logger->debug("pid {$pid} saved in $pidFile");
        return file_put_contents($pidFile, $pid);
    }

    protected function getLogPath()
    {
        // var_dump( $this->command ); 
        if ($logPath = $this->command->options->{'log-path'}) {
            return $logPath;
        }

        if ($options = $this->getApplicationOptions()) {
            if ($logPath = $options->{'log-path'}) {
                return $logPath;
            }
        }
        return null;
    }

    protected function getLogger()
    {
        if ($this->hasApplication()) {
            $this->logger = $this->command->getLogger();
        }
        if (!$this->logger) {
            $this->logger = new Logger();
        }
        return $this->logger;
    }

    protected function getApplicationOptions()
    {
        if (!$this->hasApplication()) {
            return null;
        }
        return $this->command->getApplication()->getOptions();
    }

    private function getCommandOptions()
    {
        return $this->command ? $this->command->getOptions() : null;
    }

    private function hasApplication()
    {
        return $this->command && $this->command->hasApplication();
    }
}
<?php
namespace CLIFramework\Extension;
use CLIFramework\Command;

interface Extension
{
}
<?php
namespace CLIFramework\Extension;
use CLIFramework\ServiceContainer;
use CLIFramework\Command;
use CLIFramework\CommandBase;
use CLIFramework\Logger;
use GetOptionKit\OptionCollection;
use LogicException;
use CLIFramework\ArgInfoList;

abstract class ExtensionBase
{
    protected $container;

    public function __construct()
    {

    }

    public function setServiceContainer(ServiceContainer $container)
    {
        $this->container = $container;
    }


    /**
     * init method is called when the extension is added to the pool.
     */
    public function init()
    {

    }

    static public function isSupported()
    {
        return true;
    }

    public function isAvailable()
    {
        return true;
    }

    public function options($opts)
    {
    }

    public function arguments($args) 
    {

    }

    public function prepare() 
    {

    }

    public function execute() 
    {

    }

    public function finish() 
    {

    }

    public function __get($accessor) 
    {
        if (isset($this->container[$accessor])) {
            return $this->container[$accessor];
        }
        throw new LogicException("Undefined accessor '$accessor'");
    }

}




<?php
/*
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace CLIFramework;

/**
 * Console output formatter class
 *
 *
 *   $formatter = new Formatter;
 *   $text = $formatter->format( 'text', 'styleName' );
 *   $text = $formatter->format( 'text', 'red' );
 *   $text = $formatter->format( 'text', 'green' );
 *
 */
class Formatter
{

    // Refactor style builder out.
    protected $styles = array(
        'dim'          => array('dim' => 1),
        'red'          => array('fg' => 'red'),
        'green'        => array('fg' => 'green'),
        'white'        => array('fg' => 'white'),
        'yellow'       => array('fg' => 'yellow'),
        'strong_red'   => array('fg' => 'red',     'bold'  => 1),
        'strong_green' => array('fg' => 'green',   'bold' => 1),
        'strong_white' => array('fg' => 'white',   'bold' => 1),
        'ask'          => array('fg' => 'white',   'bold' => 1 , 'underline' => 1 ),
        'choose'       => array('fg' => 'white',   'bold' => 1 , 'underline' => 1 ),

        'bold' => array('fg' => 'white', 'bold' => 1 ),
        'underline' => array( 'fg' => 'white' , 'underline' => 1 ),

        // generic styles for logger
        'info'   => array('fg'  => 'white', 'bold' => 1 ),
        'debug'  => array('fg'  => 'white' ),
        'notice' => array('fg'  => 'yellow' ),
        'warn'   => array('fg'  => 'red' ),
        'error'  => array('fg'  => 'red', 'bold'   => 1 ),

        'done'    => array('fg' => 'black', 'bg' => 'green' ),
        'success' => array('fg' => 'black', 'bg' => 'green' ),
        'fail'    => array('fg' => 'black', 'bg' => 'red' ),

        'action' => array('fg' => 'white', 'bg' => 'green' ),
    );

    protected $options = array(
        'bold' => 1,
        'dim' => 2,
        'underline' => 4,
        'blink' => 5,
        'reverse' => 7,
        'conceal' => 8
    );

    protected $foreground = array(
        'black' => 30,
        'red' => 31,
        'green' => 32,
        'yellow' => 33,
        'blue' => 34,
        'magenta' => 35,
        'cyan' => 36,
        'white' => 37
    );

    protected $background = array(
        'black' => 40,
        'red' => 41,
        'green' => 42,
        'yellow' => 43,
        'blue' => 44,
        'magenta' => 45,
        'cyan' => 46,
        'white' => 47
    );

    protected $supportsColors;

    public function __construct()
    {
        $this->supportsColors = DIRECTORY_SEPARATOR != '\\'
                && function_exists('posix_isatty') && @posix_isatty(STDOUT);
    }

    public function preferRawOutput()
    {
        $this->supportsColors = false;
    }

    public function addStyle( $name, $style )
    {
        $this->styles[ $name ] = $style;
    }

    public function hasStyle( $name )
    {
        return isset($this->styles[ $name ]);
    }

    public function getStartMark($style)
    {
        if (!$this->supportsColors) {
            return;
        }

        if ($style == 'none' || ! isset($this->styles[$style])) {
            return '';
        }

        $parameters = $this->styles[$style];
        $codes = array();

        if (isset($parameters['fg'])) {
            $codes[] = $this->foreground[$parameters['fg']];
        }

        if (isset($parameters['bg'])) {
            $codes[] = $this->background[$parameters['bg']];
        }

        foreach ($this->options as $option => $value) {
            if (isset($parameters[$option]) && $parameters[$option]) {
                $codes[] = $value;
            }
        }

        return "\033[".implode(';', $codes).'m';
    }

    public function getClearMark()
    {
        if (! $this->supportsColors) {
            return '';
        }
        return "\033[0m";
    }

    /**
     * Formats a text according to the given style or parameters.
     *
     * @param string $text  The text to style
     * @param string $style A style name
     *
     * @return string The styled text
     */
    public function format($text = '', $style = 'none')
    {
        return $this->getStartMark($style) . $text . $this->getClearMark();
    }
}
<?php

namespace CLIFramework\IO;

interface Console
{
    /**
     * Read a line from user input.
     *
     * @return string
     */
    public function readLine($prompt);

    /**
     * Read a line from user input without echoing if possible.
     *
     * @return string
     */
    public function readPassword($prompt);

    /**
     * Turn off echo and execute the callback function.
     *
     * @param \Closure $callback the callback function to execute.
     *
     * @return mixed return the result value returned by the callback.
     */
    public function noEcho(\Closure $callback);
}
<?php

namespace CLIFramework\IO;

class EchoWriter implements Writer
{
    public function write($text)
    {
        echo $text;
    }

    public function writeln($text)
    {
        echo $text."\n";
    }

    public function writef($format)
    {
        $args = func_get_args();
        $this->write(call_user_func_array('sprintf', $args));
    }
}
<?php

namespace CLIFramework\IO;

class NullStty implements Stty
{
    public function enableEcho()
    {
    }

    public function disableEcho()
    {
    }

    public function dump()
    {
        return '';
    }

    public function withoutEcho(\Closure $callback)
    {
        return $callback();
    }
}
<?php

namespace CLIFramework\IO;

/**
 * Console utilities using readline.
 */
class ReadlineConsole implements Console
{
    /**
     * @var Stty
     */
    private $stty;

    public function __construct(Stty $stty)
    {
        $this->stty = $stty;
    }

    public static function isAvailable()
    {
        return extension_loaded('readline');
    }

    public function readLine($prompt)
    {
        $line = $this->doReadLine($prompt);
        readline_add_history($line);

        return $line;
    }

    public function readPassword($prompt)
    {
        return $this->noEcho(function () use ($prompt) {
            return $this->doReadLine($prompt);
        });
    }

    public function noEcho(\Closure $callback)
    {
        return $this->stty->withoutEcho($callback);
    }

    private function doReadLine($prompt)
    {
        return readline($prompt);
    }
}
<?php

namespace CLIFramework\IO;

/**
 * Console utilities using STDIN.
 */
class StandardConsole implements Console
{
    /**
     * @var Stty
     */
    private $stty;

    public function __construct(Stty $stty)
    {
        $this->stty = $stty;
    }

    public function readLine($prompt)
    {
        echo $prompt;

        return $this->read();
    }

    public function readPassword($prompt)
    {
        echo $prompt;

        return $this->noEcho(function () use ($prompt) {
            return $this->read();
        });
    }

    public function noEcho(\Closure $callback)
    {
        return $this->stty->withoutEcho($callback);
    }

    private function read()
    {
        return rtrim(fgets(STDIN), "\n");
    }
}
<?php

namespace CLIFramework\IO;

/**
 * @code
 *  $writer = new StreamWriter(STDERR);
 */
class StreamWriter implements Writer
{
    private $stream;

    public function __construct($stream)
    {
        if (!is_resource($stream)) {
            throw new \RuntimeException('invalid stream');
        }

        $this->stream = $stream;
    }

    public function write($text)
    {
        fwrite($this->stream, $text);
    }

    public function writeln($text)
    {
        fwrite($this->stream, $text."\n");
    }

    public function writef($format)
    {
        $args = func_get_args();
        $this->write(call_user_func_array('sprintf', $args));
    }
}
<?php

namespace CLIFramework\IO;

/**
 * The interface of classes which handle stty.
 */
interface Stty
{
    /**
     * Turn on echo.
     */
    public function enableEcho();

    /**
     * Turn off echo.
     */
    public function disableEcho();

    /**
     * Dump all current settings in a-stty readable form.
     *
     * @return string
     */
    public function dump();

    /**
     * Turn off echoing and execute the callback function.
     *
     * @param Closure $callback
     *
     * @return mixed
     */
    public function withoutEcho(\Closure $callback);
}
<?php

namespace CLIFramework\IO;

class UnixStty implements Stty
{
    public function enableEcho()
    {
        shell_exec('stty echo');
    }

    public function disableEcho()
    {
        shell_exec('stty -echo');
    }

    public function dump()
    {
        return shell_exec('stty -g');
    }

    public function withoutEcho(\Closure $callback)
    {
        $oldStyle = $this->dump();
        // don't display characters from user input.
        $this->disableEcho();
        $result = null;

        try {
            $result = $callback();
            $this->restoreStyle($oldStyle);
        } catch (\Exception $e) {
            $this->restoreStyle($oldStyle);
            throw $e;
        }

        return $result;
    }

    private function restoreStyle($style)
    {
        if (is_null($style)) {
            return;
        }

        shell_exec('stty '.$style);
    }
}
<?php

namespace CLIFramework\IO;

interface Writer
{
    /**
     * @param string $text
     */
    public function write($text);

    /**
     * @param string $text
     */
    public function writeln($text);

    /**
     * @param string $format
     */
    public function writef($format);
}
<?php
namespace CLIFramework;

class LevenshteinCorrector extends Corrector
{
    public function match($input) {
        // no shortest distance found, yet
        $shortest = -1;

        // loop through words to find the closest
        foreach ($this->possibleTokens as $word) {

            // calculate the distance between the input word,
            // and the current word
            $lev = levenshtein($input, $word);

            // check for an exact match
            if ($lev == 0) {

                // closest word is this one (exact match)
                $closest = $word;
                $shortest = 0;

                // break out of the loop; we've found an exact match
                break;
            }

            // if this distance is less than the next found shortest
            // distance, OR if a next shortest word has not yet been found
            if ($lev <= $shortest || $shortest < 0) {
                // set the closest match, and shortest distance
                $closest  = $word;
                $shortest = $lev;
            }
        }
        return $closet;
    }
}



<?php

namespace CLIFramework\Logger;

use CLIFramework\Formatter;
use CLIFramework\Ansi\CursorControl;

class LogAction
{
    public $title;

    public $desc;

    public $status;

    protected $logger;

    protected $cursorControl;

    protected $actionColumnWidth = 38;

    public function __construct($logger, $title, $desc, $status = 'waiting')
    {
        $this->logger = $logger;
        $this->title = $title;
        $this->desc = $desc;
        $this->status = $status;

        $this->cursorControl = new CursorControl($this->logger->fd);
        $this->cursorControl->hide();
    }

    public function setStatus($status, $style = 'green')
    {
        $this->status = $status;
        $this->update($style);
    }

    public function setActionColumnWidth($width)
    {
        $this->actionColumnWidth = $width;
    }

    protected function update($style = 'green')
    {
        $padding = max($this->actionColumnWidth - strlen($this->title), 1);
        $buf = sprintf('  %s % -20s',
            $this->logger->formatter->format(sprintf('%s', $this->title), $style).str_repeat(' ', $padding),
            $this->status
        );
        fwrite($this->logger->fd, $buf."\r");
        fflush($this->logger->fd);
    }

    public function finalize()
    {
        fwrite($this->logger->fd, "\n");
        fflush($this->logger->fd);
        $this->cursorControl->show();
    }

    public function done()
    {
        $this->setStatus('done');
        $this->finalize();
    }
}

class ActionLogger
{
    public $fd;

    public $formatter;

    public function __construct($fd = null, $formatter = null)
    {
        $this->fd = $fd ?: fopen('php://stderr', 'w');
        $this->formatter = $formatter ?: new Formatter();
    }

    public function newAction($title, $desc = '', $status = 'waiting')
    {
        $logAction = new LogAction($this, $title, $desc);
        return $logAction;
    }
}
<?php

namespace CLIFramework\Logger;

interface Logger
{
}
<?php
/*
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace CLIFramework;
use CLIFramework\Formatter;
use CLIFramework\ServiceContainer;
use CLIFramework\IO\Writer;

class Logger
{
    /*
     * log level
     *
     * critical error = 1
     * error          = 2
     * warn           = 3
     * info           = 4
     * info2          = 5
     * debug          = 6
     * debug2         = 7
     * */
    public $logLevels = array(
        'critical' => 1,
        'error'    => 2,
        'warn'     => 3,
        'info' => 4,
        'info2' => 5,
        'debug' => 6,
        'debug2' => 7,
    );

    public $levelStyles = array(
        'critical' => 'strong_red',
        'error'    => 'strong_red',
        'warn'     => 'red',
        'info'     => 'green',
        'info2'    => 'green',
        'debug'    => 'white',
        'debug2'   => 'white',
    );

    /**
     * current level
     *
     * any message level lower than this will be displayed.
     * */
    public $level = 4;

    protected $indent = 0;

    protected $indentCharacter = '  ';

    /**
     * foramtter class
     *
     * @var CLIFramework\Formatter
     */
    public $formatter;

    /**
     * writer class
     *
     * @var CLIFramework\IO\Writer
     */
    private $writer;

    public function __construct(ServiceContainer $container = null)
    {
        $container = $container ?: ServiceContainer::getInstance();
        $this->formatter = $container['formatter']; // new Formatter;
        $this->writer = $container['writer'];
    }

    public function setLevel($level, $indent = 0)
    {
        $this->level = $level;
    }

    public function getLevel()
    {
        return $this->level;
    }

    public function quiet()
    {
        $this->level = 0;
    }

    public function setAbsoluteQuiet()
    {
        $this->level = 0;
    }

    public function setQuiet()
    {
        $this->level = 2;
    }

    public function setVerbose()
    {
        $this->level = $this->getLevelByName('info2');
    }

    public function isVerbose()
    {
        return $this->level == $this->getLevelByName('info2');
    }

    public function setDebug()
    {
        $this->level = $this->getLevelByName('debug2');
    }

    public function isDebug()
    {
        return $this->level == $this->getLevelByName('debug2') || $this->level == $this->getLevelByName('debug');
    }

    public function isQuiet() {
        return $this->level == 2;
    }


    /**
     * Set formatter object
     *
     * @param Formatter $formatter
     */
    public function setFormatter(Formatter $formatter)
    {
        $this->formatter = $formatter;
    }

    public function getFormatter()
    {
        return $this->formatter;
    }

    /**
     * Set writer object
     *
     * @param Writer $writer
     */
    public function setWriter(Writer $writer)
    {
        $this->writer = $writer;
    }

    public function indent($level = 1) {
        $this->indent += $level;
    }

    public function unIndent($level = 1) {
        $this->indent = max(0 ,$this->indent - $level);
    }

    public function resetIndent() {
        $this->indent = 0;
    }

    public function __call($method, $args)
    {
        $msg = $args[0];
        $indent = isset($args[1]) ? $args[1] : 0;
        $level = $this->getLevelByName($method);
        $style = $this->getStyleByName($method);
        if ($level > $this->level) {
            // do not print.
            return;
        }

        if ($this->level <= 4 && $level >= 4) {
            $style = 'dim';
        }

        if ($this->indent) {
            $this->writer->write(str_repeat($this->indentCharacter, $this->indent));
        }

        /* detect object */
        if (is_object($msg) || is_array($msg)) {
            $this->writer->writeln($this->formatter->format(print_r($msg , 1), $style));
        } else {
            $this->writer->writeln($this->formatter->format($msg , $style));
        }
    }

    /**
     * Write to console with given output format.
     *
     * $logger->writef('%s ... %s');
     *
     * @param string $format
     */
    public function writef($format) {
        $args = func_get_args();
        $this->writer->write(call_user_func_array('sprintf', $args));
    }

    /**
     * @param string $text text to write by `writer`
     */
    public function write($text) {
        $this->writer->write($text);
    }

    /**
     * @param string $text write text and append a newline charactor.
     */
    public function writeln($text)
    {
        $this->writer->writeln($text);
    }

    /**
     * Append a newline charactor to the console
     */
    public function newline()
    {
        $this->writer->writeln('');
    }

    /**
     * @param Exception $exception an exception to write to console.
     */
    public function logException(\Exception $exception)
    {
        echo $exception->getMessage();
        $this->newline();
    }

    /**
     * return the style of the given level name
     *
     * @param string $levelName
     */
    public function getStyleByName($levelName)
    {
        if (isset($this->levelStyles[$levelName])) {
            return $this->levelStyles[$levelName];
        }
    }

    /**
     * Return the log level name of the given level
     *
     * @param string $levelName
     */
    public function getLevelByName($levelName)
    {
        if (isset($this->logLevels[$levelName])) {
            return $this->logLevels[$levelName];
        }
    }

    public static function getInstance()
    {
        static $instance;
        return $instance ? $instance : $instance = new static;
    }
}
<?php
/**
 * This file is part of the GetOptionKit package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace CLIFramework;
use GetOptionKit\OptionCollection;
use GetOptionKit\Option;
use GetOptionKit\OptionPrinter\OptionPrinterInterface;
use CLIFramework\Formatter;

class OptionPrinter implements OptionPrinterInterface
{
    public $screenWidth = 78;

    public $formatter;

    public function __construct() {
        $this->formatter = new Formatter;
    }

    /**
     * Render readable spec
     */
    public function renderOption(Option $opt)
    {
        $columns = array();
        if ($opt->short) {
            $columns[] = $this->formatter->format(sprintf('-%s',$opt->short), 'strong_white') 
                . $this->renderOptionValueHint($opt, false);
        }
        if ($opt->long) {
            $columns[] = $this->formatter->format(sprintf('--%s',$opt->long ), 'strong_white')
                . $this->renderOptionValueHint($opt, true);
        }
        return join(', ', $columns);
    }

    public function renderOptionValueHint(Option $opt, $assign = true)
    {
        $n = 'value';
        if ($opt->valueName) {
            $n = $opt->valueName;
        } elseif ($opt->isa) {
            $n = $opt->isa;
        }

        if ( $opt->isRequired() ) {
            return sprintf('%s<%s>',   $assign ? '=' : ' ', $this->formatter->format($n, 'underline') );
        } elseif ( $opt->isOptional() ) {
            return sprintf('%s[<%s>]', $assign ? '=' : ' ', $this->formatter->format($n, 'underline'));
        }

        return '';
    }

    /**
     * render option descriptions
     *
     * @return string output
     */
    public function render(OptionCollection $options)
    {
        # echo "* Available options:\n";
        $lines = array();
        foreach( $options as $option ) {
            $c1 = $this->renderOption($option);
            $lines[] = "\t" . $c1;
            $lines[] = wordwrap("\t\t" . $option->desc, $this->screenWidth, "\n\t\t");  # wrap text
            $lines[] = "";
        }
        return join("\n",$lines);
    }
}


<?php
namespace CLIFramework\PharKit;
use Phar;
use CLIFramework\Logger;

use CodeGen\Block;
use CodeGen\Expr\NewObjectExpr;
use CodeGen\Statement\UseStatement;
use CodeGen\Statement\FunctionCallStatement;
use CodeGen\Statement\AssignStatement;
use CodeGen\Statement\MethodCallStatement;
use GetOptionKit\OptionResult;


class PharGenerator
{
    protected $pharFile;

    protected $alias;

    protected $map;

    protected $phar;

    protected $shellbang = '#!/usr/bin/env php';

    protected $logger;

    protected $options;

    public function __construct(Logger $logger, OptionResult $options, $pharFile, $alias = null)
    {
        $this->logger = $logger;
        $this->options = $options;
        $this->pharFile = $pharFile;

        if ($alias) {
            $this->alias = $alias;
        } else {
            $this->alias = basename($pharFile);
        }

        $this->phar = new Phar($this->pharFile, 0, $this->alias);
        $this->phar->setSignatureAlgorithm(Phar::SHA1);
    }

    public function shellbang($shellbang)
    {
        $this->shellbang = $shellbang;
    }

    public function getPhar()
    {
        return $this->phar;
    }

    public function generate()
    {
        // $this->phar->startBuffering();


        // Finish building...
        $this->phar->stopBuffering();

        $compressType = Phar::GZ;
        if ($this->options->{'no-compress'} ) {
            $compressType = null;
        } else if ($type = $this->options->compress) {
            switch ($type) {
            case 'gz':
                $compressType = Phar::GZ;
                break;
            case 'bz2':
                $compressType = Phar::BZ2;
                break;
            default:
                throw new Exception("Phar compression: $type is not supported, valid values are gz, bz2");
                break;
            }
        }
        if ($compressType) {
            $this->logger->info( "Compressing phar files...");
            $this->phar->compressFiles($compressType);
        }
    }





}

<?php
namespace CLIFramework\PharKit;
use CodeGen\Renderable;

class PharURI implements Renderable
{
    protected $alias;

    protected $localPath;

    public function __construct($alias, $localPath)
    {
        $this->alias = $alias;
        $this->localPath = $localPath;
    }

    public function getLocalPath()
    {
        return $this->localPath;
    }

    public function getAlias()
    {
        return $this->alias;
    }


    /**
     * 'render' is a method of Renderable interface
     */
    public function render(array $args = array())
    {
        return $this->__toString();
    }


    public function __toString()
    {
        // $stmt = new RequireStatement("phar://$pharFile/" . $localPath);
        return var_export('phar://' . $this->alias . '/' . $this->localPath, true);
    }

}




<?php
namespace CLIFramework;
use CLIFramework\ServiceContainer;

/**
 * Prompter class
 */
class Prompter
{
    private $style;
    private $formatter;
    private $console;

    public function __construct(ServiceContainer $container = null)
    {
        $container = $container ?: ServiceContainer::getInstance();
        $this->formatter = $container['formatter'];
        $this->console = $container['console'];
    }

    /**
     * set prompt style
     */
    public function setStyle($style)
    {
        return $this->style = $style;
    }

    /**
     * show prompt with message
     */
    public function ask($prompt, $validAnswers = NULL, $default = NULL)
    {
        if ($validAnswers) {
            $prompt .= ' [' . join('/',$validAnswers) . ']';
        }
        $prompt .= ' ';

        if ($this->style) {
            echo $this->formatter->getStartMark( $this->style );
            // $prompt = $this->formatter->getStartMark( $this->style ) . $prompt . $this->formatter->getClearMark();
        }

        $answer = null;
        while (1) {
            $answer = trim($this->console->readLine( $prompt ));
            if ($validAnswers) {
                if (in_array($answer,$validAnswers) ) {
                    break;
                } else {
                    if (trim($answer) === "" && $default ) {
                        $answer = $default;
                        break;
                    }
                    continue;
                }
            }
            break;
        }
        if ($this->style) {
            echo $this->formatter->getClearMark();
        }
        return $answer;
    }

    /**
     * Show password prompt with a message.
     */
    public function password($prompt)
    {
        if ($this->style) {
            echo $this->formatter->getStartMark( $this->style );
        }

        $result = $this->console->readPassword($prompt);

        if ($this->style) {
            echo $this->formatter->getClearMark();
        }

        return $result;
    }
}
<?php
namespace CLIFramework;
use Pimple\Container;
use CLIFramework\Logger;
use CLIFramework\CommandLoader;
use CLIFramework\Config\GlobalConfig;
use CLIFramework\IO\StreamWriter;
use CLIFramework\IO\NullStty;
use CLIFramework\IO\UnixStty;
use CLIFramework\IO\ReadlineConsole;
use CLIFramework\IO\StandardConsole;
use Universal\Event\PhpEvent;


/**
 *
 * Provided services:
 *
 *    logger:  CLIFramework\Logger
 *    formatter: CLIFramework\Formatter
 *    command_loader: CLIFramework\CommandLoader
 *    writer: CLIFramework\IO\Writer
 *
 * Usage:
 *
 *    $container = ServiceContainer::getInstance();
 *    $logger = $container['logger'];
 *
 */
class ServiceContainer extends Container
{
    public function __construct()
    {
        $that = $this;
        $this['config.path'] = function($c) {

            $filename = 'cliframework.ini';
            $configAtCurrentDirectory = getcwd() . DIRECTORY_SEPARATOR . $filename;
            $configAtHomeDirectory = getenv('HOME') . DIRECTORY_SEPARATOR . $filename;

            if (file_exists($configAtCurrentDirectory)) {
                return $configAtCurrentDirectory;
            }

            if (file_exists($configAtHomeDirectory)) {
                return $configAtHomeDirectory;
            }
            return null;
        };

        $this['event'] = function() {
            return new PhpEvent;
        };

        $this['config'] = function($c) {
            if (empty($c['config.path']) || !$c['config.path']) {
                return new GlobalConfig(array());
            }
            return new GlobalConfig(parse_ini_file($c['config.path'], true));
        };
        $this['writer'] = function($c) {
            // return new StreamWriter(STDOUT);
            $output = fopen("php://output", "w");
            return new StreamWriter($output);
        };
        $this['logger'] = function($c) use ($that) {
            return new Logger($that);
        };
        $this['formatter'] = function($c) {
            return new Formatter;
        };
        $this['console.stty'] = function($c) use ($that){
            if ($that->isWindows()) {
                // TODO support Windows
                return new NullStty();
            }
            return new UnixStty();
        };
        $this['console'] = function($c) {
            if (ReadlineConsole::isAvailable()) {
                return new ReadlineConsole($c['console.stty']);
            }
            return new StandardConsole($c['console.stty']);
        };
        $this['command_loader'] = function($c) {
            return CommandLoader::getInstance();
        };
        parent::__construct();
    }

    public function isWindows()
    {
        return preg_match('/^Win/', PHP_OS);
    }

    static public function getInstance()
    {
        static $instance;

        if (!$instance) {
            $instance = new static;
        }

        return $instance;
    }
}


<?php
namespace CLIFramework\Testing;
use PHPUnit\Framework\TestCase;

abstract class CommandTestCase extends \PHPUnit\Framework\TestCase
{
    public $app;

    public $outputBufferingActive = false;

    abstract public function setupApplication();

    public function getApplication()
    {
        return $this->app;
    }

    public function setUp()
    {
        if ($this->outputBufferingActive) {
            ob_start();
        }
        $this->app = $this->setupApplication();
    }

    public function tearDown()
    {
        $this->app = NULL;
        if ($this->outputBufferingActive) {
            ob_end_clean();
        }
    }

    public function runCommand($args) {
        if (is_string($args)) {
            $args = preg_split('/\s+/',$args);
        }
        return $this->app->run($args);
    }
}
<?php
namespace CLIFramework\Testing;

class ConsoleTestCase extends \\PHPUnit\Framework\TestCase
{
    protected function runScript($path, $input, $callback)
    {
        $descriptors = array(
            0 => array('pipe', 'r'),
            1 => array('pipe', 'w'),
            2 => array('pipe', 'w')
        );
        $pipes = array();
        $process = proc_open("php $path", $descriptors, $pipes, null, $_ENV);

        $this->assertTrue(is_resource($process));

        fwrite($pipes[0], $input);
        fflush($pipes[0]);
        $content = trim(stream_get_contents($pipes[1]));
        @fclose($pipes[0]);
        @fclose($pipes[1]);
        @fclose($pipes[2]);
        @pclose($process);
        $callback($content);
    }
}
<?php
namespace CLIFramework\Topic;

abstract class BaseTopic
{

    public $title = 'Untitled Topic';

    public $url;

    public $id;

    public function getUrl() { return $this->url; }
    public function getId() { return $this->id; }

    public function getTitle() { return $this->title; }
    public function getContent() { return ''; }
    public function getFooter() { 
        if ($url = $this->getUrl() ) {
            return "\tYou may view this topic at " . $url . "\n";
        }
        return '';
    }
}



<?php
namespace CLIFramework\Topic;

class GitHubTopic extends BaseTopic
{
}



<?php
/*
 * This file is part of the CLIFramework package.
 *
 * (c) Yo-An Lin <cornelius.howl@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 */
namespace CLIFramework;
use ReflectionClass;

class Utils
{

    /**
     * translate command name to class name
     *
     * so something like:   to-list will be ToListCommand
     *
     * */
    public static function translateCommandClassName($command)
    {
        $args = explode('-',$command);
        foreach($args as & $a)
            $a = ucfirst($a);
        $subclass = join('',$args) . 'Command';

        return $subclass;
    }

    public static function getClassPath($class, $baseDir = null) 
    {
        $refclass = new ReflectionClass($class);
        $path = $refclass->getFilename();
        if ($path && $baseDir) {
            return str_replace(
                rtrim(realpath($baseDir),DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR,
                '', 
                $path);
        }
        return $path;
    }


}
<?php
namespace CLIFramework;
use IteratorAggregate;
use ArrayIterator;

/**
 * 
 */
class ValueCollection implements IteratorAggregate
{

    public $groups = array();

    /**
     * @var label[group id] group labels
     */
    public $labels = array();



    /**
     * Add Grouped Values:
     *
     *     ->group('id', 'ID', [ 'a', 'b', 'c' ]);
     *     ->group('id', 'ID', [ 'label' => 'desc' ]);
     *
     */
    public function group($groupId, $label, $values) {
        // for indexed array
        if (is_array($values)) {
            if ( !isset($this->groups[ $groupId ])) {
                $this->groups[$groupId] = $values;
            } else {
                $this->groups[ $groupId ] = array_merge(
                    $this->groups[ $groupId ], $values );
            }
        } else {
            $this->groups[ $groupId ][] = $values;
        }
        $this->setGroupLabel($groupId, $label);
    }



    public function getGroups() {
        return $this->groups;
    }


    public function setGroup($groupId, $values) {
        $this->groups[ $groupId ] = $values;
    }

    public function getGroup($groupId) {
        return $this->groups[ $groupId ];
    }

    public function setGroupLabel($groupId, $label) {
        $this->labels[ $groupId ] = $label;
    }

    public function getGroupLabel($groupId) {
        if ( isset($this->labels[ $groupId ]) ) {
            return $this->labels[ $groupId ];
        }
    }

    public function containsValue($value) {
        foreach($this->groups as $groupId => $values) {
            if (in_array($value, $values)) {
                return true;
            }
        }
        return false;
    }

    public function getGroupLabels() {
        return $this->labels;
    }

    public function toJson() {
        return json_encode($this->groups);
    }

    public function getIterator() {
        return new ArrayIterator( $this->groups );
    }
}


<?php
namespace CLIFramework;
use ArrayObject;

class ValueGroup extends ArrayObject
{

    public function values() {
        return array_values($this->getArrayCopy());
    }

    public function keys() {
        return array_keys($this->getArrayCopy());
    }

    public function append($val) { 
        parent::append($val);
        return $this;
    }


    public function add($val) {
        parent::append($val);
        return $this;
    }
}


CHANGELOG
=========

2.8.0
-----

 * Deprecated usage of a colon in an unquoted mapping value
 * Deprecated usage of @, \`, | and > at the beginning of an unquoted string
 * When surrounding strings with double-quotes, you must now escape `\` characters. Not
   escaping those characters (when surrounded by double-quotes) is deprecated.

   Before:

   ```yml
   class: "Foo\Var"
   ```

   After:

   ```yml
   class: "Foo\\Var"
   ```

2.1.0
-----

 * Yaml::parse() does not evaluate loaded files as PHP files by default
   anymore (call Yaml::enablePhpParsing() to get back the old behavior)
{
    "name": "symfony/yaml",
    "type": "library",
    "description": "Symfony Yaml Component",
    "keywords": [],
    "homepage": "https://symfony.com",
    "license": "MIT",
    "authors": [
        {
            "name": "Fabien Potencier",
            "email": "fabien@symfony.com"
        },
        {
            "name": "Symfony Community",
            "homepage": "https://symfony.com/contributors"
        }
    ],
    "require": {
        "php": ">=5.3.9"
    },
    "autoload": {
        "psr-4": { "Symfony\\Component\\Yaml\\": "" },
        "exclude-from-classmap": [
            "/Tests/"
        ]
    },
    "minimum-stability": "dev",
    "extra": {
        "branch-alias": {
            "dev-master": "2.8-dev"
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml;

/**
 * Dumper dumps PHP variables to YAML strings.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Dumper
{
    /**
     * The amount of spaces to use for indentation of nested nodes.
     *
     * @var int
     */
    protected $indentation = 4;

    /**
     * Sets the indentation.
     *
     * @param int $num The amount of spaces to use for indentation of nested nodes.
     */
    public function setIndentation($num)
    {
        $this->indentation = (int) $num;
    }

    /**
     * Dumps a PHP value to YAML.
     *
     * @param mixed $input                  The PHP value
     * @param int   $inline                 The level where you switch to inline YAML
     * @param int   $indent                 The level of indentation (used internally)
     * @param bool  $exceptionOnInvalidType true if an exception must be thrown on invalid types (a PHP resource or object), false otherwise
     * @param bool  $objectSupport          true if object support is enabled, false otherwise
     *
     * @return string The YAML representation of the PHP value
     */
    public function dump($input, $inline = 0, $indent = 0, $exceptionOnInvalidType = false, $objectSupport = false)
    {
        $output = '';
        $prefix = $indent ? str_repeat(' ', $indent) : '';

        if ($inline <= 0 || !is_array($input) || empty($input)) {
            $output .= $prefix.Inline::dump($input, $exceptionOnInvalidType, $objectSupport);
        } else {
            $isAHash = array_keys($input) !== range(0, count($input) - 1);

            foreach ($input as $key => $value) {
                $willBeInlined = $inline - 1 <= 0 || !is_array($value) || empty($value);

                $output .= sprintf('%s%s%s%s',
                    $prefix,
                    $isAHash ? Inline::dump($key, $exceptionOnInvalidType, $objectSupport).':' : '-',
                    $willBeInlined ? ' ' : "\n",
                    $this->dump($value, $inline - 1, $willBeInlined ? 0 : $indent + $this->indentation, $exceptionOnInvalidType, $objectSupport)
                ).($willBeInlined ? "\n" : '');
            }
        }

        return $output;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml;

/**
 * Escaper encapsulates escaping rules for single and double-quoted
 * YAML strings.
 *
 * @author Matthew Lewinski <matthew@lewinski.org>
 *
 * @internal
 */
class Escaper
{
    // Characters that would cause a dumped string to require double quoting.
    const REGEX_CHARACTER_TO_ESCAPE = "[\\x00-\\x1f]|\xc2\x85|\xc2\xa0|\xe2\x80\xa8|\xe2\x80\xa9";

    // Mapping arrays for escaping a double quoted string. The backslash is
    // first to ensure proper escaping because str_replace operates iteratively
    // on the input arrays. This ordering of the characters avoids the use of strtr,
    // which performs more slowly.
    private static $escapees = array('\\', '\\\\', '\\"', '"',
                                     "\x00",  "\x01",  "\x02",  "\x03",  "\x04",  "\x05",  "\x06",  "\x07",
                                     "\x08",  "\x09",  "\x0a",  "\x0b",  "\x0c",  "\x0d",  "\x0e",  "\x0f",
                                     "\x10",  "\x11",  "\x12",  "\x13",  "\x14",  "\x15",  "\x16",  "\x17",
                                     "\x18",  "\x19",  "\x1a",  "\x1b",  "\x1c",  "\x1d",  "\x1e",  "\x1f",
                                     "\xc2\x85", "\xc2\xa0", "\xe2\x80\xa8", "\xe2\x80\xa9");
    private static $escaped = array('\\\\', '\\"', '\\\\', '\\"',
                                     '\\0',   '\\x01', '\\x02', '\\x03', '\\x04', '\\x05', '\\x06', '\\a',
                                     '\\b',   '\\t',   '\\n',   '\\v',   '\\f',   '\\r',   '\\x0e', '\\x0f',
                                     '\\x10', '\\x11', '\\x12', '\\x13', '\\x14', '\\x15', '\\x16', '\\x17',
                                     '\\x18', '\\x19', '\\x1a', '\\e',   '\\x1c', '\\x1d', '\\x1e', '\\x1f',
                                     '\\N', '\\_', '\\L', '\\P');

    /**
     * Determines if a PHP value would require double quoting in YAML.
     *
     * @param string $value A PHP value
     *
     * @return bool True if the value would require double quotes.
     */
    public static function requiresDoubleQuoting($value)
    {
        return preg_match('/'.self::REGEX_CHARACTER_TO_ESCAPE.'/u', $value);
    }

    /**
     * Escapes and surrounds a PHP value with double quotes.
     *
     * @param string $value A PHP value
     *
     * @return string The quoted, escaped string
     */
    public static function escapeWithDoubleQuotes($value)
    {
        return sprintf('"%s"', str_replace(self::$escapees, self::$escaped, $value));
    }

    /**
     * Determines if a PHP value would require single quoting in YAML.
     *
     * @param string $value A PHP value
     *
     * @return bool True if the value would require single quotes.
     */
    public static function requiresSingleQuoting($value)
    {
        // Determines if a PHP value is entirely composed of a value that would
        // require single quoting in YAML.
        if (in_array(strtolower($value), array('null', '~', 'true', 'false', 'y', 'n', 'yes', 'no', 'on', 'off'))) {
            return true;
        }

        // Determines if the PHP value contains any single characters that would
        // cause it to require single quoting in YAML.
        return preg_match('/[ \s \' " \: \{ \} \[ \] , & \* \# \?] | \A[ \- ? | < > = ! % @ ` ]/x', $value);
    }

    /**
     * Escapes and surrounds a PHP value with single quotes.
     *
     * @param string $value A PHP value
     *
     * @return string The quoted, escaped string
     */
    public static function escapeWithSingleQuotes($value)
    {
        return sprintf("'%s'", str_replace('\'', '\'\'', $value));
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml\Exception;

/**
 * Exception class thrown when an error occurs during dumping.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class DumpException extends RuntimeException
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml\Exception;

/**
 * Exception interface for all exceptions thrown by the component.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
interface ExceptionInterface
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml\Exception;

/**
 * Exception class thrown when an error occurs during parsing.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class ParseException extends RuntimeException
{
    private $parsedFile;
    private $parsedLine;
    private $snippet;
    private $rawMessage;

    /**
     * Constructor.
     *
     * @param string     $message    The error message
     * @param int        $parsedLine The line where the error occurred
     * @param int        $snippet    The snippet of code near the problem
     * @param string     $parsedFile The file name where the error occurred
     * @param \Exception $previous   The previous exception
     */
    public function __construct($message, $parsedLine = -1, $snippet = null, $parsedFile = null, \Exception $previous = null)
    {
        $this->parsedFile = $parsedFile;
        $this->parsedLine = $parsedLine;
        $this->snippet = $snippet;
        $this->rawMessage = $message;

        $this->updateRepr();

        parent::__construct($this->message, 0, $previous);
    }

    /**
     * Gets the snippet of code near the error.
     *
     * @return string The snippet of code
     */
    public function getSnippet()
    {
        return $this->snippet;
    }

    /**
     * Sets the snippet of code near the error.
     *
     * @param string $snippet The code snippet
     */
    public function setSnippet($snippet)
    {
        $this->snippet = $snippet;

        $this->updateRepr();
    }

    /**
     * Gets the filename where the error occurred.
     *
     * This method returns null if a string is parsed.
     *
     * @return string The filename
     */
    public function getParsedFile()
    {
        return $this->parsedFile;
    }

    /**
     * Sets the filename where the error occurred.
     *
     * @param string $parsedFile The filename
     */
    public function setParsedFile($parsedFile)
    {
        $this->parsedFile = $parsedFile;

        $this->updateRepr();
    }

    /**
     * Gets the line where the error occurred.
     *
     * @return int The file line
     */
    public function getParsedLine()
    {
        return $this->parsedLine;
    }

    /**
     * Sets the line where the error occurred.
     *
     * @param int $parsedLine The file line
     */
    public function setParsedLine($parsedLine)
    {
        $this->parsedLine = $parsedLine;

        $this->updateRepr();
    }

    private function updateRepr()
    {
        $this->message = $this->rawMessage;

        $dot = false;
        if ('.' === substr($this->message, -1)) {
            $this->message = substr($this->message, 0, -1);
            $dot = true;
        }

        if (null !== $this->parsedFile) {
            if (PHP_VERSION_ID >= 50400) {
                $jsonOptions = JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE;
            } else {
                $jsonOptions = 0;
            }
            $this->message .= sprintf(' in %s', json_encode($this->parsedFile, $jsonOptions));
        }

        if ($this->parsedLine >= 0) {
            $this->message .= sprintf(' at line %d', $this->parsedLine);
        }

        if ($this->snippet) {
            $this->message .= sprintf(' (near "%s")', $this->snippet);
        }

        if ($dot) {
            $this->message .= '.';
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml\Exception;

/**
 * Exception class thrown when an error occurs during parsing.
 *
 * @author Romain Neutron <imprec@gmail.com>
 */
class RuntimeException extends \RuntimeException implements ExceptionInterface
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml;

use Symfony\Component\Yaml\Exception\ParseException;
use Symfony\Component\Yaml\Exception\DumpException;

/**
 * Inline implements a YAML parser/dumper for the YAML inline syntax.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Inline
{
    const REGEX_QUOTED_STRING = '(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'([^\']*(?:\'\'[^\']*)*)\')';

    private static $exceptionOnInvalidType = false;
    private static $objectSupport = false;
    private static $objectForMap = false;

    /**
     * Converts a YAML string to a PHP array.
     *
     * @param string $value                  A YAML string
     * @param bool   $exceptionOnInvalidType true if an exception must be thrown on invalid types (a PHP resource or object), false otherwise
     * @param bool   $objectSupport          true if object support is enabled, false otherwise
     * @param bool   $objectForMap           true if maps should return a stdClass instead of array()
     * @param array  $references             Mapping of variable names to values
     *
     * @return array A PHP array representing the YAML string
     *
     * @throws ParseException
     */
    public static function parse($value, $exceptionOnInvalidType = false, $objectSupport = false, $objectForMap = false, $references = array())
    {
        self::$exceptionOnInvalidType = $exceptionOnInvalidType;
        self::$objectSupport = $objectSupport;
        self::$objectForMap = $objectForMap;

        $value = trim($value);

        if ('' === $value) {
            return '';
        }

        if (2 /* MB_OVERLOAD_STRING */ & (int) ini_get('mbstring.func_overload')) {
            $mbEncoding = mb_internal_encoding();
            mb_internal_encoding('ASCII');
        }

        $i = 0;
        switch ($value[0]) {
            case '[':
                $result = self::parseSequence($value, $i, $references);
                ++$i;
                break;
            case '{':
                $result = self::parseMapping($value, $i, $references);
                ++$i;
                break;
            default:
                $result = self::parseScalar($value, null, array('"', "'"), $i, true, $references);
        }

        // some comments are allowed at the end
        if (preg_replace('/\s+#.*$/A', '', substr($value, $i))) {
            throw new ParseException(sprintf('Unexpected characters near "%s".', substr($value, $i)));
        }

        if (isset($mbEncoding)) {
            mb_internal_encoding($mbEncoding);
        }

        return $result;
    }

    /**
     * Dumps a given PHP variable to a YAML string.
     *
     * @param mixed $value                  The PHP variable to convert
     * @param bool  $exceptionOnInvalidType true if an exception must be thrown on invalid types (a PHP resource or object), false otherwise
     * @param bool  $objectSupport          true if object support is enabled, false otherwise
     *
     * @return string The YAML string representing the PHP array
     *
     * @throws DumpException When trying to dump PHP resource
     */
    public static function dump($value, $exceptionOnInvalidType = false, $objectSupport = false)
    {
        switch (true) {
            case is_resource($value):
                if ($exceptionOnInvalidType) {
                    throw new DumpException(sprintf('Unable to dump PHP resources in a YAML file ("%s").', get_resource_type($value)));
                }

                return 'null';
            case is_object($value):
                if ($objectSupport) {
                    return '!php/object:'.serialize($value);
                }

                if ($exceptionOnInvalidType) {
                    throw new DumpException('Object support when dumping a YAML file has been disabled.');
                }

                return 'null';
            case is_array($value):
                return self::dumpArray($value, $exceptionOnInvalidType, $objectSupport);
            case null === $value:
                return 'null';
            case true === $value:
                return 'true';
            case false === $value:
                return 'false';
            case ctype_digit($value):
                return is_string($value) ? "'$value'" : (int) $value;
            case is_numeric($value):
                $locale = setlocale(LC_NUMERIC, 0);
                if (false !== $locale) {
                    setlocale(LC_NUMERIC, 'C');
                }
                if (is_float($value)) {
                    $repr = (string) $value;
                    if (is_infinite($value)) {
                        $repr = str_ireplace('INF', '.Inf', $repr);
                    } elseif (floor($value) == $value && $repr == $value) {
                        // Preserve float data type since storing a whole number will result in integer value.
                        $repr = '!!float '.$repr;
                    }
                } else {
                    $repr = is_string($value) ? "'$value'" : (string) $value;
                }
                if (false !== $locale) {
                    setlocale(LC_NUMERIC, $locale);
                }

                return $repr;
            case '' == $value:
                return "''";
            case Escaper::requiresDoubleQuoting($value):
                return Escaper::escapeWithDoubleQuotes($value);
            case Escaper::requiresSingleQuoting($value):
            case preg_match(self::getHexRegex(), $value):
            case preg_match(self::getTimestampRegex(), $value):
                return Escaper::escapeWithSingleQuotes($value);
            default:
                return $value;
        }
    }

    /**
     * Dumps a PHP array to a YAML string.
     *
     * @param array $value                  The PHP array to dump
     * @param bool  $exceptionOnInvalidType true if an exception must be thrown on invalid types (a PHP resource or object), false otherwise
     * @param bool  $objectSupport          true if object support is enabled, false otherwise
     *
     * @return string The YAML string representing the PHP array
     */
    private static function dumpArray($value, $exceptionOnInvalidType, $objectSupport)
    {
        // array
        $keys = array_keys($value);
        $keysCount = count($keys);
        if ((1 === $keysCount && '0' == $keys[0])
            || ($keysCount > 1 && array_reduce($keys, function ($v, $w) { return (int) $v + $w; }, 0) === $keysCount * ($keysCount - 1) / 2)
        ) {
            $output = array();
            foreach ($value as $val) {
                $output[] = self::dump($val, $exceptionOnInvalidType, $objectSupport);
            }

            return sprintf('[%s]', implode(', ', $output));
        }

        // mapping
        $output = array();
        foreach ($value as $key => $val) {
            $output[] = sprintf('%s: %s', self::dump($key, $exceptionOnInvalidType, $objectSupport), self::dump($val, $exceptionOnInvalidType, $objectSupport));
        }

        return sprintf('{ %s }', implode(', ', $output));
    }

    /**
     * Parses a scalar to a YAML string.
     *
     * @param string $scalar
     * @param string $delimiters
     * @param array  $stringDelimiters
     * @param int    &$i
     * @param bool   $evaluate
     * @param array  $references
     *
     * @return string A YAML string
     *
     * @throws ParseException When malformed inline YAML string is parsed
     *
     * @internal
     */
    public static function parseScalar($scalar, $delimiters = null, $stringDelimiters = array('"', "'"), &$i = 0, $evaluate = true, $references = array())
    {
        if (in_array($scalar[$i], $stringDelimiters)) {
            // quoted scalar
            $output = self::parseQuotedScalar($scalar, $i);

            if (null !== $delimiters) {
                $tmp = ltrim(substr($scalar, $i), ' ');
                if (!in_array($tmp[0], $delimiters)) {
                    throw new ParseException(sprintf('Unexpected characters (%s).', substr($scalar, $i)));
                }
            }
        } else {
            // "normal" string
            if (!$delimiters) {
                $output = substr($scalar, $i);
                $i += strlen($output);

                // remove comments
                if (preg_match('/[ \t]+#/', $output, $match, PREG_OFFSET_CAPTURE)) {
                    $output = substr($output, 0, $match[0][1]);
                }
            } elseif (preg_match('/^(.+?)('.implode('|', $delimiters).')/', substr($scalar, $i), $match)) {
                $output = $match[1];
                $i += strlen($output);
            } else {
                throw new ParseException(sprintf('Malformed inline YAML string (%s).', $scalar));
            }

            // a non-quoted string cannot start with @ or ` (reserved) nor with a scalar indicator (| or >)
            if ($output && ('@' === $output[0] || '`' === $output[0] || '|' === $output[0] || '>' === $output[0])) {
                @trigger_error(sprintf('Not quoting the scalar "%s" starting with "%s" is deprecated since Symfony 2.8 and will throw a ParseException in 3.0.', $output, $output[0]), E_USER_DEPRECATED);

                // to be thrown in 3.0
                // throw new ParseException(sprintf('The reserved indicator "%s" cannot start a plain scalar; you need to quote the scalar.', $output[0]));
            }

            if ($evaluate) {
                $output = self::evaluateScalar($output, $references);
            }
        }

        return $output;
    }

    /**
     * Parses a quoted scalar to YAML.
     *
     * @param string $scalar
     * @param int    &$i
     *
     * @return string A YAML string
     *
     * @throws ParseException When malformed inline YAML string is parsed
     */
    private static function parseQuotedScalar($scalar, &$i)
    {
        if (!preg_match('/'.self::REGEX_QUOTED_STRING.'/Au', substr($scalar, $i), $match)) {
            throw new ParseException(sprintf('Malformed inline YAML string (%s).', substr($scalar, $i)));
        }

        $output = substr($match[0], 1, strlen($match[0]) - 2);

        $unescaper = new Unescaper();
        if ('"' == $scalar[$i]) {
            $output = $unescaper->unescapeDoubleQuotedString($output);
        } else {
            $output = $unescaper->unescapeSingleQuotedString($output);
        }

        $i += strlen($match[0]);

        return $output;
    }

    /**
     * Parses a sequence to a YAML string.
     *
     * @param string $sequence
     * @param int    &$i
     * @param array  $references
     *
     * @return string A YAML string
     *
     * @throws ParseException When malformed inline YAML string is parsed
     */
    private static function parseSequence($sequence, &$i = 0, $references = array())
    {
        $output = array();
        $len = strlen($sequence);
        ++$i;

        // [foo, bar, ...]
        while ($i < $len) {
            switch ($sequence[$i]) {
                case '[':
                    // nested sequence
                    $output[] = self::parseSequence($sequence, $i, $references);
                    break;
                case '{':
                    // nested mapping
                    $output[] = self::parseMapping($sequence, $i, $references);
                    break;
                case ']':
                    return $output;
                case ',':
                case ' ':
                    break;
                default:
                    $isQuoted = in_array($sequence[$i], array('"', "'"));
                    $value = self::parseScalar($sequence, array(',', ']'), array('"', "'"), $i, true, $references);

                    // the value can be an array if a reference has been resolved to an array var
                    if (!is_array($value) && !$isQuoted && false !== strpos($value, ': ')) {
                        // embedded mapping?
                        try {
                            $pos = 0;
                            $value = self::parseMapping('{'.$value.'}', $pos, $references);
                        } catch (\InvalidArgumentException $e) {
                            // no, it's not
                        }
                    }

                    $output[] = $value;

                    --$i;
            }

            ++$i;
        }

        throw new ParseException(sprintf('Malformed inline YAML string %s', $sequence));
    }

    /**
     * Parses a mapping to a YAML string.
     *
     * @param string $mapping
     * @param int    &$i
     * @param array  $references
     *
     * @return string A YAML string
     *
     * @throws ParseException When malformed inline YAML string is parsed
     */
    private static function parseMapping($mapping, &$i = 0, $references = array())
    {
        $output = array();
        $len = strlen($mapping);
        ++$i;

        // {foo: bar, bar:foo, ...}
        while ($i < $len) {
            switch ($mapping[$i]) {
                case ' ':
                case ',':
                    ++$i;
                    continue 2;
                case '}':
                    if (self::$objectForMap) {
                        return (object) $output;
                    }

                    return $output;
            }

            // key
            $key = self::parseScalar($mapping, array(':', ' '), array('"', "'"), $i, false);

            // value
            $done = false;

            while ($i < $len) {
                switch ($mapping[$i]) {
                    case '[':
                        // nested sequence
                        $value = self::parseSequence($mapping, $i, $references);
                        // Spec: Keys MUST be unique; first one wins.
                        // Parser cannot abort this mapping earlier, since lines
                        // are processed sequentially.
                        if (!isset($output[$key])) {
                            $output[$key] = $value;
                        }
                        $done = true;
                        break;
                    case '{':
                        // nested mapping
                        $value = self::parseMapping($mapping, $i, $references);
                        // Spec: Keys MUST be unique; first one wins.
                        // Parser cannot abort this mapping earlier, since lines
                        // are processed sequentially.
                        if (!isset($output[$key])) {
                            $output[$key] = $value;
                        }
                        $done = true;
                        break;
                    case ':':
                    case ' ':
                        break;
                    default:
                        $value = self::parseScalar($mapping, array(',', '}'), array('"', "'"), $i, true, $references);
                        // Spec: Keys MUST be unique; first one wins.
                        // Parser cannot abort this mapping earlier, since lines
                        // are processed sequentially.
                        if (!isset($output[$key])) {
                            $output[$key] = $value;
                        }
                        $done = true;
                        --$i;
                }

                ++$i;

                if ($done) {
                    continue 2;
                }
            }
        }

        throw new ParseException(sprintf('Malformed inline YAML string %s', $mapping));
    }

    /**
     * Evaluates scalars and replaces magic values.
     *
     * @param string $scalar
     * @param array  $references
     *
     * @return string A YAML string
     *
     * @throws ParseException when object parsing support was disabled and the parser detected a PHP object or when a reference could not be resolved
     */
    private static function evaluateScalar($scalar, $references = array())
    {
        $scalar = trim($scalar);
        $scalarLower = strtolower($scalar);

        if (0 === strpos($scalar, '*')) {
            if (false !== $pos = strpos($scalar, '#')) {
                $value = substr($scalar, 1, $pos - 2);
            } else {
                $value = substr($scalar, 1);
            }

            // an unquoted *
            if (false === $value || '' === $value) {
                throw new ParseException('A reference must contain at least one character.');
            }

            if (!array_key_exists($value, $references)) {
                throw new ParseException(sprintf('Reference "%s" does not exist.', $value));
            }

            return $references[$value];
        }

        switch (true) {
            case 'null' === $scalarLower:
            case '' === $scalar:
            case '~' === $scalar:
                return;
            case 'true' === $scalarLower:
                return true;
            case 'false' === $scalarLower:
                return false;
            // Optimise for returning strings.
            case $scalar[0] === '+' || $scalar[0] === '-' || $scalar[0] === '.' || $scalar[0] === '!' || is_numeric($scalar[0]):
                switch (true) {
                    case 0 === strpos($scalar, '!str'):
                        return (string) substr($scalar, 5);
                    case 0 === strpos($scalar, '! '):
                        return (int) self::parseScalar(substr($scalar, 2));
                    case 0 === strpos($scalar, '!php/object:'):
                        if (self::$objectSupport) {
                            return unserialize(substr($scalar, 12));
                        }

                        if (self::$exceptionOnInvalidType) {
                            throw new ParseException('Object support when parsing a YAML file has been disabled.');
                        }

                        return;
                    case 0 === strpos($scalar, '!!php/object:'):
                        if (self::$objectSupport) {
                            return unserialize(substr($scalar, 13));
                        }

                        if (self::$exceptionOnInvalidType) {
                            throw new ParseException('Object support when parsing a YAML file has been disabled.');
                        }

                        return;
                    case 0 === strpos($scalar, '!!float '):
                        return (float) substr($scalar, 8);
                    case ctype_digit($scalar):
                        $raw = $scalar;
                        $cast = (int) $scalar;

                        return '0' == $scalar[0] ? octdec($scalar) : (((string) $raw == (string) $cast) ? $cast : $raw);
                    case '-' === $scalar[0] && ctype_digit(substr($scalar, 1)):
                        $raw = $scalar;
                        $cast = (int) $scalar;

                        return '0' == $scalar[1] ? octdec($scalar) : (((string) $raw === (string) $cast) ? $cast : $raw);
                    case is_numeric($scalar):
                    case preg_match(self::getHexRegex(), $scalar):
                        return '0x' === $scalar[0].$scalar[1] ? hexdec($scalar) : (float) $scalar;
                    case '.inf' === $scalarLower:
                    case '.nan' === $scalarLower:
                        return -log(0);
                    case '-.inf' === $scalarLower:
                        return log(0);
                    case preg_match('/^(-|\+)?[0-9,]+(\.[0-9]+)?$/', $scalar):
                        return (float) str_replace(',', '', $scalar);
                    case preg_match(self::getTimestampRegex(), $scalar):
                        $timeZone = date_default_timezone_get();
                        date_default_timezone_set('UTC');
                        $time = strtotime($scalar);
                        date_default_timezone_set($timeZone);

                        return $time;
                }
            default:
                return (string) $scalar;
        }
    }

    /**
     * Gets a regex that matches a YAML date.
     *
     * @return string The regular expression
     *
     * @see http://www.yaml.org/spec/1.2/spec.html#id2761573
     */
    private static function getTimestampRegex()
    {
        return <<<EOF
        ~^
        (?P<year>[0-9][0-9][0-9][0-9])
        -(?P<month>[0-9][0-9]?)
        -(?P<day>[0-9][0-9]?)
        (?:(?:[Tt]|[ \t]+)
        (?P<hour>[0-9][0-9]?)
        :(?P<minute>[0-9][0-9])
        :(?P<second>[0-9][0-9])
        (?:\.(?P<fraction>[0-9]*))?
        (?:[ \t]*(?P<tz>Z|(?P<tz_sign>[-+])(?P<tz_hour>[0-9][0-9]?)
        (?::(?P<tz_minute>[0-9][0-9]))?))?)?
        $~x
EOF;
    }

    /**
     * Gets a regex that matches a YAML number in hexadecimal notation.
     *
     * @return string
     */
    private static function getHexRegex()
    {
        return '~^0x[0-9a-f]++$~i';
    }
}
Copyright (c) 2004-2016 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml;

use Symfony\Component\Yaml\Exception\ParseException;

/**
 * Parser parses YAML strings to convert them to PHP arrays.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Parser
{
    const BLOCK_SCALAR_HEADER_PATTERN = '(?P<separator>\||>)(?P<modifiers>\+|\-|\d+|\+\d+|\-\d+|\d+\+|\d+\-)?(?P<comments> +#.*)?';
    // BC - wrongly named
    const FOLDED_SCALAR_PATTERN = self::BLOCK_SCALAR_HEADER_PATTERN;

    private $offset = 0;
    private $lines = array();
    private $currentLineNb = -1;
    private $currentLine = '';
    private $refs = array();

    /**
     * Constructor.
     *
     * @param int $offset The offset of YAML document (used for line numbers in error messages)
     */
    public function __construct($offset = 0)
    {
        $this->offset = $offset;
    }

    /**
     * Parses a YAML string to a PHP value.
     *
     * @param string $value                  A YAML string
     * @param bool   $exceptionOnInvalidType true if an exception must be thrown on invalid types (a PHP resource or object), false otherwise
     * @param bool   $objectSupport          true if object support is enabled, false otherwise
     * @param bool   $objectForMap           true if maps should return a stdClass instead of array()
     *
     * @return mixed A PHP value
     *
     * @throws ParseException If the YAML is not valid
     */
    public function parse($value, $exceptionOnInvalidType = false, $objectSupport = false, $objectForMap = false)
    {
        if (!preg_match('//u', $value)) {
            throw new ParseException('The YAML value does not appear to be valid UTF-8.');
        }
        $this->currentLineNb = -1;
        $this->currentLine = '';
        $value = $this->cleanup($value);
        $this->lines = explode("\n", $value);

        if (2 /* MB_OVERLOAD_STRING */ & (int) ini_get('mbstring.func_overload')) {
            $mbEncoding = mb_internal_encoding();
            mb_internal_encoding('UTF-8');
        }

        $data = array();
        $context = null;
        $allowOverwrite = false;
        while ($this->moveToNextLine()) {
            if ($this->isCurrentLineEmpty()) {
                continue;
            }

            // tab?
            if ("\t" === $this->currentLine[0]) {
                throw new ParseException('A YAML file cannot contain tabs as indentation.', $this->getRealCurrentLineNb() + 1, $this->currentLine);
            }

            $isRef = $mergeNode = false;
            if (preg_match('#^\-((?P<leadspaces>\s+)(?P<value>.+?))?\s*$#u', $this->currentLine, $values)) {
                if ($context && 'mapping' == $context) {
                    throw new ParseException('You cannot define a sequence item when in a mapping');
                }
                $context = 'sequence';

                if (isset($values['value']) && preg_match('#^&(?P<ref>[^ ]+) *(?P<value>.*)#u', $values['value'], $matches)) {
                    $isRef = $matches['ref'];
                    $values['value'] = $matches['value'];
                }

                // array
                if (!isset($values['value']) || '' == trim($values['value'], ' ') || 0 === strpos(ltrim($values['value'], ' '), '#')) {
                    $c = $this->getRealCurrentLineNb() + 1;
                    $parser = new self($c);
                    $parser->refs = &$this->refs;
                    $data[] = $parser->parse($this->getNextEmbedBlock(null, true), $exceptionOnInvalidType, $objectSupport, $objectForMap);
                } else {
                    if (isset($values['leadspaces'])
                        && preg_match('#^(?P<key>'.Inline::REGEX_QUOTED_STRING.'|[^ \'"\{\[].*?) *\:(\s+(?P<value>.+?))?\s*$#u', $values['value'], $matches)
                    ) {
                        // this is a compact notation element, add to next block and parse
                        $c = $this->getRealCurrentLineNb();
                        $parser = new self($c);
                        $parser->refs = &$this->refs;

                        $block = $values['value'];
                        if ($this->isNextLineIndented()) {
                            $block .= "\n".$this->getNextEmbedBlock($this->getCurrentLineIndentation() + strlen($values['leadspaces']) + 1);
                        }

                        $data[] = $parser->parse($block, $exceptionOnInvalidType, $objectSupport, $objectForMap);
                    } else {
                        $data[] = $this->parseValue($values['value'], $exceptionOnInvalidType, $objectSupport, $objectForMap, $context);
                    }
                }
                if ($isRef) {
                    $this->refs[$isRef] = end($data);
                }
            } elseif (preg_match('#^(?P<key>'.Inline::REGEX_QUOTED_STRING.'|[^ \'"\[\{].*?) *\:(\s+(?P<value>.+?))?\s*$#u', $this->currentLine, $values) && (false === strpos($values['key'], ' #') || in_array($values['key'][0], array('"', "'")))) {
                if ($context && 'sequence' == $context) {
                    throw new ParseException('You cannot define a mapping item when in a sequence');
                }
                $context = 'mapping';

                // force correct settings
                Inline::parse(null, $exceptionOnInvalidType, $objectSupport, $objectForMap, $this->refs);
                try {
                    $key = Inline::parseScalar($values['key']);
                } catch (ParseException $e) {
                    $e->setParsedLine($this->getRealCurrentLineNb() + 1);
                    $e->setSnippet($this->currentLine);

                    throw $e;
                }

                // Convert float keys to strings, to avoid being converted to integers by PHP
                if (is_float($key)) {
                    $key = (string) $key;
                }

                if ('<<' === $key) {
                    $mergeNode = true;
                    $allowOverwrite = true;
                    if (isset($values['value']) && 0 === strpos($values['value'], '*')) {
                        $refName = substr($values['value'], 1);
                        if (!array_key_exists($refName, $this->refs)) {
                            throw new ParseException(sprintf('Reference "%s" does not exist.', $refName), $this->getRealCurrentLineNb() + 1, $this->currentLine);
                        }

                        $refValue = $this->refs[$refName];

                        if (!is_array($refValue)) {
                            throw new ParseException('YAML merge keys used with a scalar value instead of an array.', $this->getRealCurrentLineNb() + 1, $this->currentLine);
                        }

                        foreach ($refValue as $key => $value) {
                            if (!isset($data[$key])) {
                                $data[$key] = $value;
                            }
                        }
                    } else {
                        if (isset($values['value']) && $values['value'] !== '') {
                            $value = $values['value'];
                        } else {
                            $value = $this->getNextEmbedBlock();
                        }
                        $c = $this->getRealCurrentLineNb() + 1;
                        $parser = new self($c);
                        $parser->refs = &$this->refs;
                        $parsed = $parser->parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap);

                        if (!is_array($parsed)) {
                            throw new ParseException('YAML merge keys used with a scalar value instead of an array.', $this->getRealCurrentLineNb() + 1, $this->currentLine);
                        }

                        if (isset($parsed[0])) {
                            // If the value associated with the merge key is a sequence, then this sequence is expected to contain mapping nodes
                            // and each of these nodes is merged in turn according to its order in the sequence. Keys in mapping nodes earlier
                            // in the sequence override keys specified in later mapping nodes.
                            foreach ($parsed as $parsedItem) {
                                if (!is_array($parsedItem)) {
                                    throw new ParseException('Merge items must be arrays.', $this->getRealCurrentLineNb() + 1, $parsedItem);
                                }

                                foreach ($parsedItem as $key => $value) {
                                    if (!isset($data[$key])) {
                                        $data[$key] = $value;
                                    }
                                }
                            }
                        } else {
                            // If the value associated with the key is a single mapping node, each of its key/value pairs is inserted into the
                            // current mapping, unless the key already exists in it.
                            foreach ($parsed as $key => $value) {
                                if (!isset($data[$key])) {
                                    $data[$key] = $value;
                                }
                            }
                        }
                    }
                } elseif (isset($values['value']) && preg_match('#^&(?P<ref>[^ ]+) *(?P<value>.*)#u', $values['value'], $matches)) {
                    $isRef = $matches['ref'];
                    $values['value'] = $matches['value'];
                }

                if ($mergeNode) {
                    // Merge keys
                } elseif (!isset($values['value']) || '' == trim($values['value'], ' ') || 0 === strpos(ltrim($values['value'], ' '), '#')) {
                    // hash
                    // if next line is less indented or equal, then it means that the current value is null
                    if (!$this->isNextLineIndented() && !$this->isNextLineUnIndentedCollection()) {
                        // Spec: Keys MUST be unique; first one wins.
                        // But overwriting is allowed when a merge node is used in current block.
                        if ($allowOverwrite || !isset($data[$key])) {
                            $data[$key] = null;
                        }
                    } else {
                        $c = $this->getRealCurrentLineNb() + 1;
                        $parser = new self($c);
                        $parser->refs = &$this->refs;
                        $value = $parser->parse($this->getNextEmbedBlock(), $exceptionOnInvalidType, $objectSupport, $objectForMap);
                        // Spec: Keys MUST be unique; first one wins.
                        // But overwriting is allowed when a merge node is used in current block.
                        if ($allowOverwrite || !isset($data[$key])) {
                            $data[$key] = $value;
                        }
                    }
                } else {
                    $value = $this->parseValue($values['value'], $exceptionOnInvalidType, $objectSupport, $objectForMap, $context);
                    // Spec: Keys MUST be unique; first one wins.
                    // But overwriting is allowed when a merge node is used in current block.
                    if ($allowOverwrite || !isset($data[$key])) {
                        $data[$key] = $value;
                    }
                }
                if ($isRef) {
                    $this->refs[$isRef] = $data[$key];
                }
            } else {
                // multiple documents are not supported
                if ('---' === $this->currentLine) {
                    throw new ParseException('Multiple documents are not supported.');
                }

                // 1-liner optionally followed by newline(s)
                if (is_string($value) && $this->lines[0] === trim($value)) {
                    try {
                        $value = Inline::parse($this->lines[0], $exceptionOnInvalidType, $objectSupport, $objectForMap, $this->refs);
                    } catch (ParseException $e) {
                        $e->setParsedLine($this->getRealCurrentLineNb() + 1);
                        $e->setSnippet($this->currentLine);

                        throw $e;
                    }

                    if (is_array($value)) {
                        $first = reset($value);
                        if (is_string($first) && 0 === strpos($first, '*')) {
                            $data = array();
                            foreach ($value as $alias) {
                                $data[] = $this->refs[substr($alias, 1)];
                            }
                            $value = $data;
                        }
                    }

                    if (isset($mbEncoding)) {
                        mb_internal_encoding($mbEncoding);
                    }

                    return $value;
                }

                switch (preg_last_error()) {
                    case PREG_INTERNAL_ERROR:
                        $error = 'Internal PCRE error.';
                        break;
                    case PREG_BACKTRACK_LIMIT_ERROR:
                        $error = 'pcre.backtrack_limit reached.';
                        break;
                    case PREG_RECURSION_LIMIT_ERROR:
                        $error = 'pcre.recursion_limit reached.';
                        break;
                    case PREG_BAD_UTF8_ERROR:
                        $error = 'Malformed UTF-8 data.';
                        break;
                    case PREG_BAD_UTF8_OFFSET_ERROR:
                        $error = 'Offset doesn\'t correspond to the begin of a valid UTF-8 code point.';
                        break;
                    default:
                        $error = 'Unable to parse.';
                }

                throw new ParseException($error, $this->getRealCurrentLineNb() + 1, $this->currentLine);
            }
        }

        if (isset($mbEncoding)) {
            mb_internal_encoding($mbEncoding);
        }

        if ($objectForMap && !is_object($data) && 'mapping' === $context) {
            $object = new \stdClass();

            foreach ($data as $key => $value) {
                $object->$key = $value;
            }

            $data = $object;
        }

        return empty($data) ? null : $data;
    }

    /**
     * Returns the current line number (takes the offset into account).
     *
     * @return int The current line number
     */
    private function getRealCurrentLineNb()
    {
        return $this->currentLineNb + $this->offset;
    }

    /**
     * Returns the current line indentation.
     *
     * @return int The current line indentation
     */
    private function getCurrentLineIndentation()
    {
        return strlen($this->currentLine) - strlen(ltrim($this->currentLine, ' '));
    }

    /**
     * Returns the next embed block of YAML.
     *
     * @param int  $indentation The indent level at which the block is to be read, or null for default
     * @param bool $inSequence  True if the enclosing data structure is a sequence
     *
     * @return string A YAML string
     *
     * @throws ParseException When indentation problem are detected
     */
    private function getNextEmbedBlock($indentation = null, $inSequence = false)
    {
        $oldLineIndentation = $this->getCurrentLineIndentation();
        $blockScalarIndentations = array();

        if ($this->isBlockScalarHeader()) {
            $blockScalarIndentations[] = $this->getCurrentLineIndentation();
        }

        if (!$this->moveToNextLine()) {
            return;
        }

        if (null === $indentation) {
            $newIndent = $this->getCurrentLineIndentation();

            $unindentedEmbedBlock = $this->isStringUnIndentedCollectionItem();

            if (!$this->isCurrentLineEmpty() && 0 === $newIndent && !$unindentedEmbedBlock) {
                throw new ParseException('Indentation problem.', $this->getRealCurrentLineNb() + 1, $this->currentLine);
            }
        } else {
            $newIndent = $indentation;
        }

        $data = array();
        if ($this->getCurrentLineIndentation() >= $newIndent) {
            $data[] = substr($this->currentLine, $newIndent);
        } else {
            $this->moveToPreviousLine();

            return;
        }

        if ($inSequence && $oldLineIndentation === $newIndent && isset($data[0][0]) && '-' === $data[0][0]) {
            // the previous line contained a dash but no item content, this line is a sequence item with the same indentation
            // and therefore no nested list or mapping
            $this->moveToPreviousLine();

            return;
        }

        $isItUnindentedCollection = $this->isStringUnIndentedCollectionItem();

        if (empty($blockScalarIndentations) && $this->isBlockScalarHeader()) {
            $blockScalarIndentations[] = $this->getCurrentLineIndentation();
        }

        $previousLineIndentation = $this->getCurrentLineIndentation();

        while ($this->moveToNextLine()) {
            $indent = $this->getCurrentLineIndentation();

            // terminate all block scalars that are more indented than the current line
            if (!empty($blockScalarIndentations) && $indent < $previousLineIndentation && trim($this->currentLine) !== '') {
                foreach ($blockScalarIndentations as $key => $blockScalarIndentation) {
                    if ($blockScalarIndentation >= $this->getCurrentLineIndentation()) {
                        unset($blockScalarIndentations[$key]);
                    }
                }
            }

            if (empty($blockScalarIndentations) && !$this->isCurrentLineComment() && $this->isBlockScalarHeader()) {
                $blockScalarIndentations[] = $this->getCurrentLineIndentation();
            }

            $previousLineIndentation = $indent;

            if ($isItUnindentedCollection && !$this->isStringUnIndentedCollectionItem() && $newIndent === $indent) {
                $this->moveToPreviousLine();
                break;
            }

            if ($this->isCurrentLineBlank()) {
                $data[] = substr($this->currentLine, $newIndent);
                continue;
            }

            // we ignore "comment" lines only when we are not inside a scalar block
            if (empty($blockScalarIndentations) && $this->isCurrentLineComment()) {
                continue;
            }

            if ($indent >= $newIndent) {
                $data[] = substr($this->currentLine, $newIndent);
            } elseif (0 == $indent) {
                $this->moveToPreviousLine();

                break;
            } else {
                throw new ParseException('Indentation problem.', $this->getRealCurrentLineNb() + 1, $this->currentLine);
            }
        }

        return implode("\n", $data);
    }

    /**
     * Moves the parser to the next line.
     *
     * @return bool
     */
    private function moveToNextLine()
    {
        if ($this->currentLineNb >= count($this->lines) - 1) {
            return false;
        }

        $this->currentLine = $this->lines[++$this->currentLineNb];

        return true;
    }

    /**
     * Moves the parser to the previous line.
     */
    private function moveToPreviousLine()
    {
        $this->currentLine = $this->lines[--$this->currentLineNb];
    }

    /**
     * Parses a YAML value.
     *
     * @param string $value                  A YAML value
     * @param bool   $exceptionOnInvalidType True if an exception must be thrown on invalid types false otherwise
     * @param bool   $objectSupport          True if object support is enabled, false otherwise
     * @param bool   $objectForMap           true if maps should return a stdClass instead of array()
     * @param string $context                The parser context (either sequence or mapping)
     *
     * @return mixed A PHP value
     *
     * @throws ParseException When reference does not exist
     */
    private function parseValue($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $context)
    {
        if (0 === strpos($value, '*')) {
            if (false !== $pos = strpos($value, '#')) {
                $value = substr($value, 1, $pos - 2);
            } else {
                $value = substr($value, 1);
            }

            if (!array_key_exists($value, $this->refs)) {
                throw new ParseException(sprintf('Reference "%s" does not exist.', $value), $this->currentLine);
            }

            return $this->refs[$value];
        }

        if (preg_match('/^'.self::BLOCK_SCALAR_HEADER_PATTERN.'$/', $value, $matches)) {
            $modifiers = isset($matches['modifiers']) ? $matches['modifiers'] : '';

            return $this->parseBlockScalar($matches['separator'], preg_replace('#\d+#', '', $modifiers), (int) abs($modifiers));
        }

        try {
            $parsedValue = Inline::parse($value, $exceptionOnInvalidType, $objectSupport, $objectForMap, $this->refs);

            if ('mapping' === $context && '"' !== $value[0] && "'" !== $value[0] && '[' !== $value[0] && '{' !== $value[0] && '!' !== $value[0] && false !== strpos($parsedValue, ': ')) {
                @trigger_error(sprintf('Using a colon in the unquoted mapping value "%s" in line %d is deprecated since Symfony 2.8 and will throw a ParseException in 3.0.', $value, $this->getRealCurrentLineNb() + 1), E_USER_DEPRECATED);

                // to be thrown in 3.0
                // throw new ParseException('A colon cannot be used in an unquoted mapping value.');
            }

            return $parsedValue;
        } catch (ParseException $e) {
            $e->setParsedLine($this->getRealCurrentLineNb() + 1);
            $e->setSnippet($this->currentLine);

            throw $e;
        }
    }

    /**
     * Parses a block scalar.
     *
     * @param string $style       The style indicator that was used to begin this block scalar (| or >)
     * @param string $chomping    The chomping indicator that was used to begin this block scalar (+ or -)
     * @param int    $indentation The indentation indicator that was used to begin this block scalar
     *
     * @return string The text value
     */
    private function parseBlockScalar($style, $chomping = '', $indentation = 0)
    {
        $notEOF = $this->moveToNextLine();
        if (!$notEOF) {
            return '';
        }

        $isCurrentLineBlank = $this->isCurrentLineBlank();
        $blockLines = array();

        // leading blank lines are consumed before determining indentation
        while ($notEOF && $isCurrentLineBlank) {
            // newline only if not EOF
            if ($notEOF = $this->moveToNextLine()) {
                $blockLines[] = '';
                $isCurrentLineBlank = $this->isCurrentLineBlank();
            }
        }

        // determine indentation if not specified
        if (0 === $indentation) {
            if (preg_match('/^ +/', $this->currentLine, $matches)) {
                $indentation = strlen($matches[0]);
            }
        }

        if ($indentation > 0) {
            $pattern = sprintf('/^ {%d}(.*)$/', $indentation);

            while (
                $notEOF && (
                    $isCurrentLineBlank ||
                    preg_match($pattern, $this->currentLine, $matches)
                )
            ) {
                if ($isCurrentLineBlank && strlen($this->currentLine) > $indentation) {
                    $blockLines[] = substr($this->currentLine, $indentation);
                } elseif ($isCurrentLineBlank) {
                    $blockLines[] = '';
                } else {
                    $blockLines[] = $matches[1];
                }

                // newline only if not EOF
                if ($notEOF = $this->moveToNextLine()) {
                    $isCurrentLineBlank = $this->isCurrentLineBlank();
                }
            }
        } elseif ($notEOF) {
            $blockLines[] = '';
        }

        if ($notEOF) {
            $blockLines[] = '';
            $this->moveToPreviousLine();
        }

        // folded style
        if ('>' === $style) {
            $text = '';
            $previousLineIndented = false;
            $previousLineBlank = false;

            for ($i = 0; $i < count($blockLines); ++$i) {
                if ('' === $blockLines[$i]) {
                    $text .= "\n";
                    $previousLineIndented = false;
                    $previousLineBlank = true;
                } elseif (' ' === $blockLines[$i][0]) {
                    $text .= "\n".$blockLines[$i];
                    $previousLineIndented = true;
                    $previousLineBlank = false;
                } elseif ($previousLineIndented) {
                    $text .= "\n".$blockLines[$i];
                    $previousLineIndented = false;
                    $previousLineBlank = false;
                } elseif ($previousLineBlank || 0 === $i) {
                    $text .= $blockLines[$i];
                    $previousLineIndented = false;
                    $previousLineBlank = false;
                } else {
                    $text .= ' '.$blockLines[$i];
                    $previousLineIndented = false;
                    $previousLineBlank = false;
                }
            }
        } else {
            $text = implode("\n", $blockLines);
        }

        // deal with trailing newlines
        if ('' === $chomping) {
            $text = preg_replace('/\n+$/', "\n", $text);
        } elseif ('-' === $chomping) {
            $text = preg_replace('/\n+$/', '', $text);
        }

        return $text;
    }

    /**
     * Returns true if the next line is indented.
     *
     * @return bool Returns true if the next line is indented, false otherwise
     */
    private function isNextLineIndented()
    {
        $currentIndentation = $this->getCurrentLineIndentation();
        $EOF = !$this->moveToNextLine();

        while (!$EOF && $this->isCurrentLineEmpty()) {
            $EOF = !$this->moveToNextLine();
        }

        if ($EOF) {
            return false;
        }

        $ret = false;
        if ($this->getCurrentLineIndentation() > $currentIndentation) {
            $ret = true;
        }

        $this->moveToPreviousLine();

        return $ret;
    }

    /**
     * Returns true if the current line is blank or if it is a comment line.
     *
     * @return bool Returns true if the current line is empty or if it is a comment line, false otherwise
     */
    private function isCurrentLineEmpty()
    {
        return $this->isCurrentLineBlank() || $this->isCurrentLineComment();
    }

    /**
     * Returns true if the current line is blank.
     *
     * @return bool Returns true if the current line is blank, false otherwise
     */
    private function isCurrentLineBlank()
    {
        return '' == trim($this->currentLine, ' ');
    }

    /**
     * Returns true if the current line is a comment line.
     *
     * @return bool Returns true if the current line is a comment line, false otherwise
     */
    private function isCurrentLineComment()
    {
        //checking explicitly the first char of the trim is faster than loops or strpos
        $ltrimmedLine = ltrim($this->currentLine, ' ');

        return '' !== $ltrimmedLine && $ltrimmedLine[0] === '#';
    }

    /**
     * Cleanups a YAML string to be parsed.
     *
     * @param string $value The input YAML string
     *
     * @return string A cleaned up YAML string
     */
    private function cleanup($value)
    {
        $value = str_replace(array("\r\n", "\r"), "\n", $value);

        // strip YAML header
        $count = 0;
        $value = preg_replace('#^\%YAML[: ][\d\.]+.*\n#u', '', $value, -1, $count);
        $this->offset += $count;

        // remove leading comments
        $trimmedValue = preg_replace('#^(\#.*?\n)+#s', '', $value, -1, $count);
        if ($count == 1) {
            // items have been removed, update the offset
            $this->offset += substr_count($value, "\n") - substr_count($trimmedValue, "\n");
            $value = $trimmedValue;
        }

        // remove start of the document marker (---)
        $trimmedValue = preg_replace('#^\-\-\-.*?\n#s', '', $value, -1, $count);
        if ($count == 1) {
            // items have been removed, update the offset
            $this->offset += substr_count($value, "\n") - substr_count($trimmedValue, "\n");
            $value = $trimmedValue;

            // remove end of the document marker (...)
            $value = preg_replace('#\.\.\.\s*$#', '', $value);
        }

        return $value;
    }

    /**
     * Returns true if the next line starts unindented collection.
     *
     * @return bool Returns true if the next line starts unindented collection, false otherwise
     */
    private function isNextLineUnIndentedCollection()
    {
        $currentIndentation = $this->getCurrentLineIndentation();
        $notEOF = $this->moveToNextLine();

        while ($notEOF && $this->isCurrentLineEmpty()) {
            $notEOF = $this->moveToNextLine();
        }

        if (false === $notEOF) {
            return false;
        }

        $ret = false;
        if (
            $this->getCurrentLineIndentation() == $currentIndentation
            &&
            $this->isStringUnIndentedCollectionItem()
        ) {
            $ret = true;
        }

        $this->moveToPreviousLine();

        return $ret;
    }

    /**
     * Returns true if the string is un-indented collection item.
     *
     * @return bool Returns true if the string is un-indented collection item, false otherwise
     */
    private function isStringUnIndentedCollectionItem()
    {
        return 0 === strpos($this->currentLine, '- ');
    }

    /**
     * Tests whether or not the current line is the header of a block scalar.
     *
     * @return bool
     */
    private function isBlockScalarHeader()
    {
        return (bool) preg_match('~'.self::BLOCK_SCALAR_HEADER_PATTERN.'$~', $this->currentLine);
    }
}
<?xml version="1.0" encoding="UTF-8"?>

<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="vendor/autoload.php"
>
    <php>
        <ini name="error_reporting" value="-1" />
    </php>

    <testsuites>
        <testsuite name="Symfony Yaml Component Test Suite">
            <directory>./Tests/</directory>
        </testsuite>
    </testsuites>

    <filter>
        <whitelist>
            <directory>./</directory>
            <exclude>
                <directory>./Tests</directory>
                <directory>./vendor</directory>
            </exclude>
        </whitelist>
    </filter>
</phpunit>
Yaml Component
==============

YAML implements most of the YAML 1.2 specification.

```php
use Symfony\Component\Yaml\Yaml;

$array = Yaml::parse(file_get_contents(filename));

print Yaml::dump($array);
```

Resources
---------

You can run the unit tests with the following command:

    $ cd path/to/Symfony/Component/Yaml/
    $ composer install
    $ phpunit
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml;

/**
 * Unescaper encapsulates unescaping rules for single and double-quoted
 * YAML strings.
 *
 * @author Matthew Lewinski <matthew@lewinski.org>
 *
 * @internal
 */
class Unescaper
{
    /**
     * Parser and Inline assume UTF-8 encoding, so escaped Unicode characters
     * must be converted to that encoding.
     *
     * @deprecated since version 2.5, to be removed in 3.0
     *
     * @internal
     */
    const ENCODING = 'UTF-8';

    /**
     * Regex fragment that matches an escaped character in a double quoted string.
     */
    const REGEX_ESCAPED_CHARACTER = '\\\\(x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8}|.)';

    /**
     * Unescapes a single quoted string.
     *
     * @param string $value A single quoted string.
     *
     * @return string The unescaped string.
     */
    public function unescapeSingleQuotedString($value)
    {
        return str_replace('\'\'', '\'', $value);
    }

    /**
     * Unescapes a double quoted string.
     *
     * @param string $value A double quoted string.
     *
     * @return string The unescaped string.
     */
    public function unescapeDoubleQuotedString($value)
    {
        $self = $this;
        $callback = function ($match) use ($self) {
            return $self->unescapeCharacter($match[0]);
        };

        // evaluate the string
        return preg_replace_callback('/'.self::REGEX_ESCAPED_CHARACTER.'/u', $callback, $value);
    }

    /**
     * Unescapes a character that was found in a double-quoted string.
     *
     * @param string $value An escaped character
     *
     * @return string The unescaped character
     *
     * @internal This method is public to be usable as callback. It should not
     *           be used in user code. Should be changed in 3.0.
     */
    public function unescapeCharacter($value)
    {
        switch ($value[1]) {
            case '0':
                return "\x0";
            case 'a':
                return "\x7";
            case 'b':
                return "\x8";
            case 't':
                return "\t";
            case "\t":
                return "\t";
            case 'n':
                return "\n";
            case 'v':
                return "\xB";
            case 'f':
                return "\xC";
            case 'r':
                return "\r";
            case 'e':
                return "\x1B";
            case ' ':
                return ' ';
            case '"':
                return '"';
            case '/':
                return '/';
            case '\\':
                return '\\';
            case 'N':
                // U+0085 NEXT LINE
                return "\xC2\x85";
            case '_':
                // U+00A0 NO-BREAK SPACE
                return "\xC2\xA0";
            case 'L':
                // U+2028 LINE SEPARATOR
                return "\xE2\x80\xA8";
            case 'P':
                // U+2029 PARAGRAPH SEPARATOR
                return "\xE2\x80\xA9";
            case 'x':
                return self::utf8chr(hexdec(substr($value, 2, 2)));
            case 'u':
                return self::utf8chr(hexdec(substr($value, 2, 4)));
            case 'U':
                return self::utf8chr(hexdec(substr($value, 2, 8)));
            default:
                @trigger_error('Not escaping a backslash in a double-quoted string is deprecated since Symfony 2.8 and will throw a ParseException in 3.0.', E_USER_DEPRECATED);

                return $value;
        }
    }

    /**
     * Get the UTF-8 character for the given code point.
     *
     * @param int $c The unicode code point
     *
     * @return string The corresponding UTF-8 character
     */
    private static function utf8chr($c)
    {
        if (0x80 > $c %= 0x200000) {
            return chr($c);
        }
        if (0x800 > $c) {
            return chr(0xC0 | $c >> 6).chr(0x80 | $c & 0x3F);
        }
        if (0x10000 > $c) {
            return chr(0xE0 | $c >> 12).chr(0x80 | $c >> 6 & 0x3F).chr(0x80 | $c & 0x3F);
        }

        return chr(0xF0 | $c >> 18).chr(0x80 | $c >> 12 & 0x3F).chr(0x80 | $c >> 6 & 0x3F).chr(0x80 | $c & 0x3F);
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Yaml;

use Symfony\Component\Yaml\Exception\ParseException;

/**
 * Yaml offers convenience methods to load and dump YAML.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class Yaml
{
    /**
     * Parses YAML into a PHP value.
     *
     *  Usage:
     *  <code>
     *   $array = Yaml::parse(file_get_contents('config.yml'));
     *   print_r($array);
     *  </code>
     *
     * As this method accepts both plain strings and file names as an input,
     * you must validate the input before calling this method. Passing a file
     * as an input is a deprecated feature and will be removed in 3.0.
     *
     * Note: the ability to pass file names to the Yaml::parse method is deprecated since version 2.2 and will be removed in 3.0. Pass the YAML contents of the file instead.
     *
     * @param string $input                  Path to a YAML file or a string containing YAML
     * @param bool   $exceptionOnInvalidType True if an exception must be thrown on invalid types false otherwise
     * @param bool   $objectSupport          True if object support is enabled, false otherwise
     * @param bool   $objectForMap           True if maps should return a stdClass instead of array()
     *
     * @return mixed The YAML converted to a PHP value
     *
     * @throws ParseException If the YAML is not valid
     */
    public static function parse($input, $exceptionOnInvalidType = false, $objectSupport = false, $objectForMap = false)
    {
        // if input is a file, process it
        $file = '';
        if (strpos($input, "\n") === false && is_file($input)) {
            @trigger_error('The ability to pass file names to the '.__METHOD__.' method is deprecated since version 2.2 and will be removed in 3.0. Pass the YAML contents of the file instead.', E_USER_DEPRECATED);

            if (false === is_readable($input)) {
                throw new ParseException(sprintf('Unable to parse "%s" as the file is not readable.', $input));
            }

            $file = $input;
            $input = file_get_contents($file);
        }

        $yaml = new Parser();

        try {
            return $yaml->parse($input, $exceptionOnInvalidType, $objectSupport, $objectForMap);
        } catch (ParseException $e) {
            if ($file) {
                $e->setParsedFile($file);
            }

            throw $e;
        }
    }

    /**
     * Dumps a PHP array to a YAML string.
     *
     * The dump method, when supplied with an array, will do its best
     * to convert the array into friendly YAML.
     *
     * @param array $array                  PHP array
     * @param int   $inline                 The level where you switch to inline YAML
     * @param int   $indent                 The amount of spaces to use for indentation of nested nodes.
     * @param bool  $exceptionOnInvalidType true if an exception must be thrown on invalid types (a PHP resource or object), false otherwise
     * @param bool  $objectSupport          true if object support is enabled, false otherwise
     *
     * @return string A YAML string representing the original PHP array
     */
    public static function dump($array, $inline = 2, $indent = 4, $exceptionOnInvalidType = false, $objectSupport = false)
    {
        $yaml = new Dumper();
        $yaml->setIndentation($indent);

        return $yaml->dump($array, $inline, 0, $exceptionOnInvalidType, $objectSupport);
    }
}
<?php
namespace ConfigKit;
use ArrayAccess;
use ArrayIterator;
use IteratorAggregate;

class Accessor
    implements ArrayAccess, IteratorAggregate
{

    public $config = array();

    public $cache = array();

    public function __construct($config = array())
    {
        $this->config = $config;
    }

    public function getIterator() 
    {
        return new ArrayIterator($this->config);
    }
    
    public function offsetSet($name,$value)
    {
        $this->config[ $name ] = $value;
    }
    
    public function offsetExists($name)
    {
        return isset($this->config[ $name ]);
    }
    
    public function offsetGet($name)
    {
        if (isset($this->config[$name])) {
            if (is_array($this->config[$name])) {
                return new self($this->config[$name]);
            }
            return $this->config[ $name ];
        }
    }
    
    public function offsetUnset($name)
    {
        unset($this->config[$name]);
    }
    
    public function toArray()
    {
        return $this->config;
    }

    public function isEmpty()
    {
        return null === $this->config || empty( $this->config );
    }

    public function __get($name)
    {
        return $this->offsetGet($name);
    }


    /**
     * lookup config value
     *
     * @param string $key config key
     * @return mixed
     */
    public function lookup( $key )
    {
        if ( isset($this->cache[$key]) ) {
            return $this->cache[$key];
        }

        if ( isset($this->config[ $key ]) ) {
            if ( is_array( $this->config[ $key ] ) ) {
                return $this->cache[$key] = new self($this->config[ $key ]);
            }
            return $this->cache[$key] = $this->config[ $key ];
        }
        if ( strchr( $key , '.' ) !== false ) {
            $parts = explode( '.' , $key );
            $ref = $this->config;
            while ( $refKey = array_shift( $parts ) ) {
                if ( is_array($ref) && isset($ref[ $refKey ]) ) {
                    $ref = & $ref[ $refKey ];
                    continue;
                } else {
                    return null;
                }
            }
            if ( is_array($ref) ) {
                return $this->cache[$key] = new self($ref);
            }
            return $this->cache[$key] = $ref;
        }
        return null;
    }
    
}

<?php
/**
 *  use ConfigKit\ConfigCompiler;
 *  $compiled = ConfigCompiler::compile('source_file.yml' , 'compiled_file.php');
 *  $config = ConfigCompiler::load('source_file.yml', 'compiled_file.php');
 *  $config = ConfigCompiler::load('source_file.yml');
 */
namespace ConfigKit;
use Symfony\Component\Yaml\Yaml;
use Symfony\Component\Yaml\Dumper;
use Exception;


global $extensionSupport;
$extensionSupport = extension_loaded('yaml');

class ConfigFileException extends Exception {  }

class ConfigCompiler
{
    static $statCheck = true;

    public static function format_supported($filename)
    {
        $extension = futil_get_extension($filename);
        return in_array($extension, array('yml','yaml','json'));
    }

    public static function parse($sourceFile) {
        $content = file_get_contents($sourceFile);
        if (strpos($content,'---') === 0) {
            global $extensionSupport;
            if ( $extensionSupport ) {
                return \yaml_parse($content);
            } else {
                return Yaml::parse($content);
            }
        } elseif (strpos($content,'{') === 0) {
            return \json_decode($content);
        } elseif (strpos($content,'<?php') === 0 ) {
            return require $sourceFile;
        }
        throw new ConfigFileException('Unknown file format.');
    }

    public static function _compile_file($sourceFile,$compiledFile, $overrideConfig = null)
    {
        $config = self::parse($sourceFile);

        if ($overrideConfig) {
            if (! is_array($overrideConfig)) {
                throw new InvalidArgumentException("overrideConfig must be an array.");
            }
            $config = array_merge($config, $overrideConfig);
        }
        self::write($compiledFile,$config);

        // inline apc cache
        if (extension_loaded('apc')) {
            apc_store($sourceFile . filemtime($sourceFile) , $config);
        }
        return $config;
    }

    /**
     * Write config array into the YAML file. using Symfony YAML component.
     */
    public static function write_yaml($yamlFile, $config) {
        $yaml = '';
        if (extension_loaded('yaml')) {
            $yaml = yaml_emit($config);
        } else {
            $yaml = "---\n" . Yaml::dump($config, $inline = true, $exceptionOnInvalidType = true);
        }
        return file_put_contents($yamlFile, $yaml);
    }

    public static function write($compiledFile, $config)
    {
        if ( file_put_contents( $compiledFile , '<?php return ' . var_export($config,true) . ';' ) === false ) {
            throw new ConfigFileException("Can not write config file.");
        }
    }


    /**
     * Test if a the source file is updated, and the compiled cache file needs 
     * to be updated.
     *
     * @param path $sourceFile 
     * @param path $compiledFile
     *
     * @return bool true means compilation is needed. false means we can ignore it.
     */
    public static function test($sourceFile, $compiledFile) {
        if (file_exists($compiledFile)) {
            return \futil_mtime_compare($sourceFile, $compiledFile) > 0;
        }
        return true;
    }

    public static function compiled_filename($sourceFile) {
        return futil_replace_extension($sourceFile, 'php');
    }


    /**
     * Compile the source file to cache file.
     *
     * @param path $sourceFile 
     * @param path $compiledFile
     *
     * @return path the compiled file path
     */
    public static function compile($sourceFile, $compiledFile = null) { 
        if ( ! $compiledFile ) {
            $compiledFile = self::compiled_filename($sourceFile);
        }
        if (self::test($sourceFile, $compiledFile)) {
            self::_compile_file($sourceFile,$compiledFile);
        }
        return $compiledFile;
    }


    /**
     * override the original config and compile to cache.
     */
    public static function override_compile($sourceFile, $overrideConfig, $compiledFile = null) {
        if ( ! $compiledFile ) {
            $compiledFile = \futil_replace_extension($sourceFile, 'php');
        }
        if (self::test($sourceFile, $compiledFile)) {
            self::_compile_file($sourceFile,$compiledFile, $overrideConfig);
        }
        return $compiledFile;
    }


    public static function load($sourceFile, $compiledFile = null, $statCheck = true)
    {
        $cacheKey = $sourceFile . filemtime($sourceFile);
        if (extension_loaded('apc')) {
            if ($cache = apc_fetch($cacheKey)) {
                return $cache;
            }
        }
        if ((!$statCheck || !self::$statCheck) && ($compiledFile && file_exists($compiledFile)) ) {
            return require $compiledFile;
        }
        $file = self::compile($sourceFile, $compiledFile);
        return require $file;
    }

    public static function unlink($sourceFile,$compiledFile = null) {
        $file = self::compile($sourceFile,$compiledFile);
        return unlink($file);
    }
}
<?php

namespace ConfigKit;

use CodeGen\UserClass;
use Doctrine\Common\Inflector\Inflector;

class ConfigLoader
{
    public $stashes = array();

    public $files = array();

    public function load($section, $file)
    {
        // register to files
        $this->files[ $section ] = array($file);

        return $this->stashes[ $section ] = ConfigCompiler::load($file);
    }

    /**
     * Merge config into one specific section.
     *
     * @param string $section section key
     * @param string $file    config file.
     *
     * @return array merged config array
     */
    public function merge($section, $file)
    {
        if (isset($this->stashes[$section])) {
            $this->files[ $section ][] = $file;
            $config = ConfigCompiler::load($file);

            return $this->stashes[$section] = array_merge($this->stashes[$section], $config);
        } else {
            return $this->load($section, $file);
        }
    }

    /**
     * Write section config to a file.
     *
     * @param string $section
     * @param string $file
     */
    public function writeSection($section, $file)
    {
        if (!isset($this->stashes[$section])) {
            throw new Exception("$section section is not loaded.");
        }
        $config = $this->stashes[$section];

        return ConfigCompiler::write($file, $config);
    }

    /**
     * Write config stashes to file.
     *
     * @param string $file
     */
    public function writeStashes($file)
    {
        return ConfigCompiler::write($file, $this->stashes);
    }

    /**
     * Load stashes from config file directly.
     *
     * @param string $file
     */
    public function loadStashes($file)
    {
        return $this->stashes = ConfigCompiler::load($file);
    }

    public function getStashes()
    {
        return $this->stashes;
    }

    /**
     * Allow more useful getter.
     */
    public function __get($name)
    {
        if (isset($this->stashes[$name])) {
            // It must be an array.
            return new Accessor($this->stashes[$name]);
        }
    }

    public function __isset($name)
    {
        return isset($this->stashes[$name]);
    }

    /**
     * Get section stash, returns stash in pure php array.
     *
     * @param string $section section name
     *
     * @return array
     */
    public function getSection($section)
    {
        if (isset($this->stashes[$section])) {
            return $this->stashes[$section];
        }
    }

    public function getSectionAccessor($section)
    {
        if (isset($this->stashes[$section])) {
            return new Accessor($this->stashes[$section]);
        }
    }

    /**
     * get config from the "config key" like:.
     *
     *   mail.user
     *   mail.pass
     *
     * @return array
     */
    public function get($section, $key = null)
    {
        if (isset($this->stashes[$section])) {
            $config = new Accessor($this->stashes[ $section ]);
            if ($key) {
                return $config->lookup($key);
            }

            return $config;
        }
    }

    /**
     * Check whether a config file is loaded into a section.
     *
     * @param string $section
     *
     * @return bool
     */
    public function isLoaded($section)
    {
        return isset($this->stashes[$section]);
    }

    public function generateAppClass($className)
    {
        $appClass = new UserClass($className);
        $appClass->useClass('ConfigKit\\Accessor');
        $appClass->useClass('ConfigKit\\ConfigLoader');
        $appClass->extendClass('ConfigLoader');

        // override the parent stashes property
        $appClass->addPublicProperty('stashes', $this->stashes);
        $appClass->addPublicProperty('files', $this->files);

        foreach ($this->stashes as $sectionName => $stash) {
            $appClass->addMethod(
                'public',
                'get'.Inflector::classify($sectionName).'Section',
                array(),
                array('return new Accessor($this->stashes['.var_export($sectionName, true).']);')
            );
        }

        return $appClass;
    }
}
<?php
/**
 * CssMin - A (simple) css minifier with benefits
 *
 * --
 * Copyright (c) 2011 Joe Scylla <joe.scylla@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * --
 *
 * @package		CssMin
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
/**
 * Abstract definition of a CSS token class.
 *
 * Every token has to extend this class.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssToken
{
	/**
	 * Returns the token as string.
	 *
	 * @return string
	 */
	abstract public function __toString();
}

/**
 * Abstract definition of a for a ruleset start token.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssRulesetStartToken extends aCssToken
{

}

/**
 * Abstract definition of a for ruleset end token.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssRulesetEndToken extends aCssToken
{
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "}";
	}
}

/**
 * Abstract definition of a parser plugin.
 *
 * Every parser plugin have to extend this class. A parser plugin contains the logic to parse one or aspects of a
 * stylesheet.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssParserPlugin
{
	/**
	 * Plugin configuration.
	 *
	 * @var array
	 */
	protected $configuration = array();
	/**
	 * The CssParser of the plugin.
	 *
	 * @var CssParser
	 */
	protected $parser = null;
	/**
	 * Plugin buffer.
	 *
	 * @var string
	 */
	protected $buffer = "";
	/**
	 * Constructor.
	 *
	 * @param CssParser $parser The CssParser object of this plugin.
	 * @param array $configuration Plugin configuration [optional]
	 * @return void
	 */
	public function __construct(CssParser $parser, array $configuration = null)
	{
		$this->configuration	= $configuration;
		$this->parser			= $parser;
	}
	/**
	 * Returns the array of chars triggering the parser plugin.
	 *
	 * @return array
	 */
	abstract public function getTriggerChars();
	/**
	 * Returns the array of states triggering the parser plugin or FALSE if every state will trigger the parser plugin.
	 *
	 * @return array
	 */
	abstract public function getTriggerStates();
	/**
	 * Parser routine of the plugin.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	abstract public function parse($index, $char, $previousChar, $state);
}

/**
 * Abstract definition of a minifier plugin class.
 *
 * Minifier plugin process the parsed tokens one by one to apply changes to the token. Every minifier plugin has to
 * extend this class.
 *
 * @package		CssMin/Minifier/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssMinifierPlugin
{
	/**
	 * Plugin configuration.
	 *
	 * @var array
	 */
	protected $configuration = array();
	/**
	 * The CssMinifier of the plugin.
	 *
	 * @var CssMinifier
	 */
	protected $minifier = null;
	/**
	 * Constructor.
	 *
	 * @param CssMinifier $minifier The CssMinifier object of this plugin.
	 * @param array $configuration Plugin configuration [optional]
	 * @return void
	 */
	public function __construct(CssMinifier $minifier, array $configuration = array())
	{
		$this->configuration	= $configuration;
		$this->minifier			= $minifier;
	}
	/**
	 * Apply the plugin to the token.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	abstract public function apply(aCssToken &$token);
	/**
	 * --
	 *
	 * @return array
	 */
	abstract public function getTriggerTokens();
}

/**
 * Abstract definition of a minifier filter class.
 *
 * Minifier filters allows a pre-processing of the parsed token to add, edit or delete tokens. Every minifier filter
 * has to extend this class.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssMinifierFilter
{
	/**
	 * Filter configuration.
	 *
	 * @var array
	 */
	protected $configuration = array();
	/**
	 * The CssMinifier of the filter.
	 *
	 * @var CssMinifier
	 */
	protected $minifier = null;
	/**
	 * Constructor.
	 *
	 * @param CssMinifier $minifier The CssMinifier object of this plugin.
	 * @param array $configuration Filter configuration [optional]
	 * @return void
	 */
	public function __construct(CssMinifier $minifier, array $configuration = array())
	{
		$this->configuration	= $configuration;
		$this->minifier			= $minifier;
	}
	/**
	 * Filter the tokens.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
	 */
	abstract public function apply(array &$tokens);
}

/**
 * Abstract formatter definition.
 *
 * Every formatter have to extend this class.
 *
 * @package		CssMin/Formatter
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssFormatter
{
	/**
	 * Indent string.
	 *
	 * @var string
	 */
	protected $indent = "    ";
	/**
	 * Declaration padding.
	 *
	 * @var integer
	 */
	protected $padding = 0;
	/**
	 * Tokens.
	 *
	 * @var array
	 */
	protected $tokens = array();
	/**
	 * Constructor.
	 *
	 * @param array $tokens Array of CssToken
	 * @param string $indent Indent string [optional]
	 * @param integer $padding Declaration value padding [optional]
	 */
	public function __construct(array $tokens, $indent = null, $padding = null)
	{
		$this->tokens	= $tokens;
		$this->indent	= !is_null($indent) ? $indent : $this->indent;
		$this->padding	= !is_null($padding) ? $padding : $this->padding;
	}
	/**
	 * Returns the array of aCssToken as formatted string.
	 *
	 * @return string
	 */
	abstract public function __toString();
}

/**
 * Abstract definition of a ruleset declaration token.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssDeclarationToken extends aCssToken
{
	/**
	 * Is the declaration flagged as important?
	 *
	 * @var boolean
	 */
	public $IsImportant = false;
	/**
	 * Is the declaration flagged as last one of the ruleset?
	 *
	 * @var boolean
	 */
	public $IsLast = false;
	/**
	 * Property name of the declaration.
	 *
	 * @var string
	 */
	public $Property = "";
	/**
	 * Value of the declaration.
	 *
	 * @var string
	 */
	public $Value = "";
	/**
	 * Set the properties of the @font-face declaration.
	 *
	 * @param string $property Property of the declaration
	 * @param string $value Value of the declaration
	 * @param boolean $isImportant Is the !important flag is set?
	 * @param boolean $IsLast Is the declaration the last one of the block?
	 * @return void
	 */
	public function __construct($property, $value, $isImportant = false, $isLast = false)
	{
		$this->Property		= $property;
		$this->Value		= $value;
		$this->IsImportant	= $isImportant;
		$this->IsLast		= $isLast;
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return $this->Property . ":" . $this->Value . ($this->IsImportant ? " !important" : "") . ($this->IsLast ? "" : ";");
	}
}

/**
 * Abstract definition of a for at-rule block start token.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssAtBlockStartToken extends aCssToken
{

}

/**
 * Abstract definition of a for at-rule block end token.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
abstract class aCssAtBlockEndToken extends aCssToken
{
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "}";
	}
}

/**
 * {@link aCssFromatter Formatter} returning the CSS source in {@link http://goo.gl/etzLs Whitesmiths indent style}.
 *
 * @package		CssMin/Formatter
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssWhitesmithsFormatter extends aCssFormatter
{
	/**
	 * Implements {@link aCssFormatter::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		$r				= array();
		$level			= 0;
		for ($i = 0, $l = count($this->tokens); $i < $l; $i++)
		{
			$token		= $this->tokens[$i];
			$class		= get_class($token);
			$indent 	= str_repeat($this->indent, $level);
			if ($class === "CssCommentToken")
			{
				$lines = array_map("trim", explode("\n", $token->Comment));
				for ($ii = 0, $ll = count($lines); $ii < $ll; $ii++)
				{
					$r[] = $indent . (substr($lines[$ii], 0, 1) == "*" ? " " : "") . $lines[$ii];
				}
			}
			elseif ($class === "CssAtCharsetToken")
			{
				$r[] = $indent . "@charset " . $token->Charset . ";";
			}
			elseif ($class === "CssAtFontFaceStartToken")
			{
				$r[] = $indent . "@font-face";
				$r[] = $this->indent . $indent . "{";
				$level++;
			}
			elseif ($class === "CssAtImportToken")
			{
				$r[] = $indent . "@import " . $token->Import . " " . implode(", ", $token->MediaTypes) . ";";
			}
			elseif ($class === "CssAtKeyframesStartToken")
			{
				$r[] = $indent . "@keyframes " . $token->Name;
				$r[] = $this->indent . $indent . "{";
				$level++;
			}
			elseif ($class === "CssAtMediaStartToken")
			{
				$r[] = $indent . "@media " . implode(", ", $token->MediaTypes);
				$r[] = $this->indent . $indent . "{";
				$level++;
			}
			elseif ($class === "CssAtPageStartToken")
			{
				$r[] = $indent . "@page";
				$r[] = $this->indent . $indent . "{";
				$level++;
			}
			elseif ($class === "CssAtVariablesStartToken")
			{
				$r[] = $indent . "@variables " . implode(", ", $token->MediaTypes);
				$r[] = $this->indent . $indent . "{";
				$level++;
			}
			elseif ($class === "CssRulesetStartToken" || $class === "CssAtKeyframesRulesetStartToken")
			{
				$r[] = $indent . implode(", ", $token->Selectors);
				$r[] = $this->indent . $indent . "{";
				$level++;
			}
			elseif ($class === "CssAtFontFaceDeclarationToken"
				|| $class === "CssAtKeyframesRulesetDeclarationToken"
				|| $class === "CssAtPageDeclarationToken"
				|| $class === "CssAtVariablesDeclarationToken"
				|| $class === "CssRulesetDeclarationToken"
			)
			{
				$declaration = $indent . $token->Property . ": ";
				if ($this->padding)
				{
					$declaration = str_pad($declaration, $this->padding, " ", STR_PAD_RIGHT);
				}
				$r[] = $declaration . $token->Value . ($token->IsImportant ? " !important" : "") . ";";
			}
			elseif ($class === "CssAtFontFaceEndToken"
				|| $class === "CssAtMediaEndToken"
				|| $class === "CssAtKeyframesEndToken"
				|| $class === "CssAtKeyframesRulesetEndToken"
				|| $class === "CssAtPageEndToken"
				|| $class === "CssAtVariablesEndToken"
				|| $class === "CssRulesetEndToken"
			)
			{
				$r[] = $indent . "}";
				$level--;
			}
		}
		return implode("\n", $r);
	}
}

/**
 * This {@link aCssMinifierPlugin} will process var-statement and sets the declaration value to the variable value.
 *
 * This plugin only apply the variable values. The variable values itself will get parsed by the
 * {@link CssVariablesMinifierFilter}.
 *
 * Example:
 * <code>
 * @variables
 * 		{
 * 		defaultColor: black;
 * 		}
 * color: var(defaultColor);
 * </code>
 *
 * Will get converted to:
 * <code>
 * color:black;
 * </code>
 *
 * @package		CssMin/Minifier/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssVariablesMinifierPlugin extends aCssMinifierPlugin
{
	/**
	 * Regular expression matching a value.
	 *
	 * @var string
	 */
	private $reMatch = "/var\((.+)\)/iSU";
	/**
	 * Parsed variables.
	 *
	 * @var array
	 */
	private $variables = null;
	/**
	 * Returns the variables.
	 *
	 * @return array
	 */
	public function getVariables()
	{
		return $this->variables;
	}
	/**
	 * Implements {@link aCssMinifierPlugin::minify()}.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	public function apply(aCssToken &$token)
	{
		if (stripos($token->Value, "var") !== false && preg_match_all($this->reMatch, $token->Value, $m))
		{
			$mediaTypes	= $token->MediaTypes;
			if (!in_array("all", $mediaTypes))
			{
				$mediaTypes[] = "all";
			}
			for ($i = 0, $l = count($m[0]); $i < $l; $i++)
			{
				$variable	= trim($m[1][$i]);
				foreach ($mediaTypes as $mediaType)
				{
					if (isset($this->variables[$mediaType], $this->variables[$mediaType][$variable]))
					{
						// Variable value found => set the declaration value to the variable value and return
						$token->Value = str_replace($m[0][$i], $this->variables[$mediaType][$variable], $token->Value);
						continue 2;
					}
				}
				// If no value was found trigger an error and replace the token with a CssNullToken
				CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": No value found for variable <code>" . $variable . "</code> in media types <code>" . implode(", ", $mediaTypes) . "</code>", (string) $token));
				$token = new CssNullToken();
				return true;
			}
		}
		return false;
	}
	/**
	 * Implements {@link aMinifierPlugin::getTriggerTokens()}
	 *
	 * @return array
	 */
	public function getTriggerTokens()
	{
		return array
		(
			"CssAtFontFaceDeclarationToken",
			"CssAtPageDeclarationToken",
			"CssRulesetDeclarationToken"
		);
	}
	/**
	 * Sets the variables.
	 *
	 * @param array $variables Variables to set
	 * @return void
	 */
	public function setVariables(array $variables)
	{
		$this->variables = $variables;
	}
}

/**
 * This {@link aCssMinifierFilter minifier filter} will parse the variable declarations out of @variables at-rule
 * blocks. The variables will get store in the {@link CssVariablesMinifierPlugin} that will apply the variables to
 * declaration.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssVariablesMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		$variables			= array();
		$defaultMediaTypes	= array("all");
		$mediaTypes			= array();
		$remove				= array();
		for($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			// @variables at-rule block found
			if (get_class($tokens[$i]) === "CssAtVariablesStartToken")
			{
				$remove[] = $i;
				$mediaTypes = (count($tokens[$i]->MediaTypes) == 0 ? $defaultMediaTypes : $tokens[$i]->MediaTypes);
				foreach ($mediaTypes as $mediaType)
				{
					if (!isset($variables[$mediaType]))
					{
						$variables[$mediaType] = array();
					}
				}
				// Read the variable declaration tokens
				for($i = $i; $i < $l; $i++)
				{
					// Found a variable declaration => read the variable values
					if (get_class($tokens[$i]) === "CssAtVariablesDeclarationToken")
					{
						foreach ($mediaTypes as $mediaType)
						{
							$variables[$mediaType][$tokens[$i]->Property] = $tokens[$i]->Value;
						}
						$remove[] = $i;
					}
					// Found the variables end token => break;
					elseif (get_class($tokens[$i]) === "CssAtVariablesEndToken")
					{
						$remove[] = $i;
						break;
					}
				}
			}
		}
		// Variables in @variables at-rule blocks
		foreach($variables as $mediaType => $null)
		{
			foreach($variables[$mediaType] as $variable => $value)
			{
				// If a var() statement in a variable value found...
				if (stripos($value, "var") !== false && preg_match_all("/var\((.+)\)/iSU", $value, $m))
				{
					// ... then replace the var() statement with the variable values.
					for ($i = 0, $l = count($m[0]); $i < $l; $i++)
					{
						$variables[$mediaType][$variable] = str_replace($m[0][$i], (isset($variables[$mediaType][$m[1][$i]]) ? $variables[$mediaType][$m[1][$i]] : ""), $variables[$mediaType][$variable]);
					}
				}
			}
		}
		// Remove the complete @variables at-rule block
		foreach ($remove as $i)
		{
			$tokens[$i] = null;
		}
		if (!($plugin = $this->minifier->getPlugin("CssVariablesMinifierPlugin")))
		{
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": The plugin <code>CssVariablesMinifierPlugin</code> was not found but is required for <code>" . __CLASS__ . "</code>"));
		}
		else
		{
			$plugin->setVariables($variables);
		}
		return count($remove);
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for preserve parsing url() values.
 *
 * This plugin return no {@link aCssToken CssToken} but ensures that url() values will get parsed properly.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssUrlParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("(", ")");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return false;
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		// Start of string
		if ($char === "(" && strtolower(substr($this->parser->getSource(), $index - 3, 4)) === "url(" && $state !== "T_URL")
		{
			$this->parser->pushState("T_URL");
			$this->parser->setExclusive(__CLASS__);
		}
		// Escaped LF in url => remove escape backslash and LF
		elseif ($char === "\n" && $previousChar === "\\" && $state === "T_URL")
		{
			$this->parser->setBuffer(substr($this->parser->getBuffer(), 0, -2));
		}
		// Parse error: Unescaped LF in string literal
		elseif ($char === "\n" && $previousChar !== "\\" && $state === "T_URL")
		{
			$line = $this->parser->getBuffer();
			$this->parser->setBuffer(substr($this->parser->getBuffer(), 0, -1) . ")"); // Replace the LF with the url string delimiter
			$this->parser->popState();
			$this->parser->unsetExclusive();
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated string literal", $line . "_"));
		}
		// End of string
		elseif ($char === ")" && $state === "T_URL")
		{
			$this->parser->popState();
			$this->parser->unsetExclusive();
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for preserve parsing string values.
 *
 * This plugin return no {@link aCssToken CssToken} but ensures that string values will get parsed properly.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssStringParserPlugin extends aCssParserPlugin
{
	/**
	 * Current string delimiter char.
	 *
	 * @var string
	 */
	private $delimiterChar = null;
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("\"", "'", "\n");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return false;
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		// Start of string
		if (($char === "\"" || $char === "'") && $state !== "T_STRING")
		{
			$this->delimiterChar = $char;
			$this->parser->pushState("T_STRING");
			$this->parser->setExclusive(__CLASS__);
		}
		// Escaped LF in string => remove escape backslash and LF
		elseif ($char === "\n" && $previousChar === "\\" && $state === "T_STRING")
		{
			$this->parser->setBuffer(substr($this->parser->getBuffer(), 0, -2));
		}
		// Parse error: Unescaped LF in string literal
		elseif ($char === "\n" && $previousChar !== "\\" && $state === "T_STRING")
		{
			$line = $this->parser->getBuffer();
			$this->parser->popState();
			$this->parser->unsetExclusive();
			$this->parser->setBuffer(substr($this->parser->getBuffer(), 0, -1) . $this->delimiterChar); // Replace the LF with the current string char
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated string literal", $line . "_"));
			$this->delimiterChar = null;
		}
		// End of string
		elseif ($char === $this->delimiterChar && $state === "T_STRING")
		{
			// If the Previous char is a escape char count the amount of the previous escape chars. If the amount of
			// escape chars is uneven do not end the string
			if ($previousChar == "\\")
			{
				$source	= $this->parser->getSource();
				$c		= 1;
				$i		= $index - 2;
				while (substr($source, $i, 1) === "\\")
				{
					$c++; $i--;
				}
				if ($c % 2)
				{
					return false;
				}
			}
			$this->parser->popState();
			$this->parser->unsetExclusive();
			$this->delimiterChar = null;
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * This {@link aCssMinifierFilter minifier filter} sorts the ruleset declarations of a ruleset by name.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Rowan Beentje <http://assanka.net>
 * @copyright	Rowan Beentje <http://assanka.net>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssSortRulesetPropertiesMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value larger than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		$r = 0;
		for ($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			// Only look for ruleset start rules
			if (get_class($tokens[$i]) !== "CssRulesetStartToken") { continue; }
			// Look for the corresponding ruleset end
			$endIndex = false;
			for ($ii = $i + 1; $ii < $l; $ii++)
			{
				if (get_class($tokens[$ii]) !== "CssRulesetEndToken") { continue; }
				$endIndex = $ii;
				break;
			}
			if (!$endIndex) { break; }
			$startIndex = $i;
			$i = $endIndex;
			// Skip if there's only one token in this ruleset
			if ($endIndex - $startIndex <= 2) { continue; }
			// Ensure that everything between the start and end is a declaration token, for safety
			for ($ii = $startIndex + 1; $ii < $endIndex; $ii++)
			{
				if (get_class($tokens[$ii]) !== "CssRulesetDeclarationToken") { continue(2); }
			}
			$declarations = array_slice($tokens, $startIndex + 1, $endIndex - $startIndex - 1);
			// Check whether a sort is required
			$sortRequired = $lastPropertyName = false;
			foreach ($declarations as $declaration)
			{
				if ($lastPropertyName)
				{
					if (strcmp($lastPropertyName, $declaration->Property) > 0)
					{
						$sortRequired = true;
						break;
					}
				}
				$lastPropertyName = $declaration->Property;
			}
			if (!$sortRequired) { continue; }
			// Arrange the declarations alphabetically by name
			usort($declarations, array(__CLASS__, "userDefinedSort1"));
			// Update "IsLast" property
			for ($ii = 0, $ll = count($declarations) - 1; $ii <= $ll; $ii++)
			{
				if ($ii == $ll)
				{
					$declarations[$ii]->IsLast = true;
				}
				else
				{
					$declarations[$ii]->IsLast = false;
				}
			}
			// Splice back into the array.
			array_splice($tokens, $startIndex + 1, $endIndex - $startIndex - 1, $declarations);
			$r += $endIndex - $startIndex - 1;
		}
		return $r;
	}
	/**
	 * User defined sort function.
	 *
	 * @return integer
	 */
	public static function userDefinedSort1($a, $b)
	{
		return strcmp($a->Property, $b->Property);
	}
}

/**
 * This {@link aCssToken CSS token} represents the start of a ruleset.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssRulesetStartToken extends aCssRulesetStartToken
{
	/**
	 * Array of selectors.
	 *
	 * @var array
	 */
	public $Selectors = array();
	/**
	 * Set the properties of a ruleset token.
	 *
	 * @param array $selectors Selectors of the ruleset
	 * @return void
	 */
	public function __construct(array $selectors = array())
	{
		$this->Selectors = $selectors;
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return implode(",", $this->Selectors) . "{";
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing ruleset block with including declarations.
 *
 * Found rulesets will add a {@link CssRulesetStartToken} and {@link CssRulesetEndToken} to the
 * parser; including declarations as {@link CssRulesetDeclarationToken}.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssRulesetParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array(",", "{", "}", ":", ";");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return array("T_DOCUMENT", "T_AT_MEDIA", "T_RULESET::SELECTORS", "T_RULESET", "T_RULESET_DECLARATION");
	}
	/**
	 * Selectors.
	 *
	 * @var array
	 */
	private $selectors = array();
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		// Start of Ruleset and selectors
		if ($char === "," && ($state === "T_DOCUMENT" || $state === "T_AT_MEDIA" || $state === "T_RULESET::SELECTORS"))
		{
			if ($state !== "T_RULESET::SELECTORS")
			{
				$this->parser->pushState("T_RULESET::SELECTORS");
			}
			$this->selectors[] = $this->parser->getAndClearBuffer(",{");
		}
		// End of selectors and start of declarations
		elseif ($char === "{" && ($state === "T_DOCUMENT" || $state === "T_AT_MEDIA" || $state === "T_RULESET::SELECTORS"))
		{
			if ($this->parser->getBuffer() !== "")
			{
				$this->selectors[] = $this->parser->getAndClearBuffer(",{");
				if ($state == "T_RULESET::SELECTORS")
				{
					$this->parser->popState();
				}
				$this->parser->pushState("T_RULESET");
				$this->parser->appendToken(new CssRulesetStartToken($this->selectors));
				$this->selectors = array();
			}
		}
		// Start of declaration
		elseif ($char === ":" && $state === "T_RULESET")
		{
			$this->parser->pushState("T_RULESET_DECLARATION");
			$this->buffer = $this->parser->getAndClearBuffer(":;", true);
		}
		// Unterminated ruleset declaration
		elseif ($char === ":" && $state === "T_RULESET_DECLARATION")
		{
			// Ignore Internet Explorer filter declarations
			if ($this->buffer === "filter")
			{
				return false;
			}
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
		}
		// End of declaration
		elseif (($char === ";" || $char === "}") && $state === "T_RULESET_DECLARATION")
		{
			$value = $this->parser->getAndClearBuffer(";}");
			if (strtolower(substr($value, -10, 10)) === "!important")
			{
				$value = trim(substr($value, 0, -10));
				$isImportant = true;
			}
			else
			{
				$isImportant = false;
			}
			$this->parser->popState();
			$this->parser->appendToken(new CssRulesetDeclarationToken($this->buffer, $value, $this->parser->getMediaTypes(), $isImportant));
			// Declaration ends with a right curly brace; so we have to end the ruleset
			if ($char === "}")
			{
				$this->parser->appendToken(new CssRulesetEndToken());
				$this->parser->popState();
			}
			$this->buffer = "";
		}
		// End of ruleset
		elseif ($char === "}" && $state === "T_RULESET")
		{
			$this->parser->popState();
			$this->parser->clearBuffer();
			$this->parser->appendToken(new CssRulesetEndToken());
			$this->buffer = "";
			$this->selectors = array();
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 *  This {@link aCssToken CSS token} represents the end of a ruleset.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssRulesetEndToken extends aCssRulesetEndToken
{

}

/**
 * This {@link aCssToken CSS token} represents a ruleset declaration.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssRulesetDeclarationToken extends aCssDeclarationToken
{
	/**
	 * Media types of the declaration.
	 *
	 * @var array
	 */
	public $MediaTypes = array("all");
	/**
	 * Set the properties of a ddocument- or at-rule @media level declaration.
	 *
	 * @param string $property Property of the declaration
	 * @param string $value Value of the declaration
	 * @param mixed $mediaTypes Media types of the declaration
	 * @param boolean $isImportant Is the !important flag is set
	 * @param boolean $isLast Is the declaration the last one of the ruleset
	 * @return void
	 */
	public function __construct($property, $value, $mediaTypes = null, $isImportant = false, $isLast = false)
	{
		parent::__construct($property, $value, $isImportant, $isLast);
		$this->MediaTypes	= $mediaTypes ? $mediaTypes : array("all");
	}
}

/**
 * This {@link aCssMinifierFilter minifier filter} sets the IsLast property of any last declaration in a ruleset,
 * @font-face at-rule or @page at-rule block. If the property IsLast is TRUE the decrations will get stringified
 * without tailing semicolon.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssRemoveLastDelarationSemiColonMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		for ($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			$current	= get_class($tokens[$i]);
			$next		= isset($tokens[$i+1]) ? get_class($tokens[$i+1]) : false;
			if (($current === "CssRulesetDeclarationToken" && $next === "CssRulesetEndToken") ||
				($current === "CssAtFontFaceDeclarationToken" && $next === "CssAtFontFaceEndToken") ||
				($current === "CssAtPageDeclarationToken" && $next === "CssAtPageEndToken"))
			{
				$tokens[$i]->IsLast = true;
			}
		}
		return 0;
	}
}

/**
 * This {@link aCssMinifierFilter minifier filter} will remove any empty rulesets (including @keyframes at-rule block
 * rulesets).
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssRemoveEmptyRulesetsMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		$r = 0;
		for ($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			$current	= get_class($tokens[$i]);
			$next		= isset($tokens[$i + 1]) ? get_class($tokens[$i + 1]) : false;
			if (($current === "CssRulesetStartToken" && $next === "CssRulesetEndToken") ||
				($current === "CssAtKeyframesRulesetStartToken" && $next === "CssAtKeyframesRulesetEndToken" && !array_intersect(array("from", "0%", "to", "100%"), array_map("strtolower", $tokens[$i]->Selectors)))
			)
			{
				$tokens[$i]		= null;
				$tokens[$i + 1]	= null;
				$i++;
				$r = $r + 2;
			}
		}
		return $r;
	}
}

/**
 * This {@link aCssMinifierFilter minifier filter} will remove any empty @font-face, @keyframes, @media and @page
 * at-rule blocks.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssRemoveEmptyAtBlocksMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		$r = 0;
		for ($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			$current	= get_class($tokens[$i]);
			$next		= isset($tokens[$i + 1]) ? get_class($tokens[$i + 1]) : false;
			if (($current === "CssAtFontFaceStartToken" && $next === "CssAtFontFaceEndToken") ||
				($current === "CssAtKeyframesStartToken" && $next === "CssAtKeyframesEndToken") ||
				($current === "CssAtPageStartToken" && $next === "CssAtPageEndToken") ||
				($current === "CssAtMediaStartToken" && $next === "CssAtMediaEndToken"))
			{
				$tokens[$i]		= null;
				$tokens[$i + 1]	= null;
				$i++;
				$r = $r + 2;
			}
		}
		return $r;
	}
}

/**
 * This {@link aCssMinifierFilter minifier filter} will remove any comments from the array of parsed tokens.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssRemoveCommentsMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		$r = 0;
		for ($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			if (get_class($tokens[$i]) === "CssCommentToken")
			{
				$tokens[$i] = null;
				$r++;
			}
		}
		return $r;
	}
}

/**
 * CSS Parser.
 *
 * @package		CssMin/Parser
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssParser
{
	/**
	 * Parse buffer.
	 *
	 * @var string
	 */
	private $buffer = "";
	/**
	 * {@link aCssParserPlugin Plugins}.
	 *
	 * @var array
	 */
	private $plugins = array();
	/**
	 * Source to parse.
	 *
	 * @var string
	 */
	private $source = "";
	/**
	 * Current state.
	 *
	 * @var integer
	 */
	private $state = "T_DOCUMENT";
	/**
	 * Exclusive state.
	 *
	 * @var string
	 */
	private $stateExclusive = false;
	/**
	 * Media types state.
	 *
	 * @var mixed
	 */
	private $stateMediaTypes = false;
	/**
	 * State stack.
	 *
	 * @var array
	 */
	private $states = array("T_DOCUMENT");
	/**
	 * Parsed tokens.
	 *
	 * @var array
	 */
	private $tokens = array();
	/**
	 * Constructer.
	 *
	 *  Create instances of the used {@link aCssParserPlugin plugins}.
	 *
	 * @param string $source CSS source [optional]
	 * @param array $plugins Plugin configuration [optional]
	 * @return void
	 */
	public function __construct($source = null, array $plugins = null)
	{
		$plugins = array_merge(array
		                       (
		                       "Comment"		=> true,
		                       "String"		=> true,
		                       "Url"			=> true,
		                       "Expression"	=> true,
		                       "Ruleset"		=> true,
		                       "AtCharset"		=> true,
		                       "AtFontFace"	=> true,
		                       "AtImport"		=> true,
		                       "AtKeyframes"	=> true,
		                       "AtMedia"		=> true,
		                       "AtPage"		=> true,
		                       "AtVariables"	=> true
		                       ), is_array($plugins) ? $plugins : array());
		// Create plugin instances
		foreach ($plugins as $name => $config)
		{
			if ($config !== false)
			{
				$class	= "Css" . $name . "ParserPlugin";
				$config = is_array($config) ? $config : array();
				if (class_exists($class))
				{
					$this->plugins[] = new $class($this, $config);
				}
				else
				{
					CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": The plugin <code>" . $name . "</code> with the class name <code>" . $class . "</code> was not found"));
				}
			}
		}
		if (!is_null($source))
		{
			$this->parse($source);
		}
	}
	/**
	 * Append a token to the array of tokens.
	 *
	 * @param aCssToken $token Token to append
	 * @return void
	 */
	public function appendToken(aCssToken $token)
	{
		$this->tokens[] = $token;
	}
	/**
	 * Clears the current buffer.
	 *
	 * @return void
	 */
	public function clearBuffer()
	{
		$this->buffer = "";
	}
	/**
	 * Returns and clear the current buffer.
	 *
	 * @param string $trim Chars to use to trim the returned buffer
	 * @param boolean $tolower if TRUE the returned buffer will get converted to lower case
	 * @return string
	 */
	public function getAndClearBuffer($trim = "", $tolower = false)
	{
		$r = $this->getBuffer($trim, $tolower);
		$this->buffer = "";
		return $r;
	}
	/**
	 * Returns the current buffer.
	 *
	 * @param string $trim Chars to use to trim the returned buffer
	 * @param boolean $tolower if TRUE the returned buffer will get converted to lower case
	 * @return string
	 */
	public function getBuffer($trim = "", $tolower = false)
	{
		$r = $this->buffer;
		if ($trim)
		{
			$r = trim($r, " \t\n\r\0\x0B" . $trim);
		}
		if ($tolower)
		{
			$r = strtolower($r);
		}
		return $r;
	}
	/**
	 * Returns the current media types state.
	 *
	 * @return array
	 */
	public function getMediaTypes()
	{
		return $this->stateMediaTypes;
	}
	/**
	 * Returns the CSS source.
	 *
	 * @return string
	 */
	public function getSource()
	{
		return $this->source;
	}
	/**
	 * Returns the current state.
	 *
	 * @return integer The current state
	 */
	public function getState()
	{
		return $this->state;
	}
	/**
	 * Returns a plugin by class name.
	 *
	 * @param string $name Class name of the plugin
	 * @return aCssParserPlugin
	 */
	public function getPlugin($class)
	{
		static $index = null;
		if (is_null($index))
		{
			$index = array();
			for ($i = 0, $l = count($this->plugins); $i < $l; $i++)
			{
				$index[get_class($this->plugins[$i])] = $i;
			}
		}
		return isset($index[$class]) ? $this->plugins[$index[$class]] : false;
	}
	/**
	 * Returns the parsed tokens.
	 *
	 * @return array
	 */
	public function getTokens()
	{
		return $this->tokens;
	}
	/**
	 * Returns if the current state equals the passed state.
	 *
	 * @param integer $state State to compare with the current state
	 * @return boolean TRUE is the state equals to the passed state; FALSE if not
	 */
	public function isState($state)
	{
		return ($this->state == $state);
	}
	/**
	 * Parse the CSS source and return a array with parsed tokens.
	 *
	 * @param string $source CSS source
	 * @return array Array with tokens
	 */
	public function parse($source)
	{
		// Reset
		$this->source = "";
		$this->tokens = array();
		// Create a global and plugin lookup table for trigger chars; set array of plugins as local variable and create
		// several helper variables for plugin handling
		$globalTriggerChars		= "";
		$plugins				= $this->plugins;
		$pluginCount			= count($plugins);
		$pluginIndex			= array();
		$pluginTriggerStates	= array();
		$pluginTriggerChars		= array();
		for ($i = 0, $l = count($plugins); $i < $l; $i++)
		{
			$tPluginClassName				= get_class($plugins[$i]);
			$pluginTriggerChars[$i]			= implode("", $plugins[$i]->getTriggerChars());
			$tPluginTriggerStates			= $plugins[$i]->getTriggerStates();
			$pluginTriggerStates[$i]		= $tPluginTriggerStates === false ? false : "|" . implode("|", $tPluginTriggerStates) . "|";
			$pluginIndex[$tPluginClassName]	= $i;
			for ($ii = 0, $ll = strlen($pluginTriggerChars[$i]); $ii < $ll; $ii++)
			{
				$c = substr($pluginTriggerChars[$i], $ii, 1);
				if (strpos($globalTriggerChars, $c) === false)
				{
					$globalTriggerChars .= $c;
				}
			}
		}
		// Normalise line endings
		$source			= str_replace("\r\n", "\n", $source);	// Windows to Unix line endings
		$source			= str_replace("\r", "\n", $source);		// Mac to Unix line endings
		$this->source	= $source;
		// Variables
		$buffer			= &$this->buffer;
		$exclusive		= &$this->stateExclusive;
		$state			= &$this->state;
		$c = $p 		= null;
		// --
		for ($i = 0, $l = strlen($source); $i < $l; $i++)
		{
			// Set the current Char
			$c = $source[$i]; // Is faster than: $c = substr($source, $i, 1);
			// Normalize and filter double whitespace characters
			if ($exclusive === false)
			{
				if ($c === "\n" || $c === "\t")
				{
					$c = " ";
				}
				if ($c === " " && $p === " ")
				{
					continue;
				}
			}
			$buffer .= $c;
			// Extended processing only if the current char is a global trigger char
			if (strpos($globalTriggerChars, $c) !== false)
			{
				// Exclusive state is set; process with the exclusive plugin
				if ($exclusive)
				{
					$tPluginIndex = $pluginIndex[$exclusive];
					if (strpos($pluginTriggerChars[$tPluginIndex], $c) !== false && ($pluginTriggerStates[$tPluginIndex] === false || strpos($pluginTriggerStates[$tPluginIndex], $state) !== false))
					{
						$r = $plugins[$tPluginIndex]->parse($i, $c, $p, $state);
						// Return value is TRUE => continue with next char
						if ($r === true)
						{
							continue;
						}
						// Return value is numeric => set new index and continue with next char
						elseif ($r !== false && $r != $i)
						{
							$i = $r;
							continue;
						}
					}
				}
				// Else iterate through the plugins
				else
				{
					$triggerState = "|" . $state . "|";
					for ($ii = 0, $ll = $pluginCount; $ii < $ll; $ii++)
					{
						// Only process if the current char is one of the plugin trigger chars
						if (strpos($pluginTriggerChars[$ii], $c) !== false && ($pluginTriggerStates[$ii] === false || strpos($pluginTriggerStates[$ii], $triggerState) !== false))
						{
							// Process with the plugin
							$r = $plugins[$ii]->parse($i, $c, $p, $state);
							// Return value is TRUE => break the plugin loop and and continue with next char
							if ($r === true)
							{
								break;
							}
							// Return value is numeric => set new index, break the plugin loop and and continue with next char
							elseif ($r !== false && $r != $i)
							{
								$i = $r;
								break;
							}
						}
					}
				}
			}
			$p = $c; // Set the parent char
		}
		return $this->tokens;
	}
	/**
	 * Remove the last state of the state stack and return the removed stack value.
	 *
	 * @return integer Removed state value
	 */
	public function popState()
	{
		$r = array_pop($this->states);
		$this->state = $this->states[count($this->states) - 1];
		return $r;
	}
	/**
	 * Adds a new state onto the state stack.
	 *
	 * @param integer $state State to add onto the state stack.
	 * @return integer The index of the added state in the state stacks
	 */
	public function pushState($state)
	{
		$r = array_push($this->states, $state);
		$this->state = $this->states[count($this->states) - 1];
		return $r;
	}
	/**
	 * Sets/restores the buffer.
	 *
	 * @param string $buffer Buffer to set
	 * @return void
	 */
	public function setBuffer($buffer)
	{
		$this->buffer = $buffer;
	}
	/**
	 * Set the exclusive state.
	 *
	 * @param string $exclusive Exclusive state
	 * @return void
	 */
	public function setExclusive($exclusive)
	{
		$this->stateExclusive = $exclusive;
	}
	/**
	 * Set the media types state.
	 *
	 * @param array $mediaTypes Media types state
	 * @return void
	 */
	public function setMediaTypes(array $mediaTypes)
	{
		$this->stateMediaTypes = $mediaTypes;
	}
	/**
	 * Sets the current state in the state stack; equals to {@link CssParser::popState()} + {@link CssParser::pushState()}.
	 *
	 * @param integer $state State to set
	 * @return integer
	 */
	public function setState($state)
	{
		$r = array_pop($this->states);
		array_push($this->states, $state);
		$this->state = $this->states[count($this->states) - 1];
		return $r;
	}
	/**
	 * Removes the exclusive state.
	 *
	 * @return void
	 */
	public function unsetExclusive()
	{
		$this->stateExclusive = false;
	}
	/**
	 * Removes the media types state.
	 *
	 * @return void
	 */
	public function unsetMediaTypes()
	{
		$this->stateMediaTypes = false;
	}
}

/**
 * {@link aCssFromatter Formatter} returning the CSS source in {@link http://goo.gl/j4XdU OTBS indent style} (The One True Brace Style).
 *
 * @package		CssMin/Formatter
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssOtbsFormatter extends aCssFormatter
{
	/**
	 * Implements {@link aCssFormatter::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		$r				= array();
		$level			= 0;
		for ($i = 0, $l = count($this->tokens); $i < $l; $i++)
		{
			$token		= $this->tokens[$i];
			$class		= get_class($token);
			$indent 	= str_repeat($this->indent, $level);
			if ($class === "CssCommentToken")
			{
				$lines = array_map("trim", explode("\n", $token->Comment));
				for ($ii = 0, $ll = count($lines); $ii < $ll; $ii++)
				{
					$r[] = $indent . (substr($lines[$ii], 0, 1) == "*" ? " " : "") . $lines[$ii];
				}
			}
			elseif ($class === "CssAtCharsetToken")
			{
				$r[] = $indent . "@charset " . $token->Charset . ";";
			}
			elseif ($class === "CssAtFontFaceStartToken")
			{
				$r[] = $indent . "@font-face {";
				$level++;
			}
			elseif ($class === "CssAtImportToken")
			{
				$r[] = $indent . "@import " . $token->Import . " " . implode(", ", $token->MediaTypes) . ";";
			}
			elseif ($class === "CssAtKeyframesStartToken")
			{
				$r[] = $indent . "@keyframes " . $token->Name . " {";
				$level++;
			}
			elseif ($class === "CssAtMediaStartToken")
			{
				$r[] = $indent . "@media " . implode(", ", $token->MediaTypes) . " {";
				$level++;
			}
			elseif ($class === "CssAtPageStartToken")
			{
				$r[] = $indent . "@page {";
				$level++;
			}
			elseif ($class === "CssAtVariablesStartToken")
			{
				$r[] = $indent . "@variables " . implode(", ", $token->MediaTypes) . " {";
				$level++;
			}
			elseif ($class === "CssRulesetStartToken" || $class === "CssAtKeyframesRulesetStartToken")
			{
				$r[] = $indent . implode(", ", $token->Selectors) . " {";
				$level++;
			}
			elseif ($class === "CssAtFontFaceDeclarationToken"
				|| $class === "CssAtKeyframesRulesetDeclarationToken"
				|| $class === "CssAtPageDeclarationToken"
				|| $class === "CssAtVariablesDeclarationToken"
				|| $class === "CssRulesetDeclarationToken"
			)
			{
				$declaration = $indent . $token->Property . ": ";
				if ($this->padding)
				{
					$declaration = str_pad($declaration, $this->padding, " ", STR_PAD_RIGHT);
				}
				$r[] = $declaration . $token->Value . ($token->IsImportant ? " !important" : "") . ";";
			}
			elseif ($class === "CssAtFontFaceEndToken"
				|| $class === "CssAtMediaEndToken"
				|| $class === "CssAtKeyframesEndToken"
				|| $class === "CssAtKeyframesRulesetEndToken"
				|| $class === "CssAtPageEndToken"
				|| $class === "CssAtVariablesEndToken"
				|| $class === "CssRulesetEndToken"
			)
			{
				$level--;
				$r[] = str_repeat($indent, $level) . "}";
			}
		}
		return implode("\n", $r);
	}
}

/**
 * This {@link aCssToken CSS token} is a utility token that extends {@link aNullToken} and returns only a empty string.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssNullToken extends aCssToken
{
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "";
	}
}

/**
 * CSS Minifier.
 *
 * @package		CssMin/Minifier
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssMinifier
{
	/**
	 * {@link aCssMinifierFilter Filters}.
	 *
	 * @var array
	 */
	private $filters = array();
	/**
	 * {@link aCssMinifierPlugin Plugins}.
	 *
	 * @var array
	 */
	private $plugins = array();
	/**
	 * Minified source.
	 *
	 * @var string
	 */
	private $minified = "";
	/**
	 * Constructer.
	 *
	 * Creates instances of {@link aCssMinifierFilter filters} and {@link aCssMinifierPlugin plugins}.
	 *
	 * @param string $source CSS source [optional]
	 * @param array $filters Filter configuration [optional]
	 * @param array $plugins Plugin configuration [optional]
	 * @return void
	 */
	public function __construct($source = null, array $filters = null, array $plugins = null)
	{
		$filters = array_merge(array
		                       (
		                       "ImportImports"					=> false,
		                       "RemoveComments"				=> true,
		                       "RemoveEmptyRulesets"			=> true,
		                       "RemoveEmptyAtBlocks"			=> true,
		                       "ConvertLevel3Properties"		=> false,
		                       "ConvertLevel3AtKeyframes"		=> false,
		                       "Variables"						=> true,
		                       "RemoveLastDelarationSemiColon"	=> true
		                       ), is_array($filters) ? $filters : array());
		$plugins = array_merge(array
		                       (
		                       "Variables"						=> true,
		                       "ConvertFontWeight"				=> false,
		                       "ConvertHslColors"				=> false,
		                       "ConvertRgbColors"				=> false,
		                       "ConvertNamedColors"			=> false,
		                       "CompressColorValues"			=> false,
		                       "CompressUnitValues"			=> false,
		                       "CompressExpressionValues"		=> false
		                       ), is_array($plugins) ? $plugins : array());
		// Filters
		foreach ($filters as $name => $config)
		{
			if ($config !== false)
			{
				$class	= "Css" . $name . "MinifierFilter";
				$config = is_array($config) ? $config : array();
				if (class_exists($class))
				{
					$this->filters[] = new $class($this, $config);
				}
				else
				{
					CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": The filter <code>" . $name . "</code> with the class name <code>" . $class . "</code> was not found"));
				}
			}
		}
		// Plugins
		foreach ($plugins as $name => $config)
		{
			if ($config !== false)
			{
				$class	= "Css" . $name . "MinifierPlugin";
				$config = is_array($config) ? $config : array();
				if (class_exists($class))
				{
					$this->plugins[] = new $class($this, $config);
				}
				else
				{
					CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": The plugin <code>" . $name . "</code> with the class name <code>" . $class . "</code> was not found"));
				}
			}
		}
		// --
		if (!is_null($source))
		{
			$this->minify($source);
		}
	}
	/**
	 * Returns the minified Source.
	 *
	 * @return string
	 */
	public function getMinified()
	{
		return $this->minified;
	}
	/**
	 * Returns a plugin by class name.
	 *
	 * @param string $name Class name of the plugin
	 * @return aCssMinifierPlugin
	 */
	public function getPlugin($class)
	{
		static $index = null;
		if (is_null($index))
		{
			$index = array();
			for ($i = 0, $l = count($this->plugins); $i < $l; $i++)
			{
				$index[get_class($this->plugins[$i])] = $i;
			}
		}
		return isset($index[$class]) ? $this->plugins[$index[$class]] : false;
	}
	/**
	 * Minifies the CSS source.
	 *
	 * @param string $source CSS source
	 * @return string
	 */
	public function minify($source)
	{
		// Variables
		$r						= "";
		$parser					= new CssParser($source);
		$tokens					= $parser->getTokens();
		$filters 				= $this->filters;
		$filterCount			= count($this->filters);
		$plugins				= $this->plugins;
		$pluginCount			= count($plugins);
		$pluginIndex			= array();
		$pluginTriggerTokens	= array();
		$globalTriggerTokens	= array();
		for ($i = 0, $l = count($plugins); $i < $l; $i++)
		{
			$tPluginClassName				= get_class($plugins[$i]);
			$pluginTriggerTokens[$i]		= $plugins[$i]->getTriggerTokens();
			foreach ($pluginTriggerTokens[$i] as $v)
			{
				if (!in_array($v, $globalTriggerTokens))
				{
					$globalTriggerTokens[] = $v;
				}
			}
			$pluginTriggerTokens[$i] = "|" . implode("|", $pluginTriggerTokens[$i]) . "|";
			$pluginIndex[$tPluginClassName]	= $i;
		}
		$globalTriggerTokens = "|" . implode("|", $globalTriggerTokens) . "|";
		/*
		 * Apply filters
		 */
		for($i = 0; $i < $filterCount; $i++)
		{
			// Apply the filter; if the return value is larger than 0...
			if ($filters[$i]->apply($tokens) > 0)
			{
				// ...then filter null values and rebuild the token array
				$tokens = array_values(array_filter($tokens));
			}
		}
		$tokenCount = count($tokens);
		/*
		 * Apply plugins
		 */
		for($i = 0; $i < $tokenCount; $i++)
		{
			$triggerToken = "|" . get_class($tokens[$i]) . "|";
			if (strpos($globalTriggerTokens, $triggerToken) !== false)
			{
				for($ii = 0; $ii < $pluginCount; $ii++)
				{
					if (strpos($pluginTriggerTokens[$ii], $triggerToken) !== false || $pluginTriggerTokens[$ii] === false)
					{
						// Apply the plugin; if the return value is TRUE continue to the next token
						if ($plugins[$ii]->apply($tokens[$i]) === true)
						{
							continue 2;
						}
					}
				}
			}
		}
		// Stringify the tokens
		for($i = 0; $i < $tokenCount; $i++)
		{
			$r .= (string) $tokens[$i];
		}
		$this->minified = $r;
		return $r;
	}
}

/**
 * CssMin - A (simple) css minifier with benefits
 *
 * --
 * Copyright (c) 2011 Joe Scylla <joe.scylla@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * --
 *
 * @package		CssMin
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssMin
{
	/**
	 * Index of classes
	 *
	 * @var array
	 */
	private static $classIndex = array();
	/**
	 * Parse/minify errors
	 *
	 * @var array
	 */
	private static $errors = array();
	/**
	 * Verbose output.
	 *
	 * @var boolean
	 */
	private static $isVerbose = false;
	/**
	 * {@link http://goo.gl/JrW54 Autoload} function of CssMin.
	 *
	 * @param string $class Name of the class
	 * @return void
	 */
	public static function autoload($class)
	{
		if (isset(self::$classIndex[$class]))
		{
			require(self::$classIndex[$class]);
		}
	}
	/**
	 * Return errors
	 *
	 * @return array of {CssError}.
	 */
	public static function getErrors()
	{
		return self::$errors;
	}
	/**
	 * Returns if there were errors.
	 *
	 * @return boolean
	 */
	public static function hasErrors()
	{
		return count(self::$errors) > 0;
	}
	/**
	 * Initialises CssMin.
	 *
	 * @return void
	 */
	public static function initialise()
	{
		// Create the class index for autoloading or including
		$paths = array(dirname(__FILE__));
		while (list($i, $path) = each($paths))
		{
			$subDirectorys = glob($path . "*", GLOB_MARK | GLOB_ONLYDIR | GLOB_NOSORT);
			if (is_array($subDirectorys))
			{
				foreach ($subDirectorys as $subDirectory)
				{
					$paths[] = $subDirectory;
				}
			}
			$files = glob($path . "*.php", 0);
			if (is_array($files))
			{
				foreach ($files as $file)
				{
					$class = substr(basename($file), 0, -4);
					self::$classIndex[$class] = $file;
				}
			}
		}
		krsort(self::$classIndex);
		// Only use autoloading if spl_autoload_register() is available and no __autoload() is defined (because
		// __autoload() breaks if spl_autoload_register() is used.
		if (function_exists("spl_autoload_register") && !is_callable("__autoload"))
		{
			spl_autoload_register(array(__CLASS__, "autoload"));
		}
		// Otherwise include all class files
		else
		{
			foreach (self::$classIndex as $class => $file)
			{
				if (!class_exists($class))
				{
					require_once($file);
				}
			}
		}
	}
	/**
	 * Minifies CSS source.
	 *
	 * @param string $source CSS source
	 * @param array $filters Filter configuration [optional]
	 * @param array $plugins Plugin configuration [optional]
	 * @return string Minified CSS
	 */
	public static function minify($source, array $filters = null, array $plugins = null)
	{
		self::$errors = array();
		$minifier = new CssMinifier($source, $filters, $plugins);
		return $minifier->getMinified();
	}
	/**
	 * Parse the CSS source.
	 *
	 * @param string $source CSS source
	 * @param array $plugins Plugin configuration [optional]
	 * @return array Array of aCssToken
	 */
	public static function parse($source, array $plugins = null)
	{
		self::$errors = array();
		$parser = new CssParser($source, $plugins);
		return $parser->getTokens();
	}
	/**
	 * --
	 *
	 * @param boolean $to
	 * @return boolean
	 */
	public static function setVerbose($to)
	{
		self::$isVerbose = (boolean) $to;
		return self::$isVerbose;
	}
	/**
	 * --
	 *
	 * @param CssError $error
	 * @return void
	 */
	public static function triggerError(CssError $error)
	{
		self::$errors[] = $error;
		if (self::$isVerbose)
		{
			trigger_error((string) $error, E_USER_WARNING);
		}
	}
}
// Initialises CssMin
CssMin::initialise();

/**
 * This {@link aCssMinifierFilter minifier filter} import external css files defined with the @import at-rule into the
 * current stylesheet.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssImportImportsMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Array with already imported external stylesheets.
	 *
	 * @var array
	 */
	private $imported = array();
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		if (!isset($this->configuration["BasePath"]) || !is_dir($this->configuration["BasePath"]))
		{
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Base path <code>" . ($this->configuration["BasePath"] ? $this->configuration["BasePath"] : "null"). "</code> is not a directory"));
			return 0;
		}
		for ($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			if (get_class($tokens[$i]) === "CssAtImportToken")
			{
				$import = $this->configuration["BasePath"] . "/" . $tokens[$i]->Import;
				// Import file was not found/is not a file
				if (!is_file($import))
				{
					CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Import file <code>" . $import. "</code> was not found.", (string) $tokens[$i]));
				}
				// Import file already imported; remove this @import at-rule to prevent recursions
				elseif (in_array($import, $this->imported))
				{
					CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Import file <code>" . $import. "</code> was already imported.", (string) $tokens[$i]));
					$tokens[$i] = null;
				}
				else
				{
					$this->imported[] = $import;
					$parser = new CssParser(file_get_contents($import));
					$import = $parser->getTokens();
					// The @import at-rule has media types defined requiring special handling
					if (count($tokens[$i]->MediaTypes) > 0 && !(count($tokens[$i]->MediaTypes) == 1 && $tokens[$i]->MediaTypes[0] == "all"))
					{
						$blocks = array();
						/*
						 * Filter or set media types of @import at-rule or remove the @import at-rule if no media type is matching the parent @import at-rule
						 */
						for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
						{
							if (get_class($import[$ii]) === "CssAtImportToken")
							{
								// @import at-rule defines no media type or only the "all" media type; set the media types to the one defined in the parent @import at-rule
								if (count($import[$ii]->MediaTypes) == 0 || (count($import[$ii]->MediaTypes) == 1 && $import[$ii]->MediaTypes[0] == "all"))
								{
									$import[$ii]->MediaTypes = $tokens[$i]->MediaTypes;
								}
								// @import at-rule defineds one or more media types; filter out media types not matching with the  parent @import at-rule
								elseif (count($import[$ii]->MediaTypes > 0))
								{
									foreach ($import[$ii]->MediaTypes as $index => $mediaType)
									{
										if (!in_array($mediaType, $tokens[$i]->MediaTypes))
										{
											unset($import[$ii]->MediaTypes[$index]);
										}
									}
									$import[$ii]->MediaTypes = array_values($import[$ii]->MediaTypes);
									// If there are no media types left in the @import at-rule remove the @import at-rule
									if (count($import[$ii]->MediaTypes) == 0)
									{
										$import[$ii] = null;
									}
								}
							}
						}
						/*
						 * Remove media types of @media at-rule block not defined in the @import at-rule
						 */
						for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
						{
							if (get_class($import[$ii]) === "CssAtMediaStartToken")
							{
								foreach ($import[$ii]->MediaTypes as $index => $mediaType)
								{
									if (!in_array($mediaType, $tokens[$i]->MediaTypes))
									{
										unset($import[$ii]->MediaTypes[$index]);
									}
									$import[$ii]->MediaTypes = array_values($import[$ii]->MediaTypes);
								}
							}
						}
						/*
						 * If no media types left of the @media at-rule block remove the complete block
						 */
						for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
						{
							if (get_class($import[$ii]) === "CssAtMediaStartToken")
							{
								if (count($import[$ii]->MediaTypes) === 0)
								{
									for ($iii = $ii; $iii < $ll; $iii++)
									{
										if (get_class($import[$iii]) === "CssAtMediaEndToken")
										{
											break;
										}
									}
									if (get_class($import[$iii]) === "CssAtMediaEndToken")
									{
										array_splice($import, $ii, $iii - $ii + 1, array());
										$ll = count($import);
									}
								}
							}
						}
						/*
						 * If the media types of the @media at-rule equals the media types defined in the @import
						 * at-rule remove the CssAtMediaStartToken and CssAtMediaEndToken token
						 */
						for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
						{
							if (get_class($import[$ii]) === "CssAtMediaStartToken" && count(array_diff($tokens[$i]->MediaTypes, $import[$ii]->MediaTypes)) === 0)
							{
								for ($iii = $ii; $iii < $ll; $iii++)
								{
									if (get_class($import[$iii]) == "CssAtMediaEndToken")
									{
										break;
									}
								}
								if (get_class($import[$iii]) == "CssAtMediaEndToken")
								{
									unset($import[$ii]);
									unset($import[$iii]);
									$import = array_values($import);
									$ll = count($import);
								}
							}
						}
						/**
						 * Extract CssAtImportToken and CssAtCharsetToken tokens
						 */
						for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
						{
							$class = get_class($import[$ii]);
							if ($class === "CssAtImportToken" || $class === "CssAtCharsetToken")
							{
								$blocks = array_merge($blocks, array_splice($import, $ii, 1, array()));
								$ll = count($import);
							}
						}
						/*
						 * Extract the @font-face, @media and @page at-rule block
						 */
						for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
						{
							$class = get_class($import[$ii]);
							if ($class === "CssAtFontFaceStartToken" || $class === "CssAtMediaStartToken" || $class === "CssAtPageStartToken" || $class === "CssAtVariablesStartToken")
							{
								for ($iii = $ii; $iii < $ll; $iii++)
								{
									$class = get_class($import[$iii]);
									if ($class === "CssAtFontFaceEndToken" || $class === "CssAtMediaEndToken" || $class === "CssAtPageEndToken" || $class === "CssAtVariablesEndToken")
									{
										break;
									}
								}
								$class = get_class($import[$iii]);
								if (isset($import[$iii]) && ($class === "CssAtFontFaceEndToken" || $class === "CssAtMediaEndToken" || $class === "CssAtPageEndToken" || $class === "CssAtVariablesEndToken"))
								{
									$blocks = array_merge($blocks, array_splice($import, $ii, $iii - $ii + 1, array()));
									$ll = count($import);
								}
							}
						}
						// Create the import array with extracted tokens and the rulesets wrapped into a @media at-rule block
						$import = array_merge($blocks, array(new CssAtMediaStartToken($tokens[$i]->MediaTypes)), $import, array(new CssAtMediaEndToken()));
					}
					// Insert the imported tokens
					array_splice($tokens, $i, 1, $import);
					// Modify parameters of the for-loop
					$i--;
					$l = count($tokens);
				}
			}
		}
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for preserve parsing expression() declaration values.
 *
 * This plugin return no {@link aCssToken CssToken} but ensures that expression() declaration values will get parsed
 * properly.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssExpressionParserPlugin extends aCssParserPlugin
{
	/**
	 * Count of left braces.
	 *
	 * @var integer
	 */
	private $leftBraces = 0;
	/**
	 * Count of right braces.
	 *
	 * @var integer
	 */
	private $rightBraces = 0;
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("(", ")", ";", "}");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return false;
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		// Start of expression
		if ($char === "(" && strtolower(substr($this->parser->getSource(), $index - 10, 11)) === "expression(" && $state !== "T_EXPRESSION")
		{
			$this->parser->pushState("T_EXPRESSION");
			$this->leftBraces++;
		}
		// Count left braces
		elseif ($char === "(" && $state === "T_EXPRESSION")
		{
			$this->leftBraces++;
		}
		// Count right braces
		elseif ($char === ")" && $state === "T_EXPRESSION")
		{
			$this->rightBraces++;
		}
		// Possible end of expression; if left and right braces are equal the expressen ends
		elseif (($char === ";" || $char === "}") && $state === "T_EXPRESSION" && $this->leftBraces === $this->rightBraces)
		{
			$this->leftBraces = $this->rightBraces = 0;
			$this->parser->popState();
			return $index - 1;
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * CSS Error.
 *
 * @package		CssMin
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssError
{
	/**
	 * File.
	 *
	 * @var string
	 */
	public $File = "";
	/**
	 * Line.
	 *
	 * @var integer
	 */
	public $Line = 0;
	/**
	 * Error message.
	 *
	 * @var string
	 */
	public $Message = "";
	/**
	 * Source.
	 *
	 * @var string
	 */
	public $Source = "";
	/**
	 * Constructor triggering the error.
	 *
	 * @param string $message Error message
	 * @param string $source Corresponding line [optional]
	 * @return void
	 */
	public function __construct($file, $line, $message, $source = "")
	{
		$this->File		= $file;
		$this->Line		= $line;
		$this->Message	= $message;
		$this->Source	= $source;
	}
	/**
	 * Returns the error as formatted string.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return $this->Message . ($this->Source ? ": <br /><code>" . $this->Source . "</code>": "") . "<br />in file " . $this->File . " at line " . $this->Line;
	}
}

/**
 * This {@link aCssMinifierPlugin} will convert a color value in rgb notation to hexadecimal notation.
 *
 * Example:
 * <code>
 * color: rgb(200,60%,5);
 * </code>
 *
 * Will get converted to:
 * <code>
 * color:#c89905;
 * </code>
 *
 * @package		CssMin/Minifier/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssConvertRgbColorsMinifierPlugin extends aCssMinifierPlugin
{
	/**
	 * Regular expression matching the value.
	 *
	 * @var string
	 */
	private $reMatch = "/rgb\s*\(\s*([0-9%]+)\s*,\s*([0-9%]+)\s*,\s*([0-9%]+)\s*\)/iS";
	/**
	 * Implements {@link aCssMinifierPlugin::minify()}.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	public function apply(aCssToken &$token)
	{
		if (stripos($token->Value, "rgb") !== false && preg_match($this->reMatch, $token->Value, $m))
		{
			for ($i = 1, $l = count($m); $i < $l; $i++)
			{
				if (strpos("%", $m[$i]) !== false)
				{
					$m[$i] = substr($m[$i], 0, -1);
					$m[$i] = (int) (256 * ($m[$i] / 100));
				}
				$m[$i] = str_pad(dechex($m[$i]),  2, "0", STR_PAD_LEFT);
			}
			$token->Value = str_replace($m[0], "#" . $m[1] . $m[2] . $m[3], $token->Value);
		}
		return false;
	}
	/**
	 * Implements {@link aMinifierPlugin::getTriggerTokens()}
	 *
	 * @return array
	 */
	public function getTriggerTokens()
	{
		return array
		(
			"CssAtFontFaceDeclarationToken",
			"CssAtPageDeclarationToken",
			"CssRulesetDeclarationToken"
		);
	}
}

/**
 * This {@link aCssMinifierPlugin} will convert named color values to hexadecimal notation.
 *
 * Example:
 * <code>
 * color: black;
 * border: 1px solid indigo;
 * </code>
 *
 * Will get converted to:
 * <code>
 * color:#000;
 * border:1px solid #4b0082;
 * </code>
 *
 * @package		CssMin/Minifier/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssConvertNamedColorsMinifierPlugin extends aCssMinifierPlugin
{

	/**
	 * Regular expression matching the value.
	 *
	 * @var string
	 */
	private $reMatch = null;
	/**
	 * Transformation table used by the {@link CssConvertNamedColorsMinifierPlugin::reReplace() replacement method}.
	 *
	 * @var array
	 */
	private $transformation = array
	(
		"aliceblue"						=> "#f0f8ff",
		"antiquewhite"					=> "#faebd7",
		"aqua"							=> "#0ff",
		"aquamarine"					=> "#7fffd4",
		"azure"							=> "#f0ffff",
		"beige"							=> "#f5f5dc",
		"black"							=> "#000",
		"blue"							=> "#00f",
		"blueviolet"					=> "#8a2be2",
		"brown"							=> "#a52a2a",
		"burlywood"						=> "#deb887",
		"cadetblue"						=> "#5f9ea0",
		"chartreuse"					=> "#7fff00",
		"chocolate"						=> "#d2691e",
		"coral"							=> "#ff7f50",
		"cornflowerblue"				=> "#6495ed",
		"cornsilk"						=> "#fff8dc",
		"crimson"						=> "#dc143c",
		"darkblue"						=> "#00008b",
		"darkcyan"						=> "#008b8b",
		"darkgoldenrod"					=> "#b8860b",
		"darkgray"						=> "#a9a9a9",
		"darkgreen"						=> "#006400",
		"darkkhaki"						=> "#bdb76b",
		"darkmagenta"					=> "#8b008b",
		"darkolivegreen"				=> "#556b2f",
		"darkorange"					=> "#ff8c00",
		"darkorchid"					=> "#9932cc",
		"darkred"						=> "#8b0000",
		"darksalmon"					=> "#e9967a",
		"darkseagreen"					=> "#8fbc8f",
		"darkslateblue"					=> "#483d8b",
		"darkslategray"					=> "#2f4f4f",
		"darkturquoise"					=> "#00ced1",
		"darkviolet"					=> "#9400d3",
		"deeppink"						=> "#ff1493",
		"deepskyblue"					=> "#00bfff",
		"dimgray"						=> "#696969",
		"dodgerblue"					=> "#1e90ff",
		"firebrick"						=> "#b22222",
		"floralwhite"					=> "#fffaf0",
		"forestgreen"					=> "#228b22",
		"fuchsia"						=> "#f0f",
		"gainsboro"						=> "#dcdcdc",
		"ghostwhite"					=> "#f8f8ff",
		"gold"							=> "#ffd700",
		"goldenrod"						=> "#daa520",
		"gray"							=> "#808080",
		"green"							=> "#008000",
		"greenyellow"					=> "#adff2f",
		"honeydew"						=> "#f0fff0",
		"hotpink"						=> "#ff69b4",
		"indianred"						=> "#cd5c5c",
		"indigo"						=> "#4b0082",
		"ivory"							=> "#fffff0",
		"khaki"							=> "#f0e68c",
		"lavender"						=> "#e6e6fa",
		"lavenderblush"					=> "#fff0f5",
		"lawngreen"						=> "#7cfc00",
		"lemonchiffon"					=> "#fffacd",
		"lightblue"						=> "#add8e6",
		"lightcoral"					=> "#f08080",
		"lightcyan"						=> "#e0ffff",
		"lightgoldenrodyellow"			=> "#fafad2",
		"lightgreen"					=> "#90ee90",
		"lightgrey"						=> "#d3d3d3",
		"lightpink"						=> "#ffb6c1",
		"lightsalmon"					=> "#ffa07a",
		"lightseagreen"					=> "#20b2aa",
		"lightskyblue"					=> "#87cefa",
		"lightslategray"				=> "#789",
		"lightsteelblue"				=> "#b0c4de",
		"lightyellow"					=> "#ffffe0",
		"lime"							=> "#0f0",
		"limegreen"						=> "#32cd32",
		"linen"							=> "#faf0e6",
		"maroon"						=> "#800000",
		"mediumaquamarine"				=> "#66cdaa",
		"mediumblue"					=> "#0000cd",
		"mediumorchid"					=> "#ba55d3",
		"mediumpurple"					=> "#9370db",
		"mediumseagreen"				=> "#3cb371",
		"mediumslateblue"				=> "#7b68ee",
		"mediumspringgreen"				=> "#00fa9a",
		"mediumturquoise"				=> "#48d1cc",
		"mediumvioletred"				=> "#c71585",
		"midnightblue"					=> "#191970",
		"mintcream"						=> "#f5fffa",
		"mistyrose"						=> "#ffe4e1",
		"moccasin"						=> "#ffe4b5",
		"navajowhite"					=> "#ffdead",
		"navy"							=> "#000080",
		"oldlace"						=> "#fdf5e6",
		"olive"							=> "#808000",
		"olivedrab"						=> "#6b8e23",
		"orange"						=> "#ffa500",
		"orangered"						=> "#ff4500",
		"orchid"						=> "#da70d6",
		"palegoldenrod"					=> "#eee8aa",
		"palegreen"						=> "#98fb98",
		"paleturquoise"					=> "#afeeee",
		"palevioletred"					=> "#db7093",
		"papayawhip"					=> "#ffefd5",
		"peachpuff"						=> "#ffdab9",
		"peru"							=> "#cd853f",
		"pink"							=> "#ffc0cb",
		"plum"							=> "#dda0dd",
		"powderblue"					=> "#b0e0e6",
		"purple"						=> "#800080",
		"red"							=> "#f00",
		"rosybrown"						=> "#bc8f8f",
		"royalblue"						=> "#4169e1",
		"saddlebrown"					=> "#8b4513",
		"salmon"						=> "#fa8072",
		"sandybrown"					=> "#f4a460",
		"seagreen"						=> "#2e8b57",
		"seashell"						=> "#fff5ee",
		"sienna"						=> "#a0522d",
		"silver"						=> "#c0c0c0",
		"skyblue"						=> "#87ceeb",
		"slateblue"						=> "#6a5acd",
		"slategray"						=> "#708090",
		"snow"							=> "#fffafa",
		"springgreen"					=> "#00ff7f",
		"steelblue"						=> "#4682b4",
		"tan"							=> "#d2b48c",
		"teal"							=> "#008080",
		"thistle"						=> "#d8bfd8",
		"tomato"						=> "#ff6347",
		"turquoise"						=> "#40e0d0",
		"violet"						=> "#ee82ee",
		"wheat"							=> "#f5deb3",
		"white"							=> "#fff",
		"whitesmoke"					=> "#f5f5f5",
		"yellow"						=> "#ff0",
		"yellowgreen"					=> "#9acd32"
	);
	/**
	 * Overwrites {@link aCssMinifierPlugin::__construct()}.
	 *
	 * The constructor will create the {@link CssConvertNamedColorsMinifierPlugin::$reMatch replace regular expression}
	 * based on the {@link CssConvertNamedColorsMinifierPlugin::$transformation transformation table}.
	 *
	 * @param CssMinifier $minifier The CssMinifier object of this plugin.
	 * @param array $configuration Plugin configuration [optional]
	 * @return void
	 */
	public function __construct(CssMinifier $minifier, array $configuration = array())
	{
		$this->reMatch = "/(^|\s)+(" . implode("|", array_keys($this->transformation)) . ")(\s|$)+/iS";
		parent::__construct($minifier, $configuration);
	}
	/**
	 * Implements {@link aCssMinifierPlugin::minify()}.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	public function apply(aCssToken &$token)
	{
		$lcValue = strtolower($token->Value);
		// Declaration value equals a value in the transformation table => simple replace
		if (isset($this->transformation[$lcValue]))
		{
			$token->Value = $this->transformation[$lcValue];
		}
		// Declaration value contains a value in the transformation table => regular expression replace
		elseif (preg_match($this->reMatch, $token->Value))
		{
			$token->Value = preg_replace_callback($this->reMatch, array($this, 'reReplace'), $token->Value);
		}
		return false;
	}
	/**
	 * Callback for replacement value.
	 *
	 * @param array $match
	 * @return string
	 */
	private function reReplace($match)
	{
		return $match[1] . $this->transformation[strtolower($match[2])] . $match[3];
	}
	/**
	 * Implements {@link aMinifierPlugin::getTriggerTokens()}
	 *
	 * @return array
	 */
	public function getTriggerTokens()
	{
		return array
		(
			"CssAtFontFaceDeclarationToken",
			"CssAtPageDeclarationToken",
			"CssRulesetDeclarationToken"
		);
	}
}

/**
 * This {@link aCssMinifierFilter minifier filter} triggers on CSS Level 3 properties and will add declaration tokens
 * with browser-specific properties.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssConvertLevel3PropertiesMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Css property transformations table. Used to convert CSS3 and proprietary properties to the browser-specific
	 * counterparts.
	 *
	 * @var array
	 */
	private $transformations = array
	(
		// Property						Array(Mozilla, Webkit, Opera, Internet Explorer); NULL values are placeholders and will get ignored
		"animation"						=> array(null, "-webkit-animation", null, null),
		"animation-delay"				=> array(null, "-webkit-animation-delay", null, null),
		"animation-direction" 			=> array(null, "-webkit-animation-direction", null, null),
		"animation-duration"			=> array(null, "-webkit-animation-duration", null, null),
		"animation-fill-mode"			=> array(null, "-webkit-animation-fill-mode", null, null),
		"animation-iteration-count"		=> array(null, "-webkit-animation-iteration-count", null, null),
		"animation-name"				=> array(null, "-webkit-animation-name", null, null),
		"animation-play-state"			=> array(null, "-webkit-animation-play-state", null, null),
		"animation-timing-function"		=> array(null, "-webkit-animation-timing-function", null, null),
		"appearance"					=> array("-moz-appearance", "-webkit-appearance", null, null),
		"backface-visibility"			=> array(null, "-webkit-backface-visibility", null, null),
		"background-clip"				=> array(null, "-webkit-background-clip", null, null),
		"background-composite"			=> array(null, "-webkit-background-composite", null, null),
		"background-inline-policy"		=> array("-moz-background-inline-policy", null, null, null),
		"background-origin"				=> array(null, "-webkit-background-origin", null, null),
		"background-position-x"			=> array(null, null, null, "-ms-background-position-x"),
		"background-position-y"			=> array(null, null, null, "-ms-background-position-y"),
		"background-size"				=> array(null, "-webkit-background-size", null, null),
		"behavior"						=> array(null, null, null, "-ms-behavior"),
		"binding"						=> array("-moz-binding", null, null, null),
		"border-after"					=> array(null, "-webkit-border-after", null, null),
		"border-after-color"			=> array(null, "-webkit-border-after-color", null, null),
		"border-after-style"			=> array(null, "-webkit-border-after-style", null, null),
		"border-after-width"			=> array(null, "-webkit-border-after-width", null, null),
		"border-before"					=> array(null, "-webkit-border-before", null, null),
		"border-before-color"			=> array(null, "-webkit-border-before-color", null, null),
		"border-before-style"			=> array(null, "-webkit-border-before-style", null, null),
		"border-before-width"			=> array(null, "-webkit-border-before-width", null, null),
		"border-border-bottom-colors"	=> array("-moz-border-bottom-colors", null, null, null),
		"border-bottom-left-radius"		=> array("-moz-border-radius-bottomleft", "-webkit-border-bottom-left-radius", null, null),
		"border-bottom-right-radius"	=> array("-moz-border-radius-bottomright", "-webkit-border-bottom-right-radius", null, null),
		"border-end"					=> array("-moz-border-end", "-webkit-border-end", null, null),
		"border-end-color"				=> array("-moz-border-end-color", "-webkit-border-end-color", null, null),
		"border-end-style"				=> array("-moz-border-end-style", "-webkit-border-end-style", null, null),
		"border-end-width"				=> array("-moz-border-end-width", "-webkit-border-end-width", null, null),
		"border-fit"					=> array(null, "-webkit-border-fit", null, null),
		"border-horizontal-spacing"		=> array(null, "-webkit-border-horizontal-spacing", null, null),
		"border-image"					=> array("-moz-border-image", "-webkit-border-image", null, null),
		"border-left-colors"			=> array("-moz-border-left-colors", null, null, null),
		"border-radius"					=> array("-moz-border-radius", "-webkit-border-radius", null, null),
		"border-border-right-colors"	=> array("-moz-border-right-colors", null, null, null),
		"border-start"					=> array("-moz-border-start", "-webkit-border-start", null, null),
		"border-start-color"			=> array("-moz-border-start-color", "-webkit-border-start-color", null, null),
		"border-start-style"			=> array("-moz-border-start-style", "-webkit-border-start-style", null, null),
		"border-start-width"			=> array("-moz-border-start-width", "-webkit-border-start-width", null, null),
		"border-top-colors"				=> array("-moz-border-top-colors", null, null, null),
		"border-top-left-radius"		=> array("-moz-border-radius-topleft", "-webkit-border-top-left-radius", null, null),
		"border-top-right-radius"		=> array("-moz-border-radius-topright", "-webkit-border-top-right-radius", null, null),
		"border-vertical-spacing"		=> array(null, "-webkit-border-vertical-spacing", null, null),
		"box-align"						=> array("-moz-box-align", "-webkit-box-align", null, null),
		"box-direction"					=> array("-moz-box-direction", "-webkit-box-direction", null, null),
		"box-flex"						=> array("-moz-box-flex", "-webkit-box-flex", null, null),
		"box-flex-group"				=> array(null, "-webkit-box-flex-group", null, null),
		"box-flex-lines"				=> array(null, "-webkit-box-flex-lines", null, null),
		"box-ordinal-group"				=> array("-moz-box-ordinal-group", "-webkit-box-ordinal-group", null, null),
		"box-orient"					=> array("-moz-box-orient", "-webkit-box-orient", null, null),
		"box-pack"						=> array("-moz-box-pack", "-webkit-box-pack", null, null),
		"box-reflect"					=> array(null, "-webkit-box-reflect", null, null),
		"box-shadow"					=> array("-moz-box-shadow", "-webkit-box-shadow", null, null),
		"box-sizing"					=> array("-moz-box-sizing", null, null, null),
		"color-correction"				=> array(null, "-webkit-color-correction", null, null),
		"column-break-after"			=> array(null, "-webkit-column-break-after", null, null),
		"column-break-before"			=> array(null, "-webkit-column-break-before", null, null),
		"column-break-inside"			=> array(null, "-webkit-column-break-inside", null, null),
		"column-count"					=> array("-moz-column-count", "-webkit-column-count", null, null),
		"column-gap"					=> array("-moz-column-gap", "-webkit-column-gap", null, null),
		"column-rule"					=> array("-moz-column-rule", "-webkit-column-rule", null, null),
		"column-rule-color"				=> array("-moz-column-rule-color", "-webkit-column-rule-color", null, null),
		"column-rule-style"				=> array("-moz-column-rule-style", "-webkit-column-rule-style", null, null),
		"column-rule-width"				=> array("-moz-column-rule-width", "-webkit-column-rule-width", null, null),
		"column-span"					=> array(null, "-webkit-column-span", null, null),
		"column-width"					=> array("-moz-column-width", "-webkit-column-width", null, null),
		"columns"						=> array(null, "-webkit-columns", null, null),
		"filter"						=> array(__CLASS__, "filter"),
		"float-edge"					=> array("-moz-float-edge", null, null, null),
		"font-feature-settings"			=> array("-moz-font-feature-settings", null, null, null),
		"font-language-override"		=> array("-moz-font-language-override", null, null, null),
		"font-size-delta"				=> array(null, "-webkit-font-size-delta", null, null),
		"font-smoothing"				=> array(null, "-webkit-font-smoothing", null, null),
		"force-broken-image-icon"		=> array("-moz-force-broken-image-icon", null, null, null),
		"highlight"						=> array(null, "-webkit-highlight", null, null),
		"hyphenate-character"			=> array(null, "-webkit-hyphenate-character", null, null),
		"hyphenate-locale"				=> array(null, "-webkit-hyphenate-locale", null, null),
		"hyphens"						=> array(null, "-webkit-hyphens", null, null),
		"force-broken-image-icon"		=> array("-moz-image-region", null, null, null),
		"ime-mode"						=> array(null, null, null, "-ms-ime-mode"),
		"interpolation-mode"			=> array(null, null, null, "-ms-interpolation-mode"),
		"layout-flow"					=> array(null, null, null, "-ms-layout-flow"),
		"layout-grid"					=> array(null, null, null, "-ms-layout-grid"),
		"layout-grid-char"				=> array(null, null, null, "-ms-layout-grid-char"),
		"layout-grid-line"				=> array(null, null, null, "-ms-layout-grid-line"),
		"layout-grid-mode"				=> array(null, null, null, "-ms-layout-grid-mode"),
		"layout-grid-type"				=> array(null, null, null, "-ms-layout-grid-type"),
		"line-break"					=> array(null, "-webkit-line-break", null, "-ms-line-break"),
		"line-clamp"					=> array(null, "-webkit-line-clamp", null, null),
		"line-grid-mode"				=> array(null, null, null, "-ms-line-grid-mode"),
		"logical-height"				=> array(null, "-webkit-logical-height", null, null),
		"logical-width"					=> array(null, "-webkit-logical-width", null, null),
		"margin-after"					=> array(null, "-webkit-margin-after", null, null),
		"margin-after-collapse"			=> array(null, "-webkit-margin-after-collapse", null, null),
		"margin-before"					=> array(null, "-webkit-margin-before", null, null),
		"margin-before-collapse"		=> array(null, "-webkit-margin-before-collapse", null, null),
		"margin-bottom-collapse"		=> array(null, "-webkit-margin-bottom-collapse", null, null),
		"margin-collapse"				=> array(null, "-webkit-margin-collapse", null, null),
		"margin-end"					=> array("-moz-margin-end", "-webkit-margin-end", null, null),
		"margin-start"					=> array("-moz-margin-start", "-webkit-margin-start", null, null),
		"margin-top-collapse"			=> array(null, "-webkit-margin-top-collapse", null, null),
		"marquee "						=> array(null, "-webkit-marquee", null, null),
		"marquee-direction"				=> array(null, "-webkit-marquee-direction", null, null),
		"marquee-increment"				=> array(null, "-webkit-marquee-increment", null, null),
		"marquee-repetition"			=> array(null, "-webkit-marquee-repetition", null, null),
		"marquee-speed"					=> array(null, "-webkit-marquee-speed", null, null),
		"marquee-style"					=> array(null, "-webkit-marquee-style", null, null),
		"mask"							=> array(null, "-webkit-mask", null, null),
		"mask-attachment"				=> array(null, "-webkit-mask-attachment", null, null),
		"mask-box-image"				=> array(null, "-webkit-mask-box-image", null, null),
		"mask-clip"						=> array(null, "-webkit-mask-clip", null, null),
		"mask-composite"				=> array(null, "-webkit-mask-composite", null, null),
		"mask-image"					=> array(null, "-webkit-mask-image", null, null),
		"mask-origin"					=> array(null, "-webkit-mask-origin", null, null),
		"mask-position"					=> array(null, "-webkit-mask-position", null, null),
		"mask-position-x"				=> array(null, "-webkit-mask-position-x", null, null),
		"mask-position-y"				=> array(null, "-webkit-mask-position-y", null, null),
		"mask-repeat"					=> array(null, "-webkit-mask-repeat", null, null),
		"mask-repeat-x"					=> array(null, "-webkit-mask-repeat-x", null, null),
		"mask-repeat-y"					=> array(null, "-webkit-mask-repeat-y", null, null),
		"mask-size"						=> array(null, "-webkit-mask-size", null, null),
		"match-nearest-mail-blockquote-color" => array(null, "-webkit-match-nearest-mail-blockquote-color", null, null),
		"max-logical-height"			=> array(null, "-webkit-max-logical-height", null, null),
		"max-logical-width"				=> array(null, "-webkit-max-logical-width", null, null),
		"min-logical-height"			=> array(null, "-webkit-min-logical-height", null, null),
		"min-logical-width"				=> array(null, "-webkit-min-logical-width", null, null),
		"object-fit"					=> array(null, null, "-o-object-fit", null),
		"object-position"				=> array(null, null, "-o-object-position", null),
		"opacity"						=> array(__CLASS__, "opacity"),
		"outline-radius"				=> array("-moz-outline-radius", null, null, null),
		"outline-bottom-left-radius"	=> array("-moz-outline-radius-bottomleft", null, null, null),
		"outline-bottom-right-radius"	=> array("-moz-outline-radius-bottomright", null, null, null),
		"outline-top-left-radius"		=> array("-moz-outline-radius-topleft", null, null, null),
		"outline-top-right-radius"		=> array("-moz-outline-radius-topright", null, null, null),
		"padding-after"					=> array(null, "-webkit-padding-after", null, null),
		"padding-before"				=> array(null, "-webkit-padding-before", null, null),
		"padding-end"					=> array("-moz-padding-end", "-webkit-padding-end", null, null),
		"padding-start"					=> array("-moz-padding-start", "-webkit-padding-start", null, null),
		"perspective"					=> array(null, "-webkit-perspective", null, null),
		"perspective-origin"			=> array(null, "-webkit-perspective-origin", null, null),
		"perspective-origin-x"			=> array(null, "-webkit-perspective-origin-x", null, null),
		"perspective-origin-y"			=> array(null, "-webkit-perspective-origin-y", null, null),
		"rtl-ordering"					=> array(null, "-webkit-rtl-ordering", null, null),
		"scrollbar-3dlight-color"		=> array(null, null, null, "-ms-scrollbar-3dlight-color"),
		"scrollbar-arrow-color"			=> array(null, null, null, "-ms-scrollbar-arrow-color"),
		"scrollbar-base-color"			=> array(null, null, null, "-ms-scrollbar-base-color"),
		"scrollbar-darkshadow-color"	=> array(null, null, null, "-ms-scrollbar-darkshadow-color"),
		"scrollbar-face-color"			=> array(null, null, null, "-ms-scrollbar-face-color"),
		"scrollbar-highlight-color"		=> array(null, null, null, "-ms-scrollbar-highlight-color"),
		"scrollbar-shadow-color"		=> array(null, null, null, "-ms-scrollbar-shadow-color"),
		"scrollbar-track-color"			=> array(null, null, null, "-ms-scrollbar-track-color"),
		"stack-sizing"					=> array("-moz-stack-sizing", null, null, null),
		"svg-shadow"					=> array(null, "-webkit-svg-shadow", null, null),
		"tab-size"						=> array("-moz-tab-size", null, "-o-tab-size", null),
		"table-baseline"				=> array(null, null, "-o-table-baseline", null),
		"text-align-last"				=> array(null, null, null, "-ms-text-align-last"),
		"text-autospace"				=> array(null, null, null, "-ms-text-autospace"),
		"text-combine"					=> array(null, "-webkit-text-combine", null, null),
		"text-decorations-in-effect"	=> array(null, "-webkit-text-decorations-in-effect", null, null),
		"text-emphasis"					=> array(null, "-webkit-text-emphasis", null, null),
		"text-emphasis-color"			=> array(null, "-webkit-text-emphasis-color", null, null),
		"text-emphasis-position"		=> array(null, "-webkit-text-emphasis-position", null, null),
		"text-emphasis-style"			=> array(null, "-webkit-text-emphasis-style", null, null),
		"text-fill-color"				=> array(null, "-webkit-text-fill-color", null, null),
		"text-justify"					=> array(null, null, null, "-ms-text-justify"),
		"text-kashida-space"			=> array(null, null, null, "-ms-text-kashida-space"),
		"text-overflow"					=> array(null, null, "-o-text-overflow", "-ms-text-overflow"),
		"text-security"					=> array(null, "-webkit-text-security", null, null),
		"text-size-adjust"				=> array(null, "-webkit-text-size-adjust", null, "-ms-text-size-adjust"),
		"text-stroke"					=> array(null, "-webkit-text-stroke", null, null),
		"text-stroke-color"				=> array(null, "-webkit-text-stroke-color", null, null),
		"text-stroke-width"				=> array(null, "-webkit-text-stroke-width", null, null),
		"text-underline-position"		=> array(null, null, null, "-ms-text-underline-position"),
		"transform"						=> array("-moz-transform", "-webkit-transform", "-o-transform", null),
		"transform-origin"				=> array("-moz-transform-origin", "-webkit-transform-origin", "-o-transform-origin", null),
		"transform-origin-x"			=> array(null, "-webkit-transform-origin-x", null, null),
		"transform-origin-y"			=> array(null, "-webkit-transform-origin-y", null, null),
		"transform-origin-z"			=> array(null, "-webkit-transform-origin-z", null, null),
		"transform-style"				=> array(null, "-webkit-transform-style", null, null),
		"transition"					=> array("-moz-transition", "-webkit-transition", "-o-transition", null),
		"transition-delay"				=> array("-moz-transition-delay", "-webkit-transition-delay", "-o-transition-delay", null),
		"transition-duration"			=> array("-moz-transition-duration", "-webkit-transition-duration", "-o-transition-duration", null),
		"transition-property"			=> array("-moz-transition-property", "-webkit-transition-property", "-o-transition-property", null),
		"transition-timing-function"	=> array("-moz-transition-timing-function", "-webkit-transition-timing-function", "-o-transition-timing-function", null),
		"user-drag"						=> array(null, "-webkit-user-drag", null, null),
		"user-focus"					=> array("-moz-user-focus", null, null, null),
		"user-input"					=> array("-moz-user-input", null, null, null),
		"user-modify"					=> array("-moz-user-modify", "-webkit-user-modify", null, null),
		"user-select"					=> array("-moz-user-select", "-webkit-user-select", null, null),
		"white-space"					=> array(__CLASS__, "whiteSpace"),
		"window-shadow"					=> array("-moz-window-shadow", null, null, null),
		"word-break"					=> array(null, null, null, "-ms-word-break"),
		"word-wrap"						=> array(null, null, null, "-ms-word-wrap"),
		"writing-mode"					=> array(null, "-webkit-writing-mode", null, "-ms-writing-mode"),
		"zoom"							=> array(null, null, null, "-ms-zoom")
	);
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		$r = 0;
		$transformations = &$this->transformations;
		for ($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			if (get_class($tokens[$i]) === "CssRulesetDeclarationToken")
			{
				$tProperty = $tokens[$i]->Property;
				if (isset($transformations[$tProperty]))
				{
					$result = array();
					if (is_callable($transformations[$tProperty]))
					{
						$result = call_user_func_array($transformations[$tProperty], array($tokens[$i]));
						if (!is_array($result) && is_object($result))
						{
							$result = array($result);
						}
					}
					else
					{
						$tValue			= $tokens[$i]->Value;
						$tMediaTypes	= $tokens[$i]->MediaTypes;
						foreach ($transformations[$tProperty] as $property)
						{
							if ($property !== null)
							{
								$result[] = new CssRulesetDeclarationToken($property, $tValue, $tMediaTypes);
							}
						}
					}
					if (count($result) > 0)
					{
						array_splice($tokens, $i + 1, 0, $result);
						$i += count($result);
						$l += count($result);
					}
				}
			}
		}
		return $r;
	}
	/**
	 * Transforms the Internet Explorer specific declaration property "filter" to Internet Explorer 8+ compatible
	 * declaratiopn property "-ms-filter".
	 *
	 * @param aCssToken $token
	 * @return array
	 */
	private static function filter($token)
	{
		$r = array
		(
			new CssRulesetDeclarationToken("-ms-filter", "\"" . $token->Value . "\"", $token->MediaTypes),
		);
		return $r;
	}
	/**
	 * Transforms "opacity: {value}" into browser specific counterparts.
	 *
	 * @param aCssToken $token
	 * @return array
	 */
	private static function opacity($token)
	{
		// Calculate the value for Internet Explorer filter statement
		$ieValue = (int) ((float) $token->Value * 100);
		$r = array
		(
			// Internet Explorer >= 8
			new CssRulesetDeclarationToken("-ms-filter", "\"alpha(opacity=" . $ieValue . ")\"", $token->MediaTypes),
			// Internet Explorer >= 4 <= 7
			new CssRulesetDeclarationToken("filter", "alpha(opacity=" . $ieValue . ")", $token->MediaTypes),
			new CssRulesetDeclarationToken("zoom", "1", $token->MediaTypes)
		);
		return $r;
	}
	/**
	 * Transforms "white-space: pre-wrap" into browser specific counterparts.
	 *
	 * @param aCssToken $token
	 * @return array
	 */
	private static function whiteSpace($token)
	{
		if (strtolower($token->Value) === "pre-wrap")
		{
			$r = array
			(
				// Firefox < 3
				new CssRulesetDeclarationToken("white-space", "-moz-pre-wrap", $token->MediaTypes),
				// Webkit
				new CssRulesetDeclarationToken("white-space", "-webkit-pre-wrap", $token->MediaTypes),
				// Opera >= 4 <= 6
				new CssRulesetDeclarationToken("white-space", "-pre-wrap", $token->MediaTypes),
				// Opera >= 7
				new CssRulesetDeclarationToken("white-space", "-o-pre-wrap", $token->MediaTypes),
				// Internet Explorer >= 5.5
				new CssRulesetDeclarationToken("word-wrap", "break-word", $token->MediaTypes)
			);
			return $r;
		}
		else
		{
			return array();
		}
	}
}

/**
 * This {@link aCssMinifierFilter minifier filter} will convert @keyframes at-rule block to browser specific counterparts.
 *
 * @package		CssMin/Minifier/Filters
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssConvertLevel3AtKeyframesMinifierFilter extends aCssMinifierFilter
{
	/**
	 * Implements {@link aCssMinifierFilter::filter()}.
	 *
	 * @param array $tokens Array of objects of type aCssToken
	 * @return integer Count of added, changed or removed tokens; a return value larger than 0 will rebuild the array
	 */
	public function apply(array &$tokens)
	{
		$r = 0;
		$transformations = array("-moz-keyframes", "-webkit-keyframes");
		for ($i = 0, $l = count($tokens); $i < $l; $i++)
		{
			if (get_class($tokens[$i]) === "CssAtKeyframesStartToken")
			{
				for ($ii = $i; $ii < $l; $ii++)
				{
					if (get_class($tokens[$ii]) === "CssAtKeyframesEndToken")
					{
						break;
					}
				}
				if (get_class($tokens[$ii]) === "CssAtKeyframesEndToken")
				{
					$add	= array();
					$source	= array();
					for ($iii = $i; $iii <= $ii; $iii++)
					{
						$source[] = clone($tokens[$iii]);
					}
					foreach ($transformations as $transformation)
					{
						$t = array();
						foreach ($source as $token)
						{
							$t[] = clone($token);
						}
						$t[0]->AtRuleName = $transformation;
						$add = array_merge($add, $t);
					}
					if (isset($this->configuration["RemoveSource"]) && $this->configuration["RemoveSource"] === true)
					{
						array_splice($tokens, $i, $ii - $i + 1, $add);
					}
					else
					{
						array_splice($tokens, $ii + 1, 0, $add);
					}
					$l = count($tokens);
					$i = $ii + count($add);
					$r += count($add);
				}
			}
		}
		return $r;
	}
}

/**
 * This {@link aCssMinifierPlugin} will convert a color value in hsl notation to hexadecimal notation.
 *
 * Example:
 * <code>
 * color: hsl(232,36%,48%);
 * </code>
 *
 * Will get converted to:
 * <code>
 * color:#4e5aa7;
 * </code>
 *
 * @package		CssMin/Minifier/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssConvertHslColorsMinifierPlugin extends aCssMinifierPlugin
{
	/**
	 * Regular expression matching the value.
	 *
	 * @var string
	 */
	private $reMatch = "/^hsl\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*%\s*,\s*([0-9]+)\s*%\s*\)/iS";
	/**
	 * Implements {@link aCssMinifierPlugin::minify()}.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	public function apply(aCssToken &$token)
	{
		if (stripos($token->Value, "hsl") !== false && preg_match($this->reMatch, $token->Value, $m))
		{
			$token->Value = str_replace($m[0], $this->hsl2hex($m[1], $m[2], $m[3]), $token->Value);
		}
		return false;
	}
	/**
	 * Implements {@link aMinifierPlugin::getTriggerTokens()}
	 *
	 * @return array
	 */
	public function getTriggerTokens()
	{
		return array
		(
			"CssAtFontFaceDeclarationToken",
			"CssAtPageDeclarationToken",
			"CssRulesetDeclarationToken"
		);
	}
	/**
	 * Convert a HSL value to hexadecimal notation.
	 *
	 * Based on: {@link http://www.easyrgb.com/index.php?X=MATH&H=19#text19}.
	 *
	 * @param integer $hue Hue
	 * @param integer $saturation Saturation
	 * @param integer $lightness Lightnesss
	 * @return string
	 */
	private function hsl2hex($hue, $saturation, $lightness)
	{
		$hue		= $hue / 360;
		$saturation	= $saturation / 100;
		$lightness	= $lightness / 100;
		if ($saturation == 0)
		{
			$red	= $lightness * 255;
			$green	= $lightness * 255;
			$blue	= $lightness * 255;
		}
		else
		{
			if ($lightness < 0.5 )
			{
				$v2 = $lightness * (1 + $saturation);
			}
			else
			{
				$v2 = ($lightness + $saturation) - ($saturation * $lightness);
			}
			$v1		= 2 * $lightness - $v2;
			$red	= 255 * self::hue2rgb($v1, $v2, $hue + (1 / 3));
			$green	= 255 * self::hue2rgb($v1, $v2, $hue);
			$blue	= 255 * self::hue2rgb($v1, $v2, $hue - (1 / 3));
		}
		return "#" . str_pad(dechex(round($red)), 2, "0", STR_PAD_LEFT) . str_pad(dechex(round($green)), 2, "0", STR_PAD_LEFT) . str_pad(dechex(round($blue)), 2, "0", STR_PAD_LEFT);
	}
	/**
	 * Apply hue to a rgb color value.
	 *
	 * @param integer $v1 Value 1
	 * @param integer $v2 Value 2
	 * @param integer $hue Hue
	 * @return integer
	 */
	private function hue2rgb($v1, $v2, $hue)
	{
		if ($hue < 0)
		{
			$hue += 1;
		}
		if ($hue > 1)
		{
			$hue -= 1;
		}
		if ((6 * $hue) < 1)
		{
			return ($v1 + ($v2 - $v1) * 6 * $hue);
		}
		if ((2 * $hue) < 1)
		{
			return ($v2);
		}
		if ((3 * $hue) < 2)
		{
			return ($v1 + ($v2 - $v1) * (( 2 / 3) - $hue) * 6);
		}
		return $v1;
	}
}

/**
 * This {@link aCssMinifierPlugin} will convert the font-weight values normal and bold to their numeric notation.
 *
 * Example:
 * <code>
 * font-weight: normal;
 * font: bold 11px monospace;
 * </code>
 *
 * Will get converted to:
 * <code>
 * font-weight:400;
 * font:700 11px monospace;
 * </code>
 *
 * @package		CssMin/Minifier/Pluginsn
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssConvertFontWeightMinifierPlugin extends aCssMinifierPlugin
{
	/**
	 * Array of included declaration properties this plugin will process; others declaration properties will get
	 * ignored.
	 *
	 * @var array
	 */
	private $include = array
	(
		"font",
		"font-weight"
	);
	/**
	 * Regular expression matching the value.
	 *
	 * @var string
	 */
	private $reMatch = null;
	/**
	 * Transformation table used by the {@link CssConvertFontWeightMinifierPlugin::reReplace() replacement method}.
	 *
	 * @var array
	 */
	private $transformation = array
	(
		"normal"	=> "400",
		"bold"		=> "700"
	);
	/**
	 * Overwrites {@link aCssMinifierPlugin::__construct()}.
	 *
	 * The constructor will create the {@link CssConvertFontWeightMinifierPlugin::$reMatch replace regular expression}
	 * based on the {@link CssConvertFontWeightMinifierPlugin::$transformation transformation table}.
	 *
	 * @param CssMinifier $minifier The CssMinifier object of this plugin.
	 * @return void
	 */
	public function __construct(CssMinifier $minifier)
	{
		$this->reMatch = "/(^|\s)+(" . implode("|", array_keys($this->transformation)). ")(\s|$)+/iS";
		parent::__construct($minifier);
	}
	/**
	 * Implements {@link aCssMinifierPlugin::minify()}.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	public function apply(aCssToken &$token)
	{
		if (in_array($token->Property, $this->include) && preg_match($this->reMatch, $token->Value, $m))
		{
			$token->Value = preg_replace_callback($this->reMatch, array($this, 'reReplace'), $token->Value);
		}
		return false;
	}
	/**
	 * Callback for replacement value.
	 *
	 * @param array $match
	 * @return string
	 */
	private function reReplace($match)
	{
		return $match[1] . $this->transformation[strtolower($match[2])] . $match[3];
	}
	/**
	 * Implements {@link aMinifierPlugin::getTriggerTokens()}
	 *
	 * @return array
	 */
	public function getTriggerTokens()
	{
		return array
		(
			"CssAtFontFaceDeclarationToken",
			"CssAtPageDeclarationToken",
			"CssRulesetDeclarationToken"
		);
	}
}

/**
 * This {@link aCssMinifierPlugin} will compress several unit values to their short notations. Examples:
 *
 * <code>
 * padding: 0.5em;
 * border: 0px;
 * margin: 0 0 0 0;
 * </code>
 *
 * Will get compressed to:
 *
 * <code>
 * padding:.5px;
 * border:0;
 * margin:0;
 * </code>
 *
 * --
 *
 * @package		CssMin/Minifier/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssCompressUnitValuesMinifierPlugin extends aCssMinifierPlugin
{
	/**
	 * Regular expression used for matching and replacing unit values.
	 *
	 * @var array
	 */
	private $re = array
	(
		"/(^| |-)0\.([0-9]+?)(0+)?(%|em|ex|px|in|cm|mm|pt|pc)/iS" => "\${1}.\${2}\${4}",
		"/(^| )-?(\.?)0(%|em|ex|px|in|cm|mm|pt|pc)/iS" => "\${1}0",
	);
	/**
	 * Regular expression used for matching and replacing unit values only for non-blacklisted declarations.
	 *
	 * @var array
	 */
	private $reBlacklisted = array(
		"/(^0\s0\s0\s0)|(^0\s0\s0$)|(^0\s0$)/iS" => "0",
	);
	/**
	 * Blacklisted properties for the above regular expression.
	 *
	 * @var array
	 */
	private $propertiesBlacklist = array('background-position');
	/**
	 * Regular expression matching the value.
	 *
	 * @var string
	 */
	private $reMatch = "/(^| |-)0\.([0-9]+?)(0+)?(%|em|ex|px|in|cm|mm|pt|pc)|(^| )-?(\.?)0(%|em|ex|px|in|cm|mm|pt|pc)|(^0\s0\s0\s0$)|(^0\s0\s0$)|(^0\s0$)/iS";
	/**
	 * Implements {@link aCssMinifierPlugin::minify()}.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	public function apply(aCssToken &$token)
	{
		if (preg_match($this->reMatch, $token->Value))
		{
			foreach ($this->re as $reMatch => $reReplace)
			{
				$token->Value = preg_replace($reMatch, $reReplace, $token->Value);
			}
			if (!in_array($token->Property, $this->propertiesBlacklist))
			{
				foreach ($this->reBlacklisted as $reMatch => $reReplace)
				{
					$token->Value = preg_replace($reMatch, $reReplace, $token->Value);
				}
			}
		}
		return false;
	}
	/**
	 * Implements {@link aMinifierPlugin::getTriggerTokens()}
	 *
	 * @return array
	 */
	public function getTriggerTokens()
	{
		return array
		(
			"CssAtFontFaceDeclarationToken",
			"CssAtPageDeclarationToken",
			"CssRulesetDeclarationToken"
		);
	}
}

/**
 * This {@link aCssMinifierPlugin} compress the content of expresssion() declaration values.
 *
 * For compression of expressions {@link https://github.com/rgrove/jsmin-php/ JSMin} will get used. JSMin have to be
 * already included or loadable via {@link http://goo.gl/JrW54 PHP autoloading}.
 *
 * @package		CssMin/Minifier/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssCompressExpressionValuesMinifierPlugin extends aCssMinifierPlugin
{
	/**
	 * Implements {@link aCssMinifierPlugin::minify()}.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	public function apply(aCssToken &$token)
	{
		if (class_exists("JSMin") && stripos($token->Value, "expression(") !== false)
		{
			$value	= $token->Value;
			$value	= substr($token->Value, stripos($token->Value, "expression(") + 10);
			$value	= trim(JSMin::minify($value));
			$token->Value = "expression(" . $value . ")";
		}
		return false;
	}
	/**
	 * Implements {@link aMinifierPlugin::getTriggerTokens()}
	 *
	 * @return array
	 */
	public function getTriggerTokens()
	{
		return array
		(
			"CssAtFontFaceDeclarationToken",
			"CssAtPageDeclarationToken",
			"CssRulesetDeclarationToken"
		);
	}
}

/**
 * This {@link aCssMinifierPlugin} will convert hexadecimal color value with 6 chars to their 3 char hexadecimal
 * notation (if possible).
 *
 * Example:
 * <code>
 * color: #aabbcc;
 * </code>
 *
 * Will get converted to:
 * <code>
 * color:#abc;
 * </code>
 *
 * @package		CssMin/Minifier/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssCompressColorValuesMinifierPlugin extends aCssMinifierPlugin
{
	/**
	 * Regular expression matching 6 char hexadecimal color values.
	 *
	 * @var string
	 */
	private $reMatch = "/\#([0-9a-f]{6})/iS";
	/**
	 * Implements {@link aCssMinifierPlugin::minify()}.
	 *
	 * @param aCssToken $token Token to process
	 * @return boolean Return TRUE to break the processing of this token; FALSE to continue
	 */
	public function apply(aCssToken &$token)
	{
		if (strpos($token->Value, "#") !== false && preg_match($this->reMatch, $token->Value, $m))
		{
			$value = strtolower($m[1]);
			if ($value[0] == $value[1] && $value[2] == $value[3] && $value[4] == $value[5])
			{
				$token->Value = str_replace($m[0], "#" . $value[0] . $value[2] . $value[4], $token->Value);
			}
		}
		return false;
	}
	/**
	 * Implements {@link aMinifierPlugin::getTriggerTokens()}
	 *
	 * @return array
	 */
	public function getTriggerTokens()
	{
		return array
		(
			"CssAtFontFaceDeclarationToken",
			"CssAtPageDeclarationToken",
			"CssRulesetDeclarationToken"
		);
	}
}

/**
 * This {@link aCssToken CSS token} represents a CSS comment.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssCommentToken extends aCssToken
{
	/**
	 * Comment as Text.
	 *
	 * @var string
	 */
	public $Comment = "";
	/**
	 * Set the properties of a comment token.
	 *
	 * @param string $comment Comment including comment delimiters
	 * @return void
	 */
	public function __construct($comment)
	{
		$this->Comment = $comment;
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return $this->Comment;
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing comments.
 *
 * Adds a {@link CssCommentToken} to the parser if a comment was found.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssCommentParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("*", "/");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return false;
	}
	/**
	 * Stored buffer for restore.
	 *
	 * @var string
	 */
	private $restoreBuffer = "";
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		if ($char === "*" && $previousChar === "/" && $state !== "T_COMMENT")
		{
			$this->parser->pushState("T_COMMENT");
			$this->parser->setExclusive(__CLASS__);
			$this->restoreBuffer = substr($this->parser->getAndClearBuffer(), 0, -2);
		}
		elseif ($char === "/" && $previousChar === "*" && $state === "T_COMMENT")
		{
			$this->parser->popState();
			$this->parser->unsetExclusive();
			$this->parser->appendToken(new CssCommentToken("/*" . $this->parser->getAndClearBuffer()));
			$this->parser->setBuffer($this->restoreBuffer);
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * This {@link aCssToken CSS token} represents the start of a @variables at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtVariablesStartToken extends aCssAtBlockStartToken
{
	/**
	 * Media types of the @variables at-rule block.
	 *
	 * @var array
	 */
	public $MediaTypes = array();
	/**
	 * Set the properties of a @variables at-rule token.
	 *
	 * @param array $mediaTypes Media types
	 * @return void
	 */
	public function __construct($mediaTypes = null)
	{
		$this->MediaTypes = $mediaTypes ? $mediaTypes : array("all");
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "";
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @variables at-rule block with including declarations.
 *
 * Found @variables at-rule blocks will add a {@link CssAtVariablesStartToken} and {@link CssAtVariablesEndToken} to the
 * parser; including declarations as {@link CssAtVariablesDeclarationToken}.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtVariablesParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("@", "{", "}", ":", ";");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return array("T_DOCUMENT", "T_AT_VARIABLES::PREPARE", "T_AT_VARIABLES", "T_AT_VARIABLES_DECLARATION");
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		// Start of @variables at-rule block
		if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 10)) === "@variables")
		{
			$this->parser->pushState("T_AT_VARIABLES::PREPARE");
			$this->parser->clearBuffer();
			return $index + 10;
		}
		// Start of @variables declarations
		elseif ($char === "{" && $state === "T_AT_VARIABLES::PREPARE")
		{
			$this->parser->setState("T_AT_VARIABLES");
			$mediaTypes = array_filter(array_map("trim", explode(",", $this->parser->getAndClearBuffer("{"))));
			$this->parser->appendToken(new CssAtVariablesStartToken($mediaTypes));
		}
		// Start of @variables declaration
		if ($char === ":" && $state === "T_AT_VARIABLES")
		{
			$this->buffer = $this->parser->getAndClearBuffer(":");
			$this->parser->pushState("T_AT_VARIABLES_DECLARATION");
		}
		// Unterminated @variables declaration
		elseif ($char === ":" && $state === "T_AT_VARIABLES_DECLARATION")
		{
			// Ignore Internet Explorer filter declarations
			if ($this->buffer === "filter")
			{
				return false;
			}
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated @variables declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
		}
		// End of @variables declaration
		elseif (($char === ";" || $char === "}") && $state === "T_AT_VARIABLES_DECLARATION")
		{
			$value = $this->parser->getAndClearBuffer(";}");
			if (strtolower(substr($value, -10, 10)) === "!important")
			{
				$value = trim(substr($value, 0, -10));
				$isImportant = true;
			}
			else
			{
				$isImportant = false;
			}
			$this->parser->popState();
			$this->parser->appendToken(new CssAtVariablesDeclarationToken($this->buffer, $value, $isImportant));
			$this->buffer = "";
		}
		// End of @variables at-rule block
		elseif ($char === "}" && $state === "T_AT_VARIABLES")
		{
			$this->parser->popState();
			$this->parser->clearBuffer();
			$this->parser->appendToken(new CssAtVariablesEndToken());
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * This {@link aCssToken CSS token} represents the end of a @variables at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtVariablesEndToken extends aCssAtBlockEndToken
{
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "";
	}
}

/**
 * This {@link aCssToken CSS token} represents a declaration of a @variables at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtVariablesDeclarationToken extends aCssDeclarationToken
{
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "";
	}
}

/**
 * This {@link aCssToken CSS token} represents the start of a @page at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtPageStartToken extends aCssAtBlockStartToken
{
	/**
	 * Selector.
	 *
	 * @var string
	 */
	public $Selector = "";
	/**
	 * Sets the properties of the @page at-rule.
	 *
	 * @param string $selector Selector
	 * @return void
	 */
	public function __construct($selector = "")
	{
		$this->Selector = $selector;
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "@page" . ($this->Selector ? " " . $this->Selector : "") . "{";
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @page at-rule block with including declarations.
 *
 * Found @page at-rule blocks will add a {@link CssAtPageStartToken} and {@link CssAtPageEndToken} to the
 * parser; including declarations as {@link CssAtPageDeclarationToken}.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtPageParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("@", "{", "}", ":", ";");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return array("T_DOCUMENT", "T_AT_PAGE::SELECTOR", "T_AT_PAGE", "T_AT_PAGE_DECLARATION");
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		// Start of @page at-rule block
		if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 5)) === "@page")
		{
			$this->parser->pushState("T_AT_PAGE::SELECTOR");
			$this->parser->clearBuffer();
			return $index + 5;
		}
		// Start of @page declarations
		elseif ($char === "{" && $state === "T_AT_PAGE::SELECTOR")
		{
			$selector = $this->parser->getAndClearBuffer("{");
			$this->parser->setState("T_AT_PAGE");
			$this->parser->clearBuffer();
			$this->parser->appendToken(new CssAtPageStartToken($selector));
		}
		// Start of @page declaration
		elseif ($char === ":" && $state === "T_AT_PAGE")
		{
			$this->parser->pushState("T_AT_PAGE_DECLARATION");
			$this->buffer = $this->parser->getAndClearBuffer(":", true);
		}
		// Unterminated @font-face declaration
		elseif ($char === ":" && $state === "T_AT_PAGE_DECLARATION")
		{
			// Ignore Internet Explorer filter declarations
			if ($this->buffer === "filter")
			{
				return false;
			}
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated @page declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
		}
		// End of @page declaration
		elseif (($char === ";" || $char === "}") && $state == "T_AT_PAGE_DECLARATION")
		{
			$value = $this->parser->getAndClearBuffer(";}");
			if (strtolower(substr($value, -10, 10)) == "!important")
			{
				$value = trim(substr($value, 0, -10));
				$isImportant = true;
			}
			else
			{
				$isImportant = false;
			}
			$this->parser->popState();
			$this->parser->appendToken(new CssAtPageDeclarationToken($this->buffer, $value, $isImportant));
			// --
			if ($char === "}")
			{
				$this->parser->popState();
				$this->parser->appendToken(new CssAtPageEndToken());
			}
			$this->buffer = "";
		}
		// End of @page at-rule block
		elseif ($char === "}" && $state === "T_AT_PAGE")
		{
			$this->parser->popState();
			$this->parser->clearBuffer();
			$this->parser->appendToken(new CssAtPageEndToken());
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * This {@link aCssToken CSS token} represents the end of a @page at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtPageEndToken extends aCssAtBlockEndToken
{

}

/**
 * This {@link aCssToken CSS token} represents a declaration of a @page at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtPageDeclarationToken extends aCssDeclarationToken
{

}

/**
 * This {@link aCssToken CSS token} represents the start of a @media at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtMediaStartToken extends aCssAtBlockStartToken
{
	/**
	 * Sets the properties of the @media at-rule.
	 *
	 * @param array $mediaTypes Media types
	 * @return void
	 */
	public function __construct(array $mediaTypes = array())
	{
		$this->MediaTypes = $mediaTypes;
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "@media " . implode(",", $this->MediaTypes) . "{";
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @media at-rule block.
 *
 * Found @media at-rule blocks will add a {@link CssAtMediaStartToken} and {@link CssAtMediaEndToken} to the parser.
 * This plugin will also set the the current media types using {@link CssParser::setMediaTypes()} and
 * {@link CssParser::unsetMediaTypes()}.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtMediaParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("@", "{", "}");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return array("T_DOCUMENT", "T_AT_MEDIA::PREPARE", "T_AT_MEDIA");
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 6)) === "@media")
		{
			$this->parser->pushState("T_AT_MEDIA::PREPARE");
			$this->parser->clearBuffer();
			return $index + 6;
		}
		elseif ($char === "{" && $state === "T_AT_MEDIA::PREPARE")
		{
			$mediaTypes = array_filter(array_map("trim", explode(",", $this->parser->getAndClearBuffer("{"))));
			$this->parser->setMediaTypes($mediaTypes);
			$this->parser->setState("T_AT_MEDIA");
			$this->parser->appendToken(new CssAtMediaStartToken($mediaTypes));
		}
		elseif ($char === "}" && $state === "T_AT_MEDIA")
		{
			$this->parser->appendToken(new CssAtMediaEndToken());
			$this->parser->clearBuffer();
			$this->parser->unsetMediaTypes();
			$this->parser->popState();
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * This {@link aCssToken CSS token} represents the end of a @media at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtMediaEndToken extends aCssAtBlockEndToken
{

}

/**
 * This {@link aCssToken CSS token} represents the start of a @keyframes at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtKeyframesStartToken extends aCssAtBlockStartToken
{
	/**
	 * Name of the at-rule.
	 *
	 * @var string
	 */
	public $AtRuleName = "keyframes";
	/**
	 * Name
	 *
	 * @var string
	 */
	public $Name = "";
	/**
	 * Sets the properties of the @page at-rule.
	 *
	 * @param string $selector Selector
	 * @return void
	 */
	public function __construct($name, $atRuleName = null)
	{
		$this->Name = $name;
		if (!is_null($atRuleName))
		{
			$this->AtRuleName = $atRuleName;
		}
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		if ($this->AtRuleName === "-moz-keyframes")
		{
			return "@-moz-keyframes " . $this->Name . " {";
		}
		return "@" . $this->AtRuleName . " " . $this->Name . "{";
	}
}

/**
 * This {@link aCssToken CSS token} represents the start of a ruleset of a @keyframes at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtKeyframesRulesetStartToken extends aCssRulesetStartToken
{
	/**
	 * Array of selectors.
	 *
	 * @var array
	 */
	public $Selectors = array();
	/**
	 * Set the properties of a ruleset token.
	 *
	 * @param array $selectors Selectors of the ruleset
	 * @return void
	 */
	public function __construct(array $selectors = array())
	{
		$this->Selectors = $selectors;
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return implode(",", $this->Selectors) . "{";
	}
}

/**
 * This {@link aCssToken CSS token} represents the end of a ruleset of a @keyframes at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtKeyframesRulesetEndToken extends aCssRulesetEndToken
{

}

/**
 * This {@link aCssToken CSS token} represents a ruleset declaration of a @keyframes at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtKeyframesRulesetDeclarationToken extends aCssDeclarationToken
{

}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @keyframes at-rule blocks, rulesets and declarations.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtKeyframesParserPlugin extends aCssParserPlugin
{
	/**
	 * @var string Keyword
	 */
	private $atRuleName = "";
	/**
	 * Selectors.
	 *
	 * @var array
	 */
	private $selectors = array();
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("@", "{", "}", ":", ",", ";");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return array("T_DOCUMENT", "T_AT_KEYFRAMES::NAME", "T_AT_KEYFRAMES", "T_AT_KEYFRAMES_RULESETS", "T_AT_KEYFRAMES_RULESET", "T_AT_KEYFRAMES_RULESET_DECLARATION");
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		// Start of @keyframes at-rule block
		if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 10)) === "@keyframes")
		{
			$this->atRuleName = "keyframes";
			$this->parser->pushState("T_AT_KEYFRAMES::NAME");
			$this->parser->clearBuffer();
			return $index + 10;
		}
		// Start of @keyframes at-rule block (@-moz-keyframes)
		elseif ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 15)) === "@-moz-keyframes")
		{
			$this->atRuleName = "-moz-keyframes";
			$this->parser->pushState("T_AT_KEYFRAMES::NAME");
			$this->parser->clearBuffer();
			return $index + 15;
		}
		// Start of @keyframes at-rule block (@-webkit-keyframes)
		elseif ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 18)) === "@-webkit-keyframes")
		{
			$this->atRuleName = "-webkit-keyframes";
			$this->parser->pushState("T_AT_KEYFRAMES::NAME");
			$this->parser->clearBuffer();
			return $index + 18;
		}
		// Start of @keyframes at-rule block (@-o-keyframes)
		elseif ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 13)) === "@-o-keyframes")
		{
			$this->atRuleName = "-o-keyframes";
			$this->parser->pushState("T_AT_KEYFRAMES::NAME");
			$this->parser->clearBuffer();
			return $index + 13;
		}
		// Start of @keyframes at-rule block (@-ms-keyframes)
		elseif ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 14)) === "@-ms-keyframes")
		{
			$this->atRuleName = "-ms-keyframes";
			$this->parser->pushState("T_AT_KEYFRAMES::NAME");
			$this->parser->clearBuffer();
			return $index + 14;
		}
		// Start of @keyframes rulesets
		elseif ($char === "{" && $state === "T_AT_KEYFRAMES::NAME")
		{
			$name = $this->parser->getAndClearBuffer("{\"'");
			$this->parser->setState("T_AT_KEYFRAMES_RULESETS");
			$this->parser->clearBuffer();
			$this->parser->appendToken(new CssAtKeyframesStartToken($name, $this->atRuleName));
		}
		// Start of @keyframe ruleset and selectors
		if ($char === "," && $state === "T_AT_KEYFRAMES_RULESETS")
		{
			$this->selectors[] = $this->parser->getAndClearBuffer(",{");
		}
		// Start of a @keyframes ruleset
		elseif ($char === "{" && $state === "T_AT_KEYFRAMES_RULESETS")
		{
			if ($this->parser->getBuffer() !== "")
			{
				$this->selectors[] = $this->parser->getAndClearBuffer(",{");
				$this->parser->pushState("T_AT_KEYFRAMES_RULESET");
				$this->parser->appendToken(new CssAtKeyframesRulesetStartToken($this->selectors));
				$this->selectors = array();
			}
		}
		// Start of @keyframes ruleset declaration
		elseif ($char === ":" && $state === "T_AT_KEYFRAMES_RULESET")
		{
			$this->parser->pushState("T_AT_KEYFRAMES_RULESET_DECLARATION");
			$this->buffer = $this->parser->getAndClearBuffer(":;", true);
		}
		// Unterminated @keyframes ruleset declaration
		elseif ($char === ":" && $state === "T_AT_KEYFRAMES_RULESET_DECLARATION")
		{
			// Ignore Internet Explorer filter declarations
			if ($this->buffer === "filter")
			{
				return false;
			}
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated @keyframes ruleset declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
		}
		// End of declaration
		elseif (($char === ";" || $char === "}") && $state === "T_AT_KEYFRAMES_RULESET_DECLARATION")
		{
			$value = $this->parser->getAndClearBuffer(";}");
			if (strtolower(substr($value, -10, 10)) === "!important")
			{
				$value = trim(substr($value, 0, -10));
				$isImportant = true;
			}
			else
			{
				$isImportant = false;
			}
			$this->parser->popState();
			$this->parser->appendToken(new CssAtKeyframesRulesetDeclarationToken($this->buffer, $value, $isImportant));
			// Declaration ends with a right curly brace; so we have to end the ruleset
			if ($char === "}")
			{
				$this->parser->appendToken(new CssAtKeyframesRulesetEndToken());
				$this->parser->popState();
			}
			$this->buffer = "";
		}
		// End of @keyframes ruleset
		elseif ($char === "}" && $state === "T_AT_KEYFRAMES_RULESET")
		{
			$this->parser->clearBuffer();

			$this->parser->popState();
			$this->parser->appendToken(new CssAtKeyframesRulesetEndToken());
		}
		// End of @keyframes rulesets
		elseif ($char === "}" && $state === "T_AT_KEYFRAMES_RULESETS")
		{
			$this->parser->clearBuffer();
			$this->parser->popState();
			$this->parser->appendToken(new CssAtKeyframesEndToken());
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * This {@link aCssToken CSS token} represents the end of a @keyframes at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtKeyframesEndToken extends aCssAtBlockEndToken
{

}

/**
 * This {@link aCssToken CSS token} represents a @import at-rule.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1.b1 (2001-02-22)
 */
class CssAtImportToken extends aCssToken
{
	/**
	 * Import path of the @import at-rule.
	 *
	 * @var string
	 */
	public $Import = "";
	/**
	 * Media types of the @import at-rule.
	 *
	 * @var array
	 */
	public $MediaTypes = array();
	/**
	 * Set the properties of a @import at-rule token.
	 *
	 * @param string $import Import path
	 * @param array $mediaTypes Media types
	 * @return void
	 */
	public function __construct($import, $mediaTypes)
	{
		$this->Import		= $import;
		$this->MediaTypes	= $mediaTypes ? $mediaTypes : array();
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "@import \"" . $this->Import . "\"" . (count($this->MediaTypes) > 0 ? " "  . implode(",", $this->MediaTypes) : ""). ";";
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @import at-rule.
 *
 * If a @import at-rule was found this plugin will add a {@link CssAtImportToken} to the parser.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtImportParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("@", ";", ",", "\n");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return array("T_DOCUMENT", "T_AT_IMPORT");
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 7)) === "@import")
		{
			$this->parser->pushState("T_AT_IMPORT");
			$this->parser->clearBuffer();
			return $index + 7;
		}
		elseif (($char === ";" || $char === "\n") && $state === "T_AT_IMPORT")
		{
			$this->buffer = $this->parser->getAndClearBuffer(";");
			$pos = false;
			foreach (array(")", "\"", "'") as $needle)
			{
				if (($pos = strrpos($this->buffer, $needle)) !== false)
				{
					break;
				}
			}
			$import = substr($this->buffer, 0, $pos + 1);
			if (stripos($import, "url(") === 0)
			{
				$import = substr($import, 4, -1);
			}
			$import = trim($import, " \t\n\r\0\x0B'\"");
			$mediaTypes = array_filter(array_map("trim", explode(",", trim(substr($this->buffer, $pos + 1), " \t\n\r\0\x0B{"))));
			if ($pos)
			{
				$this->parser->appendToken(new CssAtImportToken($import, $mediaTypes));
			}
			else
			{
				CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Invalid @import at-rule syntax", $this->buffer));
			}
			$this->parser->popState();
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * This {@link aCssToken CSS token} represents the start of a @font-face at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtFontFaceStartToken extends aCssAtBlockStartToken
{
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "@font-face{";
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @font-face at-rule block with including declarations.
 *
 * Found @font-face at-rule blocks will add a {@link CssAtFontFaceStartToken} and {@link CssAtFontFaceEndToken} to the
 * parser; including declarations as {@link CssAtFontFaceDeclarationToken}.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtFontFaceParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("@", "{", "}", ":", ";");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return array("T_DOCUMENT", "T_AT_FONT_FACE::PREPARE", "T_AT_FONT_FACE", "T_AT_FONT_FACE_DECLARATION");
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		// Start of @font-face at-rule block
		if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 10)) === "@font-face")
		{
			$this->parser->pushState("T_AT_FONT_FACE::PREPARE");
			$this->parser->clearBuffer();
			return $index + 10 - 1;
		}
		// Start of @font-face declarations
		elseif ($char === "{" && $state === "T_AT_FONT_FACE::PREPARE")
		{
			$this->parser->setState("T_AT_FONT_FACE");
			$this->parser->clearBuffer();
			$this->parser->appendToken(new CssAtFontFaceStartToken());
		}
		// Start of @font-face declaration
		elseif ($char === ":" && $state === "T_AT_FONT_FACE")
		{
			$this->parser->pushState("T_AT_FONT_FACE_DECLARATION");
			$this->buffer = $this->parser->getAndClearBuffer(":", true);
		}
		// Unterminated @font-face declaration
		elseif ($char === ":" && $state === "T_AT_FONT_FACE_DECLARATION")
		{
			// Ignore Internet Explorer filter declarations
			if ($this->buffer === "filter")
			{
				return false;
			}
			CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated @font-face declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
		}
		// End of @font-face declaration
		elseif (($char === ";" || $char === "}") && $state === "T_AT_FONT_FACE_DECLARATION")
		{
			$value = $this->parser->getAndClearBuffer(";}");
			if (strtolower(substr($value, -10, 10)) === "!important")
			{
				$value = trim(substr($value, 0, -10));
				$isImportant = true;
			}
			else
			{
				$isImportant = false;
			}
			$this->parser->popState();
			$this->parser->appendToken(new CssAtFontFaceDeclarationToken($this->buffer, $value, $isImportant));
			$this->buffer = "";
			// --
			if ($char === "}")
			{
				$this->parser->appendToken(new CssAtFontFaceEndToken());
				$this->parser->popState();
			}
		}
		// End of @font-face at-rule block
		elseif ($char === "}" && $state === "T_AT_FONT_FACE")
		{
			$this->parser->appendToken(new CssAtFontFaceEndToken());
			$this->parser->clearBuffer();
			$this->parser->popState();
		}
		else
		{
			return false;
		}
		return true;
	}
}

/**
 * This {@link aCssToken CSS token} represents the end of a @font-face at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtFontFaceEndToken extends aCssAtBlockEndToken
{

}

/**
 * This {@link aCssToken CSS token} represents a declaration of a @font-face at-rule block.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtFontFaceDeclarationToken extends aCssDeclarationToken
{

}

/**
 * This {@link aCssToken CSS token} represents a @charset at-rule.
 *
 * @package		CssMin/Tokens
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtCharsetToken extends aCssToken
{
	/**
	 * Charset of the @charset at-rule.
	 *
	 * @var string
	 */
	public $Charset = "";
	/**
	 * Set the properties of @charset at-rule token.
	 *
	 * @param string $charset Charset of the @charset at-rule token
	 * @return void
	 */
	public function __construct($charset)
	{
		$this->Charset = $charset;
	}
	/**
	 * Implements {@link aCssToken::__toString()}.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return "@charset " . $this->Charset . ";";
	}
}

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @charset at-rule.
 *
 * If a @charset at-rule was found this plugin will add a {@link CssAtCharsetToken} to the parser.
 *
 * @package		CssMin/Parser/Plugins
 * @link		http://code.google.com/p/cssmin/
 * @author		Joe Scylla <joe.scylla@gmail.com>
 * @copyright	2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license		http://opensource.org/licenses/mit-license.php MIT License
 * @version		3.0.1
 */
class CssAtCharsetParserPlugin extends aCssParserPlugin
{
	/**
	 * Implements {@link aCssParserPlugin::getTriggerChars()}.
	 *
	 * @return array
	 */
	public function getTriggerChars()
	{
		return array("@", ";", "\n");
	}
	/**
	 * Implements {@link aCssParserPlugin::getTriggerStates()}.
	 *
	 * @return array
	 */
	public function getTriggerStates()
	{
		return array("T_DOCUMENT", "T_AT_CHARSET");
	}
	/**
	 * Implements {@link aCssParserPlugin::parse()}.
	 *
	 * @param integer $index Current index
	 * @param string $char Current char
	 * @param string $previousChar Previous char
	 * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
	 */
	public function parse($index, $char, $previousChar, $state)
	{
		if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 8)) === "@charset")
		{
			$this->parser->pushState("T_AT_CHARSET");
			$this->parser->clearBuffer();
			return $index + 8;
		}
		elseif (($char === ";" || $char === "\n") && $state === "T_AT_CHARSET")
		{
			$charset = $this->parser->getAndClearBuffer(";");
			$this->parser->popState();
			$this->parser->appendToken(new CssAtCharsetToken($charset));
		}
		else
		{
			return false;
		}
		return true;
	}
}

?>
CHANGELOG
=========

2.5.0
-----

 * added support for PTY mode
 * added the convenience method "mustRun"
 * deprecation: Process::setStdin() is deprecated in favor of Process::setInput()
 * deprecation: Process::getStdin() is deprecated in favor of Process::getInput()
 * deprecation: Process::setInput() and ProcessBuilder::setInput() do not accept non-scalar types

2.4.0
-----

 * added the ability to define an idle timeout

2.3.0
-----

 * added ProcessUtils::escapeArgument() to fix the bug in escapeshellarg() function on Windows
 * added Process::signal()
 * added Process::getPid()
 * added support for a TTY mode

2.2.0
-----

 * added ProcessBuilder::setArguments() to reset the arguments on a builder
 * added a way to retrieve the standard and error output incrementally
 * added Process:restart()

2.1.0
-----

 * added support for non-blocking processes (start(), wait(), isRunning(), stop())
 * enhanced Windows compatibility
 * added Process::getExitCodeText() that returns a string representation for
   the exit code returned by the process
 * added ProcessBuilder
{
    "name": "symfony/process",
    "type": "library",
    "description": "Symfony Process Component",
    "keywords": [],
    "homepage": "https://symfony.com",
    "license": "MIT",
    "authors": [
        {
            "name": "Fabien Potencier",
            "email": "fabien@symfony.com"
        },
        {
            "name": "Symfony Community",
            "homepage": "https://symfony.com/contributors"
        }
    ],
    "require": {
        "php": ">=5.3.9"
    },
    "autoload": {
        "psr-4": { "Symfony\\Component\\Process\\": "" },
        "exclude-from-classmap": [
            "/Tests/"
        ]
    },
    "minimum-stability": "dev",
    "extra": {
        "branch-alias": {
            "dev-master": "2.8-dev"
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Exception;

/**
 * Marker Interface for the Process Component.
 *
 * @author Johannes M. Schmitt <schmittjoh@gmail.com>
 */
interface ExceptionInterface
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Exception;

/**
 * InvalidArgumentException for the Process Component.
 *
 * @author Romain Neutron <imprec@gmail.com>
 */
class InvalidArgumentException extends \InvalidArgumentException implements ExceptionInterface
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Exception;

/**
 * LogicException for the Process Component.
 *
 * @author Romain Neutron <imprec@gmail.com>
 */
class LogicException extends \LogicException implements ExceptionInterface
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Exception;

use Symfony\Component\Process\Process;

/**
 * Exception for failed processes.
 *
 * @author Johannes M. Schmitt <schmittjoh@gmail.com>
 */
class ProcessFailedException extends RuntimeException
{
    private $process;

    public function __construct(Process $process)
    {
        if ($process->isSuccessful()) {
            throw new InvalidArgumentException('Expected a failed process, but the given process was successful.');
        }

        $error = sprintf('The command "%s" failed.'."\n\nExit Code: %s(%s)\n\nWorking directory: %s",
            $process->getCommandLine(),
            $process->getExitCode(),
            $process->getExitCodeText(),
            $process->getWorkingDirectory()
        );

        if (!$process->isOutputDisabled()) {
            $error .= sprintf("\n\nOutput:\n================\n%s\n\nError Output:\n================\n%s",
                $process->getOutput(),
                $process->getErrorOutput()
            );
        }

        parent::__construct($error);

        $this->process = $process;
    }

    public function getProcess()
    {
        return $this->process;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Exception;

use Symfony\Component\Process\Process;

/**
 * Exception that is thrown when a process times out.
 *
 * @author Johannes M. Schmitt <schmittjoh@gmail.com>
 */
class ProcessTimedOutException extends RuntimeException
{
    const TYPE_GENERAL = 1;
    const TYPE_IDLE = 2;

    private $process;
    private $timeoutType;

    public function __construct(Process $process, $timeoutType)
    {
        $this->process = $process;
        $this->timeoutType = $timeoutType;

        parent::__construct(sprintf(
            'The process "%s" exceeded the timeout of %s seconds.',
            $process->getCommandLine(),
            $this->getExceededTimeout()
        ));
    }

    public function getProcess()
    {
        return $this->process;
    }

    public function isGeneralTimeout()
    {
        return $this->timeoutType === self::TYPE_GENERAL;
    }

    public function isIdleTimeout()
    {
        return $this->timeoutType === self::TYPE_IDLE;
    }

    public function getExceededTimeout()
    {
        switch ($this->timeoutType) {
            case self::TYPE_GENERAL:
                return $this->process->getTimeout();

            case self::TYPE_IDLE:
                return $this->process->getIdleTimeout();

            default:
                throw new \LogicException(sprintf('Unknown timeout type "%d".', $this->timeoutType));
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Exception;

/**
 * RuntimeException for the Process Component.
 *
 * @author Johannes M. Schmitt <schmittjoh@gmail.com>
 */
class RuntimeException extends \RuntimeException implements ExceptionInterface
{
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process;

/**
 * Generic executable finder.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Johannes M. Schmitt <schmittjoh@gmail.com>
 */
class ExecutableFinder
{
    private $suffixes = array('.exe', '.bat', '.cmd', '.com');

    /**
     * Replaces default suffixes of executable.
     *
     * @param array $suffixes
     */
    public function setSuffixes(array $suffixes)
    {
        $this->suffixes = $suffixes;
    }

    /**
     * Adds new possible suffix to check for executable.
     *
     * @param string $suffix
     */
    public function addSuffix($suffix)
    {
        $this->suffixes[] = $suffix;
    }

    /**
     * Finds an executable by name.
     *
     * @param string $name      The executable name (without the extension)
     * @param string $default   The default to return if no executable is found
     * @param array  $extraDirs Additional dirs to check into
     *
     * @return string The executable path or default value
     */
    public function find($name, $default = null, array $extraDirs = array())
    {
        if (ini_get('open_basedir')) {
            $searchPath = explode(PATH_SEPARATOR, ini_get('open_basedir'));
            $dirs = array();
            foreach ($searchPath as $path) {
                // Silencing against https://bugs.php.net/69240
                if (@is_dir($path)) {
                    $dirs[] = $path;
                } else {
                    if (basename($path) == $name && is_executable($path)) {
                        return $path;
                    }
                }
            }
        } else {
            $dirs = array_merge(
                explode(PATH_SEPARATOR, getenv('PATH') ?: getenv('Path')),
                $extraDirs
            );
        }

        $suffixes = array('');
        if ('\\' === DIRECTORY_SEPARATOR) {
            $pathExt = getenv('PATHEXT');
            $suffixes = $pathExt ? explode(PATH_SEPARATOR, $pathExt) : $this->suffixes;
        }
        foreach ($suffixes as $suffix) {
            foreach ($dirs as $dir) {
                if (is_file($file = $dir.DIRECTORY_SEPARATOR.$name.$suffix) && ('\\' === DIRECTORY_SEPARATOR || is_executable($file))) {
                    return $file;
                }
            }
        }

        return $default;
    }
}
Copyright (c) 2004-2016 Fabien Potencier

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process;

/**
 * An executable finder specifically designed for the PHP executable.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Johannes M. Schmitt <schmittjoh@gmail.com>
 */
class PhpExecutableFinder
{
    private $executableFinder;

    public function __construct()
    {
        $this->executableFinder = new ExecutableFinder();
    }

    /**
     * Finds The PHP executable.
     *
     * @param bool $includeArgs Whether or not include command arguments
     *
     * @return string|false The PHP executable path or false if it cannot be found
     */
    public function find($includeArgs = true)
    {
        $args = $this->findArguments();
        $args = $includeArgs && $args ? ' '.implode(' ', $args) : '';

        // HHVM support
        if (defined('HHVM_VERSION')) {
            return (getenv('PHP_BINARY') ?: PHP_BINARY).$args;
        }

        // PHP_BINARY return the current sapi executable
        if (defined('PHP_BINARY') && PHP_BINARY && in_array(PHP_SAPI, array('cli', 'cli-server', 'phpdbg')) && is_file(PHP_BINARY)) {
            return PHP_BINARY.$args;
        }

        if ($php = getenv('PHP_PATH')) {
            if (!is_executable($php)) {
                return false;
            }

            return $php;
        }

        if ($php = getenv('PHP_PEAR_PHP_BIN')) {
            if (is_executable($php)) {
                return $php;
            }
        }

        $dirs = array(PHP_BINDIR);
        if ('\\' === DIRECTORY_SEPARATOR) {
            $dirs[] = 'C:\xampp\php\\';
        }

        return $this->executableFinder->find('php', false, $dirs);
    }

    /**
     * Finds the PHP executable arguments.
     *
     * @return array The PHP executable arguments
     */
    public function findArguments()
    {
        $arguments = array();

        if (defined('HHVM_VERSION')) {
            $arguments[] = '--php';
        } elseif ('phpdbg' === PHP_SAPI) {
            $arguments[] = '-qrr';
        }

        return $arguments;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process;

use Symfony\Component\Process\Exception\RuntimeException;

/**
 * PhpProcess runs a PHP script in an independent process.
 *
 * $p = new PhpProcess('<?php echo "foo"; ?>');
 * $p->run();
 * print $p->getOutput()."\n";
 *
 * @author Fabien Potencier <fabien@symfony.com>
 */
class PhpProcess extends Process
{
    /**
     * Constructor.
     *
     * @param string      $script  The PHP script to run (as a string)
     * @param string|null $cwd     The working directory or null to use the working dir of the current PHP process
     * @param array|null  $env     The environment variables or null to use the same environment as the current PHP process
     * @param int         $timeout The timeout in seconds
     * @param array       $options An array of options for proc_open
     */
    public function __construct($script, $cwd = null, array $env = null, $timeout = 60, array $options = array())
    {
        $executableFinder = new PhpExecutableFinder();
        if (false === $php = $executableFinder->find()) {
            $php = null;
        }
        if ('phpdbg' === PHP_SAPI) {
            $file = tempnam(sys_get_temp_dir(), 'dbg');
            file_put_contents($file, $script);
            register_shutdown_function('unlink', $file);
            $php .= ' '.ProcessUtils::escapeArgument($file);
            $script = null;
        }
        if ('\\' !== DIRECTORY_SEPARATOR && null !== $php) {
            // exec is mandatory to deal with sending a signal to the process
            // see https://github.com/symfony/symfony/issues/5030 about prepending
            // command with exec
            $php = 'exec '.$php;
        }

        parent::__construct($php, $cwd, $env, $script, $timeout, $options);
    }

    /**
     * Sets the path to the PHP binary to use.
     */
    public function setPhpBinary($php)
    {
        $this->setCommandLine($php);
    }

    /**
     * {@inheritdoc}
     */
    public function start($callback = null)
    {
        if (null === $this->getCommandLine()) {
            throw new RuntimeException('Unable to find the PHP executable.');
        }

        parent::start($callback);
    }
}
<?xml version="1.0" encoding="UTF-8"?>

<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="vendor/autoload.php"
>
    <php>
        <ini name="error_reporting" value="-1" />
    </php>

    <testsuites>
        <testsuite name="Symfony Process Component Test Suite">
            <directory>./Tests/</directory>
        </testsuite>
    </testsuites>

    <filter>
        <whitelist>
            <directory>./</directory>
            <exclude>
                <directory>./Tests</directory>
                <directory>./vendor</directory>
            </exclude>
        </whitelist>
    </filter>
</phpunit>
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Pipes;

/**
 * @author Romain Neutron <imprec@gmail.com>
 *
 * @internal
 */
abstract class AbstractPipes implements PipesInterface
{
    /** @var array */
    public $pipes = array();

    /** @var string */
    protected $inputBuffer = '';
    /** @var resource|null */
    protected $input;

    /** @var bool */
    private $blocked = true;

    /**
     * {@inheritdoc}
     */
    public function close()
    {
        foreach ($this->pipes as $pipe) {
            fclose($pipe);
        }
        $this->pipes = array();
    }

    /**
     * Returns true if a system call has been interrupted.
     *
     * @return bool
     */
    protected function hasSystemCallBeenInterrupted()
    {
        $lastError = error_get_last();

        // stream_select returns false when the `select` system call is interrupted by an incoming signal
        return isset($lastError['message']) && false !== stripos($lastError['message'], 'interrupted system call');
    }

    /**
     * Unblocks streams.
     */
    protected function unblock()
    {
        if (!$this->blocked) {
            return;
        }

        foreach ($this->pipes as $pipe) {
            stream_set_blocking($pipe, 0);
        }
        if (null !== $this->input) {
            stream_set_blocking($this->input, 0);
        }

        $this->blocked = false;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Pipes;

/**
 * PipesInterface manages descriptors and pipes for the use of proc_open.
 *
 * @author Romain Neutron <imprec@gmail.com>
 *
 * @internal
 */
interface PipesInterface
{
    const CHUNK_SIZE = 16384;

    /**
     * Returns an array of descriptors for the use of proc_open.
     *
     * @return array
     */
    public function getDescriptors();

    /**
     * Returns an array of filenames indexed by their related stream in case these pipes use temporary files.
     *
     * @return string[]
     */
    public function getFiles();

    /**
     * Reads data in file handles and pipes.
     *
     * @param bool $blocking Whether to use blocking calls or not.
     * @param bool $close    Whether to close pipes if they've reached EOF.
     *
     * @return string[] An array of read data indexed by their fd.
     */
    public function readAndWrite($blocking, $close = false);

    /**
     * Returns if the current state has open file handles or pipes.
     *
     * @return bool
     */
    public function areOpen();

    /**
     * Closes file handles and pipes.
     */
    public function close();
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Pipes;

use Symfony\Component\Process\Process;

/**
 * UnixPipes implementation uses unix pipes as handles.
 *
 * @author Romain Neutron <imprec@gmail.com>
 *
 * @internal
 */
class UnixPipes extends AbstractPipes
{
    /** @var bool */
    private $ttyMode;
    /** @var bool */
    private $ptyMode;
    /** @var bool */
    private $disableOutput;

    public function __construct($ttyMode, $ptyMode, $input, $disableOutput)
    {
        $this->ttyMode = (bool) $ttyMode;
        $this->ptyMode = (bool) $ptyMode;
        $this->disableOutput = (bool) $disableOutput;

        if (is_resource($input)) {
            $this->input = $input;
        } else {
            $this->inputBuffer = (string) $input;
        }
    }

    public function __destruct()
    {
        $this->close();
    }

    /**
     * {@inheritdoc}
     */
    public function getDescriptors()
    {
        if ($this->disableOutput) {
            $nullstream = fopen('/dev/null', 'c');

            return array(
                array('pipe', 'r'),
                $nullstream,
                $nullstream,
            );
        }

        if ($this->ttyMode) {
            return array(
                array('file', '/dev/tty', 'r'),
                array('file', '/dev/tty', 'w'),
                array('file', '/dev/tty', 'w'),
            );
        }

        if ($this->ptyMode && Process::isPtySupported()) {
            return array(
                array('pty'),
                array('pty'),
                array('pty'),
            );
        }

        return array(
            array('pipe', 'r'),
            array('pipe', 'w'), // stdout
            array('pipe', 'w'), // stderr
        );
    }

    /**
     * {@inheritdoc}
     */
    public function getFiles()
    {
        return array();
    }

    /**
     * {@inheritdoc}
     */
    public function readAndWrite($blocking, $close = false)
    {
        // only stdin is left open, job has been done !
        // we can now close it
        if (1 === count($this->pipes) && array(0) === array_keys($this->pipes)) {
            fclose($this->pipes[0]);
            unset($this->pipes[0]);
        }

        if (empty($this->pipes)) {
            return array();
        }

        $this->unblock();

        $read = array();

        if (null !== $this->input) {
            // if input is a resource, let's add it to stream_select argument to
            // fill a buffer
            $r = array_merge($this->pipes, array('input' => $this->input));
        } else {
            $r = $this->pipes;
        }
        // discard read on stdin
        unset($r[0]);

        $w = isset($this->pipes[0]) ? array($this->pipes[0]) : null;
        $e = null;

        // let's have a look if something changed in streams
        if (false === $n = @stream_select($r, $w, $e, 0, $blocking ? Process::TIMEOUT_PRECISION * 1E6 : 0)) {
            // if a system call has been interrupted, forget about it, let's try again
            // otherwise, an error occurred, let's reset pipes
            if (!$this->hasSystemCallBeenInterrupted()) {
                $this->pipes = array();
            }

            return $read;
        }

        // nothing has changed
        if (0 === $n) {
            return $read;
        }

        foreach ($r as $pipe) {
            // prior PHP 5.4 the array passed to stream_select is modified and
            // lose key association, we have to find back the key
            $type = (false !== $found = array_search($pipe, $this->pipes)) ? $found : 'input';
            $data = '';
            while ('' !== $dataread = (string) fread($pipe, self::CHUNK_SIZE)) {
                $data .= $dataread;
            }

            if ('' !== $data) {
                if ($type === 'input') {
                    $this->inputBuffer .= $data;
                } else {
                    $read[$type] = $data;
                }
            }

            if (false === $data || (true === $close && feof($pipe) && '' === $data)) {
                if ($type === 'input') {
                    // no more data to read on input resource
                    // use an empty buffer in the next reads
                    $this->input = null;
                } else {
                    fclose($this->pipes[$type]);
                    unset($this->pipes[$type]);
                }
            }
        }

        if (null !== $w && 0 < count($w)) {
            while (strlen($this->inputBuffer)) {
                $written = fwrite($w[0], $this->inputBuffer, 2 << 18); // write 512k
                if ($written > 0) {
                    $this->inputBuffer = (string) substr($this->inputBuffer, $written);
                } else {
                    break;
                }
            }
        }

        // no input to read on resource, buffer is empty and stdin still open
        if ('' === $this->inputBuffer && null === $this->input && isset($this->pipes[0])) {
            fclose($this->pipes[0]);
            unset($this->pipes[0]);
        }

        return $read;
    }

    /**
     * {@inheritdoc}
     */
    public function areOpen()
    {
        return (bool) $this->pipes;
    }

    /**
     * Creates a new UnixPipes instance.
     *
     * @param Process         $process
     * @param string|resource $input
     *
     * @return UnixPipes
     */
    public static function create(Process $process, $input)
    {
        return new static($process->isTty(), $process->isPty(), $input, $process->isOutputDisabled());
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process\Pipes;

use Symfony\Component\Process\Process;
use Symfony\Component\Process\Exception\RuntimeException;

/**
 * WindowsPipes implementation uses temporary files as handles.
 *
 * @see https://bugs.php.net/bug.php?id=51800
 * @see https://bugs.php.net/bug.php?id=65650
 *
 * @author Romain Neutron <imprec@gmail.com>
 *
 * @internal
 */
class WindowsPipes extends AbstractPipes
{
    /** @var array */
    private $files = array();
    /** @var array */
    private $fileHandles = array();
    /** @var array */
    private $readBytes = array(
        Process::STDOUT => 0,
        Process::STDERR => 0,
    );
    /** @var bool */
    private $disableOutput;

    public function __construct($disableOutput, $input)
    {
        $this->disableOutput = (bool) $disableOutput;

        if (!$this->disableOutput) {
            // Fix for PHP bug #51800: reading from STDOUT pipe hangs forever on Windows if the output is too big.
            // Workaround for this problem is to use temporary files instead of pipes on Windows platform.
            //
            // @see https://bugs.php.net/bug.php?id=51800
            $this->files = array(
                Process::STDOUT => tempnam(sys_get_temp_dir(), 'out_sf_proc'),
                Process::STDERR => tempnam(sys_get_temp_dir(), 'err_sf_proc'),
            );
            foreach ($this->files as $offset => $file) {
                if (false === $file || false === $this->fileHandles[$offset] = fopen($file, 'rb')) {
                    throw new RuntimeException('A temporary file could not be opened to write the process output to, verify that your TEMP environment variable is writable');
                }
            }
        }

        if (is_resource($input)) {
            $this->input = $input;
        } else {
            $this->inputBuffer = $input;
        }
    }

    public function __destruct()
    {
        $this->close();
        $this->removeFiles();
    }

    /**
     * {@inheritdoc}
     */
    public function getDescriptors()
    {
        if ($this->disableOutput) {
            $nullstream = fopen('NUL', 'c');

            return array(
                array('pipe', 'r'),
                $nullstream,
                $nullstream,
            );
        }

        // We're not using pipe on Windows platform as it hangs (https://bugs.php.net/bug.php?id=51800)
        // We're not using file handles as it can produce corrupted output https://bugs.php.net/bug.php?id=65650
        // So we redirect output within the commandline and pass the nul device to the process
        return array(
            array('pipe', 'r'),
            array('file', 'NUL', 'w'),
            array('file', 'NUL', 'w'),
        );
    }

    /**
     * {@inheritdoc}
     */
    public function getFiles()
    {
        return $this->files;
    }

    /**
     * {@inheritdoc}
     */
    public function readAndWrite($blocking, $close = false)
    {
        $this->write($blocking, $close);

        $read = array();
        $fh = $this->fileHandles;
        foreach ($fh as $type => $fileHandle) {
            if (0 !== fseek($fileHandle, $this->readBytes[$type])) {
                continue;
            }
            $data = '';
            $dataread = null;
            while (!feof($fileHandle)) {
                if (false !== $dataread = fread($fileHandle, self::CHUNK_SIZE)) {
                    $data .= $dataread;
                }
            }
            if (0 < $length = strlen($data)) {
                $this->readBytes[$type] += $length;
                $read[$type] = $data;
            }

            if (false === $dataread || (true === $close && feof($fileHandle) && '' === $data)) {
                fclose($this->fileHandles[$type]);
                unset($this->fileHandles[$type]);
            }
        }

        return $read;
    }

    /**
     * {@inheritdoc}
     */
    public function areOpen()
    {
        return (bool) $this->pipes && (bool) $this->fileHandles;
    }

    /**
     * {@inheritdoc}
     */
    public function close()
    {
        parent::close();
        foreach ($this->fileHandles as $handle) {
            fclose($handle);
        }
        $this->fileHandles = array();
    }

    /**
     * Creates a new WindowsPipes instance.
     *
     * @param Process $process The process
     * @param $input
     *
     * @return WindowsPipes
     */
    public static function create(Process $process, $input)
    {
        return new static($process->isOutputDisabled(), $input);
    }

    /**
     * Removes temporary files.
     */
    private function removeFiles()
    {
        foreach ($this->files as $filename) {
            if (file_exists($filename)) {
                @unlink($filename);
            }
        }
        $this->files = array();
    }

    /**
     * Writes input to stdin.
     *
     * @param bool $blocking
     * @param bool $close
     */
    private function write($blocking, $close)
    {
        if (empty($this->pipes)) {
            return;
        }

        $this->unblock();

        $r = null !== $this->input ? array('input' => $this->input) : null;
        $w = isset($this->pipes[0]) ? array($this->pipes[0]) : null;
        $e = null;

        // let's have a look if something changed in streams
        if (false === $n = @stream_select($r, $w, $e, 0, $blocking ? Process::TIMEOUT_PRECISION * 1E6 : 0)) {
            // if a system call has been interrupted, forget about it, let's try again
            // otherwise, an error occurred, let's reset pipes
            if (!$this->hasSystemCallBeenInterrupted()) {
                $this->pipes = array();
            }

            return;
        }

        // nothing has changed
        if (0 === $n) {
            return;
        }

        if (null !== $w && 0 < count($r)) {
            $data = '';
            while ($dataread = fread($r['input'], self::CHUNK_SIZE)) {
                $data .= $dataread;
            }

            $this->inputBuffer .= $data;

            if (false === $data || (true === $close && feof($r['input']) && '' === $data)) {
                // no more data to read on input resource
                // use an empty buffer in the next reads
                $this->input = null;
            }
        }

        if (null !== $w && 0 < count($w)) {
            while (strlen($this->inputBuffer)) {
                $written = fwrite($w[0], $this->inputBuffer, 2 << 18);
                if ($written > 0) {
                    $this->inputBuffer = (string) substr($this->inputBuffer, $written);
                } else {
                    break;
                }
            }
        }

        // no input to read on resource, buffer is empty and stdin still open
        if ('' === $this->inputBuffer && null === $this->input && isset($this->pipes[0])) {
            fclose($this->pipes[0]);
            unset($this->pipes[0]);
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process;

use Symfony\Component\Process\Exception\InvalidArgumentException;
use Symfony\Component\Process\Exception\LogicException;
use Symfony\Component\Process\Exception\ProcessFailedException;
use Symfony\Component\Process\Exception\ProcessTimedOutException;
use Symfony\Component\Process\Exception\RuntimeException;
use Symfony\Component\Process\Pipes\PipesInterface;
use Symfony\Component\Process\Pipes\UnixPipes;
use Symfony\Component\Process\Pipes\WindowsPipes;

/**
 * Process is a thin wrapper around proc_* functions to easily
 * start independent PHP processes.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Romain Neutron <imprec@gmail.com>
 */
class Process
{
    const ERR = 'err';
    const OUT = 'out';

    const STATUS_READY = 'ready';
    const STATUS_STARTED = 'started';
    const STATUS_TERMINATED = 'terminated';

    const STDIN = 0;
    const STDOUT = 1;
    const STDERR = 2;

    // Timeout Precision in seconds.
    const TIMEOUT_PRECISION = 0.2;

    private $callback;
    private $commandline;
    private $cwd;
    private $env;
    private $input;
    private $starttime;
    private $lastOutputTime;
    private $timeout;
    private $idleTimeout;
    private $options;
    private $exitcode;
    private $fallbackStatus = array();
    private $processInformation;
    private $outputDisabled = false;
    private $stdout;
    private $stderr;
    private $enhanceWindowsCompatibility = true;
    private $enhanceSigchildCompatibility;
    private $process;
    private $status = self::STATUS_READY;
    private $incrementalOutputOffset = 0;
    private $incrementalErrorOutputOffset = 0;
    private $tty;
    private $pty;

    private $useFileHandles = false;
    /** @var PipesInterface */
    private $processPipes;

    private $latestSignal;

    private static $sigchild;

    /**
     * Exit codes translation table.
     *
     * User-defined errors must use exit codes in the 64-113 range.
     *
     * @var array
     */
    public static $exitCodes = array(
        0 => 'OK',
        1 => 'General error',
        2 => 'Misuse of shell builtins',

        126 => 'Invoked command cannot execute',
        127 => 'Command not found',
        128 => 'Invalid exit argument',

        // signals
        129 => 'Hangup',
        130 => 'Interrupt',
        131 => 'Quit and dump core',
        132 => 'Illegal instruction',
        133 => 'Trace/breakpoint trap',
        134 => 'Process aborted',
        135 => 'Bus error: "access to undefined portion of memory object"',
        136 => 'Floating point exception: "erroneous arithmetic operation"',
        137 => 'Kill (terminate immediately)',
        138 => 'User-defined 1',
        139 => 'Segmentation violation',
        140 => 'User-defined 2',
        141 => 'Write to pipe with no one reading',
        142 => 'Signal raised by alarm',
        143 => 'Termination (request to terminate)',
        // 144 - not defined
        145 => 'Child process terminated, stopped (or continued*)',
        146 => 'Continue if stopped',
        147 => 'Stop executing temporarily',
        148 => 'Terminal stop signal',
        149 => 'Background process attempting to read from tty ("in")',
        150 => 'Background process attempting to write to tty ("out")',
        151 => 'Urgent data available on socket',
        152 => 'CPU time limit exceeded',
        153 => 'File size limit exceeded',
        154 => 'Signal raised by timer counting virtual time: "virtual timer expired"',
        155 => 'Profiling timer expired',
        // 156 - not defined
        157 => 'Pollable event',
        // 158 - not defined
        159 => 'Bad syscall',
    );

    /**
     * Constructor.
     *
     * @param string         $commandline The command line to run
     * @param string|null    $cwd         The working directory or null to use the working dir of the current PHP process
     * @param array|null     $env         The environment variables or null to use the same environment as the current PHP process
     * @param string|null    $input       The input
     * @param int|float|null $timeout     The timeout in seconds or null to disable
     * @param array          $options     An array of options for proc_open
     *
     * @throws RuntimeException When proc_open is not installed
     */
    public function __construct($commandline, $cwd = null, array $env = null, $input = null, $timeout = 60, array $options = array())
    {
        if (!function_exists('proc_open')) {
            throw new RuntimeException('The Process class relies on proc_open, which is not available on your PHP installation.');
        }

        $this->commandline = $commandline;
        $this->cwd = $cwd;

        // on Windows, if the cwd changed via chdir(), proc_open defaults to the dir where PHP was started
        // on Gnu/Linux, PHP builds with --enable-maintainer-zts are also affected
        // @see : https://bugs.php.net/bug.php?id=51800
        // @see : https://bugs.php.net/bug.php?id=50524
        if (null === $this->cwd && (defined('ZEND_THREAD_SAFE') || '\\' === DIRECTORY_SEPARATOR)) {
            $this->cwd = getcwd();
        }
        if (null !== $env) {
            $this->setEnv($env);
        }

        $this->input = $input;
        $this->setTimeout($timeout);
        $this->useFileHandles = '\\' === DIRECTORY_SEPARATOR;
        $this->pty = false;
        $this->enhanceWindowsCompatibility = true;
        $this->enhanceSigchildCompatibility = '\\' !== DIRECTORY_SEPARATOR && $this->isSigchildEnabled();
        $this->options = array_replace(array('suppress_errors' => true, 'binary_pipes' => true), $options);
    }

    public function __destruct()
    {
        $this->stop(0);
    }

    public function __clone()
    {
        $this->resetProcessData();
    }

    /**
     * Runs the process.
     *
     * The callback receives the type of output (out or err) and
     * some bytes from the output in real-time. It allows to have feedback
     * from the independent process during execution.
     *
     * The STDOUT and STDERR are also available after the process is finished
     * via the getOutput() and getErrorOutput() methods.
     *
     * @param callable|null $callback A PHP callback to run whenever there is some
     *                                output available on STDOUT or STDERR
     *
     * @return int The exit status code
     *
     * @throws RuntimeException When process can't be launched
     * @throws RuntimeException When process stopped after receiving signal
     * @throws LogicException   In case a callback is provided and output has been disabled
     */
    public function run($callback = null)
    {
        $this->start($callback);

        return $this->wait();
    }

    /**
     * Runs the process.
     *
     * This is identical to run() except that an exception is thrown if the process
     * exits with a non-zero exit code.
     *
     * @param callable|null $callback
     *
     * @return self
     *
     * @throws RuntimeException       if PHP was compiled with --enable-sigchild and the enhanced sigchild compatibility mode is not enabled
     * @throws ProcessFailedException if the process didn't terminate successfully
     */
    public function mustRun($callback = null)
    {
        if (!$this->enhanceSigchildCompatibility && $this->isSigchildEnabled()) {
            throw new RuntimeException('This PHP has been compiled with --enable-sigchild. You must use setEnhanceSigchildCompatibility() to use this method.');
        }

        if (0 !== $this->run($callback)) {
            throw new ProcessFailedException($this);
        }

        return $this;
    }

    /**
     * Starts the process and returns after writing the input to STDIN.
     *
     * This method blocks until all STDIN data is sent to the process then it
     * returns while the process runs in the background.
     *
     * The termination of the process can be awaited with wait().
     *
     * The callback receives the type of output (out or err) and some bytes from
     * the output in real-time while writing the standard input to the process.
     * It allows to have feedback from the independent process during execution.
     *
     * @param callable|null $callback A PHP callback to run whenever there is some
     *                                output available on STDOUT or STDERR
     *
     * @throws RuntimeException When process can't be launched
     * @throws RuntimeException When process is already running
     * @throws LogicException   In case a callback is provided and output has been disabled
     */
    public function start($callback = null)
    {
        if ($this->isRunning()) {
            throw new RuntimeException('Process is already running');
        }
        if ($this->outputDisabled && null !== $callback) {
            throw new LogicException('Output has been disabled, enable it to allow the use of a callback.');
        }

        $this->resetProcessData();
        $this->starttime = $this->lastOutputTime = microtime(true);
        $this->callback = $this->buildCallback($callback);
        $descriptors = $this->getDescriptors();

        $commandline = $this->commandline;

        if ('\\' === DIRECTORY_SEPARATOR && $this->enhanceWindowsCompatibility) {
            $commandline = 'cmd /V:ON /E:ON /D /C "('.$commandline.')';
            foreach ($this->processPipes->getFiles() as $offset => $filename) {
                $commandline .= ' '.$offset.'>'.ProcessUtils::escapeArgument($filename);
            }
            $commandline .= '"';

            if (!isset($this->options['bypass_shell'])) {
                $this->options['bypass_shell'] = true;
            }
        } elseif (!$this->useFileHandles && $this->enhanceSigchildCompatibility && $this->isSigchildEnabled()) {
            // last exit code is output on the fourth pipe and caught to work around --enable-sigchild
            $descriptors[3] = array('pipe', 'w');

            // See https://unix.stackexchange.com/questions/71205/background-process-pipe-input
            $commandline = '{ ('.$this->commandline.') <&3 3<&- 3>/dev/null & } 3<&0;';
            $commandline .= 'pid=$!; echo $pid >&3; wait $pid; code=$?; echo $code >&3; exit $code';

            // Workaround for the bug, when PTS functionality is enabled.
            // @see : https://bugs.php.net/69442
            $ptsWorkaround = fopen(__FILE__, 'r');
        }

        $this->process = proc_open($commandline, $descriptors, $this->processPipes->pipes, $this->cwd, $this->env, $this->options);

        if (!is_resource($this->process)) {
            throw new RuntimeException('Unable to launch a new process.');
        }
        $this->status = self::STATUS_STARTED;

        if (isset($descriptors[3])) {
            $this->fallbackStatus['pid'] = (int) fgets($this->processPipes->pipes[3]);
        }

        if ($this->tty) {
            return;
        }

        $this->updateStatus(false);
        $this->checkTimeout();
    }

    /**
     * Restarts the process.
     *
     * Be warned that the process is cloned before being started.
     *
     * @param callable|null $callback A PHP callback to run whenever there is some
     *                                output available on STDOUT or STDERR
     *
     * @return Process The new process
     *
     * @throws RuntimeException When process can't be launched
     * @throws RuntimeException When process is already running
     *
     * @see start()
     */
    public function restart($callback = null)
    {
        if ($this->isRunning()) {
            throw new RuntimeException('Process is already running');
        }

        $process = clone $this;
        $process->start($callback);

        return $process;
    }

    /**
     * Waits for the process to terminate.
     *
     * The callback receives the type of output (out or err) and some bytes
     * from the output in real-time while writing the standard input to the process.
     * It allows to have feedback from the independent process during execution.
     *
     * @param callable|null $callback A valid PHP callback
     *
     * @return int The exitcode of the process
     *
     * @throws RuntimeException When process timed out
     * @throws RuntimeException When process stopped after receiving signal
     * @throws LogicException   When process is not yet started
     */
    public function wait($callback = null)
    {
        $this->requireProcessIsStarted(__FUNCTION__);

        $this->updateStatus(false);
        if (null !== $callback) {
            $this->callback = $this->buildCallback($callback);
        }

        do {
            $this->checkTimeout();
            $running = '\\' === DIRECTORY_SEPARATOR ? $this->isRunning() : $this->processPipes->areOpen();
            $close = '\\' !== DIRECTORY_SEPARATOR || !$running;
            $this->readPipes(true, $close);
        } while ($running);

        while ($this->isRunning()) {
            usleep(1000);
        }

        if ($this->processInformation['signaled'] && $this->processInformation['termsig'] !== $this->latestSignal) {
            throw new RuntimeException(sprintf('The process has been signaled with signal "%s".', $this->processInformation['termsig']));
        }

        return $this->exitcode;
    }

    /**
     * Returns the Pid (process identifier), if applicable.
     *
     * @return int|null The process id if running, null otherwise
     */
    public function getPid()
    {
        return $this->isRunning() ? $this->processInformation['pid'] : null;
    }

    /**
     * Sends a POSIX signal to the process.
     *
     * @param int $signal A valid POSIX signal (see http://www.php.net/manual/en/pcntl.constants.php)
     *
     * @return Process
     *
     * @throws LogicException   In case the process is not running
     * @throws RuntimeException In case --enable-sigchild is activated and the process can't be killed
     * @throws RuntimeException In case of failure
     */
    public function signal($signal)
    {
        $this->doSignal($signal, true);

        return $this;
    }

    /**
     * Disables fetching output and error output from the underlying process.
     *
     * @return Process
     *
     * @throws RuntimeException In case the process is already running
     * @throws LogicException   if an idle timeout is set
     */
    public function disableOutput()
    {
        if ($this->isRunning()) {
            throw new RuntimeException('Disabling output while the process is running is not possible.');
        }
        if (null !== $this->idleTimeout) {
            throw new LogicException('Output can not be disabled while an idle timeout is set.');
        }

        $this->outputDisabled = true;

        return $this;
    }

    /**
     * Enables fetching output and error output from the underlying process.
     *
     * @return Process
     *
     * @throws RuntimeException In case the process is already running
     */
    public function enableOutput()
    {
        if ($this->isRunning()) {
            throw new RuntimeException('Enabling output while the process is running is not possible.');
        }

        $this->outputDisabled = false;

        return $this;
    }

    /**
     * Returns true in case the output is disabled, false otherwise.
     *
     * @return bool
     */
    public function isOutputDisabled()
    {
        return $this->outputDisabled;
    }

    /**
     * Returns the current output of the process (STDOUT).
     *
     * @return string The process output
     *
     * @throws LogicException in case the output has been disabled
     * @throws LogicException In case the process is not started
     */
    public function getOutput()
    {
        if ($this->outputDisabled) {
            throw new LogicException('Output has been disabled.');
        }

        $this->requireProcessIsStarted(__FUNCTION__);

        $this->readPipes(false, '\\' === DIRECTORY_SEPARATOR ? !$this->processInformation['running'] : true);

        if (false === $ret = stream_get_contents($this->stdout, -1, 0)) {
            return '';
        }

        return $ret;
    }

    /**
     * Returns the output incrementally.
     *
     * In comparison with the getOutput method which always return the whole
     * output, this one returns the new output since the last call.
     *
     * @throws LogicException in case the output has been disabled
     * @throws LogicException In case the process is not started
     *
     * @return string The process output since the last call
     */
    public function getIncrementalOutput()
    {
        if ($this->outputDisabled) {
            throw new LogicException('Output has been disabled.');
        }

        $this->requireProcessIsStarted(__FUNCTION__);

        $latest = stream_get_contents($this->stdout, -1, $this->incrementalOutputOffset);
        $this->incrementalOutputOffset = ftell($this->stdout);

        if (false === $latest) {
            return '';
        }

        return $latest;
    }

    /**
     * Clears the process output.
     *
     * @return Process
     */
    public function clearOutput()
    {
        ftruncate($this->stdout, 0);
        fseek($this->stdout, 0);
        $this->incrementalOutputOffset = 0;

        return $this;
    }

    /**
     * Returns the current error output of the process (STDERR).
     *
     * @return string The process error output
     *
     * @throws LogicException in case the output has been disabled
     * @throws LogicException In case the process is not started
     */
    public function getErrorOutput()
    {
        if ($this->outputDisabled) {
            throw new LogicException('Output has been disabled.');
        }

        $this->requireProcessIsStarted(__FUNCTION__);

        $this->readPipes(false, '\\' === DIRECTORY_SEPARATOR ? !$this->processInformation['running'] : true);

        if (false === $ret = stream_get_contents($this->stderr, -1, 0)) {
            return '';
        }

        return $ret;
    }

    /**
     * Returns the errorOutput incrementally.
     *
     * In comparison with the getErrorOutput method which always return the
     * whole error output, this one returns the new error output since the last
     * call.
     *
     * @throws LogicException in case the output has been disabled
     * @throws LogicException In case the process is not started
     *
     * @return string The process error output since the last call
     */
    public function getIncrementalErrorOutput()
    {
        if ($this->outputDisabled) {
            throw new LogicException('Output has been disabled.');
        }

        $this->requireProcessIsStarted(__FUNCTION__);

        $latest = stream_get_contents($this->stderr, -1, $this->incrementalErrorOutputOffset);
        $this->incrementalErrorOutputOffset = ftell($this->stderr);

        if (false === $latest) {
            return '';
        }

        return $latest;
    }

    /**
     * Clears the process output.
     *
     * @return Process
     */
    public function clearErrorOutput()
    {
        ftruncate($this->stderr, 0);
        fseek($this->stderr, 0);
        $this->incrementalErrorOutputOffset = 0;

        return $this;
    }

    /**
     * Returns the exit code returned by the process.
     *
     * @return null|int The exit status code, null if the Process is not terminated
     *
     * @throws RuntimeException In case --enable-sigchild is activated and the sigchild compatibility mode is disabled
     */
    public function getExitCode()
    {
        if (!$this->enhanceSigchildCompatibility && $this->isSigchildEnabled()) {
            throw new RuntimeException('This PHP has been compiled with --enable-sigchild. You must use setEnhanceSigchildCompatibility() to use this method.');
        }

        $this->updateStatus(false);

        return $this->exitcode;
    }

    /**
     * Returns a string representation for the exit code returned by the process.
     *
     * This method relies on the Unix exit code status standardization
     * and might not be relevant for other operating systems.
     *
     * @return null|string A string representation for the exit status code, null if the Process is not terminated.
     *
     * @see http://tldp.org/LDP/abs/html/exitcodes.html
     * @see http://en.wikipedia.org/wiki/Unix_signal
     */
    public function getExitCodeText()
    {
        if (null === $exitcode = $this->getExitCode()) {
            return;
        }

        return isset(self::$exitCodes[$exitcode]) ? self::$exitCodes[$exitcode] : 'Unknown error';
    }

    /**
     * Checks if the process ended successfully.
     *
     * @return bool true if the process ended successfully, false otherwise
     */
    public function isSuccessful()
    {
        return 0 === $this->getExitCode();
    }

    /**
     * Returns true if the child process has been terminated by an uncaught signal.
     *
     * It always returns false on Windows.
     *
     * @return bool
     *
     * @throws RuntimeException In case --enable-sigchild is activated
     * @throws LogicException   In case the process is not terminated
     */
    public function hasBeenSignaled()
    {
        $this->requireProcessIsTerminated(__FUNCTION__);

        if (!$this->enhanceSigchildCompatibility && $this->isSigchildEnabled()) {
            throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal can not be retrieved.');
        }

        return $this->processInformation['signaled'];
    }

    /**
     * Returns the number of the signal that caused the child process to terminate its execution.
     *
     * It is only meaningful if hasBeenSignaled() returns true.
     *
     * @return int
     *
     * @throws RuntimeException In case --enable-sigchild is activated
     * @throws LogicException   In case the process is not terminated
     */
    public function getTermSignal()
    {
        $this->requireProcessIsTerminated(__FUNCTION__);

        if ($this->isSigchildEnabled() && (!$this->enhanceSigchildCompatibility || -1 === $this->processInformation['termsig'])) {
            throw new RuntimeException('This PHP has been compiled with --enable-sigchild. Term signal can not be retrieved.');
        }

        return $this->processInformation['termsig'];
    }

    /**
     * Returns true if the child process has been stopped by a signal.
     *
     * It always returns false on Windows.
     *
     * @return bool
     *
     * @throws LogicException In case the process is not terminated
     */
    public function hasBeenStopped()
    {
        $this->requireProcessIsTerminated(__FUNCTION__);

        return $this->processInformation['stopped'];
    }

    /**
     * Returns the number of the signal that caused the child process to stop its execution.
     *
     * It is only meaningful if hasBeenStopped() returns true.
     *
     * @return int
     *
     * @throws LogicException In case the process is not terminated
     */
    public function getStopSignal()
    {
        $this->requireProcessIsTerminated(__FUNCTION__);

        return $this->processInformation['stopsig'];
    }

    /**
     * Checks if the process is currently running.
     *
     * @return bool true if the process is currently running, false otherwise
     */
    public function isRunning()
    {
        if (self::STATUS_STARTED !== $this->status) {
            return false;
        }

        $this->updateStatus(false);

        return $this->processInformation['running'];
    }

    /**
     * Checks if the process has been started with no regard to the current state.
     *
     * @return bool true if status is ready, false otherwise
     */
    public function isStarted()
    {
        return $this->status != self::STATUS_READY;
    }

    /**
     * Checks if the process is terminated.
     *
     * @return bool true if process is terminated, false otherwise
     */
    public function isTerminated()
    {
        $this->updateStatus(false);

        return $this->status == self::STATUS_TERMINATED;
    }

    /**
     * Gets the process status.
     *
     * The status is one of: ready, started, terminated.
     *
     * @return string The current process status
     */
    public function getStatus()
    {
        $this->updateStatus(false);

        return $this->status;
    }

    /**
     * Stops the process.
     *
     * @param int|float $timeout The timeout in seconds
     * @param int       $signal  A POSIX signal to send in case the process has not stop at timeout, default is SIGKILL (9)
     *
     * @return int The exit-code of the process
     */
    public function stop($timeout = 10, $signal = null)
    {
        $timeoutMicro = microtime(true) + $timeout;
        if ($this->isRunning()) {
            // given `SIGTERM` may not be defined and that `proc_terminate` uses the constant value and not the constant itself, we use the same here
            $this->doSignal(15, false);
            do {
                usleep(1000);
            } while ($this->isRunning() && microtime(true) < $timeoutMicro);

            if ($this->isRunning()) {
                // Avoid exception here: process is supposed to be running, but it might have stopped just
                // after this line. In any case, let's silently discard the error, we cannot do anything.
                $this->doSignal($signal ?: 9, false);
            }
        }

        if ($this->isRunning()) {
            if (isset($this->fallbackStatus['pid'])) {
                unset($this->fallbackStatus['pid']);

                return $this->stop(0, $signal);
            }
            $this->close();
        }

        return $this->exitcode;
    }

    /**
     * Adds a line to the STDOUT stream.
     *
     * @internal
     *
     * @param string $line The line to append
     */
    public function addOutput($line)
    {
        $this->lastOutputTime = microtime(true);

        fseek($this->stdout, 0, SEEK_END);
        fwrite($this->stdout, $line);
        fseek($this->stdout, $this->incrementalOutputOffset);
    }

    /**
     * Adds a line to the STDERR stream.
     *
     * @internal
     *
     * @param string $line The line to append
     */
    public function addErrorOutput($line)
    {
        $this->lastOutputTime = microtime(true);

        fseek($this->stderr, 0, SEEK_END);
        fwrite($this->stderr, $line);
        fseek($this->stderr, $this->incrementalErrorOutputOffset);
    }

    /**
     * Gets the command line to be executed.
     *
     * @return string The command to execute
     */
    public function getCommandLine()
    {
        return $this->commandline;
    }

    /**
     * Sets the command line to be executed.
     *
     * @param string $commandline The command to execute
     *
     * @return self The current Process instance
     */
    public function setCommandLine($commandline)
    {
        $this->commandline = $commandline;

        return $this;
    }

    /**
     * Gets the process timeout (max. runtime).
     *
     * @return float|null The timeout in seconds or null if it's disabled
     */
    public function getTimeout()
    {
        return $this->timeout;
    }

    /**
     * Gets the process idle timeout (max. time since last output).
     *
     * @return float|null The timeout in seconds or null if it's disabled
     */
    public function getIdleTimeout()
    {
        return $this->idleTimeout;
    }

    /**
     * Sets the process timeout (max. runtime).
     *
     * To disable the timeout, set this value to null.
     *
     * @param int|float|null $timeout The timeout in seconds
     *
     * @return self The current Process instance
     *
     * @throws InvalidArgumentException if the timeout is negative
     */
    public function setTimeout($timeout)
    {
        $this->timeout = $this->validateTimeout($timeout);

        return $this;
    }

    /**
     * Sets the process idle timeout (max. time since last output).
     *
     * To disable the timeout, set this value to null.
     *
     * @param int|float|null $timeout The timeout in seconds
     *
     * @return self The current Process instance.
     *
     * @throws LogicException           if the output is disabled
     * @throws InvalidArgumentException if the timeout is negative
     */
    public function setIdleTimeout($timeout)
    {
        if (null !== $timeout && $this->outputDisabled) {
            throw new LogicException('Idle timeout can not be set while the output is disabled.');
        }

        $this->idleTimeout = $this->validateTimeout($timeout);

        return $this;
    }

    /**
     * Enables or disables the TTY mode.
     *
     * @param bool $tty True to enabled and false to disable
     *
     * @return self The current Process instance
     *
     * @throws RuntimeException In case the TTY mode is not supported
     */
    public function setTty($tty)
    {
        if ('\\' === DIRECTORY_SEPARATOR && $tty) {
            throw new RuntimeException('TTY mode is not supported on Windows platform.');
        }
        if ($tty && (!file_exists('/dev/tty') || !is_readable('/dev/tty'))) {
            throw new RuntimeException('TTY mode requires /dev/tty to be readable.');
        }

        $this->tty = (bool) $tty;

        return $this;
    }

    /**
     * Checks if the TTY mode is enabled.
     *
     * @return bool true if the TTY mode is enabled, false otherwise
     */
    public function isTty()
    {
        return $this->tty;
    }

    /**
     * Sets PTY mode.
     *
     * @param bool $bool
     *
     * @return self
     */
    public function setPty($bool)
    {
        $this->pty = (bool) $bool;

        return $this;
    }

    /**
     * Returns PTY state.
     *
     * @return bool
     */
    public function isPty()
    {
        return $this->pty;
    }

    /**
     * Gets the working directory.
     *
     * @return string|null The current working directory or null on failure
     */
    public function getWorkingDirectory()
    {
        if (null === $this->cwd) {
            // getcwd() will return false if any one of the parent directories does not have
            // the readable or search mode set, even if the current directory does
            return getcwd() ?: null;
        }

        return $this->cwd;
    }

    /**
     * Sets the current working directory.
     *
     * @param string $cwd The new working directory
     *
     * @return self The current Process instance
     */
    public function setWorkingDirectory($cwd)
    {
        $this->cwd = $cwd;

        return $this;
    }

    /**
     * Gets the environment variables.
     *
     * @return array The current environment variables
     */
    public function getEnv()
    {
        return $this->env;
    }

    /**
     * Sets the environment variables.
     *
     * An environment variable value should be a string.
     * If it is an array, the variable is ignored.
     *
     * That happens in PHP when 'argv' is registered into
     * the $_ENV array for instance.
     *
     * @param array $env The new environment variables
     *
     * @return self The current Process instance
     */
    public function setEnv(array $env)
    {
        // Process can not handle env values that are arrays
        $env = array_filter($env, function ($value) {
            return !is_array($value);
        });

        $this->env = array();
        foreach ($env as $key => $value) {
            $this->env[$key] = (string) $value;
        }

        return $this;
    }

    /**
     * Gets the contents of STDIN.
     *
     * @return string|null The current contents
     *
     * @deprecated since version 2.5, to be removed in 3.0.
     *             Use setInput() instead.
     *             This method is deprecated in favor of getInput.
     */
    public function getStdin()
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 2.5 and will be removed in 3.0. Use the getInput() method instead.', E_USER_DEPRECATED);

        return $this->getInput();
    }

    /**
     * Gets the Process input.
     *
     * @return null|string The Process input
     */
    public function getInput()
    {
        return $this->input;
    }

    /**
     * Sets the contents of STDIN.
     *
     * @param string|null $stdin The new contents
     *
     * @return self The current Process instance
     *
     * @deprecated since version 2.5, to be removed in 3.0.
     *             Use setInput() instead.
     *
     * @throws LogicException           In case the process is running
     * @throws InvalidArgumentException In case the argument is invalid
     */
    public function setStdin($stdin)
    {
        @trigger_error('The '.__METHOD__.' method is deprecated since version 2.5 and will be removed in 3.0. Use the setInput() method instead.', E_USER_DEPRECATED);

        return $this->setInput($stdin);
    }

    /**
     * Sets the input.
     *
     * This content will be passed to the underlying process standard input.
     *
     * @param mixed $input The content
     *
     * @return self The current Process instance
     *
     * @throws LogicException In case the process is running
     *
     * Passing an object as an input is deprecated since version 2.5 and will be removed in 3.0.
     */
    public function setInput($input)
    {
        if ($this->isRunning()) {
            throw new LogicException('Input can not be set while the process is running.');
        }

        $this->input = ProcessUtils::validateInput(sprintf('%s::%s', __CLASS__, __FUNCTION__), $input);

        return $this;
    }

    /**
     * Gets the options for proc_open.
     *
     * @return array The current options
     */
    public function getOptions()
    {
        return $this->options;
    }

    /**
     * Sets the options for proc_open.
     *
     * @param array $options The new options
     *
     * @return self The current Process instance
     */
    public function setOptions(array $options)
    {
        $this->options = $options;

        return $this;
    }

    /**
     * Gets whether or not Windows compatibility is enabled.
     *
     * This is true by default.
     *
     * @return bool
     */
    public function getEnhanceWindowsCompatibility()
    {
        return $this->enhanceWindowsCompatibility;
    }

    /**
     * Sets whether or not Windows compatibility is enabled.
     *
     * @param bool $enhance
     *
     * @return self The current Process instance
     */
    public function setEnhanceWindowsCompatibility($enhance)
    {
        $this->enhanceWindowsCompatibility = (bool) $enhance;

        return $this;
    }

    /**
     * Returns whether sigchild compatibility mode is activated or not.
     *
     * @return bool
     */
    public function getEnhanceSigchildCompatibility()
    {
        return $this->enhanceSigchildCompatibility;
    }

    /**
     * Activates sigchild compatibility mode.
     *
     * Sigchild compatibility mode is required to get the exit code and
     * determine the success of a process when PHP has been compiled with
     * the --enable-sigchild option
     *
     * @param bool $enhance
     *
     * @return self The current Process instance
     */
    public function setEnhanceSigchildCompatibility($enhance)
    {
        $this->enhanceSigchildCompatibility = (bool) $enhance;

        return $this;
    }

    /**
     * Performs a check between the timeout definition and the time the process started.
     *
     * In case you run a background process (with the start method), you should
     * trigger this method regularly to ensure the process timeout
     *
     * @throws ProcessTimedOutException In case the timeout was reached
     */
    public function checkTimeout()
    {
        if ($this->status !== self::STATUS_STARTED) {
            return;
        }

        if (null !== $this->timeout && $this->timeout < microtime(true) - $this->starttime) {
            $this->stop(0);

            throw new ProcessTimedOutException($this, ProcessTimedOutException::TYPE_GENERAL);
        }

        if (null !== $this->idleTimeout && $this->idleTimeout < microtime(true) - $this->lastOutputTime) {
            $this->stop(0);

            throw new ProcessTimedOutException($this, ProcessTimedOutException::TYPE_IDLE);
        }
    }

    /**
     * Returns whether PTY is supported on the current operating system.
     *
     * @return bool
     */
    public static function isPtySupported()
    {
        static $result;

        if (null !== $result) {
            return $result;
        }

        if ('\\' === DIRECTORY_SEPARATOR) {
            return $result = false;
        }

        return $result = (bool) @proc_open('echo 1', array(array('pty'), array('pty'), array('pty')), $pipes);
    }

    /**
     * Creates the descriptors needed by the proc_open.
     *
     * @return array
     */
    private function getDescriptors()
    {
        if ('\\' === DIRECTORY_SEPARATOR) {
            $this->processPipes = WindowsPipes::create($this, $this->input);
        } else {
            $this->processPipes = UnixPipes::create($this, $this->input);
        }

        return $this->processPipes->getDescriptors();
    }

    /**
     * Builds up the callback used by wait().
     *
     * The callbacks adds all occurred output to the specific buffer and calls
     * the user callback (if present) with the received output.
     *
     * @param callable|null $callback The user defined PHP callback
     *
     * @return \Closure A PHP closure
     */
    protected function buildCallback($callback)
    {
        $that = $this;
        $out = self::OUT;
        $callback = function ($type, $data) use ($that, $callback, $out) {
            if ($out == $type) {
                $that->addOutput($data);
            } else {
                $that->addErrorOutput($data);
            }

            if (null !== $callback) {
                call_user_func($callback, $type, $data);
            }
        };

        return $callback;
    }

    /**
     * Updates the status of the process, reads pipes.
     *
     * @param bool $blocking Whether to use a blocking read call.
     */
    protected function updateStatus($blocking)
    {
        if (self::STATUS_STARTED !== $this->status) {
            return;
        }

        $this->processInformation = proc_get_status($this->process);

        $this->readPipes($blocking, '\\' === DIRECTORY_SEPARATOR ? !$this->processInformation['running'] : true);

        if ($this->fallbackStatus && $this->enhanceSigchildCompatibility && $this->isSigchildEnabled()) {
            $this->processInformation = $this->fallbackStatus + $this->processInformation;
        }

        if (!$this->processInformation['running']) {
            $this->close();
        }
    }

    /**
     * Returns whether PHP has been compiled with the '--enable-sigchild' option or not.
     *
     * @return bool
     */
    protected function isSigchildEnabled()
    {
        if (null !== self::$sigchild) {
            return self::$sigchild;
        }

        if (!function_exists('phpinfo') || defined('HHVM_VERSION')) {
            return self::$sigchild = false;
        }

        ob_start();
        phpinfo(INFO_GENERAL);

        return self::$sigchild = false !== strpos(ob_get_clean(), '--enable-sigchild');
    }

    /**
     * Validates and returns the filtered timeout.
     *
     * @param int|float|null $timeout
     *
     * @return float|null
     *
     * @throws InvalidArgumentException if the given timeout is a negative number
     */
    private function validateTimeout($timeout)
    {
        $timeout = (float) $timeout;

        if (0.0 === $timeout) {
            $timeout = null;
        } elseif ($timeout < 0) {
            throw new InvalidArgumentException('The timeout value must be a valid positive integer or float number.');
        }

        return $timeout;
    }

    /**
     * Reads pipes, executes callback.
     *
     * @param bool $blocking Whether to use blocking calls or not.
     * @param bool $close    Whether to close file handles or not.
     */
    private function readPipes($blocking, $close)
    {
        $result = $this->processPipes->readAndWrite($blocking, $close);

        $callback = $this->callback;
        foreach ($result as $type => $data) {
            if (3 !== $type) {
                $callback($type === self::STDOUT ? self::OUT : self::ERR, $data);
            } elseif (!isset($this->fallbackStatus['signaled'])) {
                $this->fallbackStatus['exitcode'] = (int) $data;
            }
        }
    }

    /**
     * Closes process resource, closes file handles, sets the exitcode.
     *
     * @return int The exitcode
     */
    private function close()
    {
        $this->processPipes->close();
        if (is_resource($this->process)) {
            proc_close($this->process);
        }
        $this->exitcode = $this->processInformation['exitcode'];
        $this->status = self::STATUS_TERMINATED;

        if (-1 === $this->exitcode) {
            if ($this->processInformation['signaled'] && 0 < $this->processInformation['termsig']) {
                // if process has been signaled, no exitcode but a valid termsig, apply Unix convention
                $this->exitcode = 128 + $this->processInformation['termsig'];
            } elseif ($this->enhanceSigchildCompatibility && $this->isSigchildEnabled()) {
                $this->processInformation['signaled'] = true;
                $this->processInformation['termsig'] = -1;
            }
        }

        // Free memory from self-reference callback created by buildCallback
        // Doing so in other contexts like __destruct or by garbage collector is ineffective
        // Now pipes are closed, so the callback is no longer necessary
        $this->callback = null;

        return $this->exitcode;
    }

    /**
     * Resets data related to the latest run of the process.
     */
    private function resetProcessData()
    {
        $this->starttime = null;
        $this->callback = null;
        $this->exitcode = null;
        $this->fallbackStatus = array();
        $this->processInformation = null;
        $this->stdout = fopen('php://temp/maxmemory:'.(1024 * 1024), 'wb+');
        $this->stderr = fopen('php://temp/maxmemory:'.(1024 * 1024), 'wb+');
        $this->process = null;
        $this->latestSignal = null;
        $this->status = self::STATUS_READY;
        $this->incrementalOutputOffset = 0;
        $this->incrementalErrorOutputOffset = 0;
    }

    /**
     * Sends a POSIX signal to the process.
     *
     * @param int  $signal         A valid POSIX signal (see http://www.php.net/manual/en/pcntl.constants.php)
     * @param bool $throwException Whether to throw exception in case signal failed
     *
     * @return bool True if the signal was sent successfully, false otherwise
     *
     * @throws LogicException   In case the process is not running
     * @throws RuntimeException In case --enable-sigchild is activated and the process can't be killed
     * @throws RuntimeException In case of failure
     */
    private function doSignal($signal, $throwException)
    {
        if (null === $pid = $this->getPid()) {
            if ($throwException) {
                throw new LogicException('Can not send signal on a non running process.');
            }

            return false;
        }

        if ('\\' === DIRECTORY_SEPARATOR) {
            exec(sprintf('taskkill /F /T /PID %d 2>&1', $pid), $output, $exitCode);
            if ($exitCode && $this->isRunning()) {
                if ($throwException) {
                    throw new RuntimeException(sprintf('Unable to kill the process (%s).', implode(' ', $output)));
                }

                return false;
            }
        } else {
            if (!$this->enhanceSigchildCompatibility || !$this->isSigchildEnabled()) {
                $ok = @proc_terminate($this->process, $signal);
            } elseif (function_exists('posix_kill')) {
                $ok = @posix_kill($pid, $signal);
            } elseif ($ok = proc_open(sprintf('kill -%d %d', $signal, $pid), array(2 => array('pipe', 'w')), $pipes)) {
                $ok = false === fgets($pipes[2]);
            }
            if (!$ok) {
                if ($throwException) {
                    throw new RuntimeException(sprintf('Error while sending signal `%s`.', $signal));
                }

                return false;
            }
        }

        $this->latestSignal = (int) $signal;
        $this->fallbackStatus['signaled'] = true;
        $this->fallbackStatus['exitcode'] = -1;
        $this->fallbackStatus['termsig'] = $this->latestSignal;

        return true;
    }

    /**
     * Ensures the process is running or terminated, throws a LogicException if the process has a not started.
     *
     * @param string $functionName The function name that was called.
     *
     * @throws LogicException If the process has not run.
     */
    private function requireProcessIsStarted($functionName)
    {
        if (!$this->isStarted()) {
            throw new LogicException(sprintf('Process must be started before calling %s.', $functionName));
        }
    }

    /**
     * Ensures the process is terminated, throws a LogicException if the process has a status different than `terminated`.
     *
     * @param string $functionName The function name that was called.
     *
     * @throws LogicException If the process is not yet terminated.
     */
    private function requireProcessIsTerminated($functionName)
    {
        if (!$this->isTerminated()) {
            throw new LogicException(sprintf('Process must be terminated before calling %s.', $functionName));
        }
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process;

use Symfony\Component\Process\Exception\InvalidArgumentException;
use Symfony\Component\Process\Exception\LogicException;

/**
 * Process builder.
 *
 * @author Kris Wallsmith <kris@symfony.com>
 */
class ProcessBuilder
{
    private $arguments;
    private $cwd;
    private $env = array();
    private $input;
    private $timeout = 60;
    private $options = array();
    private $inheritEnv = true;
    private $prefix = array();
    private $outputDisabled = false;

    /**
     * Constructor.
     *
     * @param string[] $arguments An array of arguments
     */
    public function __construct(array $arguments = array())
    {
        $this->arguments = $arguments;
    }

    /**
     * Creates a process builder instance.
     *
     * @param string[] $arguments An array of arguments
     *
     * @return ProcessBuilder
     */
    public static function create(array $arguments = array())
    {
        return new static($arguments);
    }

    /**
     * Adds an unescaped argument to the command string.
     *
     * @param string $argument A command argument
     *
     * @return ProcessBuilder
     */
    public function add($argument)
    {
        $this->arguments[] = $argument;

        return $this;
    }

    /**
     * Adds a prefix to the command string.
     *
     * The prefix is preserved when resetting arguments.
     *
     * @param string|array $prefix A command prefix or an array of command prefixes
     *
     * @return ProcessBuilder
     */
    public function setPrefix($prefix)
    {
        $this->prefix = is_array($prefix) ? $prefix : array($prefix);

        return $this;
    }

    /**
     * Sets the arguments of the process.
     *
     * Arguments must not be escaped.
     * Previous arguments are removed.
     *
     * @param string[] $arguments
     *
     * @return ProcessBuilder
     */
    public function setArguments(array $arguments)
    {
        $this->arguments = $arguments;

        return $this;
    }

    /**
     * Sets the working directory.
     *
     * @param null|string $cwd The working directory
     *
     * @return ProcessBuilder
     */
    public function setWorkingDirectory($cwd)
    {
        $this->cwd = $cwd;

        return $this;
    }

    /**
     * Sets whether environment variables will be inherited or not.
     *
     * @param bool $inheritEnv
     *
     * @return ProcessBuilder
     */
    public function inheritEnvironmentVariables($inheritEnv = true)
    {
        $this->inheritEnv = $inheritEnv;

        return $this;
    }

    /**
     * Sets an environment variable.
     *
     * Setting a variable overrides its previous value. Use `null` to unset a
     * defined environment variable.
     *
     * @param string      $name  The variable name
     * @param null|string $value The variable value
     *
     * @return ProcessBuilder
     */
    public function setEnv($name, $value)
    {
        $this->env[$name] = $value;

        return $this;
    }

    /**
     * Adds a set of environment variables.
     *
     * Already existing environment variables with the same name will be
     * overridden by the new values passed to this method. Pass `null` to unset
     * a variable.
     *
     * @param array $variables The variables
     *
     * @return ProcessBuilder
     */
    public function addEnvironmentVariables(array $variables)
    {
        $this->env = array_replace($this->env, $variables);

        return $this;
    }

    /**
     * Sets the input of the process.
     *
     * @param mixed $input The input as a string
     *
     * @return ProcessBuilder
     *
     * @throws InvalidArgumentException In case the argument is invalid
     *
     * Passing an object as an input is deprecated since version 2.5 and will be removed in 3.0.
     */
    public function setInput($input)
    {
        $this->input = ProcessUtils::validateInput(sprintf('%s::%s', __CLASS__, __FUNCTION__), $input);

        return $this;
    }

    /**
     * Sets the process timeout.
     *
     * To disable the timeout, set this value to null.
     *
     * @param float|null $timeout
     *
     * @return ProcessBuilder
     *
     * @throws InvalidArgumentException
     */
    public function setTimeout($timeout)
    {
        if (null === $timeout) {
            $this->timeout = null;

            return $this;
        }

        $timeout = (float) $timeout;

        if ($timeout < 0) {
            throw new InvalidArgumentException('The timeout value must be a valid positive integer or float number.');
        }

        $this->timeout = $timeout;

        return $this;
    }

    /**
     * Adds a proc_open option.
     *
     * @param string $name  The option name
     * @param string $value The option value
     *
     * @return ProcessBuilder
     */
    public function setOption($name, $value)
    {
        $this->options[$name] = $value;

        return $this;
    }

    /**
     * Disables fetching output and error output from the underlying process.
     *
     * @return ProcessBuilder
     */
    public function disableOutput()
    {
        $this->outputDisabled = true;

        return $this;
    }

    /**
     * Enables fetching output and error output from the underlying process.
     *
     * @return ProcessBuilder
     */
    public function enableOutput()
    {
        $this->outputDisabled = false;

        return $this;
    }

    /**
     * Creates a Process instance and returns it.
     *
     * @return Process
     *
     * @throws LogicException In case no arguments have been provided
     */
    public function getProcess()
    {
        if (0 === count($this->prefix) && 0 === count($this->arguments)) {
            throw new LogicException('You must add() command arguments before calling getProcess().');
        }

        $options = $this->options;

        $arguments = array_merge($this->prefix, $this->arguments);
        $script = implode(' ', array_map(array(__NAMESPACE__.'\\ProcessUtils', 'escapeArgument'), $arguments));

        if ($this->inheritEnv) {
            // include $_ENV for BC purposes
            $env = array_replace($_ENV, $_SERVER, $this->env);
        } else {
            $env = $this->env;
        }

        $process = new Process($script, $this->cwd, $env, $this->input, $this->timeout, $options);

        if ($this->outputDisabled) {
            $process->disableOutput();
        }

        return $process;
    }
}
<?php

/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Symfony\Component\Process;

use Symfony\Component\Process\Exception\InvalidArgumentException;

/**
 * ProcessUtils is a bunch of utility methods.
 *
 * This class contains static methods only and is not meant to be instantiated.
 *
 * @author Martin HasoÅˆ <martin.hason@gmail.com>
 */
class ProcessUtils
{
    /**
     * This class should not be instantiated.
     */
    private function __construct()
    {
    }

    /**
     * Escapes a string to be used as a shell argument.
     *
     * @param string $argument The argument that will be escaped
     *
     * @return string The escaped argument
     */
    public static function escapeArgument($argument)
    {
        //Fix for PHP bug #43784 escapeshellarg removes % from given string
        //Fix for PHP bug #49446 escapeshellarg doesn't work on Windows
        //@see https://bugs.php.net/bug.php?id=43784
        //@see https://bugs.php.net/bug.php?id=49446
        if ('\\' === DIRECTORY_SEPARATOR) {
            if ('' === $argument) {
                return escapeshellarg($argument);
            }

            $escapedArgument = '';
            $quote = false;
            foreach (preg_split('/(")/', $argument, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE) as $part) {
                if ('"' === $part) {
                    $escapedArgument .= '\\"';
                } elseif (self::isSurroundedBy($part, '%')) {
                    // Avoid environment variable expansion
                    $escapedArgument .= '^%"'.substr($part, 1, -1).'"^%';
                } else {
                    // escape trailing backslash
                    if ('\\' === substr($part, -1)) {
                        $part .= '\\';
                    }
                    $quote = true;
                    $escapedArgument .= $part;
                }
            }
            if ($quote) {
                $escapedArgument = '"'.$escapedArgument.'"';
            }

            return $escapedArgument;
        }

        return escapeshellarg($argument);
    }

    /**
     * Validates and normalizes a Process input.
     *
     * @param string $caller The name of method call that validates the input
     * @param mixed  $input  The input to validate
     *
     * @return string The validated input
     *
     * @throws InvalidArgumentException In case the input is not valid
     *
     * Passing an object as an input is deprecated since version 2.5 and will be removed in 3.0.
     */
    public static function validateInput($caller, $input)
    {
        if (null !== $input) {
            if (is_resource($input)) {
                return $input;
            }
            if (is_scalar($input)) {
                return (string) $input;
            }
            // deprecated as of Symfony 2.5, to be removed in 3.0
            if (is_object($input) && method_exists($input, '__toString')) {
                @trigger_error('Passing an object as an input is deprecated since version 2.5 and will be removed in 3.0.', E_USER_DEPRECATED);

                return (string) $input;
            }

            throw new InvalidArgumentException(sprintf('%s only accepts strings or stream resources.', $caller));
        }

        return $input;
    }

    private static function isSurroundedBy($arg, $char)
    {
        return 2 < strlen($arg) && $char === $arg[0] && $char === $arg[strlen($arg) - 1];
    }
}
Process Component
=================

Process executes commands in sub-processes.

In this example, we run a simple directory listing and get the result back:

```php
use Symfony\Component\Process\Process;
use Symfony\Component\Process\Exception\ProcessFailedException;

$process = new Process('ls -lsa');
$process->setTimeout(3600);
$process->run();
if (!$process->isSuccessful()) {
    throw new ProcessFailedException($process);
}

print $process->getOutput();
```

You can think that this is easy to achieve with plain PHP but it's not especially
if you want to take care of the subtle differences between the different platforms.

You can simplify the code by using `mustRun()` instead of `run()`, which will
throw a `ProcessFailedException` automatically in case of a problem:

```php
use Symfony\Component\Process\Process;

$process = new Process('ls -lsa');
$process->setTimeout(3600);
$process->mustRun();

print $process->getOutput();
```

And if you want to be able to get some feedback in real-time, just pass an
anonymous function to the ``run()`` method and you will get the output buffer
as it becomes available:

```php
use Symfony\Component\Process\Process;

$process = new Process('ls -lsa');
$process->run(function ($type, $buffer) {
    if (Process::ERR === $type) {
        echo 'ERR > '.$buffer;
    } else {
        echo 'OUT > '.$buffer;
    }
});
```

That's great if you want to execute a long running command (like rsync-ing files to a
remote server) and give feedback to the user in real-time.

Resources
---------

You can run the unit tests with the following command:

    $ cd path/to/Symfony/Component/Process/
    $ composer install
    $ phpunit
<?php
namespace AssetKit;
use ZipArchive;
use SerializerKit;
use Exception;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use AssetKit\FileUtil;
use AssetKit\FileUtils;
use ConfigKit\ConfigCompiler;
use ArrayAccess;


/**
 * Asset class
 *
 * Asset object can be created from a manifest file.
 * Or can just be created with no arguments.
 *
 *
 *    assets/jquery          <-- source dir
 *    public/assets/jquery   <-- install dir
 *    public                 <-- asset base dir
 *    
 *    /assets                <-- asset base url
 *    /assets/jquery         <-- asset url
 *
 * Manifest file
 *
 *    assets/jquery/manifest.yml  <-- manifest
 *    public/assets/jquery/manifest.yml <-- public manifest
 * 
 * Compiled assets
 *
 *    assets/jquery/js/*.js       <-- js source
 *    assets/jquery/js/*.cs       <-- cs source
 *    assets/jquery/css/*.css     <-- css source
 *    assets/jquery/css/*.sass    <-- sass source
 *
 *    public/assets/jquery/jquery.min.css
 *    public/assets/jquery/jquery.min.js
 *
 */
class Asset implements ArrayAccess
{
    /**
     * @var string the asset name
     */
    public $name;


    /**
     * @var array config stash.
     */
    public $stash;

    /**
     * @var string asset dir (related path, relate to config file) 
     *
     *     "assets/jquery"
     *     "bundles/ResourceA/assets/underscore"
     *     "bundles/ResourceA/assets/font-awesome"
     *
     */
    public $sourceDir;


    public $baseDir;



    /**
     * @var string manifest file path, we assume that the manifest file should be PHP format.
     *
     *     "bundles/ResourceA/assets/font-awesome/manifest.yml"
     */
    public $manifestFile;

    public $manifestCacheFile;


    /**
     * @var AssetKit\Collection[]
     */
    public $collections = array();


    /**
     * We keep the constructor empty because sometimes we need to create an 
     * asset object and setup later.
     */
    public function __construct() { }


    /**
     *
     *
     * @param string $manifestYamlFile related YAML manifest file path, which 
     *          should be absolute path.
     *
     * @param string $name Asset name. If any
     *
     * @param boolean $force force compile manifest file even there is a cached file.
     */
    public function loadManifestFile($manifestYamlFile, $name = NULL, $force = false)
    {
        $this->name = $name ?: basename($this->sourceDir);
        $this->setManifestFile($manifestYamlFile);
        $this->compileManifestFile($force);
        // $this->loadFromArray($stash);
    }

    static public function createFromManifestFile($manifestYamlFile, $name = NULL, $force = false) 
    {
        $asset = new Asset;
        $asset->loadManifestFile($manifestYamlFile, $name, $force);
        return $asset;
    }


    public function setSourceDir($dir) {
        $this->sourceDir = $dir;
    }


    /**
     *
     * @param string $manifestYamlFile
     */
    public function setManifestFile($manifestYamlFile) {
        $this->manifestFile = $manifestYamlFile;
        $this->sourceDir    = dirname($manifestYamlFile);
        $this->manifestCacheFile = ConfigCompiler::compiled_filename($manifestYamlFile);
    }


    /**
     * This method should only "compile" the YAML file and load the data into the "stash" property.
     *
     * @param bool $force
     */
    protected function compileManifestFile($force = false) {
        if ($force || ConfigCompiler::test($this->manifestFile, $this->manifestCacheFile)) {
            $stash = ConfigCompiler::parse($this->manifestFile);

            // expand file list
            if (isset($stash['collections'])) {
                foreach($stash['collections'] as & $cStash) {
                    $key = $this->_getFileListKey($cStash);
                    if (!$key) {
                        throw new Exception("{$this->manifestFile}: type key undefined.");
                    }
                    $cStash[$key] = $this->expandFileList($this->sourceDir, $cStash[$key]);
                }
            }

            // write config back
            ConfigCompiler::write($this->manifestCacheFile, $stash);
            return $this->stash = $stash;
        } else {
            return $this->stash = require $this->manifestCacheFile;
        }
    }


    public function getDepends()
    {
        if (isset($this->stash['depends'])) {
            return $this->stash['depends'];
        }
        return array();
    }

    /**
     * @return array the loaded manifest config array
     */
    public function getManifestConfig()
    {
        return $this->stash;
    }

    public function loadFromArray(array $stash)
    {
        $this->stash = $stash;
    }


    /**
     * This method create collection objects based on the config from manifest file,
     *
     * File paths will be expanded.
     *
     * Thie method copies class members to to the file collection
     *
     * TODO: Save the absolute path in our cache.
     * TODO: Save the collection object in the asset config, so we may use APC to cache the objects.
     *       To save the collection objects in our APC, the objects must not depend on the config/loader object.
     */
    public function loadCollections(array $collectionStash)
    {
        $sourceDir = $this->sourceDir;
        $collections = array();

        // if the asset name contains the file type mark #js or #css
        //    jquery-ui:javascript
        //    jquery-ui:stylesheet
        //    jquery-ui#basic-theme
        $targetId = NULL;
        $targetType = NULL;
        if ($p = strpos($this->name, '#')) {
            $targetId = substr($this->name, $p + 1);
        }
        if ($p = strpos($this->name, ':')) {
            $targetType = substr($this->name, $p + 1);
        }

        foreach($collectionStash as $stash) {
            $collection = new Collection($stash);
            if (isset($stash['id']) ) {
                $collection->id = $stash['id'];
            }
            if (isset($stash['attrs']) ) {
                $collection->attributes = $stash['attrs'];
            }
            if( isset($stash['filters']) ) {
                $collection->filters = $stash['filters'];
            }
            if( isset($stash['compressors']) ) {
                $collection->compressors = $stash['compressors'];
            }

            $fileKey = $collection->initContentType($stash);
            // $collection->files = $this->expandFileList($sourceDir, $stash[$fileKey]);
            $collection->files = $stash[$fileKey];
            $collection->sourceDir = $this->getSourceDir();

            if ($targetId && $collection->id === $targetId) {
                return array($collection);
            }
            if ($targetType && $fileKey !== $targetType) {
                continue;
            }
            $collections[] = $collection;
        }
        return $collections;
    }

    public function expandFileList($sourceDir, $files) {
        $expandedFiles = array();
        foreach( $files as $p ) {
            // if we found a glob pattern
            if (strpos($p,'*') !== false) {

                $expanded = FileUtil::expand_glob_from_dir($sourceDir, $p);
                $expandedFiles = array_unique( array_merge( $expandedFiles , $expanded ) );

            } elseif(is_dir( $sourceDir . DIRECTORY_SEPARATOR . $p )) {

                // We remove the base dir becase we need to build the 
                // asset urls
                $expanded = FileUtil::expand_dir_recursively( $sourceDir . DIRECTORY_SEPARATOR . $p );
                $expanded = FileUtil::remove_basedir_from_paths($expanded , $sourceDir);
                $expandedFiles = array_unique(array_merge( $expandedFiles , $expanded ));

            } else {
                $expandedFiles[] = $p;
            }
        }
        return $expandedFiles;
    }


    /**
     * @param integer Collection::FileType*
     */
    public function findCollectionsByFileType($filetype) {
        $collections = $this->getCollections();
        foreach($collections as $collection) {
            if ($filetype === $collection->filetype) {
                return $collection;
            }
        }
        return NULL;
    }

    /**
     * Find collection by specific ID
     */
    public function findCollectionById($id)
    {
        $collections = $this->getCollections();
        foreach($collections as $collection) {
            if ($id === $collection->id) {
                return $collection;
            }
        }
        return NULL;
    }


    public function getCollections()
    {
        if ($this->collections) {
            return $this->collections;
        }

        // load assets
        if (isset($this->stash['collections']) ) {
            return $this->collections = $this->loadCollections($this->stash['collections']);
        }
    }

    public function export()
    {
        // we should also save installed_dir
        // installed_dir = public dir + source dir
        return array(
            'stash'       => $this->stash,
            'manifest'    => $this->manifestFile,
            'source_dir'  => $this->sourceDir,
            // 'collections' => $this->collections,
            'name'        => $this->name,
        );
    }


    /**
     * @return string Asset name
     */
    public function getName()
    {
        return $this->name;
    }



    /**
     * Get the asset source directory
     *
     * @param bool $absolute
     */
    public function getSourceDir()
    {
        return $this->sourceDir;
    }


    /**
     * Check if collection files are out of date.
     */
    public function isOutOfDate($fromTime)
    {
        $collections = $this->getCollections();
        foreach( $collections as $c ) {
            // if the collectino is newer than from time.
            if ( $c->isOutOfDate($fromTime) ) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check source file existence.
     *
     * @return bool
     */
    public function hasSourceFiles()
    {
        foreach( $this->collections as $collection ) {
            $paths = $collection->getSourcePaths();
            foreach( $paths as $path ) {
                if ( ! file_exists($path) ) {
                    return false;
                }
            }
        }
        return true;
    }

    public function __set_state($array) {
        // TODO: implement this
    }


    private function _getFileListKey(array $stash) {
        foreach(array('file','js','css','javascript', 'coffeescript', 'coffee', 'sass', 'scss', 'stylesheet') as $key) {
            if (isset($stash[$key])) {
                return $key;
            }
        }
    }


    public function offsetSet($name,$value)
    {
        $this->stash[ $name ] = $value;
    }
    
    public function offsetExists($name)
    {
        return isset($this->stash[ $name ]);
    }
    
    public function offsetGet($name)
    {
        return $this->stash[ $name ];
    }
    
    public function offsetUnset($name)
    {
        unset($this->stash[$name]);
    }
    
}



<?php
namespace AssetKit;
use ArrayAccess;
use AssetKit\Cache;
use IteratorAggregate;
use Countable;
use ArrayIterator;
use AssetKit\Asset;

class AssetCollection implements ArrayAccess, IteratorAggregate, Countable
{
    public $assets = array();

    public function __construct($assets = null)
    {
        if ($assets) {
            $this->assets = $assets;
        }
    }

    public function add(Asset $asset)
    {
        $this->assets[] = $asset;
    }

    public function getIterator() {
        return new ArrayIterator($this->assets);
    }

    public function count() {
        return count($this->assets);
    }
    
    public function offsetSet($name, $value)
    {
        $this->assets[ $name ] = $value;
    }

    public function offsetExists($name)
    {
        return isset($this->assets[ $name ]);
    }

    public function offsetGet($name)
    {
        return $this->assets[ $name ];
    }

    public function offsetUnset($name)
    {
        unset($this->assets[$name]);
    }

}



<?php
namespace AssetKit;
use AssetKit\FileUtil;
use AssetKit\AssetUrlBuilder;
use AssetKit\Collection;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;

// Filters
use AssetKit\Filter\SassFilter;
use AssetKit\Filter\ScssFilter;
use AssetKit\Filter\CoffeeScriptFilter;
use AssetKit\Filter\CssImportFilter;

// Compressors
use AssetKit\Compressor\Yui\JsCompressor as YuiJsCompressor;
use AssetKit\Compressor\Yui\CssCompressor as YuiCssCompressor;

// Exceptions
use AssetKit\Exception\UndefinedFilterException;
use AssetKit\Exception\UndefinedCompressorException;
use AssetKit\Exception\UnwritableFileException;
use Exception;
use RuntimeException;
use InvalidArgumentException;


class AssetCompilerException extends Exception {  }

class AssetCompiler
{

    /**
     * @var AssetKit\AssetConfig asset config object.
     */
    public $config;


    /**
     * @var AssetKit\AssetLoader asset loader object.
     */
    public $loader;


    /**
     * @var boolean enable compressor in production mode
     */
    public $enableCompressor = true;

    /**
     * @var array cached filters
     */
    protected $filters = array();


    /**
     * @var array cached compressors
     */
    protected $compressors = array();

    /**
     * @var array filter builders
     */
    protected $_filters = array();

    /**
     * @var array compressor builders
     */
    protected $_compressors = array();

    public $defaultJsCompressor = 'jsmin';

    public $defaultCssCompressor = 'cssmin';

    public $autoAddUnknownTarget = false;

    public function __construct(AssetConfig $config, AssetLoader $loader)
    {
        $this->config = $config;
        $this->loader = $loader;
        $this->urlBuilder = new AssetUrlBuilder($config);
    }

    public function setConfig(AssetConfig $config)
    {
        $this->config = $config;
    }


    public function setLoader(AssetLoader $loader)
    {
        $this->loader = $loader;
    }


    /**
     * Register the default compressors that are supported from AssetKit.
     */
    public function registerDefaultCompressors()
    {
        if (extension_loaded('jsmin')) {
            $this->registerCompressor('jsmin', '\AssetKit\Compressor\JsMinExtCompressor');
        } else {
            $this->registerCompressor('jsmin', '\AssetKit\Compressor\JsMinCompressor');
        }
        $this->registerCompressor('cssmin', '\AssetKit\Compressor\CssMinCompressor');
        $this->registerCompressor('uglifyjs', '\AssetKit\Compressor\UglifyCompressor');
        $this->registerCompressor('yuicss', '\AssetKit\Compressor\Yui\CssCompressor');
        $this->registerCompressor('yuijs', '\AssetKit\Compressor\Yui\JsCompressor');
    }

    public function registerDefaultFilters()
    {
        $this->registerFilter( 'coffeescript','\AssetKit\Filter\CoffeeScriptFilter');
        $this->registerFilter( 'css_import', '\AssetKit\Filter\CssImportFilter');
        $this->registerFilter( 'sass', '\AssetKit\Filter\SassFilter');
        $this->registerFilter( 'scss', '\AssetKit\Filter\ScssFilter');
        $this->registerFilter( 'css_rewrite', '\AssetKit\Filter\CssRewriteFilter');
    }


    /**
     * Simply run filters through these assets.
     *
     * @param AssetKit\Assets[] asset objects
     */
    public function compileAssets(array $assets, $target = null)
    {
        $assetNames = array();
        $out = array();

        $root = $this->config->getRoot();
        $baseDir = $this->config->getBaseDir(true);
        foreach ($assets as $asset) {
            $assetNames[] = $asset->name;
            $assetBaseUrl = $this->urlBuilder->buildBaseUrl($asset);

            $collections = $asset->getCollections();
            if (!$collections) {
                continue;
            }
            foreach ($collections as $c ) {
                $type = null;
                if ( $c->isScript ) {
                    $type = 'javascript';
                } elseif ( $c->isStylesheet ) {
                    $type = 'stylesheet';
                } else {
                    // skip non-filetype collections
                    continue;
                }

                // for collections has filters, 
                // pipe content through these filters.
                $filtered = false;

                // if user defined filters, run it.
                if ( $filters = $c->getFilters() ) {
                    $filtered = $this->runUserDefinedFilters($c);
                } else {
                    $filtered = $this->runDefaultFilters($asset, $c);
                }

                // for coffee-script we need to pass the coffee-script to compiler
                // and get the javascript from the output, we can simply render the 
                // content in the pipe.
                if ( $filtered ) {
                    $content = $c->getContent();
                    $out[] = array(
                        'type' => $type,
                        'content' => $content,
                        'attrs' => $c->attributes
                    );
                } else {
                    $paths = $c->getFilePaths();
                    foreach( $paths as $path ) {
                        $out[] = array( 
                            'type' => $type, 
                            'url' => $assetBaseUrl . '/' . $path,
                            'attrs' => $c->attributes,
                        );
                    }
                }
            }
        }

        // if we got target name, then we should register the target to the assetkit config.
        if ( $this->autoAddUnknownTarget && $target ) {
            // we should always update the target, because we might change the target assets from
            // template or php code.
            $this->loader->addTarget($target, $assetNames);
            $this->loader->saveEntries();
        }

        return $out;
    }




    /**
     * Clean up compiled files 
     *
     * @param array $meta
     */
    public function clean(array $meta)
    {
        foreach( array('css_file','js_file') as $key ) {
            if ( $meta[$key] ) {
                futil_unlink_if_exists( $meta[$key] );
            }
        }
    }



    /**
     * Register filter builder
     *
     * @param string $name filter name
     * @param function $cb builder closure
     */
    public function registerFilter($name,$cb)
    {
        $this->_filters[ $name ] = $cb;
    }


    /**
     * Register compressor
     *
     * @param string $name compressor name
     * @param function $cb function builder
     */
    public function registerCompressor($name,$cb)
    {
        $this->_compressors[ $name ] = $cb;
    }


    /**
     * Get Filter object
     *
     * @param string $name filter name
     */
    public function getFilter($name)
    {
        if ( isset($this->filters[$name]) ) {
            return $this->filters[$name];
        }

        // check the factory closure
        if ( ! isset($this->_filters[$name]) ) {
            throw new UndefinedFilterException("$name filter is undefined.");
        }

        $cb = $this->_filters[ $name ];
        if ( is_callable($cb) ) {
            return $this->filters[ $name ] = call_user_func($cb);
        } elseif ( class_exists($cb,true) ) {
            return $this->filters[ $name ] = new $cb($this->config);
        }
        throw new InvalidArgumentException("Unsupported filter builder type.");
    }

    public function getFilters()
    {
        $self = $this;
        return array_map(function($n) use ($self) { 
            return $self->getFilter($n);
                }, $this->_filters);
    }


    /**
     * Get compressor object
     *
     * @param string $name compressor name
     */
    public function getCompressor($name)
    {
        if ( isset($this->compressors[$name]) ) {
            return $this->compressors[$name];
        }

        // check compressor builder
        if ( ! isset($this->_compressors[$name]) ) {
            throw new UndefinedCompressorException("$name compressor is undefined.");
        }

        $cb = $this->_compressors[ $name ];

        if ( is_string($cb) ) {
            if ( class_exists($cb,true) ) {
                return $this->compressors[ $name ] = new $cb;
            } else {
                throw new AssetCompilerException("$cb class not found.");
            }
        } else if ( is_callable($cb) ) {
            return $this->compressors[ $name ] = call_user_func($cb);
        } else {
            throw new InvalidArgumentException("Unsupported compressor builder type");
        }
    }

    public function getCompressors()
    {
        $self = $this;
        $c = array();
        return array_map(function($n) use($self) { 
            return $self->getCompressor($n);
             }, $this->_compressors);
    }


    /**
     * Run user-defined filters to the file collection
     *
     * @param Collection the collection objecct
     */
    public function runUserDefinedFilters(Collection $collection)
    {
        if ( empty($this->filters) ) {
            return false;
        }
        if ( $this->hasFilter('no') ) {
            return false;
        }
        foreach( $this->filters as $n ) {
            $filter = $this->getFilter( $n );
            $filter->filter($collection);
            return true; // XXX: check this logic flow
        }
        return false;
    }


    /**
     * Run default filters, for coffee-script, sass, scss filetype,
     * these content must be filtered.
     *
     * @param Asset 
     * @param Collection
     *
     * @return bool returns true if filter is matched, returns false if there is no filter matched.
     */
    public function runDefaultFilters(Asset $asset, Collection $collection)
    {
        $assetBaseUrl = $this->urlBuilder->buildBaseUrl($asset);

        if ($collection->filetype === Collection::FileTypeCoffee) {
            $coffee = new CoffeeScriptFilter($this->config);
            $coffee->filter( $collection );
            return true;
        } elseif ( $collection->filetype === Collection::FileTypeSass ) {
            $sass = new SassFilter($this->config, $assetBaseUrl);
            $sass->filter($collection);
            return true;
        } elseif ( $collection->filetype === Collection::FileTypeScss ) {
            $scss = new ScssFilter($this->config, $assetBaseUrl);
            $scss->filter( $collection );
            return true;
        }
        return false;
    }



}

<?php
namespace AssetKit;
use Exception;
use RuntimeException;
use AssetKit\FileUtil;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\AssetUrlBuilder;
use AssetKit\Collection;
use AssetKit\ProductionAssetCompiler;
use AssetKit\AssetCompiler;


class AssetCompilerFactory
{
    static public function create(AssetConfig $config, AssetLoader $loader) {
        $compiler = NULL;
        if ($config->getEnvironment() === 'production' ) {
            $compiler = new ProductionAssetCompiler($config,$loader);
        } elseif ($config->getEnvironment() === 'development' ) {
            $compiler = new AssetCompiler($config, $loader);
        } else {
            $compiler = new AssetCompiler($config, $loader);
        }
        $compiler->registerDefaultCompressors();
        $compiler->registerDefaultFilters();
        return $compiler;
    }
}




<?php
namespace AssetKit;
use ConfigKit\ConfigCompiler;
use AssetKit\Asset;
use AssetKit\Data;
use Exception;
use ArrayAccess;

/**
 * AssetConfig defines methods to get/set asset config value.
 *
 *
 */
class AssetConfig implements ArrayAccess
{
    const PRODUCTION = 1;
    const DEVELOPMENT = 2;

    /**
     * @var string $file the config file path
     */
    public $file;


    /**
     * @var string root path (absolute path)
     */
    public $root;


    /**
     * @var array $config the config hash.
     *
     *    'BaseDir': The base directory for public files.
     *    'BaseUrl': The base url for front-end.
     *    'dirs': asset directories.
     *    'assets': contains asset configs
     *
     *       { 
     *          manifest: manifest path
     *          source_dir: asset directory
     *       }
     */
    public $stash = array();

    /**
     * @var array
     */
    public $options = array();

    /**
     * Cache object instance
     */
    public $cache;

    public function __construct($arg = null, $options = null) {
        if ($arg) {
            if (is_string($arg)) {
                $this->file = $arg;
                if (file_exists($arg)) {
                    $this->load();
                }
            } elseif (is_array($arg)) {
                $this->stash = $arg;
            }
        }
        if ($options) {
            $this->options = $options;
            if ( isset($options['Root']) ) {
                $this->root = $options['Root'];
            }
            if ( isset($options['Cache']) ) {
                $this->cache = $options['Cache'];
            }
            if (isset($options['Environment'])) {
                $this->setEnvironment($options['Environment']);
            }
        }
    }


    public function getDefaultTarget()
    {
        if ( isset($this->stash['DefaultTarget']) ) {
            return $this->stash['DefaultTarget'];
        }
        return 'minified';
    }

    public function getCache() {
        return $this->cache;
    }

    public function setCache($cache) {
        $this->cache = $cache;
    }

    public function setCacheDir($dir)
    {
        $this->stash['CacheDir'] = $dir;
    }

    public function getCacheDir($absolute = false)
    {
        $dir = null;
        if ( isset($this->stash['CacheDir']) ) {
            $dir = $this->stash['CacheDir'];
        } else {
            $dir = 'cache'; // default cache_dir
        }
        return $absolute ? $this->getRoot() . DIRECTORY_SEPARATOR . $dir : $dir;
    }


    /**
     * Return namespace
     */
    public function getNamespace()
    {
        if ( isset($this->stash['Namespace']) ) {
            return $this->stash['Namespace'];
        }
        return getcwd();
    }


    public function setNamespace($namespace)
    {
        $this->stash['Namespace'] = $namespace;
    }

    /**
     * Extra options
     *
     * @param array $options
     */
    public function setOptions($options)
    {
        $this->options = $options;
    }


    /**
     * @var string
     *
     * Return the file that stores data from AssetEntryStorage.
     */
    public function getEntryFile() {
        if (isset($this->stash['EntryFile']) ) {
            return $this->getRoot() . DIRECTORY_SEPARATOR . $this->stash['EntryFile'];
        }
        return $this->getRoot() . DIRECTORY_SEPARATOR . '.asset-entries.php';
    }

    public function getEnvironment() {
        if (isset($this->stash['Environment']) ) {
            return $this->stash['Environment'];
        }
    }

    public function setEnvironment($env)
    {
        if ($env == self::PRODUCTION) {
            $this->stash['Environment'] = 'production';
        } elseif ($env == self::DEVELOPMENT ) {
            $this->stash['Environment'] = 'development';
        } else {
            $this->stash['Environment'] = $env;
        }
    }

    public function loadFile($file) {
        $this->file = $file;
        $this->load();
    }

    /**
     * Load or reload the stash file.
     */
    public function load()
    {
        if (extension_loaded('apc')) {
            $key = 'asset-config:' . $this->root . ':' . $this->file;
            if ($stash = apc_fetch($key)) {
                $this->stash = $stash;
            } else {
                $this->stash = ConfigCompiler::load($this->file);
                apc_store($key, $this->stash);
            }
            if (!$this->stash) {
                throw new Exception('Config load failed: ' . $this->file);
            }
            return $this->stash;
        }
        return $this->stash = ConfigCompiler::load($this->file);
    }

    /**
     * Write current config to file
     *
     * @param string $filename
     */
    public function writeFile($filepath, array $config)
    {
        ConfigCompiler::write_yaml($filepath, $config);
    }

    /**
     * Save current asset config with $format
     */
    public function save($file = null)
    {
        if ($file) {
            $this->file = $file;
        }
        if (!$this->file) {
            throw new Exception("Filename for config is not defined.");
        }
        ConfigCompiler::write_yaml($this->file, $this->stash);
    }

    public function getConfigFile() {
        return $this->file;
    }


    public function hasTarget($targetId)
    {
        return isset($this->stash['Targets'][ $targetId ]);
    }

    public function getTarget($targetId)
    {
        if ( isset($this->stash['Targets'][ $targetId ]) ) {
            return $this->stash['Targets'][ $targetId ];
        }
    }

    public function getTargets()
    {
        if ( isset($this->stash['Targets']) ) {
            return $this->stash['Targets'];
        }
    }

    /**
     * Add asset directory, this asset directory is for looking up asset to 
     * register.
     *
     * @param string $dir
     */
    public function addAssetDirectory($dir)
    {
        $this->stash['Dirs'][] = $dir;
    }



    /**
     * Return asset directories
     *
     * @return array
     */
    public function getAssetDirectories()
    {
        if(isset($this->stash['Dirs']) ) {
            return $this->stash['Dirs'];
        }
        return array();
    }

    /**
     * get config
     */
    public function getConfigArray()
    {
        return $this->stash;
    }


    /**
     * Get BaseDir, this is usually used for compiling and minifing.
     *
     * @param bool $absolute reutrn absolute path or not 
     * @return string the path
     */
    public function getBaseDir($absolute = false)
    {
        // Here the absolute base dir path should not be prefixed by fileDirectory
        // We should simply get the realpath in their context.
        if( isset($this->stash['BaseDir']) && $this->stash['BaseDir'] ) 
        {
            if( $absolute ) {
                return $this->getRoot() . DIRECTORY_SEPARATOR .  $this->stash['BaseDir'];
            }
            return $this->stash['BaseDir'];
        }
        throw new Exception("BaseDir is not defined in asset config.");
    }


    /**
     * Get BaseUrl for front-end including
     *
     * @return string the path.
     */
    public function getBaseUrl()
    {
        if ( isset($this->stash['BaseUrl']) && $this->stash['BaseUrl'] ) {
            return $this->stash['BaseUrl'];
        }
        throw new Exception("BaseUrl is not defined in asset config.");
    }



    /**
     * Get the base url of the installed assets.
     */
    public function setBaseUrl($url) 
    {
        $this->stash['BaseUrl'] = $url;
    }

    /**
     * Set the base dir of installed asset.
     *
     * @param string $path must be relative path.
     *
     */
    public function setBaseDir($path) 
    {
        $this->stash['BaseDir'] = $path;
    }


    /**
     * @return string Return the absolute path of the compiled asset directory.
     */
    public function getCompiledDir()
    {
        return $this->getBaseDir(true) . DIRECTORY_SEPARATOR . 'compiled';
    }


    /**
     * @return string Return the base url of the compiled asset directory
     */
    public function getCompiledUrl()
    {
        return $this->getBaseUrl() . '/compiled';
    }


    /**
     * Set base path for assets and asset directories
     *
     * @param string $root
     */
    public function setRoot($root)
    {
        $this->root = $root;
    }


    /**
     * Return the config file dir path.
     *
     * Or return the root path from the config file.
     */
    public function getRoot()
    {
        if ($this->root) {
            return $this->root;
        }
        if ($this->file) {
            return realpath(dirname($this->file));
        }
    }

    public function offsetSet($name,$value)
    {
        $this->stash[ $name ] = $value;
    }

    public function offsetExists($name)
    {
        return isset($this->stash[ $name ]);
    }

    public function offsetGet($name)
    {
        return $this->stash[ $name ];
    }

    public function offsetUnset($name)
    {
        unset($this->stash[$name]);
    }

}

<?php
namespace AssetKit;
use ArrayAccess;
use AssetKit\Cache;
use IteratorAggregate;
use ArrayIterator;

/**
 * An asset cache container that caches the config of the 
 * assets.
 */
class AssetEntryStorage implements ArrayAccess, IteratorAggregate
{
    /**
     * @array the assets array that contains the config of all assets.
     *
     *   $assets = [
     *       [asset name] = [ 'source' => .... ];
     *   ];
     */
    public $stash = array();

    public $targets = array();

    public function __construct($stash = NULL) {
        if ($stash) {
            $this->stash = $stash;
        }
    }

    public function getIterator() {
        return new ArrayIterator($this->stash);
    }

    /**
     * Get the config of name asset.
     *
     * The asset config contains:
     *
     *   "manifest": "tests\/assets\/jquery\/manifest.yml"
     *   "source_dir": "tests\/assets\/jquery"
     *   "name": "jquery"
     *
     * @param string $name asset name
     */
    public function get($name)
    {
        if( isset($this->stash[$name]) ) {
            return $this->stash[$name];
        }
    }

    /**
     * @var string check if we've loaded this asset.
     * @return bool
     */
    public function has($name)
    {
        return isset($this->stash[$name]);
    }

    /**
     * Add asset to the config assets.
     *
     * @param string $name
     * @param array $config
     */
    public function set($name, $config)
    {
        $this->stash[$name] = $config;
    }


    /**
     * Remove asset from config
     *
     * @param string $name asset name
     */
    public function remove($name)
    {
        unset($this->stash[$name]);
    }

    public function removeAll() {
        $this->stash = array();
    }


    /**
     * Add an asset object to the config assets.
     *
     * @param Asset $asset
     */
    public function add(Asset $asset)
    {
        $this->stash[ $asset->name ] = $asset->export(); 
    }


    /**
     * Returns all asset objects (keys and values)
     */
    public function pairs()
    {
        return $this->stash;
    }

    /**
     * This method returns all assets in an indexed array.
     *
     * @return Asset[]
     */
    public function all()
    {
        return array_values($this->stash);
    }




    /***********************************************
     * Methods implemented for ArrayAccess interface.
     ***********************************************/


    public function offsetSet($name, $value)
    {
        $this->stash[ $name ] = $value;
    }

    public function offsetExists($name)
    {
        return isset($this->stash[ $name ]);
    }

    public function offsetGet($name)
    {
        return $this->stash[ $name ];
    }

    public function offsetUnset($name)
    {
        unset($this->stash[$name]);
    }

    static public function __set_state($array) {
        $o = new self();
        $o->stash = $array['stash'];
        $o->targets = $array['targets'];
        return $o;
    }


    /**
     * Register Assets to a target,
     * So that we can get assets by a target Id.
     *
     * @param string $targetId
     * @param string[] $assets The names of assets.
     */
    public function addTarget($targetId, $assetNames)
    {
        $this->targets[ $targetId ] = $assetNames;
    }

    /**
     * Remove a target from the config stash
     *
     * @param string $targetId
     */
    public function removeTarget($targetId)
    {
        unset($this->targets[ $targetId ]);
    }

    public function hasTarget($targetId)
    {
        return isset($this->targets[ $targetId ]);
    }

    public function getTarget($targetId)
    {
        if ( isset($this->targets[ $targetId ]) ) {
            return $this->targets[ $targetId ];
        }
    }

    public function getTargets()
    {
        return $this->targets;
    }

}


<?php
namespace AssetKit;
use AssetKit\Asset;
use AssetKit\AssetConfig;
use AssetKit\AssetEntryStorage;
use ConfigKit\ConfigCompiler;
use Exception;
use BadMethodCallException;

class ManifestFileNotFoundException extends Exception {}

/**
 * @class
 *
 * Load Asset from manifest File.
 *
 *
 *
 * Operations:
 *
 *
 * 1. Register asset: compile and register asset manifest to the asset config.
 * 2. Load asset: load the registered asset from the config hash, simply load the compiled php asset config.
 * 3. Update asset: get registered assets and re-compile their manifest file from the config.
 * 4. Remove asset: remove the registered assets by asset name.
 *
 */
class AssetLoader
{
    /**
     * @var AssetConfig
     */
    public $config;


    /**
     * @var Asset[string name]
     *
     * Used for storing loaded asset objects
     */
    public $objects = array();

    /**
     * @var AssetEntryStorage 
     *
     * Used for saving registered asset configs (PHP arrays)
     */
    public $entries;

    /**
     *
     * @param AssetKit\AssetConfig $config
     */
    public function __construct(AssetConfig $config)
    {
        $this->config = $config;

        // TODO: support entry file stat check
        if ($cache = $config->getCache()) {
            if ($entries = $cache->get('asset_entries')) {
                $this->entries = $entries;
                return;
            }
        }

        // Fallback to entry file automatically
        $entryFile = $config->getEntryFile();
        if (file_exists($entryFile)) {
            $this->entries = require $config->getEntryFile();
            return;
        }

        $this->entries = new AssetEntryStorage;
    }





    /**
     * Load mutiple assets.
     *
     * @param string[] asset names
     * @return Asset[]
     */
    public function loadAssets(array $names)
    {
        $assets = array();
        foreach( $names as $name ) {
            if ($asset = $this->load($name)) {
                $assets[] = $asset;
            }
        }
        return $assets;
    }


    public function updateAsset(Asset $asset)
    {
        $this->register($asset->manifestFile, $asset->name);
    }

    public function updateAssetByName($name)
    {
        $asset = $this->load($name);
        return $this->updateAsset($asset);
    }

    /**
     * This method is for updating all manifest files that
     * is registed in asset config.
     */
    public function updateAssetManifests()
    {
        $assets = array();
        $registered = $this->entries->all();
        foreach( $registered as $name => $subconfig ) {
            $assets[] = $this->register($subconfig['manifest'], $name);
        }
        return $assets;
    }



    /**
     * Load all registered assets from the entry storage
     *
     * @return Asset[]
     */
    public function loadAll()
    {
        $assets = array();
        $registered = $this->entries->pairs();
        foreach( $registered as $name => $subconfig ) {
            $assets[] = $this->load($name);
        }
        return $assets;
    }

    /**
     * Load asset by name
     *
     * This method looks up the asset in the entry storage by the asset name.
     *
     * If the asset is not found, then it will fallback to lookup method (check 
     * each asset directory) and use register method to register the found asset. (if any)
     *
     * @param string $name asset name (with ID or filetype)
     *
     * @return Asset
     */
    public function load($name) {
        if (isset($this->objects[$name])) {
            return $this->objects[$name];
        }

        // Get the asset config from entries cluster
        if ($config = $this->entries->get($name)) {
            if (! isset($config['manifest'])) {
                throw new Exception("manifest path is not defined in $name");
            }

            // load the asset manifest file
            $asset = $this->register($config['manifest'], $name);
            // Save the asset object into the pool
            $this->objects[$name] = $asset;
            $this->loadDepends($asset);
            return $asset;
        }

        // fallback to lookup
        if ($asset = $this->lookup($name)) {
            $this->objects[$name] = $asset;
            $this->loadDepends($asset);
            return $asset;
        } else {
            throw new Exception("Asset $name not found. auto lookup failed.");
        }
    }

    public function loadDepends(Asset $asset)
    {
        $deps = $asset->getDepends();
        if (!empty($deps)) {
            foreach($deps as $dep) {
                $depAsset = $this->load($dep);
                $this->objects[$dep] = $depAsset;
            }
        }
    }


    /**
     * Look up an asset by its name and register the asset into the entry storage.
     *
     * @param string $name
     */
    public function lookup($name)
    {
        // some code to find asset automatically.
        // if there is not asset registered in config, we should look up from the asset paths
        $root = $this->config->getRoot();
        $dirname = preg_replace('/[#:]\w+$/', '', $name);
        foreach ($this->config->getAssetDirectories() as $dir ) {
            if ($asset = $this->register($root . DIRECTORY_SEPARATOR . $dir . DIRECTORY_SEPARATOR . $dirname . DIRECTORY_SEPARATOR . 'manifest.yml', $name)) {
                return $asset;
            }
        }
    }


    /**
     * Load asset from a manifest file or a directory that contains a manifest.yml file.
     *
     * @param string $path absolute path
     * @parma integer $format
     */
    public function register($path, $name = NULL, $force = false)
    {
        if ($p = realpath($path)) {
            $path = $p;
        }

        if (is_dir($path)) {
            $path = $path . DIRECTORY_SEPARATOR . 'manifest.yml';
        }

        if (!file_exists($path)) {
            throw new ManifestFileNotFoundException("Manifest file not found: $path");
        }

        if (!$name) {
            $name = basename(dirname($path));
        }

        $asset = Asset::createFromManifestFile($path, $name, $force);
        $this->entries->add($asset);
        return $asset;
    }

    public function __call($method, $args) {
        if (method_exists($this->entries, $method)) {
            return call_user_func_array(array($this->entries, $method), $args);
        }
        throw new BadMethodCallException("Method $method is not defined.");
    }

    /**
     * Save cache
     */
    public function saveEntryCache() {
        if ($cache = $this->config->getCache()) {
            $cache->set('asset_entries', $this->entries);
        }
    }

    public function loadEntryCache() {
        if ($cache = $this->config->getCache()) {
            if ($entries =$cache->get('asset_entries')) {
                $this->entries = $entries;
            }
        }
        if (!$this->entries) {
            $this->entries = new AssetEntryStorage;
        }
        return false;
    }

    public function saveEntries()
    {
        $root = $this->config->getRoot();
        $jsonFile = $root . DIRECTORY_SEPARATOR . '.asset-entries.json';
        file_put_contents($jsonFile, json_encode($this->entries));
        return ConfigCompiler::write($this->config->getEntryFile(), $this->entries);
    }


    public function getEntries() {
        return $this->entries;
    }

}

<?php
namespace AssetKit;
use Exception;
use RuntimeException;
use AssetKit\AssetCompilerFactory;
use AssetKit\AssetCompiler;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Exception\UnknownFragmentException;

/**
 * AssetIncluder is the top-level API for including asset files.
 *
 * $render = new AssetRender($config,$loader);
 * $render->render( $manifest );
 */
class AssetRender
{
    public $force = false;

    public $compiler;

    public function __construct(AssetConfig $config, AssetLoader $loader, AssetCompiler $compiler = null)
    {
        $this->config = $config;
        $this->loader = $loader;
        if ( $compiler ) {
            $this->compiler = $compiler;
        }
    }

    public function force() 
    {
        $this->force = true;
    }


    public function getCompiler()
    {
        if ($this->compiler) {
            return $this->compiler;
        }
        return $this->compiler = AssetCompilerFactory::create($this->config, $this->loader);
    }




    /**
     * Render assets by target name
     *
     * @param string $target
     */
    public function renderTarget($target)
    {
        // get assets from the target
        $assetNames = $this->loader->getTarget($target);
        if ( ! $assetNames ) {
            throw new RuntimeException("Target $target not found.");
        }
        $assets = $this->loader->loadAssets($assetNames);
        $this->renderAssets($assets, $target);
    }

    /**
     *
     * @param Asset[] $assets
     * @param string $target
     */
    public function renderAssets(array $assets, $target = '')
    {
        // TODO: Get compiled info by target name from cache or mmap.
        $compiler = $this->getCompiler();
        $out = $compiler->compileAssets($assets, $target, $this->force);
        $this->renderFragments($out);
    }


    /**
     * Render the output fragments to html tags.
     *
     * @param array $outs
     */
    public function renderFragments(array $outs)
    {
        foreach( $outs as $out ) {
            $this->renderFragment($out);
        }
    }


    /**
     * Render one single fragment.
     *
     * @param array $out
     */
    public function renderFragment(array $out)
    {
        // check for css_url and js_url
        if ( isset($out['js_url']) ) {
            $this->renderJavascriptTag($out['js_url']);
        }
        if ( isset($out['css_url']) ) {
            $this->renderStylesheetTag($out['css_url']);
        }

        if ( isset($out['type']) ) {
            if ( isset($out['url']) ) {
                if ($out['type'] === "stylesheet") {
                    $this->renderStylesheetTag( $out['url'] );
                } elseif ( $out['type'] === "javascript" ) {
                    $this->renderJavascriptTag( $out['url'] );
                } else {
                    throw new UnknownFragmentException("Unknown fragment type: " . $out['type'], $out);
                }
            } else if ( isset($out['content']) ) {
                if($out['type'] === "stylesheet") {
                    echo '<style type="text/css">',  $out['content'] , '</style>' , PHP_EOL;
                } elseif( $out['type'] === "javascript" ) {
                    echo '<script type="text/javascript">', $out['content'] , '</script>' , PHP_EOL;
                } else {
                    throw new UnknownFragmentException("Unknown fragment type: " . $out['type'], $out);
                }
            }
        }
    }



    /**
     * @param string $url
     * @param array $attributes
     */
    public function renderJavascriptTag($url, $innerContent = '' ,$attributes = array())
    {
        echo '<script type="text/javascript" src="' . $url . '"';
        foreach( $attributes as $name => $value ) {
            echo ' ' , $name , '="' , $value , '"';
        }
        echo '>';
        if ($innerContent) {
            echo $innerContent;
        }
        echo '</script>' , PHP_EOL;
    }

    /**
     * @param string $url
     * @param array $attributes
     */
    public function renderStylesheetTag($url,$attributes = array())
    {
        // <link rel="stylesheet" href="http://static.ak.fbcdn.net/rsrc.php/v2/yJ/r/S-EheTP3T8X.css"/>
        echo '<link rel="stylesheet" type="text/css"';
        echo ' href="' . $url . '"';
        foreach( $attributes as $name => $value ) {
            echo ' ' . $name . '="' . $value . '"';
        }
        echo '/>' , PHP_EOL;
    }
}

<?php
namespace AssetKit;
use AssetKit\AssetConfig;
use AssetKit\Asset;
use AssetKit\Collection;

class AssetUrlBuilder
{
    protected $config;

    public function __construct(AssetConfig $config) {
        $this->config = $config;
    }

    /**
     * Build Asset base url
     *
     * @param Asset $asset The asset object.
     */
    public function buildBaseUrl(Asset $asset) {
        return $this->config->getBaseUrl() . '/' . $asset->name;
    }

    /**
     * Build urls for asset collection
     *
     * @param Asset $asset
     * @param Collection $collection
     *
     * @return path[]
     */
    public function buildCollectionUrls(Asset $asset, Collection $collection) {
        $urls = array();
        $baseUrl = $this->buildBaseUrl($asset);
        $paths = $collection->getFilePaths();
        foreach( $paths as $path ) {
            $urls[] = $baseUrl . '/' . $path;
        }
        return $urls;
    }

}




<?php
namespace AssetKit;
use UniversalCache\ApcCache;
use UniversalCache\FileSystemCache;
use UniversalCache\UniversalCache;
use AssetKit\AssetConfig;

class CacheFactory
{

    /**
     * Create default universal cache from config object.
     */
    static public function create(AssetConfig $config)
    {
        $cache = new UniversalCache(array());

        // since APC is faster.
        if ( extension_loaded('apc') ) {
            $cache->addBackend( new ApcCache(array( 
                'namespace' => $config->getNamespace(),
            )));
        }
        $cache->addBackend( new FileSystemCache(array(
            'cache_dir' => $config->getCacheDir(),
        )));
        return $cache;
    }
}

<?php
namespace AssetKit;
use Exception;
use IteratorAggregate;
use ArrayAccess;
use InvalidArgumentException;
use AssetKit\Exception\UnknownCollectionKeyException;

class Collection
    implements IteratorAggregate, ArrayAccess
{
    const FileTypeFile   = 1;

    const FileTypeJs     = 2;

    const FileTypeCss    = 3;

    const FileTypeSass   = 4;

    const FileTypeScss   = 5;

    const FileTypeCoffee = 6;


    public $filters = array();

    public $compressors = array();

    public $files = array();

    /**
     * @var the collection ID
     */
    public $id;

    /**
     * @var string path Asset source directory
     */
    public $sourceDir;


    /**
     * @var boolean content type for <style> or rel="stylesheet"
     */
    public $isStylesheet;

    /**
     * @var boolean content type for <script>
     */
    public $isScript;

    /**
     * file content cache (content is from the getContent method)
     */
    public $content;


    public $stash = array();


    /**
     * file chunks with metadata
     */
    public $chunks;


    /**
     * @var int  FileTypeFile, FileTypeJs, FileTypeCoffee, FileTypeCss, FileTypeSass, FileTypeScss, FileTypeCss
     */
    public $filetype;


    // attributes for assets rendering
    public $attributes = array();

    // cache
    private $_lastmtime = 0;

    public function __construct(array $stash = array()) {
        $this->stash = $stash;
    }


    /**
     * Return source path (with relative or absolute path)
     *
     * @param bool $absolute Should return absolute or relative.
     * @return string
     */
    public function getSourcePaths()
    {
        return \futil_paths_prepend($this->files, $this->sourceDir);
    }


    /**
     * Return fullpath of files
     *
     * @return string[] fullpaths.
     */
    public function getFullpaths()
    {
        return \futil_paths_prepend($this->files, $this->sourceDir);
    }

    /**
     * @return array return the collection file list
     */
    public function getFilePaths()
    {
        return $this->files;
    }

    public function addFile($path)
    {
        $this->files[] = $path;
        return $this;
    }


    public function hasCompressor($name)
    {
        return in_array( $name, $this->compressors );
    }

    public function hasFilter($name)
    {
        return in_array( $name, $this->filters );
    }

    public function getCompressors()
    {
        return $this->compressors;
    }

    public function getFilters()
    {
        return $this->filters;
    }

    public function addFilter($filter)
    {
        $this->filters[] = $filter;
        return $this;
    }

    public function getLastModifiedTime()
    {
        if ( $this->_lastmtime ) {
            return $this->_lastmtime;
        }
        if ( ! empty($this->files) ) {
            return $this->_lastmtime = \futil_lastmtime($this->getFullpaths());
        }
        return 0;
    }



    /**
     * Set content chunks with metadata.
     *
     * @param array $chunks
     */
    public function setChunks(array $chunks)
    {
        $this->chunks = $chunks;
    }

    /**
     * Returns content chunks with metadata.
     *
     * @return [content=>,path=>,fullpath=>][]
     */
    public function getChunks()
    {
        if ( $this->chunks ) {
            return $this->chunks;
        }

        foreach( $this->files as $file ) {
            $fullpath = $this->sourceDir . DIRECTORY_SEPARATOR . $file;

            if ( ($out = file_get_contents( $fullpath )) !== false ) {
                $this->chunks[] = array(
                    'content' => $out,
                    'path'    => $file,
                    'fullpath' => $fullpath,
                );
            } else {
                throw new Exception("Asset collection: Can not read file $fullpath");
            }
        }
        return $this->chunks;
    }



    /**
     * Squash chunks into a string.
     *
     * @return string
     */
    public function squashChunks(array $chunks)
    {
        $content = '';
        foreach( $chunks as $c ) {
            $content .= $c['content'];
        }
        return $content;
    }


    public function setContent($content)
    {
        if ($content === NULL || $content === FALSE) {
            throw new EmptyContentException("The assigned content is empty.");
        }
        // Warning: calling setContent to chunks might lose metadata.
        $this->chunks = array(array(
            'content' => $content, 
            'fullpath' => '',
            'path' => '',
        )); 
    }

    public function getContent()
    {
        $chunks = $this->getChunks();
        return $this->squashChunks($chunks);
    }




    public function getIterator()
    {
        return new ArrayIterator($this->getSourcePaths());
    }


    /**
     * Check if collection files are out of date.
     */
    public function isOutOfDate($fromTime)
    {
        return $this->getLastModifiedTime() > $fromTime;
    }


    public function initContentType(array & $stash) {
        // for normal static files
        if( isset($stash['file']) ) {
            $this->filetype = Collection::FileTypeFile;
            return 'file';
        } elseif (isset($stash['js'])) {
            $this->filetype     = Collection::FileTypeJs;
            $this->isScript = true;
            return 'js';
        } elseif (isset($stash['javascript'])) {
            $this->filetype     = Collection::FileTypeJs;
            $this->isScript = true;
            return 'javascript';
        } elseif (isset($stash['coffeescript'])) {
            $this->filetype       = Collection::FileTypeCoffee;
            $this->isScript = true;
            return 'coffeescript';
        } elseif (isset($stash['coffee'])) {
            $this->filetype       = Collection::FileTypeCoffee;
            $this->isScript = true;
            return 'coffee';
        } elseif (isset($stash['css'])) {
            $this->filetype     = Collection::FileTypeCss;
            $this->isStylesheet = true;
            return 'css';
        } elseif (isset($stash['sass'])) {
            $this->filetype     = Collection::FileTypeSass;
            $this->isStylesheet = true;
            return 'sass';
        } elseif (isset($stash['scss'])) {
            $this->filetype     = Collection::FileTypeScss;
            $this->isStylesheet = true;
            return 'scss';
        } elseif (isset($stash['stylesheet']) ) {
            $this->filetype     = Collection::FileTypeCss;
            $this->isStylesheet = true;
            return 'stylesheet';
        } else {
            var_dump( $stash );
            throw new UnknownCollectionKeyException('Unknown collection key.', $stash);
        }
    }

    public function __set_state($array) {
        $c = new self;
        $c->filters = $array['filters'];
        $c->compressors = $array['compressors'];
        $c->files = $array['files'];
        $c->sourceDir = $array['sourceDir'];
        $c->filetype = $array['filetype'];
        $c->isStylesheet = $array['isStylesheet'];
        $c->isScript = $array['isScript'];
        return $c;
    }


    public function offsetSet($name,$value)
    {
        $this->stash[ $name ] = $value;
    }
    
    public function offsetExists($name)
    {
        return isset($this->stash[ $name ]);
    }
    
    public function offsetGet($name)
    {
        return $this->stash[ $name ];
    }
    
    public function offsetUnset($name)
    {
        unset($this->stash[$name]);
    }

    public function getStash()
    {
        return $this->stash;
    }
}

<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use AssetKit\Command\BaseCommand;
use CLIFramework\Command;
use Exception;

class AddCommand extends BaseCommand
{
    public function brief() { return 'add and initialize asset.'; }

    public function execute($manifestFile)
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();
        $asset = $loader->register($manifestFile);

        if (!$asset) {
            throw new Exception("Can not load asset from $manifestFile.");
        }

        $this->logger->info("Initializing resource...");

        $updater = new \AssetKit\ResourceUpdater();
        $updater->update($asset);

        $this->logger->info( "Installing {$asset->name}" );

        $installer = $this->getInstaller();
        $installer->install( $asset );

        $loader->saveEntries();
        $this->logger->info("Done");
    }
}


<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use AssetKit\Command\BaseCommand;
use Exception;

class AddTargetCommand extends BaseCommand {

    public function brief() {
        return 'Add asset target'; 
    }

    /*
    public function arguments($args) {
        $args->add
    }
    */

    public function execute($target)
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();

        $args = func_get_args();
        $targetName = array_shift($args);
        $assetNames = $args;
        foreach( $assetNames as $n ) {
            $a = $loader->load($n);
            if ( ! $a ) {
                throw new Exception("Asset $n not found, please add the asset manifest file.");
            }
        }
        $this->logger->info("Adding target '$targetName': " . join(", ", $assetNames) );
        $loader->entries->addTarget($targetName, $assetNames);
        $loader->saveEntries();
    }


}
<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use AssetKit\CacheFactory;
use AssetKit\ResourceUpdater;
use CLIFramework\Command;
use Exception;

abstract class BaseCommand extends Command
{
    public $assetConfig;
    public $assetLoader;
    public $assetCache;

    public function options($opts)
    {
        $opts->add('config?','the asset config file, defualt to assetkit.yml');
    }

    public function getAssetConfigLink() {
        return ".assetkit.yml";
    }

    public function getAssetConfigFile()
    {
        return $this->options->config ?: "assetkit.yml";
    }

    public function getAssetConfig()
    {
        if ($this->assetConfig) {
            return $this->assetConfig;
        }

        $file = $this->getAssetConfigLink();
        if ( file_exists($file) ) {
            return $this->assetConfig = new AssetConfig($file);
        }
        return $this->assetConfig = new AssetConfig($this->getAssetConfigFile());
    }

    public function getAssetCache() {
        if ($this->assetCache) {
            return $this->assetCache;
        }
        $config = $this->getAssetConfig();
        return $this->assetCache = CacheFactory::create($config);
    }

    public function getAssetLoader()
    {
        if ( $this->assetLoader )
            return $this->assetLoader;
        return $this->assetLoader = new AssetLoader( $this->getAssetConfig() );
    }

    public function getAssetUpdater()
    {
        return new \AssetKit\ResourceUpdater();
    }

    public function updateAsset(Asset $asset, $fetch = false)
    {
        $updater = $this->getAssetUpdater();
        $updater->update($asset, $fetch);
    }


    public function getInstaller()
    {
        if( $this->options->link ) {
            return new LinkInstaller($this->getAssetConfig());
        }
        return new Installer($this->getAssetConfig());
    }
}

<?php
namespace AssetKit\Command;
use Exception;
use DateTime;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\AssetCompiler;
use AssetKit\Asset;
use AssetKit\Cache;
use AssetKit\CacheFactory;
use AssetKit\Command\BaseCommand;
use AssetKit\ProductionAssetCompiler;
use CLIFramework\Command;
use ConfigKit\ConfigCompiler;

/**
 * Command to clean up cache
 */
class CleanCommand extends BaseCommand
{
    public function options($opts)
    {
        parent::options($opts);
    }

    public function brief() { return 'Clean up caches'; }

    public function execute()
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();

        $this->logger->info("Cleaning up caches...");
        $cache = CacheFactory::create($config);
        $cache->clear();

        $compiler = new ProductionAssetCompiler($config, $loader);

        $compiledDir = $config->getCompiledDir();

        foreach( $loader->entries->getTargets() as $targetId => $assetNames) {
            $metaFile = $compiledDir . DIRECTORY_SEPARATOR . $compiler->buildTargetMetaFilename($targetId);
            if (file_exists($metaFile)) {
                $entries = require $metaFile;
                foreach($entries as $entry) {
                    foreach(array('js_file', 'css_file') as $key) {
                        if (isset($entry[$key])) {
                            $file = $entry[$key];
                            file_exists($file) && unlink($file);
                        }
                    }
                }
                unlink($metaFile);
            }
        }

        foreach( $loader->entries as $entry ) {
            $asset = new Asset;
            $asset->loadManifestFile($entry['manifest']);
            $metaFile = $compiledDir . DIRECTORY_SEPARATOR . $compiler->buildAssetMetaFilename($asset);
            if (file_exists($metaFile)) {
                $entries = require $metaFile;
                foreach(array('js_file', 'css_file') as $key) {
                    if (isset($entries[$key])) {
                        $file = $entries[$key];
                        file_exists($file) && unlink($file);
                    }
                }
                unlink($metaFile);
            }
        }
    }
}




<?php
namespace AssetKit\Command;

use Exception;
use DateTime;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\Command\BaseCommand;
use AssetKit\AssetCompiler;
use AssetKit\ProductionAssetCompiler;
use CLIFramework\Command;

class CompileCommand extends BaseCommand
{
    public function options($opts)
    {
        parent::options($opts);
        $opts->add('t|target:', 'The target ID');
        $opts->add('html-output:', 'Output html file');
    }

    public function brief() { return 'precompile asset files.'; }

    public function execute()
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();

        $target = $this->options->target ?: $config->getDefaultTarget();
        if ( $target != $config->getDefaultTarget() ) {
            if ( $loader->entries->hasTarget($target) ) {
                $assetNames = $loader->entries->getTarget($target);
            } else {
                $assetNames = func_get_args();
            }
        } else {
            $assetNames = func_get_args();
            if( empty($assetNames) ) {
                throw new Exception("Asset names are required.");
            }
        }

        if( ! ini_get('apc.enable_cli') ) {
            $this->logger->info("Notice: You may enable apc.enable_cli option to precompile production files from command-line.");
        }


        // initialize loader and writer
        $this->logger->info("Loading assets " . join(', ', $assetNames));
        $assets = $loader->loadAssets($assetNames);
        $loader->entries->addTarget($target, $assetNames);
        $loader->saveEntries();

        $compiler = new ProductionAssetCompiler($config,$loader);
        $compiler->registerDefaultCompressors();
        $compiler->registerDefaultFilters();


        $this->logger->info("Compiling assets to target '$target'...");

        
        // force compile
        $entries = $compiler->compileAssets($assets, $target, true); // use the force
        $files = $entries[0];


        printf( "----------------------------------------------------\n" );
        printf( "Target:            %s\n" , $files['target'] );
        printf( "Cache Key:         %s\n" , $files['cache_key'] );
        printf( "Meta File:         %s\n" , $files['metafile'] );
        printf( "Modofication Time: %s\n" , date(\DateTime::ATOM,$files['mtime']) );

        if ( isset($files['css_file']) ) {
            printf( "Stylesheet:\n" );
            printf( "  MD5:   %s\n" , $files['css_checksum'] );
            printf( "  URL:   %s\n" , $files['css_url'] );
            printf( "  File:  %s\n" , $files['css_file'] );
            printf( "  Size:  %d KBytes\n" , filesize($files['css_file']) / 1024 );
        }

        if ( isset($files['js_file']) ) {
            printf( "Javascript:\n" );
            printf( "  MD5:   %s\n" , $files['js_checksum'] );
            printf( "  URL:   %s\n" , $files['js_url'] );
            printf( "  File:  %s\n" , $files['js_file'] );
            printf( "  Size:  %d KBytes\n" , filesize($files['js_file']) / 1024 );
        }
        printf( "----------------------------------------------------\n" );


        $render = new \AssetKit\AssetRender($config, $loader);
        ob_start();
        $render->renderFragment($files);
        $html = ob_get_contents();
        ob_end_clean();

        if ( $outputFile = $this->options->{"html-output"} ) {
            $this->logger->info("Writing output to $outputFile");
            if ( false === file_put_contents($outputFile, $html) ) {
                throw new Exception("Can not write file.");
            }
            $this->logger->info("You may simply require this file to render.");
        } else {
            $this->logger->info("HTML Output (you may use --html-output option to write as a file):");
            printf( "----------------------------------------------------\n" );
            echo $html;
            printf( "----------------------------------------------------\n" );
        }
        $this->logger->info("Done");
    }
}




<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use AssetKit\Command\BaseCommand;
use CLIFramework\Command;
use Exception;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use ConfigKit\ConfigCompiler;
use Symfony\Component\Yaml\Yaml;
use Symfony\Component\Yaml\Dumper;

class CreateManifestCommand extends Command
{
    public function brief() { return 'Create asset manifest file'; }

    public function options($opts) {
        $opts->add('s|search+', 'Search relative paths to the manifest file that might contain asset files.');
        $opts->add('include-min', 'Include minified asset files.');
    }


    public function execute($manifestDir = NULL)
    {
        $manifestDir = $manifestDir ?: getcwd();
        $possiblePaths = $this->options->search ?: array();

        $jsFiles = array();
        $cssFiles = array();
        $imageFiles = array();
        $fontFiles = array();

        $inspectDirs = array(
            'javascript' => array('js','javascript', 'javascripts'),
            'stylesheet' => array('css', 'stylesheet', 'stylesheets'),
            'file' => array('fonts', 'images'),
        );

        $config = array();
        $config['collections'] = array();


        $files = array(
            'stylesheet' => array(),
            'javascript' => array(),
            'file' => array(),
        );
        $patterns = array(
            'stylesheet' => '/\.css$/',
            'javascript' => '/\.js/',
            'file' => '/\.(?:png|jpe?g|ico|gif|eot|svg|ttf|woff)$/',
        );

        if (empty($possiblePaths)) {

            foreach($inspectDirs as $type => $dirs) {
                foreach($dirs as $dir) {
                    if (file_exists($manifestDir . DIRECTORY_SEPARATOR . $dir)) {
                        $this->logger->info("Found $dir as type $type.");
                        $config['collections'][] = array( $type => array($dir) );
                    }
                }
            }

            $di = new RecursiveDirectoryIterator($manifestDir, RecursiveDirectoryIterator::SKIP_DOTS);
            $it = new RecursiveIteratorIterator($di, RecursiveIteratorIterator::CHILD_FIRST);
            foreach($it as $info) {
                if ($info->isFile()) {
                    $path = $it->getSubPathname();
                    foreach($patterns as $type => $pattern) {
                        if (preg_match($pattern, $path)) {
                            $this->logger->info("Adding $path as $type");
                            $files[$type][] = $path;
                        }
                    }
                }
            }

        } else {
            // Search recursively
            foreach($possiblePaths as $path) {
                $searchPath = $manifestDir . DIRECTORY_SEPARATOR . $path;
                if (!file_exists($searchPath)) {
                    $this->logger->warn("$searchPath does not exist.");
                    continue;
                }

                $di = new RecursiveDirectoryIterator($searchPath, RecursiveDirectoryIterator::SKIP_DOTS);
                $it = new RecursiveIteratorIterator($di, RecursiveIteratorIterator::CHILD_FIRST);
                foreach($it as $info) {
                    if ($info->isFile()) {
                        $item = $path . DIRECTORY_SEPARATOR . $it->getSubPathname();
                        foreach($patterns as $type => $pattern) {
                            if (preg_match($pattern, $item)) {
                                $this->logger->info("Adding $item as $type");
                                $files[$type][] = $item;
                            }
                        }
                    }
                }
            }
        }


        // We don't include minified files by default,
        // If users want to include these files they need to 
        // specify the option explicitly
        if (!$this->options->{'include-min'}) {
            // Remove minified files
            $files['javascript'] = array_filter($files['javascript'], function($file) {
                return !preg_match('/[.-](?:min|pack)\.js$/',$file);
            });
            $files['stylesheet'] = array_filter($files['stylesheet'], function($file) {
                return !preg_match('/[.-](?:min|pack)\.css$/',$file);
            });
        }

        foreach($files as $type => $files) {
            if (!empty($files)) {
                $config['collections'][] = array($type => array_values($files));
            }
        }
        ConfigCompiler::write_yaml($manifestDir . DIRECTORY_SEPARATOR . 'manifest.yml', $config);
        $this->logger->info("Done");
    }
}


<?php
namespace AssetKit\Command;
use CLIFramework\Command;
use AssetKit\AssetConfig;
use AssetKit\Command\BaseCommand;

use ConfigKit\ConfigCompiler;

// $config = ConfigCompiler::load('tests/ConfigKit/data/framework.yml');

class InitCommand extends BaseCommand
{
    public function brief()
    {
        return 'initialize assetkit config file.';
    }

    public function options($opts)
    {
        parent::options($opts);

        // required options
        $opts->add('baseUrl:','base URL')
            ->required()
            ;
        $opts->add('baseDir:','base directory')
            // ->isa('path')
            ->required()
            ;
        $opts->add('dir+','asset directory for looking up assets.')
            // ->isa('path')
            ->required()
            ;
    }

    public function arguments($args) {
        $args->add('configFile')
            ->isa('file')
            ;
    }

    public function execute($configFile)
    {
        if (! $this->options->baseUrl) {
            return $this->logger->error("--baseUrl option is required.");
        }

        if (! $this->options->baseDir) {
            return $this->logger->error("--baseDir option is required.");
        }

        // create asset config
        $config = $this->getAssetConfig();
        $config->setBaseUrl($this->options->baseUrl );
        $config->setBaseDir($this->options->baseDir );
        if ($dirs = (array) $this->options->dir) {
            foreach($dirs as $dir) {
                $this->logger->info("Adding asset directory $dir");
                $config->addAssetDirectory($dir);
            }
        }
        $this->logger->info("Saving config to $configFile");
        $config->save();


        if (file_exists($this->getAssetConfigLink()) ) {
            unlink($this->getAssetConfigLink());
        }
        $this->logger->info("Creating link {$this->getAssetConfigLink()} for $configFile");
        symlink($configFile, $this->getAssetConfigLink());

        $compiledDir = $config->getCompiledDir();
        if ( ! file_exists($compiledDir) ) {
            $this->logger->info("Creating compiled dir: $compiledDir");
            mkdir($compiledDir,0777,true);
        } else {
            $this->logger->info("Changing directory permission to 777 for enabling compilation through nginx/apache.");
            $this->logger->info("(You will need write permission to be opened for AssetCompiler.)");
            chmod($compiledDir, 0777);
        }
        $this->logger->info("Done");
    }

}


<?php
namespace AssetKit\Command;
use AssetKit\Asset;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use CLIFramework\Command;
use Exception;

class InstallCommand extends BaseCommand
{

    public function brief()
    {
        return 'install assets';
    }

    public function options($opts)
    {
        parent::options($opts);
        $opts->add('l|link','link asset files, instead of copy install.');
    }

    public function execute()
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();
        $loader->updateAssetManifests();

        $installer = $this->getInstaller();
        $installer->logger = $this->logger;


        $compiledDir = $config->getCompiledDir();
        $this->logger->info("Creating compiled dir: $compiledDir");
        $this->logger->info("Please chmod this directory as you need.");
        if ( ! file_exists($compiledDir) )
            mkdir($compiledDir,0755,true);

        $updater = new \AssetKit\ResourceUpdater();
        foreach( $config->all() as $name => $stash ) {
            $asset = $loader->load($name);

            $this->logger->info("Updating $name ...");
            $updater->update($asset);

            $this->logger->info( "Installing {$asset->name}" );
            $installer->install( $asset );
        }
        $config->save();
        $this->logger->info("Done");
    }
}



<?php
namespace AssetKit\Command;
use AssetKit\Asset;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use CLIFramework\Command;
use Exception;

class ListCommand extends BaseCommand
{

    public function brief()
    {
        return 'List registered assets.';
    }

    public function options($opts)
    {
        parent::options($opts);
    }

    public function execute()
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();
        // $loader->updateAssetManifests();

        $cwdLen =  strlen(getcwd()) + 1;

        $this->logger->info( sprintf("%d assets registered: ", count($loader->all()) ) );

        foreach( $loader->pairs() as $name => $stash ) {
            $asset = $loader->load($name);
            $this->logger->info( 
                sprintf('%12s | %2d collections | %s', 
                    $name, 
                    count($asset->getCollections()),
                    substr($asset->manifestFile, $cwdLen)   
                ), 1);
        }
    }
}



<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use AssetKit\Command\BaseCommand;
use Exception;

class ListTargetCommand extends BaseCommand {

    public function brief() {
        return 'List asset targets'; 
    }

    public function execute()
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();

        $this->logger->info("Available targets:");
        if ( $targets = $loader->entries->getTargets() ) {
            foreach( $targets as $target => $assetNames ) {
                $this->logger->info("$target: " . join(', ', $assetNames) ,1);
            }
        }
    }


}
<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\Asset;
use CLIFramework\Command;

class RemoveCommand extends BaseCommand
{

    public function brief()
    {
        return 'Remove an asset.';
    }

    public function execute($assetName)
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();

        $this->logger->info("Removing $assetName ...");

        $loader->remove($assetName);
        $loader->saveEntries();
    }
}


<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use AssetKit\Command\BaseCommand;
use Exception;

class RemoveTargetCommand extends BaseCommand {

    public function brief() {
        return 'Remove asset target'; 
    }

    /*
    public function arguments($args) {
        $args->add
    }
    */

    public function execute($targetName)
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();
        if ( $config->hasTarget($targetName) ) {
            $this->logger->info("Removing target '$targetName'");
            $loader->entries->removeTarget($targetName);
            $loader->saveEntries();
            $this->logger->info("Done");
        } else {
            $this->logger->warn("Target $targetName not found");
        }
    }


}
<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use AssetKit\Command\BaseCommand;
use Exception;

class TargetCommand extends BaseCommand
{
    public function brief() { return 'add, remove, list asset targets'; }

    public function options($opts)
    {
        parent::options($opts);
        $opts->add('remove:', 'remove target');
        $opts->add('add:', 'add target');
    }

    public function init() {
        $this->command('list', 'AssetKit\Command\ListTargetCommand');
        $this->command('add', 'AssetKit\Command\AddTargetCommand');
        $this->command('remove', 'AssetKit\Command\RemoveTargetCommand');
    }

    public function execute()
    {
        $list = $this->createCommand('AssetKit\Command\ListTargetCommand');
        $list->execute();
    }
}


<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\Asset;
use AssetKit\FileUtils;
use AssetKit\Installer;
use AssetKit\LinkInstaller;
use CLIFramework\Command;
use Exception;

class UpdateCommand extends BaseCommand
{
    public function brief() { return 'update and install assets'; }

    public function options($opts)
    {
        parent::options($opts);
        $opts->add('l|link','link asset files, instead of copy install.');
    }

    public function execute()
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();

        $installer = $this->getInstaller();
        $installer->logger = $this->logger;

        $assets = $loader->updateAssetManifests();
        foreach( $assets as $asset ) {
            $this->logger->info("Updating {$asset->name} ...");

            $updater = new \AssetKit\ResourceUpdater;
            $updater->update($asset, true);

            $this->logger->info( "Installing {$asset->name}" );
            $installer->install( $asset );
        }
        $this->logger->info("Done");
    }
}


<?php
namespace AssetKit\Command;
use AssetKit\AssetConfig;
use AssetKit\Asset;
use CLIFramework\Command;
use RuntimeException;
use AssetKit\CompilerRunner\CoffeeRunner;
use AssetKit\CompilerRunner\ScssRunner;
use AssetKit\CompilerRunner\SassRunner;
use Exception;

class WatchCommand extends BaseCommand
{
    public function brief()
    {
        return 'Watch an asset.';
    }

    public function execute($assetName)
    {
        $config = $this->getAssetConfig();
        $loader = $this->getAssetLoader();
        $assetNames = func_get_args();

        $this->logger->info("Loading assets " . join(', ', $assetNames));

        $assets = array();
        foreach($assetNames as $assetName) {
            $this->logger->info("-> Asset $assetName loaded");
            if ($a = $loader->load($assetName)) {
                $assets[] = $a;
            } else {
                throw new RuntimeException("Unable to load asset $assetName");
            }
        }

        $processCnt = 0;

        // Find asset that defines {'compile'} option or {'compiler','source'} option
        foreach($assets as $asset) {
            $collections = $asset->getCollections();
            foreach($collections as $collection) {
                $command = NULL;
                if (isset($collection['compile'])) {
                    $command = $collection['compile'];
                } elseif (isset($collection['compiler']) && isset($collection['source'])) {
                    switch($collection['compiler']) {
                    case "sass":
                        $runner = new SassRunner;
                        $runner->enableCompass();
                        break;
                    case "scss":
                        $runner = new ScssRunner;
                        $runner->enableCompass();
                        break;
                    case "coffee":
                        $runner = new CoffeeRunner;
                        break;
                    default:
                        throw new Exception("Unsupported compiler type: " . $collection['compiler']);
                    }
                    foreach($collection['source'] as $source) {
                        $runner->addSourceArgument($source);
                    }
                    $cmd = $runner->buildWatchCommand();
                    $command = join(' ', $cmd);
                }
                if (!$command) {
                    continue;
                }

                $this->logger->debug("Forking process to watch collection files...");
                $processCnt++;
                $pid = pcntl_fork();
                if ($pid == -1) {
                    throw new Exception("Can't fork process");
                } elseif ($pid == 0) {
                    $this->logger->debug("Directory: " . $asset->getSourceDir());
                    $this->logger->debug("Command: " . $command);
                    chdir($asset->getSourceDir());
                    system($command, $retval);
                    exit($retval);
                }
            }
        }

        // Waiting process
        pcntl_wait($status); // Protect against Zombie children
        $this->logger->debug("$processCnt stopped.");
    }
}


<?php
namespace AssetKit\CompilerRunner;
use InvalidArgumentException;

class CoffeeRunner implements CompilerRunnerInterface
{
    public $bin = 'coffee';

    protected $targets = array();

    public $bare = false;

    protected $sourceMap;

    protected $join;

    protected $outputDir;

    public function __construct($bin = null) {
        if ($bin) {
            $this->bin = $bin;
        }
    }

    public function setOutputDir($dir)
    {
        $this->outputDir = $dir;
        return $this;
    }

    public function setJoin($file) {
        $this->join = $file;
        return $this;
    }

    public function useSourceMap() {
        $this->sourceMap = true;
        return $this;
    }

    public function buildBaseCommand($force = false) {
        $cmd = array($this->bin);
        if ($this->bare) {
            $cmd[] = '--bare';
        }
        if ($this->sourceMap) {
            $cmd[] = '--map';
        }
        if ($this->join) {
            $cmd[] = '--join';
            $cmd[] = $this->join;
        }
        return $cmd;
    }

    public function buildTargetList() {
        $list = array();
        foreach( $this->targets as $target ) {
            if (is_string($target)) {
                $list[] = $target;
            } elseif (is_array($target)) {
                list($from, $to) = $target;
                if ($to) {
                    $list[] = "$from:$to";
                } else {
                    $list[] = $from;
                }
            } else {
                throw new InvalidArgumentException("Invalid argument type for building target list.");
            }

        }
        return $list;
    }

    public function addSourceArgument($argument)
    {
        $this->targets[] = $argument;
    }

    public function buildWatchCommand() {
        $cmd = $this->buildBaseCommand();
        $cmd[] = '--watch';
        $cmd[] = '--compile';
        return array_merge($cmd, $this->buildTargetList());
    }

    public function buildUpdateCommand() {
        $cmd = $this->buildBaseCommand();
        $cmd[] = '--compile';
        return array_merge($cmd, $this->buildTargetList());
    }

    public function update()
    {
        if ($force) {
            $this->force = $force;
        }
        $cmd = $this->buildUpdateCommand();
        system(join(" ", $cmd));
    }

    public function check()
    {
        $cmd = $this->buildBaseCommand($force);
        $cmd[] = '--check';
        $cmd = array_merge($cmd, $this->buildTargetList());

        // TODO: use symfony process builder 
        system( join(" ", $cmd) );
    }

    public function watch($force = false)
    {
        if ($force) {
            $this->force = $force;
        }
        $cmd = $this->buildWatchCommand();
        system( join(" ", $cmd) );
    }

}

<?php
namespace AssetKit\CompilerRunner;

interface CompilerRunnerInterface
{
    /**
     * Add source argument to the command. e.g.
     *
     *    foo.coffee
     *
     * And it will be in the command line:
     *
     *    coffee -w foo.coffee
     *
     * Or: "sass:css", "sass/foo.sass"... and it will be:
     *
     *    sass -wc sass:css sass/foo.sass
     *
     * @param string $argument
     */
    public function addSourceArgument($argument);

    /**
     * Build the command of watching files...
     */
    public function buildWatchCommand();

    /**
     * Build the command to build files but not watch them
     *
     * @return string
     */
    public function buildUpdateCommand();
}


<?php
namespace AssetKit\CompilerRunner;

class SassRunner extends ScssRunner
{
    public $bin = 'sass';
}



<?php
namespace AssetKit\CompilerRunner;
use InvalidArgumentException;

class ScssRunner implements CompilerRunnerInterface
{

    const VERSION = "1.3.1";

    public $bin = 'scss';

    public $enableCompass = false;

    public $targets = array();

    public $force = false;

    public $style;

    public $quiet = false;

    public $debug = false;

    public $loadPaths = array();

    public $sourceMap;

    public function __construct($bin = null) {
        if ($bin) {
            $this->bin = $bin;
        }
    }

    public function addLoadPath() {
        $paths = func_get_args();
        $this->loadPaths = array_merge($this->loadPaths, $paths);
        return $this;
    }

    public function setQuiet($quiet = true) 
    {
        $this->quiet = $quiet;
        return $this;
    }

    public function setForce($force = true)
    {
        $this->force = $force;
        return $this;
    }


    public function setDebug($debug = true)
    {
        $this->debug = $debug;
        return $this;
    }

    public function enableCompass($enable = true)
    {
        $this->enableCompass = $enable;
        return $this;
    }

    public function addTarget($from, $to = null) 
    {
        $this->targets[] = array($from, $to);
        return $this;
    }

    public function setStyle($style) {
        $this->style = $style;
        return $this;
    }

    public function setSourceMap($sourceMap) {
        $this->sourceMap = $sourceMap;
        return $this;
    }


    public function buildBaseCommand($force = false) {
        $cmd = array($this->bin);
        if ( $this->enableCompass ) {
            $cmd[] = '--compass';
        }
        if ($this->sourceMap) {
            $cmd[] = '--sourcemap';
            $cmd[] = $this->sourceMap;
        }
        if ($this->force || $force) {
            $cmd[] = '--force';
        }
        if ( $this->style ) {
            $cmd[] = '--style';
            $cmd[] = $this->style;
        }
        if ( $this->quiet ) {
            $cmd[] = '--quiet';
        }
        if ( $this->debug ) {
            $cmd[] = '-g';
        }

        $cmd = array_merge($cmd, $this->buildLoadPathList());
        return $cmd;
    }

    public function buildLoadPathList() {
        $list = array();
        foreach( $this->loadPaths as $path ) {
            $list[] = '--load-path';
            $list[] = $path;
        }
        return $list;
    }

    public function buildTargetList() {
        $list = array();
        foreach( $this->targets as $target ) {
            if (is_string($target)) {
                $list[] = $target;
            } elseif (is_array($target)) {
                list($from, $to) = $target;
                if ($to) {
                    $list[] = "$from:$to";
                } else {
                    $list[] = $from;
                }
            } else {
                throw new InvalidArgumentException("Invalid argument type for building target list.");
            }

        }
        return $list;
    }

    public function addSourceArgument($argument)
    {
        $this->targets[] = $argument;
    }

    public function buildWatchCommand() {
        $cmd = $this->buildBaseCommand();
        $cmd[] = '--watch';
        return array_merge($cmd, $this->buildTargetList());
    }

    public function buildUpdateCommand() {
        $cmd = $this->buildBaseCommand();
        $cmd[] = '--update';
        return array_merge($cmd, $this->buildTargetList());
    }

    public function update()
    {
        if ($force) {
            $this->force = $force;
        }
        $cmd = $this->buildUpdateCommand();
        system(join(" ", $cmd));
    }

    public function check()
    {
        $cmd = $this->buildBaseCommand($force);
        $cmd[] = '--check';
        $cmd = array_merge($cmd, $this->buildTargetList());

        // TODO: use symfony process builder 
        system( join(" ", $cmd) );
    }

    public function watch($force = false)
    {
        if ($force) {
            $this->force = $force;
        }
        $cmd = $this->buildWatchCommand();
        system( join(" ", $cmd) );
    }

}

<?php
namespace AssetKit\Compressor;
use AssetKit\Collection;
use RuntimeException;
use CssMin;

class CssMinCompressor
{
    public function compress(Collection $collection)
    {
        if (extension_loaded('cssmin')) {
            $css = cssmin($collection->getContent());
            $collection->setContent($css);
            return;
        }

        $css = CssMin::minify($collection->getContent());
        if (!$css) {
            if (CssMin::hasErrors()) {
                $errors = CssMin::getErrors();
                foreach($errors as $error) {
                    trigger_error($error->Message, E_USER_WARNING);
                }
            }
        }
        $collection->setContent($css);
    }
}

<?php
namespace AssetKit\Compressor;
use AssetKit\Collection;
use AssetKit\Process;
use AssetKit\JSMin;
use RuntimeException;

class JsMinCompressor
{
    public $bin;

    public function __construct($bin = NULL)
    {
        if ($bin) {
            $this->bin = $bin;
        }
    }
    
    public function compress(Collection $collection)
    {
        // C version jsmin is faster,
        $content = $collection->getContent();

        // If the bin is specified, we will run an external process to jsmin the content.
        if ($this->bin) {
            $proc = new Process(array($this->bin));
            $code = $proc->input($content)->run();
            if ( $code != 0 ) {
                throw new RuntimeException("JsminCompressor failure: $code");
            }
            $content = $proc->getOutput();
        } else {
            // Pure php jsmin
            $content = JSMin::minify( $content );
        }
        $collection->setContent($content);
    }
}



<?php
namespace AssetKit\Compressor;
use AssetKit\Collection;
use AssetKit\Process;
use AssetKit\JSMin;
use RuntimeException;
use Exception;

class JsMinExtException extends Exception {  }

class JsMinExtCompressor
{
    public $messages = array(
        JSMIN_ERROR_UNTERMINATED_STRING => 'Unterminated string.',
        JSMIN_ERROR_UNTERMINATED_COMMENT => 'Unterminated comment.',
        JSMIN_ERROR_UNTERMINATED_REGEX => 'Unterminated regex.',
    );

    public static function support() {
        return extension_loaded('jsmin');
    }

    public function compress(Collection $collection)
    {
        // C version jsmin is faster,
        $content = $collection->getContent();
        $content = jsmin($content);
        if (!$content) {
            $err = jsmin_last_error();
            if ($err != JSMIN_ERROR_NONE) {
                if (isset($this->messages[$err])) {
                    throw new Exception($this->messages[$err]);
                } else {
                    throw new Exception("Unknown Error");
                }
            }
        }
        $collection->setContent($content);
    }
}



<?php
namespace AssetKit\Compressor;
use AssetKit\Collection;
use AssetKit\Process;
use AssetKit\JSMin;
use RuntimeException;

class JsMinPHPCompressor
{
    public function compress(Collection $collection)
    {
        $content = $collection->getContent();
        $collection->setContent(JSMin::minify($content));
    }
}



<?php
namespace AssetKit\Compressor;
use AssetKit\Collection;
use AssetKit\Process;
use AssetKit\Utils;
use RuntimeException;
use Exception;

class UglifyCompressor
{
    public $bin;

    public $node;

    public function __construct($bin = null, $node = null)
    {
        $this->bin = $bin ?: Utils::findbin('uglifyjs');
        $this->node = $node ?: Utils::findbin('node');
        if (!$this->bin) {
            throw new Exception('uglifyjs not found.');
        }
    }
    
    public function compress(Collection $collection)
    {
        // C version jsmin is faster,
        $content = $collection->getContent();
        $proc = new Process(array($this->node, $this->bin));
        $proc->arg('-');
        $proc->input($content);

        $code = $proc->run();
        if ( $code != 0 ) {
            $command = $proc->getCommand();
            throw new RuntimeException("UglifyCompressor failure: ($code) " . $proc->getError() . " command: $command, collection: " . $collection->sourceDir );
        }
        $output = $proc->getOutput();
        $collection->setContent($output);
    }
}



<?php
namespace AssetKit\Compressor\Yui;
use AssetKit\Process;
use AssetKit\Collection;
use Exception;

class CssCompressor
{
    public $jar;
    public $java;
    public $charset;

    public function __construct($jar = NULL,$java = '/usr/bin/java')
    {
        if (!$jar) {
            $jar = getenv('YUI_COMPRESSOR_BIN');
        }
        if (!$jar) {
            throw new Exception('YUI Compressor jar path is required.');
        }
        $this->jar = $jar;
        $this->java = $java;
    }

    public function setCharset($charset)
    {
        $this->charset = $charset;
    }

    public function compress(Collection $collection)
    { 
        $input = $collection->getContent();

        $proc = new Process( array( $this->java, '-jar', $this->jar ));
        $code = $proc->arg('--type')->arg('css')->input($input)->run();
        $content = $proc->getOutput();
        $collection->setContent($content);
    }
}

<?php
namespace AssetKit\Compressor\Yui;
use AssetKit\Process;
use AssetKit\Collection;
use Exception;

class JsCompressor
{
    public $jar;
    public $java;
    public $charset;

    public function __construct($jar = NULL,$java = '/usr/bin/java')
    {
        if (!$jar) {
            $jar = getenv('YUI_COMPRESSOR_BIN');
        }
        if (!$jar) {
            throw new Exception('YUI Compressor jar path is required.');
        }
        $this->jar = $jar;
        $this->java = $java;
    }

    public function setCharset($charset)
    {
        $this->charset = $charset;
    }

    public function compress(Collection $collection)
    { 
        $input = $collection->getContent();
        $proc = new Process( array( $this->java, '-jar', $this->jar ));
        $code = $proc->arg('--type')->arg('js')->input($input)->run();
        $content = $proc->getOutput();
        $collection->setContent($content);
    }
}



<?php
namespace AssetKit;
use CLIFramework\Application;

class Console extends Application
{
    const NAME = 'assetkit';
    const VERSION = "3.4.1";

    static function getInstance()
    {
        static $self;
        $self = new self;
        return $self;
    }

    public function init()
    {
        parent::init();
        $this->command('init');
        $this->command('create-manifest');
        $this->command('add');
        $this->command('remove');
        $this->command('compile');
        $this->command('clean');
        $this->command('update');
        $this->command('install');
        $this->command('target');
        $this->command('list');
        $this->command('watch');
    }
}

<?php
namespace {
/**
 * CssMin - A (simple) css minifier with benefits
 * 
 * --
 * Copyright (c) 2011 Joe Scylla <joe.scylla@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * --
 * 
 * @package     CssMin
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
/**
 * Abstract definition of a CSS token class.
 * 
 * Every token has to extend this class.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssToken
    {
    /**
     * Returns the token as string.
     * 
     * @return string
     */
    abstract public function __toString();
    }

/**
 * Abstract definition of a for a ruleset start token.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssRulesetStartToken extends aCssToken
    {
    
    }

/**
 * Abstract definition of a for ruleset end token.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssRulesetEndToken extends aCssToken
    {
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "}";
        }
    }

/**
 * Abstract definition of a parser plugin.
 * 
 * Every parser plugin have to extend this class. A parser plugin contains the logic to parse one or aspects of a 
 * stylesheet.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssParserPlugin
    {
    /**
     * Plugin configuration.
     * 
     * @var array
     */
    protected $configuration = array();
    /**
     * The CssParser of the plugin.
     * 
     * @var CssParser
     */
    protected $parser = null;
    /**
     * Plugin buffer.
     * 
     * @var string
     */
    protected $buffer = "";
    /**
     * Constructor.
     * 
     * @param CssParser $parser The CssParser object of this plugin.
     * @param array $configuration Plugin configuration [optional]
     * @return void
     */
    public function __construct(CssParser $parser, array $configuration = null)
        {
        $this->configuration    = $configuration;
        $this->parser           = $parser;
        }
    /**
     * Returns the array of chars triggering the parser plugin.
     * 
     * @return array
     */
    abstract public function getTriggerChars();
    /**
     * Returns the array of states triggering the parser plugin or FALSE if every state will trigger the parser plugin.
     * 
     * @return array
     */
    abstract public function getTriggerStates();
    /**
     * Parser routine of the plugin.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    abstract public function parse($index, $char, $previousChar, $state);
    }

/**
 * Abstract definition of a minifier plugin class. 
 * 
 * Minifier plugin process the parsed tokens one by one to apply changes to the token. Every minifier plugin has to 
 * extend this class.
 *
 * @package     CssMin/Minifier/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssMinifierPlugin
    {
    /**
     * Plugin configuration.
     * 
     * @var array
     */
    protected $configuration = array();
    /**
     * The CssMinifier of the plugin.
     * 
     * @var CssMinifier
     */
    protected $minifier = null;
    /**
     * Constructor.
     * 
     * @param CssMinifier $minifier The CssMinifier object of this plugin.
     * @param array $configuration Plugin configuration [optional]
     * @return void
     */
    public function __construct(CssMinifier $minifier, array $configuration = array())
        {
        $this->configuration    = $configuration;
        $this->minifier         = $minifier;
        }
    /**
     * Apply the plugin to the token.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    abstract public function apply(aCssToken &$token);
    /**
     * --
     * 
     * @return array
     */
    abstract public function getTriggerTokens();
    }

/**
 * Abstract definition of a minifier filter class. 
 * 
 * Minifier filters allows a pre-processing of the parsed token to add, edit or delete tokens. Every minifier filter
 * has to extend this class.
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssMinifierFilter
    {
    /**
     * Filter configuration.
     * 
     * @var array
     */
    protected $configuration = array();
    /**
     * The CssMinifier of the filter.
     * 
     * @var CssMinifier
     */
    protected $minifier = null;
    /**
     * Constructor.
     * 
     * @param CssMinifier $minifier The CssMinifier object of this plugin.
     * @param array $configuration Filter configuration [optional]
     * @return void
     */
    public function __construct(CssMinifier $minifier, array $configuration = array())
        {
        $this->configuration    = $configuration;
        $this->minifier         = $minifier;
        }
    /**
     * Filter the tokens.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
     */
    abstract public function apply(array &$tokens);
    }

/**
 * Abstract formatter definition.
 * 
 * Every formatter have to extend this class.
 * 
 * @package     CssMin/Formatter
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssFormatter
    {
    /**
     * Indent string.
     * 
     * @var string
     */
    protected $indent = "    ";
    /**
     * Declaration padding.
     * 
     * @var integer
     */
    protected $padding = 0;
    /**
     * Tokens.
     * 
     * @var array
     */
    protected $tokens = array();
    /**
     * Constructor.
     * 
     * @param array $tokens Array of CssToken
     * @param string $indent Indent string [optional]
     * @param integer $padding Declaration value padding [optional]
     */
    public function __construct(array $tokens, $indent = null, $padding = null)
        {
        $this->tokens   = $tokens;
        $this->indent   = !is_null($indent) ? $indent : $this->indent;
        $this->padding  = !is_null($padding) ? $padding : $this->padding;
        }
    /**
     * Returns the array of aCssToken as formatted string.
     * 
     * @return string
     */
    abstract public function __toString();
    }

/**
 * Abstract definition of a ruleset declaration token.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssDeclarationToken extends aCssToken
    {
    /**
     * Is the declaration flagged as important?
     * 
     * @var boolean
     */
    public $IsImportant = false;
    /**
     * Is the declaration flagged as last one of the ruleset?
     * 
     * @var boolean
     */
    public $IsLast = false;
    /**
     * Property name of the declaration.
     * 
     * @var string
     */
    public $Property = "";
    /**
     * Value of the declaration.
     * 
     * @var string
     */
    public $Value = "";
    /**
     * Set the properties of the @font-face declaration. 
     * 
     * @param string $property Property of the declaration
     * @param string $value Value of the declaration
     * @param boolean $isImportant Is the !important flag is set?
     * @param boolean $IsLast Is the declaration the last one of the block?
     * @return void
     */
    public function __construct($property, $value, $isImportant = false, $isLast = false)
        {
        $this->Property     = $property;
        $this->Value        = $value;
        $this->IsImportant  = $isImportant;
        $this->IsLast       = $isLast;
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return $this->Property . ":" . $this->Value . ($this->IsImportant ? " !important" : "") . ($this->IsLast ? "" : ";");
        }
    }

/**
 * Abstract definition of a for at-rule block start token.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssAtBlockStartToken extends aCssToken
    {
    
    }

/**
 * Abstract definition of a for at-rule block end token.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
abstract class aCssAtBlockEndToken extends aCssToken
    {
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "}";
        }
    }

/**
 * {@link aCssFromatter Formatter} returning the CSS source in {@link http://goo.gl/etzLs Whitesmiths indent style}.
 * 
 * @package     CssMin/Formatter
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssWhitesmithsFormatter extends aCssFormatter
    {
    /**
     * Implements {@link aCssFormatter::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        $r              = array();
        $level          = 0;
        for ($i = 0, $l = count($this->tokens); $i < $l; $i++)
            {
            $token      = $this->tokens[$i];
            $class      = get_class($token);
            $indent     = str_repeat($this->indent, $level);
            if ($class === "CssCommentToken")
                {
                $lines = array_map("trim", explode("\n", $token->Comment));
                for ($ii = 0, $ll = count($lines); $ii < $ll; $ii++)
                    {
                    $r[] = $indent . (substr($lines[$ii], 0, 1) == "*" ? " " : "") . $lines[$ii];
                    }
                }
            elseif ($class === "CssAtCharsetToken")
                {
                $r[] = $indent . "@charset " . $token->Charset . ";";
                }
            elseif ($class === "CssAtFontFaceStartToken")
                {
                $r[] = $indent . "@font-face";
                $r[] = $this->indent . $indent . "{";
                $level++;
                }
            elseif ($class === "CssAtImportToken")
                {
                $r[] = $indent . "@import " . $token->Import . " " . implode(", ", $token->MediaTypes) . ";";
                }
            elseif ($class === "CssAtKeyframesStartToken")
                {
                $r[] = $indent . "@keyframes \"" . $token->Name . "\"";
                $r[] = $this->indent . $indent . "{";
                $level++;
                }
            elseif ($class === "CssAtMediaStartToken")
                {
                $r[] = $indent . "@media " . implode(", ", $token->MediaTypes);
                $r[] = $this->indent . $indent . "{";
                $level++;
                }
            elseif ($class === "CssAtPageStartToken")
                {
                $r[] = $indent . "@page";
                $r[] = $this->indent . $indent . "{";
                $level++;
                }
            elseif ($class === "CssAtVariablesStartToken")
                {
                $r[] = $indent . "@variables " . implode(", ", $token->MediaTypes);
                $r[] = $this->indent . $indent . "{";
                $level++;
                }
            elseif ($class === "CssRulesetStartToken" || $class === "CssAtKeyframesRulesetStartToken")
                {
                $r[] = $indent . implode(", ", $token->Selectors);
                $r[] = $this->indent . $indent . "{";
                $level++;
                }
            elseif ($class == "CssAtFontFaceDeclarationToken"
                || $class === "CssAtKeyframesRulesetDeclarationToken"
                || $class === "CssAtPageDeclarationToken"
                || $class == "CssAtVariablesDeclarationToken"
                || $class === "CssRulesetDeclarationToken"
                )
                {
                $declaration = $indent . $token->Property . ": ";
                if ($this->padding)
                    {
                    $declaration = str_pad($declaration, $this->padding, " ", STR_PAD_RIGHT);
                    }
                $r[] = $declaration . $token->Value . ($token->IsImportant ? " !important" : "") . ";";
                }
            elseif ($class === "CssAtFontFaceEndToken"
                || $class === "CssAtMediaEndToken"
                || $class === "CssAtKeyframesEndToken"
                || $class === "CssAtKeyframesRulesetEndToken"
                || $class === "CssAtPageEndToken"
                || $class === "CssAtVariablesEndToken"
                || $class === "CssRulesetEndToken"
                )
                {
                $r[] = $indent . "}";
                $level--;
                }
            }
        return implode("\n", $r);
        }
    }

/**
 * This {@link aCssMinifierPlugin} will process var-statement and sets the declaration value to the variable value. 
 * 
 * This plugin only apply the variable values. The variable values itself will get parsed by the
 * {@link CssVariablesMinifierFilter}.
 * 
 * Example:
 * <code>
 * @variables
 *      {
 *      defaultColor: black;
 *      }
 * color: var(defaultColor);
 * </code>
 * 
 * Will get converted to:
 * <code>
 * color:black;
 * </code>
 *
 * @package     CssMin/Minifier/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssVariablesMinifierPlugin extends aCssMinifierPlugin
    {
    /**
     * Regular expression matching a value.
     * 
     * @var string
     */
    private $reMatch = "/var\((.+)\)/iSU";
    /**
     * Parsed variables.
     * 
     * @var array
     */
    private $variables = null;
    /**
     * Returns the variables.
     * 
     * @return array
     */
    public function getVariables()
        {
        return $this->variables;
        }
    /**
     * Implements {@link aCssMinifierPlugin::minify()}.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    public function apply(aCssToken &$token)
        {
        if (stripos($token->Value, "var") !== false && preg_match_all($this->reMatch, $token->Value, $m))
            {
            $mediaTypes = $token->MediaTypes;
            if (!in_array("all", $mediaTypes))
                {
                $mediaTypes[] = "all";
                }
            for ($i = 0, $l = count($m[0]); $i < $l; $i++)
                {
                $variable   = trim($m[1][$i]);
                foreach ($mediaTypes as $mediaType)
                    {
                    if (isset($this->variables[$mediaType], $this->variables[$mediaType][$variable]))
                        {
                        // Variable value found => set the declaration value to the variable value and return
                        $token->Value = str_replace($m[0][$i], $this->variables[$mediaType][$variable], $token->Value);
                        continue 2;
                        }
                    }
                // If no value was found trigger an error and replace the token with a CssNullToken
                CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": No value found for variable <code>" . $variable . "</code> in media types <code>" . implode(", ", $mediaTypes) . "</code>", (string) $token));
                $token = new CssNullToken();
                return true;
                }
            }
        return false;
        }
    /**
     * Implements {@link aMinifierPlugin::getTriggerTokens()}
     * 
     * @return array
     */
    public function getTriggerTokens()
        {
        return array
            (
            "CssAtFontFaceDeclarationToken",
            "CssAtPageDeclarationToken",
            "CssRulesetDeclarationToken"
            );
        }
    /**
     * Sets the variables.
     * 
     * @param array $variables Variables to set
     * @return void
     */
    public function setVariables(array $variables)
        {
        $this->variables = $variables;
        }
    }

/**
 * This {@link aCssMinifierFilter minifier filter} will parse the variable declarations out of @variables at-rule 
 * blocks. The variables will get store in the {@link CssVariablesMinifierPlugin} that will apply the variables to 
 * declaration.
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssVariablesMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        $variables          = array();
        $defaultMediaTypes  = array("all");
        $mediaTypes         = array();
        $remove             = array();
        for($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            // @variables at-rule block found
            if (get_class($tokens[$i]) === "CssAtVariablesStartToken")
                {
                $remove[] = $i;
                $mediaTypes = (count($tokens[$i]->MediaTypes) == 0 ? $defaultMediaTypes : $tokens[$i]->MediaTypes);
                foreach ($mediaTypes as $mediaType)
                    {
                    if (!isset($variables[$mediaType]))
                        {
                        $variables[$mediaType] = array();
                        }
                    }
                // Read the variable declaration tokens
                for($i = $i; $i < $l; $i++)
                    {
                    // Found a variable declaration => read the variable values
                    if (get_class($tokens[$i]) === "CssAtVariablesDeclarationToken")
                        {
                        foreach ($mediaTypes as $mediaType)
                            {
                            $variables[$mediaType][$tokens[$i]->Property] = $tokens[$i]->Value;
                            }
                        $remove[] = $i;
                        }
                    // Found the variables end token => break;
                    elseif (get_class($tokens[$i]) === "CssAtVariablesEndToken")
                        {
                        $remove[] = $i;
                        break;
                        }
                    }
                }
            }
        // Variables in @variables at-rule blocks
        foreach($variables as $mediaType => $null)
            {
            foreach($variables[$mediaType] as $variable => $value)
                {
                // If a var() statement in a variable value found...
                if (stripos($value, "var") !== false && preg_match_all("/var\((.+)\)/iSU", $value, $m))
                    {
                    // ... then replace the var() statement with the variable values.
                    for ($i = 0, $l = count($m[0]); $i < $l; $i++)
                        {
                        $variables[$mediaType][$variable] = str_replace($m[0][$i], (isset($variables[$mediaType][$m[1][$i]]) ? $variables[$mediaType][$m[1][$i]] : ""), $variables[$mediaType][$variable]);
                        }
                    }
                }
            }
        // Remove the complete @variables at-rule block
        foreach ($remove as $i)
            {
            $tokens[$i] = null;
            }
        if (!($plugin = $this->minifier->getPlugin("CssVariablesMinifierPlugin")))
            {
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": The plugin <code>CssVariablesMinifierPlugin</code> was not found but is required for <code>" . __CLASS__ . "</code>"));
            }
        else
            {
            $plugin->setVariables($variables);
            }
        return count($remove);
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for preserve parsing url() values.
 * 
 * This plugin return no {@link aCssToken CssToken} but ensures that url() values will get parsed properly.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssUrlParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("(", ")");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return false;
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        // Start of string
        if ($char === "(" && strtolower(substr($this->parser->getSource(), $index - 3, 4)) === "url(" && $state !== "T_URL")
            {
            $this->parser->pushState("T_URL");
            $this->parser->setExclusive(__CLASS__);
            }
        // Escaped LF in url => remove escape backslash and LF
        elseif ($char === "\n" && $previousChar === "\\" && $state === "T_URL")
            {
            $this->parser->setBuffer(substr($this->parser->getBuffer(), 0, -2));
            }
        // Parse error: Unescaped LF in string literal
        elseif ($char === "\n" && $previousChar !== "\\" && $state === "T_URL")
            {
            $line = $this->parser->getBuffer();
            $this->parser->setBuffer(substr($this->parser->getBuffer(), 0, -1) . ")"); // Replace the LF with the url string delimiter
            $this->parser->popState();
            $this->parser->unsetExclusive();
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated string literal", $line . "_"));
            }
        // End of string
        elseif ($char === ")" && $state === "T_URL")
            {
            $this->parser->popState();
            $this->parser->unsetExclusive();
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for preserve parsing string values.
 * 
 * This plugin return no {@link aCssToken CssToken} but ensures that string values will get parsed properly.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssStringParserPlugin extends aCssParserPlugin
    {
    /**
     * Current string delimiter char.
     * 
     * @var string
     */
    private $delimiterChar = null;
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("\"", "'", "\n");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return false;
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        // Start of string
        if (($char === "\"" || $char === "'") && $state !== "T_STRING")
            {
            $this->delimiterChar = $char;
            $this->parser->pushState("T_STRING");
            $this->parser->setExclusive(__CLASS__);
            }
        // Escaped LF in string => remove escape backslash and LF
        elseif ($char === "\n" && $previousChar === "\\" && $state === "T_STRING")
            {
            $this->parser->setBuffer(substr($this->parser->getBuffer(), 0, -2));
            }
        // Parse error: Unescaped LF in string literal
        elseif ($char === "\n" && $previousChar !== "\\" && $state === "T_STRING")
            {
            $line = $this->parser->getBuffer();
            $this->parser->popState();
            $this->parser->unsetExclusive();
            $this->parser->setBuffer(substr($this->parser->getBuffer(), 0, -1) . $this->delimiterChar); // Replace the LF with the current string char
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated string literal", $line . "_"));
            $this->delimiterChar = null;
            }
        // End of string
        elseif ($char === $this->delimiterChar && $state === "T_STRING")
            {
            // If the Previous char is a escape char count the amount of the previous escape chars. If the amount of 
            // escape chars is uneven do not end the string
            if ($previousChar == "\\")
                {
                $source = $this->parser->getSource();
                $c      = 1;
                $i      = $index - 2;
                while (substr($source, $i, 1) === "\\")
                    {
                    $c++; $i--;
                    }
                if ($c % 2)
                    {
                    return false;
                    }
                }
            $this->parser->popState();
            $this->parser->unsetExclusive();
            $this->delimiterChar = null;
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * This {@link aCssMinifierFilter minifier filter} sorts the ruleset declarations of a ruleset by name.
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Rowan Beentje <http://assanka.net>
 * @copyright   Rowan Beentje <http://assanka.net>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssSortRulesetPropertiesMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value larger than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        $r = 0;
        for ($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            // Only look for ruleset start rules
            if (get_class($tokens[$i]) !== "CssRulesetStartToken") { continue; }
            // Look for the corresponding ruleset end
            $endIndex = false;
            for ($ii = $i + 1; $ii < $l; $ii++)
                {
                if (get_class($tokens[$ii]) !== "CssRulesetEndToken") { continue; }
                $endIndex = $ii;
                break;
                }
            if (!$endIndex) { break; }
            $startIndex = $i;
            $i = $endIndex;
            // Skip if there's only one token in this ruleset
            if ($endIndex - $startIndex <= 2) { continue; }
            // Ensure that everything between the start and end is a declaration token, for safety
            for ($ii = $startIndex + 1; $ii < $endIndex; $ii++)
                {
                if (get_class($tokens[$ii]) !== "CssRulesetDeclarationToken") { continue(2); }
                }
            $declarations = array_slice($tokens, $startIndex + 1, $endIndex - $startIndex - 1);
            // Check whether a sort is required
            $sortRequired = $lastPropertyName = false;
            foreach ($declarations as $declaration) 
                {
                if ($lastPropertyName)
                    {
                    if (strcmp($lastPropertyName, $declaration->Property) > 0)
                        {
                        $sortRequired = true;
                        break;
                        }
                    }
                $lastPropertyName = $declaration->Property;
                }
            if (!$sortRequired) { continue; }
            // Arrange the declarations alphabetically by name
            usort($declarations, array(__CLASS__, "userDefinedSort1"));
            // Update "IsLast" property
            for ($ii = 0, $ll = count($declarations) - 1; $ii <= $ll; $ii++)
                {
                if ($ii == $ll)
                    {
                    $declarations[$ii]->IsLast = true;
                    }
                else
                    {
                    $declarations[$ii]->IsLast = false;
                    }
                }
            // Splice back into the array.
            array_splice($tokens, $startIndex + 1, $endIndex - $startIndex - 1, $declarations);
            $r += $endIndex - $startIndex - 1;
            }
        return $r;
        }
    /**
     * User defined sort function.
     * 
     * @return integer
     */
    public static function userDefinedSort1($a, $b)
        {
        return strcmp($a->Property, $b->Property);
        }
    }

/**
 * This {@link aCssToken CSS token} represents the start of a ruleset.
 * 
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssRulesetStartToken extends aCssRulesetStartToken
    {
    /**
     * Array of selectors.
     * 
     * @var array
     */
    public $Selectors = array();
    /**
     * Set the properties of a ruleset token.
     * 
     * @param array $selectors Selectors of the ruleset 
     * @return void
     */
    public function __construct(array $selectors = array())
        {
        $this->Selectors = $selectors;
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return implode(",", $this->Selectors) . "{";
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing ruleset block with including declarations.
 * 
 * Found rulesets will add a {@link CssRulesetStartToken} and {@link CssRulesetEndToken} to the 
 * parser; including declarations as {@link CssRulesetDeclarationToken}.
 *
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssRulesetParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array(",", "{", "}", ":", ";");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return array("T_DOCUMENT", "T_AT_MEDIA", "T_RULESET::SELECTORS", "T_RULESET", "T_RULESET_DECLARATION");
        }
    /**
     * Selectors.
     * 
     * @var array
     */
    private $selectors = array();
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        // Start of Ruleset and selectors
        if ($char === "," && ($state === "T_DOCUMENT" || $state === "T_AT_MEDIA" || $state === "T_RULESET::SELECTORS"))
            {
            if ($state !== "T_RULESET::SELECTORS")
                {
                $this->parser->pushState("T_RULESET::SELECTORS");
                }
            $this->selectors[] = $this->parser->getAndClearBuffer(",{");
            }
        // End of selectors and start of declarations
        elseif ($char === "{" && ($state === "T_DOCUMENT" || $state === "T_AT_MEDIA" || $state === "T_RULESET::SELECTORS"))
            {
            if ($this->parser->getBuffer() !== "")
                {
                $this->selectors[] = $this->parser->getAndClearBuffer(",{");
                if ($state == "T_RULESET::SELECTORS")
                    {
                    $this->parser->popState();
                    }
                $this->parser->pushState("T_RULESET");
                $this->parser->appendToken(new CssRulesetStartToken($this->selectors));
                $this->selectors = array();
                }
            }
        // Start of declaration
        elseif ($char === ":" && $state === "T_RULESET")
            {
            $this->parser->pushState("T_RULESET_DECLARATION");
            $this->buffer = $this->parser->getAndClearBuffer(":;", true);
            }
        // Unterminated ruleset declaration
        elseif ($char === ":" && $state === "T_RULESET_DECLARATION")
            {
            // Ignore Internet Explorer filter declarations
            if ($this->buffer === "filter")
                {
                return false;
                }
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
            }
        // End of declaration
        elseif (($char === ";" || $char === "}") && $state === "T_RULESET_DECLARATION")
            {
            $value = $this->parser->getAndClearBuffer(";}");
            if (strtolower(substr($value, -10, 10)) === "!important")
                {
                $value = trim(substr($value, 0, -10));
                $isImportant = true;
                }
            else
                {
                $isImportant = false;
                }
            $this->parser->popState();
            $this->parser->appendToken(new CssRulesetDeclarationToken($this->buffer, $value, $this->parser->getMediaTypes(), $isImportant));
            // Declaration ends with a right curly brace; so we have to end the ruleset
            if ($char === "}")
                {
                $this->parser->appendToken(new CssRulesetEndToken());
                $this->parser->popState();
                }
            $this->buffer = "";
            }
        // End of ruleset
        elseif ($char === "}" && $state === "T_RULESET")
            {
            $this->parser->popState();
            $this->parser->clearBuffer();
            $this->parser->appendToken(new CssRulesetEndToken());
            $this->buffer = "";
            $this->selectors = array();
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 *  This {@link aCssToken CSS token} represents the end of a ruleset.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssRulesetEndToken extends aCssRulesetEndToken
    {
    
    }

/**
 * This {@link aCssToken CSS token} represents a ruleset declaration.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssRulesetDeclarationToken extends aCssDeclarationToken
    {
    /**
     * Media types of the declaration.
     * 
     * @var array
     */
    public $MediaTypes = array("all");
    /**
     * Set the properties of a ddocument- or at-rule @media level declaration. 
     * 
     * @param string $property Property of the declaration
     * @param string $value Value of the declaration
     * @param mixed $mediaTypes Media types of the declaration
     * @param boolean $isImportant Is the !important flag is set
     * @param boolean $isLast Is the declaration the last one of the ruleset
     * @return void
     */
    public function __construct($property, $value, $mediaTypes = null, $isImportant = false, $isLast = false)
        {
        parent::__construct($property, $value, $isImportant, $isLast);
        $this->MediaTypes   = $mediaTypes ? $mediaTypes : array("all");
        }
    }

/**
 * This {@link aCssMinifierFilter minifier filter} sets the IsLast property of any last declaration in a ruleset, 
 * @font-face at-rule or @page at-rule block. If the property IsLast is TRUE the decrations will get stringified 
 * without tailing semicolon.
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssRemoveLastDelarationSemiColonMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        for ($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            $current    = get_class($tokens[$i]);
            $next       = isset($tokens[$i+1]) ? get_class($tokens[$i+1]) : false;
            if (($current === "CssRulesetDeclarationToken" && $next === "CssRulesetEndToken") ||
                ($current === "CssAtFontFaceDeclarationToken" && $next === "CssAtFontFaceEndToken") || 
                ($current === "CssAtPageDeclarationToken" && $next === "CssAtPageEndToken"))
                {
                $tokens[$i]->IsLast = true;
                }
            }
        return 0;
        }
    }

/**
 * This {@link aCssMinifierFilter minifier filter} will remove any empty rulesets (including @keyframes at-rule block 
 * rulesets).
 *
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssRemoveEmptyRulesetsMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        $r = 0;
        for ($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            $current    = get_class($tokens[$i]);
            $next       = isset($tokens[$i + 1]) ? get_class($tokens[$i + 1]) : false;
            if (($current === "CssRulesetStartToken" && $next === "CssRulesetEndToken") ||
                ($current === "CssAtKeyframesRulesetStartToken" && $next === "CssAtKeyframesRulesetEndToken" && !array_intersect(array("from", "0%", "to", "100%"), array_map("strtolower", $tokens[$i]->Selectors)))
                )
                {
                $tokens[$i]     = null;
                $tokens[$i + 1] = null;
                $i++;
                $r = $r + 2;
                }
            }
        return $r;
        }
    }

/**
 * This {@link aCssMinifierFilter minifier filter} will remove any empty @font-face, @keyframes, @media and @page 
 * at-rule blocks.
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssRemoveEmptyAtBlocksMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        $r = 0;
        for ($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            $current    = get_class($tokens[$i]);
            $next       = isset($tokens[$i + 1]) ? get_class($tokens[$i + 1]) : false;
            if (($current === "CssAtFontFaceStartToken" && $next === "CssAtFontFaceEndToken") ||
                ($current === "CssAtKeyframesStartToken" && $next === "CssAtKeyframesEndToken") ||
                ($current === "CssAtPageStartToken" && $next === "CssAtPageEndToken") ||
                ($current === "CssAtMediaStartToken" && $next === "CssAtMediaEndToken"))
                {
                $tokens[$i]     = null;
                $tokens[$i + 1] = null;
                $i++;
                $r = $r + 2;
                }
            }
        return $r;
        }
    }

/**
 * This {@link aCssMinifierFilter minifier filter} will remove any comments from the array of parsed tokens.
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssRemoveCommentsMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        $r = 0;
        for ($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            if (get_class($tokens[$i]) === "CssCommentToken")
                {
                $tokens[$i] = null;
                $r++;
                }
            }
        return $r;
        }
    }

/**
 * CSS Parser.
 * 
 * @package     CssMin/Parser
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssParser
    {
    /**
     * Parse buffer.
     * 
     * @var string
     */
    private $buffer = "";
    /**
     * {@link aCssParserPlugin Plugins}.
     * 
     * @var array
     */
    private $plugins = array();
    /**
     * Source to parse.
     * 
     * @var string
     */
    private $source = "";
    /**
     * Current state.
     * 
     * @var integer
     */
    private $state = "T_DOCUMENT";
    /**
     * Exclusive state.
     * 
     * @var string
     */
    private $stateExclusive = false;
    /**
     * Media types state.
     * 
     * @var mixed
     */
    private $stateMediaTypes = false;
    /**
     * State stack.
     * 
     * @var array
     */
    private $states = array("T_DOCUMENT");
    /**
     * Parsed tokens.
     * 
     * @var array
     */
    private $tokens = array();
    /**
     * Constructer.
     * 
     *  Create instances of the used {@link aCssParserPlugin plugins}.
     * 
     * @param string $source CSS source [optional]
     * @param array $plugins Plugin configuration [optional]
     * @return void
     */
    public function __construct($source = null, array $plugins = null)
        {
        $plugins = array_merge(array
            (
            "Comment"       => true,
            "String"        => true,
            "Url"           => true,
            "Expression"    => true,
            "Ruleset"       => true,
            "AtCharset"     => true,
            "AtFontFace"    => true,
            "AtImport"      => true,
            "AtKeyframes"   => true,
            "AtMedia"       => true,
            "AtPage"        => true,
            "AtVariables"   => true
            ), is_array($plugins) ? $plugins : array());
        // Create plugin instances
        foreach ($plugins as $name => $config)
            {
            if ($config !== false)
                {
                $class  = "Css" . $name . "ParserPlugin";
                $config = is_array($config) ? $config : array();
                if (class_exists($class))
                    {
                    $this->plugins[] = new $class($this, $config);
                    }
                else
                    {
                    CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": The plugin <code>" . $name . "</code> with the class name <code>" . $class . "</code> was not found"));
                    }
                }
            }
        if (!is_null($source))
            {
            $this->parse($source);
            }
        }
    /**
     * Append a token to the array of tokens.
     * 
     * @param aCssToken $token Token to append
     * @return void
     */
    public function appendToken(aCssToken $token)
        {
        $this->tokens[] = $token;
        }
    /**
     * Clears the current buffer.
     * 
     * @return void
     */
    public function clearBuffer()
        {
        $this->buffer = "";
        }
    /**
     * Returns and clear the current buffer.
     * 
     * @param string $trim Chars to use to trim the returned buffer
     * @param boolean $tolower if TRUE the returned buffer will get converted to lower case
     * @return string
     */
    public function getAndClearBuffer($trim = "", $tolower = false)
        {
        $r = $this->getBuffer($trim, $tolower);
        $this->buffer = "";
        return $r;
        }
    /**
     * Returns the current buffer.
     * 
     * @param string $trim Chars to use to trim the returned buffer
     * @param boolean $tolower if TRUE the returned buffer will get converted to lower case
     * @return string
     */
    public function getBuffer($trim = "", $tolower = false)
        {
        $r = $this->buffer;
        if ($trim)
            {
            $r = trim($r, " \t\n\r\0\x0B" . $trim);
            }
        if ($tolower)
            {
            $r = strtolower($r);
            }
        return $r;
        }
    /**
     * Returns the current media types state.
     * 
     * @return array
     */ 
    public function getMediaTypes()
        {
        return $this->stateMediaTypes;
        }
    /**
     * Returns the CSS source.
     * 
     * @return string
     */
    public function getSource()
        {
        return $this->source;
        }
    /**
     * Returns the current state.
     * 
     * @return integer The current state
     */
    public function getState()
        {
        return $this->state;
        }
    /**
     * Returns a plugin by class name.
     * 
     * @param string $name Class name of the plugin 
     * @return aCssParserPlugin
     */
    public function getPlugin($class)
        {
        static $index = null;
        if (is_null($index))
            {
            $index = array();
            for ($i = 0, $l = count($this->plugins); $i < $l; $i++)
                {
                $index[get_class($this->plugins[$i])] = $i;
                }
            }
        return isset($index[$class]) ? $this->plugins[$index[$class]] : false;
        }
    /**
     * Returns the parsed tokens.
     * 
     * @return array
     */
    public function getTokens()
        {
        return $this->tokens;
        }
    /**
     * Returns if the current state equals the passed state.
     * 
     * @param integer $state State to compare with the current state
     * @return boolean TRUE is the state equals to the passed state; FALSE if not
     */
    public function isState($state)
        {
        return ($this->state == $state);
        }
    /**
     * Parse the CSS source and return a array with parsed tokens.
     * 
     * @param string $source CSS source
     * @return array Array with tokens
     */
    public function parse($source)
        {
        // Reset
        $this->source = "";
        $this->tokens = array();
        // Create a global and plugin lookup table for trigger chars; set array of plugins as local variable and create 
        // several helper variables for plugin handling
        $globalTriggerChars     = "";
        $plugins                = $this->plugins;
        $pluginCount            = count($plugins);
        $pluginIndex            = array();
        $pluginTriggerStates    = array();
        $pluginTriggerChars     = array();
        for ($i = 0, $l = count($plugins); $i < $l; $i++)
            {
            $tPluginClassName               = get_class($plugins[$i]);
            $pluginTriggerChars[$i]         = implode("", $plugins[$i]->getTriggerChars());
            $tPluginTriggerStates           = $plugins[$i]->getTriggerStates();
            $pluginTriggerStates[$i]        = $tPluginTriggerStates === false ? false : "|" . implode("|", $tPluginTriggerStates) . "|";
            $pluginIndex[$tPluginClassName] = $i;
            for ($ii = 0, $ll = strlen($pluginTriggerChars[$i]); $ii < $ll; $ii++)
                {
                $c = substr($pluginTriggerChars[$i], $ii, 1);
                if (strpos($globalTriggerChars, $c) === false)
                    {
                    $globalTriggerChars .= $c;
                    }
                }
            }
        // Normalise line endings
        $source         = str_replace("\r\n", "\n", $source);   // Windows to Unix line endings
        $source         = str_replace("\r", "\n", $source);     // Mac to Unix line endings
        $this->source   = $source;
        // Variables
        $buffer         = &$this->buffer;
        $exclusive      = &$this->stateExclusive;
        $state          = &$this->state;
        $c = $p         = null;
        // --
        for ($i = 0, $l = strlen($source); $i < $l; $i++)
            {
            // Set the current Char
            $c = $source[$i]; // Is faster than: $c = substr($source, $i, 1);
            // Normalize and filter double whitespace characters
            if ($exclusive === false)
                {
                if ($c === "\n" || $c === "\t")
                    {
                    $c = " ";
                    }
                if ($c === " " && $p === " ")
                    {
                    continue;
                    }
                }
            $buffer .= $c;
            // Extended processing only if the current char is a global trigger char
            if (strpos($globalTriggerChars, $c) !== false)
                {
                // Exclusive state is set; process with the exclusive plugin 
                if ($exclusive)
                    {
                    $tPluginIndex = $pluginIndex[$exclusive];
                    if (strpos($pluginTriggerChars[$tPluginIndex], $c) !== false && ($pluginTriggerStates[$tPluginIndex] === false || strpos($pluginTriggerStates[$tPluginIndex], $state) !== false))
                        {
                        $r = $plugins[$tPluginIndex]->parse($i, $c, $p, $state);
                        // Return value is TRUE => continue with next char
                        if ($r === true)
                            {
                            continue;
                            }
                        // Return value is numeric => set new index and continue with next char
                        elseif ($r !== false && $r != $i)
                            {
                            $i = $r;
                            continue;
                            }
                        }
                    }
                // Else iterate through the plugins
                else
                    {
                    $triggerState = "|" . $state . "|";
                    for ($ii = 0, $ll = $pluginCount; $ii < $ll; $ii++)
                        {
                        // Only process if the current char is one of the plugin trigger chars
                        if (strpos($pluginTriggerChars[$ii], $c) !== false && ($pluginTriggerStates[$ii] === false || strpos($pluginTriggerStates[$ii], $triggerState) !== false))
                            {
                            // Process with the plugin
                            $r = $plugins[$ii]->parse($i, $c, $p, $state);
                            // Return value is TRUE => break the plugin loop and and continue with next char
                            if ($r === true)
                                {
                                break;
                                }
                            // Return value is numeric => set new index, break the plugin loop and and continue with next char
                            elseif ($r !== false && $r != $i)
                                {
                                $i = $r;
                                break;
                                }
                            }
                        }
                    }
                }
            $p = $c; // Set the parent char
            }
        return $this->tokens;
        }
    /**
     * Remove the last state of the state stack and return the removed stack value.
     * 
     * @return integer Removed state value
     */
    public function popState()
        {
        $r = array_pop($this->states);
        $this->state = $this->states[count($this->states) - 1];
        return $r;
        }
    /**
     * Adds a new state onto the state stack.
     * 
     * @param integer $state State to add onto the state stack.
     * @return integer The index of the added state in the state stacks
     */
    public function pushState($state)
        {
        $r = array_push($this->states, $state);
        $this->state = $this->states[count($this->states) - 1];
        return $r;
        }
    /**
     * Sets/restores the buffer.
     * 
     * @param string $buffer Buffer to set
     * @return void
     */ 
    public function setBuffer($buffer)
        {
        $this->buffer = $buffer;
        }
    /**
     * Set the exclusive state.
     * 
     * @param string $exclusive Exclusive state
     * @return void
     */ 
    public function setExclusive($exclusive)
        {
        $this->stateExclusive = $exclusive; 
        }
    /**
     * Set the media types state.
     * 
     * @param array $mediaTypes Media types state
     * @return void
     */ 
    public function setMediaTypes(array $mediaTypes)
        {
        $this->stateMediaTypes = $mediaTypes; 
        }
    /**
     * Sets the current state in the state stack; equals to {@link CssParser::popState()} + {@link CssParser::pushState()}.
     * 
     * @param integer $state State to set
     * @return integer
     */
    public function setState($state)
        {
        $r = array_pop($this->states);
        array_push($this->states, $state);
        $this->state = $this->states[count($this->states) - 1];
        return $r;
        }
    /**
     * Removes the exclusive state.
     * 
     * @return void
     */
    public function unsetExclusive()
        {
        $this->stateExclusive = false;
        }
    /**
     * Removes the media types state.
     * 
     * @return void
     */
    public function unsetMediaTypes()
        {
        $this->stateMediaTypes = false;
        }
    }

/**
 * {@link aCssFromatter Formatter} returning the CSS source in {@link http://goo.gl/j4XdU OTBS indent style} (The One True Brace Style).
 * 
 * @package     CssMin/Formatter
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssOtbsFormatter extends aCssFormatter
    {
    /**
     * Implements {@link aCssFormatter::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        $r              = array();
        $level          = 0;
        for ($i = 0, $l = count($this->tokens); $i < $l; $i++)
            {
            $token      = $this->tokens[$i];
            $class      = get_class($token);
            $indent     = str_repeat($this->indent, $level);
            if ($class === "CssCommentToken")
                {
                $lines = array_map("trim", explode("\n", $token->Comment));
                for ($ii = 0, $ll = count($lines); $ii < $ll; $ii++)
                    {
                    $r[] = $indent . (substr($lines[$ii], 0, 1) == "*" ? " " : "") . $lines[$ii];
                    }
                }
            elseif ($class === "CssAtCharsetToken")
                {
                $r[] = $indent . "@charset " . $token->Charset . ";";
                }
            elseif ($class === "CssAtFontFaceStartToken")
                {
                $r[] = $indent . "@font-face {";
                $level++;
                }
            elseif ($class === "CssAtImportToken")
                {
                $r[] = $indent . "@import " . $token->Import . " " . implode(", ", $token->MediaTypes) . ";";
                }
            elseif ($class === "CssAtKeyframesStartToken")
                {
                $r[] = $indent . "@keyframes \"" . $token->Name . "\" {";
                $level++;
                }
            elseif ($class === "CssAtMediaStartToken")
                {
                $r[] = $indent . "@media " . implode(", ", $token->MediaTypes) . " {";
                $level++;
                }
            elseif ($class === "CssAtPageStartToken")
                {
                $r[] = $indent . "@page {";
                $level++;
                }
            elseif ($class === "CssAtVariablesStartToken")
                {
                $r[] = $indent . "@variables " . implode(", ", $token->MediaTypes) . " {";
                $level++;
                }
            elseif ($class === "CssRulesetStartToken" || $class === "CssAtKeyframesRulesetStartToken")
                {
                $r[] = $indent . implode(", ", $token->Selectors) . " {";
                $level++;
                }
            elseif ($class == "CssAtFontFaceDeclarationToken"
                || $class === "CssAtKeyframesRulesetDeclarationToken"
                || $class === "CssAtPageDeclarationToken"
                || $class == "CssAtVariablesDeclarationToken"
                || $class === "CssRulesetDeclarationToken"
                )
                {
                $declaration = $indent . $token->Property . ": ";
                if ($this->padding)
                    {
                    $declaration = str_pad($declaration, $this->padding, " ", STR_PAD_RIGHT);
                    }
                $r[] = $declaration . $token->Value . ($token->IsImportant ? " !important" : "") . ";";
                }
            elseif ($class === "CssAtFontFaceEndToken"
                || $class === "CssAtMediaEndToken"
                || $class === "CssAtKeyframesEndToken"
                || $class === "CssAtKeyframesRulesetEndToken"
                || $class === "CssAtPageEndToken"
                || $class === "CssAtVariablesEndToken"
                || $class === "CssRulesetEndToken"
                )
                {
                $level--;
                $r[] = str_repeat($indent, $level) . "}";
                }
            }
        return implode("\n", $r);
        }
    }

/**
 * This {@link aCssToken CSS token} is a utility token that extends {@link aNullToken} and returns only a empty string.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssNullToken extends aCssToken
    {
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "";
        }
    }

/**
 * CSS Minifier.
 * 
 * @package     CssMin/Minifier
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssMinifier
    {
    /**
     * {@link aCssMinifierFilter Filters}.
     *  
     * @var array
     */
    private $filters = array();
    /**
     * {@link aCssMinifierPlugin Plugins}.
     * 
     * @var array
     */
    private $plugins = array();
    /**
     * Minified source.
     * 
     * @var string
     */
    private $minified = "";
    /**
     * Constructer.
     * 
     * Creates instances of {@link aCssMinifierFilter filters} and {@link aCssMinifierPlugin plugins}.
     * 
     * @param string $source CSS source [optional]
     * @param array $filters Filter configuration [optional]
     * @param array $plugins Plugin configuration [optional]
     * @return void
     */
    public function __construct($source = null, array $filters = null, array $plugins = null)
        {
        $filters = array_merge(array
            (
            "ImportImports"                 => false,
            "RemoveComments"                => true, 
            "RemoveEmptyRulesets"           => true,
            "RemoveEmptyAtBlocks"           => true,
            "ConvertLevel3Properties"       => false,
            "ConvertLevel3AtKeyframes"      => false,
            "Variables"                     => true,
            "RemoveLastDelarationSemiColon" => true
            ), is_array($filters) ? $filters : array());
        $plugins = array_merge(array
            (
            "Variables"                     => true,
            "ConvertFontWeight"             => false,
            "ConvertHslColors"              => false,
            "ConvertRgbColors"              => false,
            "ConvertNamedColors"            => false,
            "CompressColorValues"           => false,
            "CompressUnitValues"            => false,
            "CompressExpressionValues"      => false
            ), is_array($plugins) ? $plugins : array());
        // Filters
        foreach ($filters as $name => $config)
            {
            if ($config !== false)
                {
                $class  = "Css" . $name . "MinifierFilter";
                $config = is_array($config) ? $config : array();
                if (class_exists($class))
                    {
                    $this->filters[] = new $class($this, $config);
                    }
                else
                    {
                    CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": The filter <code>" . $name . "</code> with the class name <code>" . $class . "</code> was not found"));
                    }
                }
            }
        // Plugins
        foreach ($plugins as $name => $config)
            {
            if ($config !== false)
                {
                $class  = "Css" . $name . "MinifierPlugin";
                $config = is_array($config) ? $config : array();
                if (class_exists($class))
                    {
                    $this->plugins[] = new $class($this, $config);
                    }
                else
                    {
                    CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": The plugin <code>" . $name . "</code> with the class name <code>" . $class . "</code> was not found"));
                    }
                }
            }
        // --
        if (!is_null($source))
            {
            $this->minify($source);
            }
        }
    /**
     * Returns the minified Source.
     * 
     * @return string
     */
    public function getMinified()
        {
        return $this->minified;
        }
    /**
     * Returns a plugin by class name.
     * 
     * @param string $name Class name of the plugin
     * @return aCssMinifierPlugin
     */
    public function getPlugin($class)
        {
        static $index = null;
        if (is_null($index))
            {
            $index = array();
            for ($i = 0, $l = count($this->plugins); $i < $l; $i++)
                {
                $index[get_class($this->plugins[$i])] = $i;
                }
            }
        return isset($index[$class]) ? $this->plugins[$index[$class]] : false;
        }
    /**
     * Minifies the CSS source.
     * 
     * @param string $source CSS source
     * @return string
     */
    public function minify($source)
        {
        // Variables
        $r                      = "";
        $parser                 = new CssParser($source);
        $tokens                 = $parser->getTokens();
        $filters                = $this->filters;
        $filterCount            = count($this->filters);
        $plugins                = $this->plugins;
        $pluginCount            = count($plugins);
        $pluginIndex            = array();
        $pluginTriggerTokens    = array();
        $globalTriggerTokens    = array();
        for ($i = 0, $l = count($plugins); $i < $l; $i++)
            {
            $tPluginClassName               = get_class($plugins[$i]);
            $pluginTriggerTokens[$i]        = $plugins[$i]->getTriggerTokens();
            foreach ($pluginTriggerTokens[$i] as $v)
                {
                if (!in_array($v, $globalTriggerTokens))
                    {
                    $globalTriggerTokens[] = $v;
                    }
                }
            $pluginTriggerTokens[$i] = "|" . implode("|", $pluginTriggerTokens[$i]) . "|";
            $pluginIndex[$tPluginClassName] = $i;
            }
        $globalTriggerTokens = "|" . implode("|", $globalTriggerTokens) . "|";
        /*
         * Apply filters
         */
        for($i = 0; $i < $filterCount; $i++)
            {
            // Apply the filter; if the return value is larger than 0...
            if ($filters[$i]->apply($tokens) > 0)
                {
                // ...then filter null values and rebuild the token array
                $tokens = array_values(array_filter($tokens));
                }
            }
        $tokenCount = count($tokens);
        /*
         * Apply plugins
         */
        for($i = 0; $i < $tokenCount; $i++)
            {
            $triggerToken = "|" . get_class($tokens[$i]) . "|";
            if (strpos($globalTriggerTokens, $triggerToken) !== false)
                {
                for($ii = 0; $ii < $pluginCount; $ii++)
                    {
                    if (strpos($pluginTriggerTokens[$ii], $triggerToken) !== false || $pluginTriggerTokens[$ii] === false)
                        {
                        // Apply the plugin; if the return value is TRUE continue to the next token
                        if ($plugins[$ii]->apply($tokens[$i]) === true)
                            {
                            continue 2;
                            }
                        }
                    }
                }
            }
        // Stringify the tokens
        for($i = 0; $i < $tokenCount; $i++)
            {
            $r .= (string) $tokens[$i];
            }
        $this->minified = $r;
        return $r;
        }
    }

/**
 * CssMin - A (simple) css minifier with benefits
 * 
 * --
 * Copyright (c) 2011 Joe Scylla <joe.scylla@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * --
 * 
 * @package     CssMin
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssMin
    {
    /**
     * Index of classes
     * 
     * @var array
     */
    private static $classIndex = array();
    /**
     * Parse/minify errors
     * 
     * @var array
     */
    private static $errors = array();
    /**
     * Verbose output.
     * 
     * @var boolean
     */
    private static $isVerbose = false;
    /**
     * {@link http://goo.gl/JrW54 Autoload} function of CssMin.
     * 
     * @param string $class Name of the class
     * @return void
     */
    public static function autoload($class)
        {
        if (isset(self::$classIndex[$class]))
            {
            require(self::$classIndex[$class]);
            }
        }
    /**
     * Return errors
     * 
     * @return array of {CssError}.
     */
    public static function getErrors()
        {
        return self::$errors;
        }
    /**
     * Returns if there were errors.
     * 
     * @return boolean
     */
    public static function hasErrors()
        {
        return count(self::$errors) > 0;
        }
    /**
     * Initialises CssMin.
     * 
     * @return void
     */
    public static function initialise()
        {
        // Create the class index for autoloading or including
        $paths = array(dirname(__FILE__));
        while (list($i, $path) = each($paths))
            {
            $subDirectorys = glob($path . "*", GLOB_MARK | GLOB_ONLYDIR | GLOB_NOSORT);
            if (is_array($subDirectorys))
                {
                foreach ($subDirectorys as $subDirectory)
                    {
                    $paths[] = $subDirectory;
                    }
                }
            $files = glob($path . "*.php", 0);
            if (is_array($files))
                {
                foreach ($files as $file)
                    {
                    $class = substr(basename($file), 0, -4);
                    self::$classIndex[$class] = $file;
                    }
                }
            }
        krsort(self::$classIndex);
        // Only use autoloading if spl_autoload_register() is available and no __autoload() is defined (because 
        // __autoload() breaks if spl_autoload_register() is used. 
        if (function_exists("spl_autoload_register") && !is_callable("__autoload"))
            {
            spl_autoload_register(array(__CLASS__, "autoload"));
            }
        // Otherwise include all class files
        else
            {
            foreach (self::$classIndex as $class => $file)
                {
                if (!class_exists($class))
                    {
                    require_once($file);
                    }
                }
            }
        }
    /**
     * Minifies CSS source.
     * 
     * @param string $source CSS source
     * @param array $filters Filter configuration [optional]
     * @param array $plugins Plugin configuration [optional]
     * @return string Minified CSS
     */
    public static function minify($source, array $filters = null, array $plugins = null)
        {
        self::$errors = array();
        $minifier = new CssMinifier($source, $filters, $plugins);
        return $minifier->getMinified();
        }
    /**
     * Parse the CSS source.
     * 
     * @param string $source CSS source
     * @param array $plugins Plugin configuration [optional]
     * @return array Array of aCssToken
     */
    public static function parse($source, array $plugins = null)
        {
        self::$errors = array();
        $parser = new CssParser($source, $plugins);
        return $parser->getTokens();
        }
    /**
     * --
     * 
     * @param boolean $to
     * @return boolean
     */
    public static function setVerbose($to)
        {
        self::$isVerbose = (boolean) $to;
        return self::$isVerbose;
        }
    /**
     * --
     * 
     * @param CssError $error
     * @return void
     */
    public static function triggerError(CssError $error)
        {
        self::$errors[] = $error;
        if (self::$isVerbose)
            {
            trigger_error((string) $error, E_USER_WARNING);
            }
        }
    }
// Initialises CssMin
CssMin::initialise();

/**
 * This {@link aCssMinifierFilter minifier filter} import external css files defined with the @import at-rule into the 
 * current stylesheet. 
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssImportImportsMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Array with already imported external stylesheets.
     * 
     * @var array
     */
    private $imported = array();
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        if (!isset($this->configuration["BasePath"]) || !is_dir($this->configuration["BasePath"]))
            {
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Base path <code>" . ($this->configuration["BasePath"] ? $this->configuration["BasePath"] : "null"). "</code> is not a directory"));
            return 0;
            }
        for ($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            if (get_class($tokens[$i]) === "CssAtImportToken")
                {
                $import = $this->configuration["BasePath"] . "/" . $tokens[$i]->Import;
                // Import file was not found/is not a file
                if (!is_file($import))
                    {
                    CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Import file <code>" . $import. "</code> was not found.", (string) $tokens[$i]));
                    }
                // Import file already imported; remove this @import at-rule to prevent recursions
                elseif (in_array($import, $this->imported))
                    {
                    CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Import file <code>" . $import. "</code> was already imported.", (string) $tokens[$i]));
                    $tokens[$i] = null;
                    }
                else
                    {
                    $this->imported[] = $import;
                    $parser = new CssParser(file_get_contents($import));
                    $import = $parser->getTokens();
                    // The @import at-rule has media types defined requiring special handling
                    if (count($tokens[$i]->MediaTypes) > 0 && !(count($tokens[$i]->MediaTypes) == 1 && $tokens[$i]->MediaTypes[0] == "all"))
                        {
                        $blocks = array();
                        /*
                         * Filter or set media types of @import at-rule or remove the @import at-rule if no media type is matching the parent @import at-rule
                         */
                        for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
                            {
                            if (get_class($import[$ii]) === "CssAtImportToken")
                                {
                                // @import at-rule defines no media type or only the "all" media type; set the media types to the one defined in the parent @import at-rule
                                if (count($import[$ii]->MediaTypes) == 0 || (count($import[$ii]->MediaTypes) == 1 && $import[$ii]->MediaTypes[0] == "all"))
                                    {
                                    $import[$ii]->MediaTypes = $tokens[$i]->MediaTypes;
                                    }
                                // @import at-rule defineds one or more media types; filter out media types not matching with the  parent @import at-rule
                                elseif (count($import[$ii]->MediaTypes > 0))
                                    {
                                    foreach ($import[$ii]->MediaTypes as $index => $mediaType)
                                        {
                                        if (!in_array($mediaType, $tokens[$i]->MediaTypes))
                                            {
                                            unset($import[$ii]->MediaTypes[$index]);
                                            }
                                        }
                                    $import[$ii]->MediaTypes = array_values($import[$ii]->MediaTypes);
                                    // If there are no media types left in the @import at-rule remove the @import at-rule
                                    if (count($import[$ii]->MediaTypes) == 0)
                                        {
                                        $import[$ii] = null;
                                        }
                                    }
                                }
                            }
                        /*
                         * Remove media types of @media at-rule block not defined in the @import at-rule
                         */
                        for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
                            {
                            if (get_class($import[$ii]) === "CssAtMediaStartToken")
                                {
                                foreach ($import[$ii]->MediaTypes as $index => $mediaType)
                                    {
                                    if (!in_array($mediaType, $tokens[$i]->MediaTypes))
                                        {
                                        unset($import[$ii]->MediaTypes[$index]);
                                        }
                                    $import[$ii]->MediaTypes = array_values($import[$ii]->MediaTypes);
                                    }
                                }
                            }
                        /*
                         * If no media types left of the @media at-rule block remove the complete block
                         */
                        for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
                            {
                            if (get_class($import[$ii]) === "CssAtMediaStartToken")
                                {
                                if (count($import[$ii]->MediaTypes) === 0)
                                    {
                                    for ($iii = $ii; $iii < $ll; $iii++)
                                        {
                                        if (get_class($import[$iii]) === "CssAtMediaEndToken")
                                            {
                                            break;
                                            }
                                        }
                                    if (get_class($import[$iii]) === "CssAtMediaEndToken")
                                        {
                                        array_splice($import, $ii, $iii - $ii + 1, array());
                                        $ll = count($import);
                                        }
                                    }
                                }
                            }
                        /*
                         * If the media types of the @media at-rule equals the media types defined in the @import 
                         * at-rule remove the CssAtMediaStartToken and CssAtMediaEndToken token
                         */ 
                        for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
                            {
                            if (get_class($import[$ii]) === "CssAtMediaStartToken" && count(array_diff($tokens[$i]->MediaTypes, $import[$ii]->MediaTypes)) === 0)
                                {
                                for ($iii = $ii; $iii < $ll; $iii++)
                                    {
                                    if (get_class($import[$iii]) == "CssAtMediaEndToken")
                                        {
                                        break;
                                        }
                                    }
                                if (get_class($import[$iii]) == "CssAtMediaEndToken")
                                    {
                                    unset($import[$ii]);
                                    unset($import[$iii]);
                                    $import = array_values($import);
                                    $ll = count($import);
                                    }
                                }
                            }
                        /**
                         * Extract CssAtImportToken and CssAtCharsetToken tokens
                         */
                        for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
                            {
                            $class = get_class($import[$ii]);
                            if ($class === "CssAtImportToken" || $class === "CssAtCharsetToken")
                                {
                                $blocks = array_merge($blocks, array_splice($import, $ii, 1, array()));
                                $ll = count($import);
                                }
                            }
                        /*
                         * Extract the @font-face, @media and @page at-rule block
                         */
                        for($ii = 0, $ll = count($import); $ii < $ll; $ii++)
                            {
                            $class = get_class($import[$ii]);
                            if ($class === "CssAtFontFaceStartToken" || $class === "CssAtMediaStartToken" || $class === "CssAtPageStartToken" || $class === "CssAtVariablesStartToken")
                                {
                                for ($iii = $ii; $iii < $ll; $iii++)
                                    {
                                    $class = get_class($import[$iii]);
                                    if ($class === "CssAtFontFaceEndToken" || $class === "CssAtMediaEndToken" || $class === "CssAtPageEndToken" || $class === "CssAtVariablesEndToken")
                                        {
                                        break;
                                        }
                                    }
                                $class = get_class($import[$iii]);
                                if (isset($import[$iii]) && ($class === "CssAtFontFaceEndToken" || $class === "CssAtMediaEndToken" || $class === "CssAtPageEndToken" || $class === "CssAtVariablesEndToken"))
                                    {
                                    $blocks = array_merge($blocks, array_splice($import, $ii, $iii - $ii + 1, array()));
                                    $ll = count($import);
                                    }
                                }
                            }
                        // Create the import array with extracted tokens and the rulesets wrapped into a @media at-rule block
                        $import = array_merge($blocks, array(new CssAtMediaStartToken($tokens[$i]->MediaTypes)), $import, array(new CssAtMediaEndToken()));
                        }
                    // Insert the imported tokens
                    array_splice($tokens, $i, 1, $import);
                    // Modify parameters of the for-loop
                    $i--;
                    $l = count($tokens);
                    }
                }
            }
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for preserve parsing expression() declaration values.
 * 
 * This plugin return no {@link aCssToken CssToken} but ensures that expression() declaration values will get parsed 
 * properly.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssExpressionParserPlugin extends aCssParserPlugin
    {
    /**
     * Count of left braces.
     * 
     * @var integer
     */
    private $leftBraces = 0;
    /**
     * Count of right braces.
     * 
     * @var integer
     */
    private $rightBraces = 0;
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("(", ")", ";", "}");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return false;
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        // Start of expression
        if ($char === "(" && strtolower(substr($this->parser->getSource(), $index - 10, 11)) === "expression(" && $state !== "T_EXPRESSION")
            {
            $this->parser->pushState("T_EXPRESSION");
            $this->leftBraces++;
            }
        // Count left braces
        elseif ($char === "(" && $state === "T_EXPRESSION")
            {
            $this->leftBraces++;
            }
        // Count right braces
        elseif ($char === ")" && $state === "T_EXPRESSION")
            {
            $this->rightBraces++;
            }
        // Possible end of expression; if left and right braces are equal the expressen ends
        elseif (($char === ";" || $char === "}") && $state === "T_EXPRESSION" && $this->leftBraces === $this->rightBraces)
            {
            $this->leftBraces = $this->rightBraces = 0;
            $this->parser->popState();
            return $index - 1;
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * CSS Error.
 * 
 * @package     CssMin
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssError
    {
    /**
     * File.
     * 
     * @var string
     */
    public $File = "";
    /**
     * Line.
     * 
     * @var integer
     */
    public $Line = 0;
    /**
     * Error message.
     * 
     * @var string
     */
    public $Message = "";
    /**
     * Source.
     * 
     * @var string
     */
    public $Source = "";
    /**
     * Constructor triggering the error.
     * 
     * @param string $message Error message
     * @param string $source Corresponding line [optional]
     * @return void
     */
    public function __construct($file, $line, $message, $source = "")
        {
        $this->File     = $file;
        $this->Line     = $line;
        $this->Message  = $message;
        $this->Source   = $source;
        }
    /**
     * Returns the error as formatted string.
     * 
     * @return string
     */ 
    public function __toString()
        {
        return $this->Message . ($this->Source ? ": <br /><code>" . $this->Source . "</code>": "") . "<br />in file " . $this->File . " at line " . $this->Line;
        }
    }

/**
 * This {@link aCssMinifierPlugin} will convert a color value in rgb notation to hexadecimal notation.
 * 
 * Example:
 * <code>
 * color: rgb(200,60%,5);
 * </code>
 * 
 * Will get converted to:
 * <code>
 * color:#c89905;
 * </code>
 *
 * @package     CssMin/Minifier/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssConvertRgbColorsMinifierPlugin extends aCssMinifierPlugin
    {
    /**
     * Regular expression matching the value.
     * 
     * @var string
     */
    private $reMatch = "/rgb\s*\(\s*([0-9%]+)\s*,\s*([0-9%]+)\s*,\s*([0-9%]+)\s*\)/iS";
    /**
     * Implements {@link aCssMinifierPlugin::minify()}.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    public function apply(aCssToken &$token)
        {
        if (stripos($token->Value, "rgb") !== false && preg_match($this->reMatch, $token->Value, $m))
            {
            for ($i = 1, $l = count($m); $i < $l; $i++)
                {
                if (strpos("%", $m[$i]) !== false)
                    {
                    $m[$i] = substr($m[$i], 0, -1);
                    $m[$i] = (int) (256 * ($m[$i] / 100));
                    }
                $m[$i] = str_pad(dechex($m[$i]),  2, "0", STR_PAD_LEFT);
                }
            $token->Value = str_replace($m[0], "#" . $m[1] . $m[2] . $m[3], $token->Value);
            }
        return false;
        }
    /**
     * Implements {@link aMinifierPlugin::getTriggerTokens()}
     * 
     * @return array
     */
    public function getTriggerTokens()
        {
        return array
            (
            "CssAtFontFaceDeclarationToken",
            "CssAtPageDeclarationToken",
            "CssRulesetDeclarationToken"
            );
        }
    }

/**
 * This {@link aCssMinifierPlugin} will convert named color values to hexadecimal notation.
 * 
 * Example:
 * <code>
 * color: black;
 * border: 1px solid indigo;
 * </code>
 * 
 * Will get converted to:
 * <code>
 * color:#000;
 * border:1px solid #4b0082;
 * </code>
 * 
 * @package     CssMin/Minifier/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssConvertNamedColorsMinifierPlugin extends aCssMinifierPlugin
    {
    
    /**
     * Regular expression matching the value.
     * 
     * @var string
     */
    private $reMatch = null;
    /**
     * Regular expression replacing the value.
     * 
     * @var string
     */
    private $reReplace = "\"\${1}\" . \$this->transformation[strtolower(\"\${2}\")] . \"\${3}\"";
    /**
     * Transformation table used by the {@link CssConvertNamedColorsMinifierPlugin::$reReplace replace regular expression}.
     * 
     * @var array
     */
    private $transformation = array
        ( 
        "aliceblue"                     => "#f0f8ff",
        "antiquewhite"                  => "#faebd7",
        "aqua"                          => "#0ff",
        "aquamarine"                    => "#7fffd4",
        "azure"                         => "#f0ffff",
        "beige"                         => "#f5f5dc",
        "black"                         => "#000",
        "blue"                          => "#00f",
        "blueviolet"                    => "#8a2be2",
        "brown"                         => "#a52a2a",
        "burlywood"                     => "#deb887",
        "cadetblue"                     => "#5f9ea0",
        "chartreuse"                    => "#7fff00",
        "chocolate"                     => "#d2691e",
        "coral"                         => "#ff7f50",
        "cornflowerblue"                => "#6495ed",
        "cornsilk"                      => "#fff8dc",
        "crimson"                       => "#dc143c",
        "darkblue"                      => "#00008b",
        "darkcyan"                      => "#008b8b",
        "darkgoldenrod"                 => "#b8860b",
        "darkgray"                      => "#a9a9a9",
        "darkgreen"                     => "#006400",
        "darkkhaki"                     => "#bdb76b",
        "darkmagenta"                   => "#8b008b",
        "darkolivegreen"                => "#556b2f",
        "darkorange"                    => "#ff8c00",
        "darkorchid"                    => "#9932cc",
        "darkred"                       => "#8b0000",
        "darksalmon"                    => "#e9967a",
        "darkseagreen"                  => "#8fbc8f",
        "darkslateblue"                 => "#483d8b",
        "darkslategray"                 => "#2f4f4f",
        "darkturquoise"                 => "#00ced1",
        "darkviolet"                    => "#9400d3",
        "deeppink"                      => "#ff1493",
        "deepskyblue"                   => "#00bfff",
        "dimgray"                       => "#696969",
        "dodgerblue"                    => "#1e90ff",
        "firebrick"                     => "#b22222",
        "floralwhite"                   => "#fffaf0",
        "forestgreen"                   => "#228b22",
        "fuchsia"                       => "#f0f",
        "gainsboro"                     => "#dcdcdc",
        "ghostwhite"                    => "#f8f8ff",
        "gold"                          => "#ffd700",
        "goldenrod"                     => "#daa520",
        "gray"                          => "#808080",
        "green"                         => "#008000",
        "greenyellow"                   => "#adff2f",
        "honeydew"                      => "#f0fff0",
        "hotpink"                       => "#ff69b4",
        "indianred"                     => "#cd5c5c",
        "indigo"                        => "#4b0082",
        "ivory"                         => "#fffff0",
        "khaki"                         => "#f0e68c",
        "lavender"                      => "#e6e6fa",
        "lavenderblush"                 => "#fff0f5",
        "lawngreen"                     => "#7cfc00",
        "lemonchiffon"                  => "#fffacd",
        "lightblue"                     => "#add8e6",
        "lightcoral"                    => "#f08080",
        "lightcyan"                     => "#e0ffff",
        "lightgoldenrodyellow"          => "#fafad2",
        "lightgreen"                    => "#90ee90",
        "lightgrey"                     => "#d3d3d3",
        "lightpink"                     => "#ffb6c1",
        "lightsalmon"                   => "#ffa07a",
        "lightseagreen"                 => "#20b2aa",
        "lightskyblue"                  => "#87cefa",
        "lightslategray"                => "#789",
        "lightsteelblue"                => "#b0c4de",
        "lightyellow"                   => "#ffffe0",
        "lime"                          => "#0f0",
        "limegreen"                     => "#32cd32",
        "linen"                         => "#faf0e6",
        "maroon"                        => "#800000",
        "mediumaquamarine"              => "#66cdaa",
        "mediumblue"                    => "#0000cd",
        "mediumorchid"                  => "#ba55d3",
        "mediumpurple"                  => "#9370db",
        "mediumseagreen"                => "#3cb371",
        "mediumslateblue"               => "#7b68ee",
        "mediumspringgreen"             => "#00fa9a",
        "mediumturquoise"               => "#48d1cc",
        "mediumvioletred"               => "#c71585",
        "midnightblue"                  => "#191970",
        "mintcream"                     => "#f5fffa",
        "mistyrose"                     => "#ffe4e1",
        "moccasin"                      => "#ffe4b5",
        "navajowhite"                   => "#ffdead",
        "navy"                          => "#000080",
        "oldlace"                       => "#fdf5e6",
        "olive"                         => "#808000",
        "olivedrab"                     => "#6b8e23",
        "orange"                        => "#ffa500",
        "orangered"                     => "#ff4500",
        "orchid"                        => "#da70d6",
        "palegoldenrod"                 => "#eee8aa",
        "palegreen"                     => "#98fb98",
        "paleturquoise"                 => "#afeeee",
        "palevioletred"                 => "#db7093",
        "papayawhip"                    => "#ffefd5",
        "peachpuff"                     => "#ffdab9",
        "peru"                          => "#cd853f",
        "pink"                          => "#ffc0cb",
        "plum"                          => "#dda0dd",
        "powderblue"                    => "#b0e0e6",
        "purple"                        => "#800080",
        "red"                           => "#f00",
        "rosybrown"                     => "#bc8f8f",
        "royalblue"                     => "#4169e1",
        "saddlebrown"                   => "#8b4513",
        "salmon"                        => "#fa8072",
        "sandybrown"                    => "#f4a460",
        "seagreen"                      => "#2e8b57",
        "seashell"                      => "#fff5ee",
        "sienna"                        => "#a0522d",
        "silver"                        => "#c0c0c0",
        "skyblue"                       => "#87ceeb",
        "slateblue"                     => "#6a5acd",
        "slategray"                     => "#708090",
        "snow"                          => "#fffafa",
        "springgreen"                   => "#00ff7f",
        "steelblue"                     => "#4682b4",
        "tan"                           => "#d2b48c",
        "teal"                          => "#008080",
        "thistle"                       => "#d8bfd8",
        "tomato"                        => "#ff6347",
        "turquoise"                     => "#40e0d0",
        "violet"                        => "#ee82ee",
        "wheat"                         => "#f5deb3",
        "white"                         => "#fff",
        "whitesmoke"                    => "#f5f5f5",
        "yellow"                        => "#ff0",
        "yellowgreen"                   => "#9acd32"
        );
    /**
     * Overwrites {@link aCssMinifierPlugin::__construct()}.
     * 
     * The constructor will create the {@link CssConvertNamedColorsMinifierPlugin::$reReplace replace regular expression}
     * based on the {@link CssConvertNamedColorsMinifierPlugin::$transformation transformation table}.
     * 
     * @param CssMinifier $minifier The CssMinifier object of this plugin.
     * @param array $configuration Plugin configuration [optional]
     * @return void
     */
    public function __construct(CssMinifier $minifier, array $configuration = array())
        {
        $this->reMatch = "/(^|\s)+(" . implode("|", array_keys($this->transformation)) . ")(\s|$)+/eiS";
        parent::__construct($minifier, $configuration);
        }
    /**
     * Implements {@link aCssMinifierPlugin::minify()}.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    public function apply(aCssToken &$token)
        {
        $lcValue = strtolower($token->Value);
        // Declaration value equals a value in the transformation table => simple replace
        if (isset($this->transformation[$lcValue]))
            {
            $token->Value = $this->transformation[$lcValue];
            }
        // Declaration value contains a value in the transformation table => regular expression replace
        elseif (preg_match($this->reMatch, $token->Value))
            {
            $token->Value = preg_replace($this->reMatch, $this->reReplace, $token->Value);
            }
        return false;
        }
    /**
     * Implements {@link aMinifierPlugin::getTriggerTokens()}
     * 
     * @return array
     */
    public function getTriggerTokens()
        {
        return array
            (
            "CssAtFontFaceDeclarationToken",
            "CssAtPageDeclarationToken",
            "CssRulesetDeclarationToken"
            );
        }
    }

/**
 * This {@link aCssMinifierFilter minifier filter} triggers on CSS Level 3 properties and will add declaration tokens
 * with browser-specific properties.
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssConvertLevel3PropertiesMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Css property transformations table. Used to convert CSS3 and proprietary properties to the browser-specific 
     * counterparts.
     * 
     * @var array
     */
    private $transformations = array
        (
        // Property                     Array(Mozilla, Webkit, Opera, Internet Explorer); NULL values are placeholders and will get ignored
        "animation"                     => array(null, "-webkit-animation", null, null),
        "animation-delay"               => array(null, "-webkit-animation-delay", null, null),
        "animation-direction"           => array(null, "-webkit-animation-direction", null, null),
        "animation-duration"            => array(null, "-webkit-animation-duration", null, null),
        "animation-fill-mode"           => array(null, "-webkit-animation-fill-mode", null, null),
        "animation-iteration-count"     => array(null, "-webkit-animation-iteration-count", null, null),
        "animation-name"                => array(null, "-webkit-animation-name", null, null),
        "animation-play-state"          => array(null, "-webkit-animation-play-state", null, null),
        "animation-timing-function"     => array(null, "-webkit-animation-timing-function", null, null),
        "appearance"                    => array("-moz-appearance", "-webkit-appearance", null, null),
        "backface-visibility"           => array(null, "-webkit-backface-visibility", null, null),
        "background-clip"               => array(null, "-webkit-background-clip", null, null),
        "background-composite"          => array(null, "-webkit-background-composite", null, null),
        "background-inline-policy"      => array("-moz-background-inline-policy", null, null, null),
        "background-origin"             => array(null, "-webkit-background-origin", null, null),
        "background-position-x"         => array(null, null, null, "-ms-background-position-x"),
        "background-position-y"         => array(null, null, null, "-ms-background-position-y"),
        "background-size"               => array(null, "-webkit-background-size", null, null),
        "behavior"                      => array(null, null, null, "-ms-behavior"),
        "binding"                       => array("-moz-binding", null, null, null),
        "border-after"                  => array(null, "-webkit-border-after", null, null),
        "border-after-color"            => array(null, "-webkit-border-after-color", null, null),
        "border-after-style"            => array(null, "-webkit-border-after-style", null, null),
        "border-after-width"            => array(null, "-webkit-border-after-width", null, null),
        "border-before"                 => array(null, "-webkit-border-before", null, null),
        "border-before-color"           => array(null, "-webkit-border-before-color", null, null),
        "border-before-style"           => array(null, "-webkit-border-before-style", null, null),
        "border-before-width"           => array(null, "-webkit-border-before-width", null, null),
        "border-border-bottom-colors"   => array("-moz-border-bottom-colors", null, null, null),
        "border-bottom-left-radius"     => array("-moz-border-radius-bottomleft", "-webkit-border-bottom-left-radius", null, null),
        "border-bottom-right-radius"    => array("-moz-border-radius-bottomright", "-webkit-border-bottom-right-radius", null, null),
        "border-end"                    => array("-moz-border-end", "-webkit-border-end", null, null),
        "border-end-color"              => array("-moz-border-end-color", "-webkit-border-end-color", null, null),
        "border-end-style"              => array("-moz-border-end-style", "-webkit-border-end-style", null, null),
        "border-end-width"              => array("-moz-border-end-width", "-webkit-border-end-width", null, null),
        "border-fit"                    => array(null, "-webkit-border-fit", null, null),
        "border-horizontal-spacing"     => array(null, "-webkit-border-horizontal-spacing", null, null),
        "border-image"                  => array("-moz-border-image", "-webkit-border-image", null, null),
        "border-left-colors"            => array("-moz-border-left-colors", null, null, null),
        "border-radius"                 => array("-moz-border-radius", "-webkit-border-radius", null, null),
        "border-border-right-colors"    => array("-moz-border-right-colors", null, null, null),
        "border-start"                  => array("-moz-border-start", "-webkit-border-start", null, null),
        "border-start-color"            => array("-moz-border-start-color", "-webkit-border-start-color", null, null),
        "border-start-style"            => array("-moz-border-start-style", "-webkit-border-start-style", null, null),
        "border-start-width"            => array("-moz-border-start-width", "-webkit-border-start-width", null, null),
        "border-top-colors"             => array("-moz-border-top-colors", null, null, null),
        "border-top-left-radius"        => array("-moz-border-radius-topleft", "-webkit-border-top-left-radius", null, null),
        "border-top-right-radius"       => array("-moz-border-radius-topright", "-webkit-border-top-right-radius", null, null),
        "border-vertical-spacing"       => array(null, "-webkit-border-vertical-spacing", null, null),
        "box-align"                     => array("-moz-box-align", "-webkit-box-align", null, null),
        "box-direction"                 => array("-moz-box-direction", "-webkit-box-direction", null, null),
        "box-flex"                      => array("-moz-box-flex", "-webkit-box-flex", null, null),
        "box-flex-group"                => array(null, "-webkit-box-flex-group", null, null),
        "box-flex-lines"                => array(null, "-webkit-box-flex-lines", null, null),
        "box-ordinal-group"             => array("-moz-box-ordinal-group", "-webkit-box-ordinal-group", null, null),
        "box-orient"                    => array("-moz-box-orient", "-webkit-box-orient", null, null),
        "box-pack"                      => array("-moz-box-pack", "-webkit-box-pack", null, null),
        "box-reflect"                   => array(null, "-webkit-box-reflect", null, null),
        "box-shadow"                    => array("-moz-box-shadow", "-webkit-box-shadow", null, null),
        "box-sizing"                    => array("-moz-box-sizing", null, null, null),
        "color-correction"              => array(null, "-webkit-color-correction", null, null),
        "column-break-after"            => array(null, "-webkit-column-break-after", null, null),
        "column-break-before"           => array(null, "-webkit-column-break-before", null, null),
        "column-break-inside"           => array(null, "-webkit-column-break-inside", null, null),
        "column-count"                  => array("-moz-column-count", "-webkit-column-count", null, null),
        "column-gap"                    => array("-moz-column-gap", "-webkit-column-gap", null, null),
        "column-rule"                   => array("-moz-column-rule", "-webkit-column-rule", null, null),
        "column-rule-color"             => array("-moz-column-rule-color", "-webkit-column-rule-color", null, null),
        "column-rule-style"             => array("-moz-column-rule-style", "-webkit-column-rule-style", null, null),
        "column-rule-width"             => array("-moz-column-rule-width", "-webkit-column-rule-width", null, null),
        "column-span"                   => array(null, "-webkit-column-span", null, null),
        "column-width"                  => array("-moz-column-width", "-webkit-column-width", null, null),
        "columns"                       => array(null, "-webkit-columns", null, null),
        "filter"                        => array(__CLASS__, "filter"),
        "float-edge"                    => array("-moz-float-edge", null, null, null),
        "font-feature-settings"         => array("-moz-font-feature-settings", null, null, null),
        "font-language-override"        => array("-moz-font-language-override", null, null, null),
        "font-size-delta"               => array(null, "-webkit-font-size-delta", null, null),
        "font-smoothing"                => array(null, "-webkit-font-smoothing", null, null),
        "force-broken-image-icon"       => array("-moz-force-broken-image-icon", null, null, null),
        "highlight"                     => array(null, "-webkit-highlight", null, null),
        "hyphenate-character"           => array(null, "-webkit-hyphenate-character", null, null),
        "hyphenate-locale"              => array(null, "-webkit-hyphenate-locale", null, null),
        "hyphens"                       => array(null, "-webkit-hyphens", null, null),
        "force-broken-image-icon"       => array("-moz-image-region", null, null, null),
        "ime-mode"                      => array(null, null, null, "-ms-ime-mode"),
        "interpolation-mode"            => array(null, null, null, "-ms-interpolation-mode"),
        "layout-flow"                   => array(null, null, null, "-ms-layout-flow"),
        "layout-grid"                   => array(null, null, null, "-ms-layout-grid"),
        "layout-grid-char"              => array(null, null, null, "-ms-layout-grid-char"),
        "layout-grid-line"              => array(null, null, null, "-ms-layout-grid-line"),
        "layout-grid-mode"              => array(null, null, null, "-ms-layout-grid-mode"),
        "layout-grid-type"              => array(null, null, null, "-ms-layout-grid-type"),
        "line-break"                    => array(null, "-webkit-line-break", null, "-ms-line-break"),
        "line-clamp"                    => array(null, "-webkit-line-clamp", null, null),
        "line-grid-mode"                => array(null, null, null, "-ms-line-grid-mode"),
        "logical-height"                => array(null, "-webkit-logical-height", null, null),
        "logical-width"                 => array(null, "-webkit-logical-width", null, null),
        "margin-after"                  => array(null, "-webkit-margin-after", null, null),
        "margin-after-collapse"         => array(null, "-webkit-margin-after-collapse", null, null),
        "margin-before"                 => array(null, "-webkit-margin-before", null, null),
        "margin-before-collapse"        => array(null, "-webkit-margin-before-collapse", null, null),
        "margin-bottom-collapse"        => array(null, "-webkit-margin-bottom-collapse", null, null),
        "margin-collapse"               => array(null, "-webkit-margin-collapse", null, null),
        "margin-end"                    => array("-moz-margin-end", "-webkit-margin-end", null, null),
        "margin-start"                  => array("-moz-margin-start", "-webkit-margin-start", null, null),
        "margin-top-collapse"           => array(null, "-webkit-margin-top-collapse", null, null),
        "marquee "                      => array(null, "-webkit-marquee", null, null),
        "marquee-direction"             => array(null, "-webkit-marquee-direction", null, null),
        "marquee-increment"             => array(null, "-webkit-marquee-increment", null, null),
        "marquee-repetition"            => array(null, "-webkit-marquee-repetition", null, null),
        "marquee-speed"                 => array(null, "-webkit-marquee-speed", null, null),
        "marquee-style"                 => array(null, "-webkit-marquee-style", null, null),
        "mask"                          => array(null, "-webkit-mask", null, null),
        "mask-attachment"               => array(null, "-webkit-mask-attachment", null, null),
        "mask-box-image"                => array(null, "-webkit-mask-box-image", null, null),
        "mask-clip"                     => array(null, "-webkit-mask-clip", null, null),
        "mask-composite"                => array(null, "-webkit-mask-composite", null, null),
        "mask-image"                    => array(null, "-webkit-mask-image", null, null),
        "mask-origin"                   => array(null, "-webkit-mask-origin", null, null),
        "mask-position"                 => array(null, "-webkit-mask-position", null, null),
        "mask-position-x"               => array(null, "-webkit-mask-position-x", null, null),
        "mask-position-y"               => array(null, "-webkit-mask-position-y", null, null),
        "mask-repeat"                   => array(null, "-webkit-mask-repeat", null, null),
        "mask-repeat-x"                 => array(null, "-webkit-mask-repeat-x", null, null),
        "mask-repeat-y"                 => array(null, "-webkit-mask-repeat-y", null, null),
        "mask-size"                     => array(null, "-webkit-mask-size", null, null),
        "match-nearest-mail-blockquote-color" => array(null, "-webkit-match-nearest-mail-blockquote-color", null, null),
        "max-logical-height"            => array(null, "-webkit-max-logical-height", null, null),
        "max-logical-width"             => array(null, "-webkit-max-logical-width", null, null),
        "min-logical-height"            => array(null, "-webkit-min-logical-height", null, null),
        "min-logical-width"             => array(null, "-webkit-min-logical-width", null, null),
        "object-fit"                    => array(null, null, "-o-object-fit", null),
        "object-position"               => array(null, null, "-o-object-position", null),
        "opacity"                       => array(__CLASS__, "opacity"),
        "outline-radius"                => array("-moz-outline-radius", null, null, null),
        "outline-bottom-left-radius"    => array("-moz-outline-radius-bottomleft", null, null, null),
        "outline-bottom-right-radius"   => array("-moz-outline-radius-bottomright", null, null, null),
        "outline-top-left-radius"       => array("-moz-outline-radius-topleft", null, null, null),
        "outline-top-right-radius"      => array("-moz-outline-radius-topright", null, null, null),
        "padding-after"                 => array(null, "-webkit-padding-after", null, null),
        "padding-before"                => array(null, "-webkit-padding-before", null, null),
        "padding-end"                   => array("-moz-padding-end", "-webkit-padding-end", null, null),
        "padding-start"                 => array("-moz-padding-start", "-webkit-padding-start", null, null),
        "perspective"                   => array(null, "-webkit-perspective", null, null),
        "perspective-origin"            => array(null, "-webkit-perspective-origin", null, null),
        "perspective-origin-x"          => array(null, "-webkit-perspective-origin-x", null, null),
        "perspective-origin-y"          => array(null, "-webkit-perspective-origin-y", null, null),
        "rtl-ordering"                  => array(null, "-webkit-rtl-ordering", null, null),
        "scrollbar-3dlight-color"       => array(null, null, null, "-ms-scrollbar-3dlight-color"),
        "scrollbar-arrow-color"         => array(null, null, null, "-ms-scrollbar-arrow-color"),
        "scrollbar-base-color"          => array(null, null, null, "-ms-scrollbar-base-color"),
        "scrollbar-darkshadow-color"    => array(null, null, null, "-ms-scrollbar-darkshadow-color"),
        "scrollbar-face-color"          => array(null, null, null, "-ms-scrollbar-face-color"),
        "scrollbar-highlight-color"     => array(null, null, null, "-ms-scrollbar-highlight-color"),
        "scrollbar-shadow-color"        => array(null, null, null, "-ms-scrollbar-shadow-color"),
        "scrollbar-track-color"         => array(null, null, null, "-ms-scrollbar-track-color"),
        "stack-sizing"                  => array("-moz-stack-sizing", null, null, null),
        "svg-shadow"                    => array(null, "-webkit-svg-shadow", null, null),
        "tab-size"                      => array("-moz-tab-size", null, "-o-tab-size", null),
        "table-baseline"                => array(null, null, "-o-table-baseline", null),
        "text-align-last"               => array(null, null, null, "-ms-text-align-last"),
        "text-autospace"                => array(null, null, null, "-ms-text-autospace"),
        "text-combine"                  => array(null, "-webkit-text-combine", null, null),
        "text-decorations-in-effect"    => array(null, "-webkit-text-decorations-in-effect", null, null),
        "text-emphasis"                 => array(null, "-webkit-text-emphasis", null, null),
        "text-emphasis-color"           => array(null, "-webkit-text-emphasis-color", null, null),
        "text-emphasis-position"        => array(null, "-webkit-text-emphasis-position", null, null),
        "text-emphasis-style"           => array(null, "-webkit-text-emphasis-style", null, null),
        "text-fill-color"               => array(null, "-webkit-text-fill-color", null, null),
        "text-justify"                  => array(null, null, null, "-ms-text-justify"),
        "text-kashida-space"            => array(null, null, null, "-ms-text-kashida-space"),
        "text-overflow"                 => array(null, null, "-o-text-overflow", "-ms-text-overflow"),
        "text-security"                 => array(null, "-webkit-text-security", null, null),
        "text-size-adjust"              => array(null, "-webkit-text-size-adjust", null, "-ms-text-size-adjust"),
        "text-stroke"                   => array(null, "-webkit-text-stroke", null, null),
        "text-stroke-color"             => array(null, "-webkit-text-stroke-color", null, null),
        "text-stroke-width"             => array(null, "-webkit-text-stroke-width", null, null),
        "text-underline-position"       => array(null, null, null, "-ms-text-underline-position"),
        "transform"                     => array("-moz-transform", "-webkit-transform", "-o-transform", null),
        "transform-origin"              => array("-moz-transform-origin", "-webkit-transform-origin", "-o-transform-origin", null),
        "transform-origin-x"            => array(null, "-webkit-transform-origin-x", null, null),
        "transform-origin-y"            => array(null, "-webkit-transform-origin-y", null, null),
        "transform-origin-z"            => array(null, "-webkit-transform-origin-z", null, null),
        "transform-style"               => array(null, "-webkit-transform-style", null, null),
        "transition"                    => array("-moz-transition", "-webkit-transition", "-o-transition", null),
        "transition-delay"              => array("-moz-transition-delay", "-webkit-transition-delay", "-o-transition-delay", null),
        "transition-duration"           => array("-moz-transition-duration", "-webkit-transition-duration", "-o-transition-duration", null),
        "transition-property"           => array("-moz-transition-property", "-webkit-transition-property", "-o-transition-property", null),
        "transition-timing-function"    => array("-moz-transition-timing-function", "-webkit-transition-timing-function", "-o-transition-timing-function", null),
        "user-drag"                     => array(null, "-webkit-user-drag", null, null),
        "user-focus"                    => array("-moz-user-focus", null, null, null),
        "user-input"                    => array("-moz-user-input", null, null, null),
        "user-modify"                   => array("-moz-user-modify", "-webkit-user-modify", null, null),
        "user-select"                   => array("-moz-user-select", "-webkit-user-select", null, null),
        "white-space"                   => array(__CLASS__, "whiteSpace"),
        "window-shadow"                 => array("-moz-window-shadow", null, null, null),
        "word-break"                    => array(null, null, null, "-ms-word-break"),
        "word-wrap"                     => array(null, null, null, "-ms-word-wrap"),
        "writing-mode"                  => array(null, "-webkit-writing-mode", null, "-ms-writing-mode"),
        "zoom"                          => array(null, null, null, "-ms-zoom")
        );
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value large than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        $r = 0;
        $transformations = &$this->transformations;
        for ($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            if (get_class($tokens[$i]) === "CssRulesetDeclarationToken")
                {
                $tProperty = $tokens[$i]->Property;
                if (isset($transformations[$tProperty]))
                    {
                    $result = array();
                    if (is_callable($transformations[$tProperty]))
                        {
                        $result = call_user_func_array($transformations[$tProperty], array($tokens[$i]));
                        if (!is_array($result) && is_object($result))
                            {
                            $result = array($result);
                            }
                        }
                    else
                        {
                        $tValue         = $tokens[$i]->Value;
                        $tMediaTypes    = $tokens[$i]->MediaTypes;
                        foreach ($transformations[$tProperty] as $property)
                            {
                            if ($property !== null)
                                {
                                $result[] = new CssRulesetDeclarationToken($property, $tValue, $tMediaTypes);
                                }
                            }
                        }
                    if (count($result) > 0)
                        {
                        array_splice($tokens, $i + 1, 0, $result);
                        $i += count($result);
                        $l += count($result);
                        }
                    }
                }
            }
        return $r;
        }
    /**
     * Transforms the Internet Explorer specific declaration property "filter" to Internet Explorer 8+ compatible 
     * declaratiopn property "-ms-filter". 
     * 
     * @param aCssToken $token
     * @return array
     */
    private static function filter($token)
        {
        $r = array
            (
            new CssRulesetDeclarationToken("-ms-filter", "\"" . $token->Value . "\"", $token->MediaTypes),
            );
        return $r;
        }
    /**
     * Transforms "opacity: {value}" into browser specific counterparts.
     * 
     * @param aCssToken $token
     * @return array
     */
    private static function opacity($token)
        {
        // Calculate the value for Internet Explorer filter statement
        $ieValue = (int) ((float) $token->Value * 100);
        $r = array
            (
            // Internet Explorer >= 8
            new CssRulesetDeclarationToken("-ms-filter", "\"alpha(opacity=" . $ieValue . ")\"", $token->MediaTypes),
            // Internet Explorer >= 4 <= 7
            new CssRulesetDeclarationToken("filter", "alpha(opacity=" . $ieValue . ")", $token->MediaTypes),
            new CssRulesetDeclarationToken("zoom", "1", $token->MediaTypes)
            );
        return $r;
        }
    /**
     * Transforms "white-space: pre-wrap" into browser specific counterparts.
     * 
     * @param aCssToken $token
     * @return array
     */
    private static function whiteSpace($token)
        {
        if (strtolower($token->Value) === "pre-wrap")
            {
            $r = array
                (
                // Firefox < 3
                new CssRulesetDeclarationToken("white-space", "-moz-pre-wrap", $token->MediaTypes),
                // Webkit
                new CssRulesetDeclarationToken("white-space", "-webkit-pre-wrap", $token->MediaTypes),
                // Opera >= 4 <= 6
                new CssRulesetDeclarationToken("white-space", "-pre-wrap", $token->MediaTypes),
                // Opera >= 7
                new CssRulesetDeclarationToken("white-space", "-o-pre-wrap", $token->MediaTypes),
                // Internet Explorer >= 5.5
                new CssRulesetDeclarationToken("word-wrap", "break-word", $token->MediaTypes)
                );
            return $r;
            }
        else
            {
            return array();
            }
        }
    }

/**
 * This {@link aCssMinifierFilter minifier filter} will convert @keyframes at-rule block to browser specific counterparts.
 * 
 * @package     CssMin/Minifier/Filters
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssConvertLevel3AtKeyframesMinifierFilter extends aCssMinifierFilter
    {
    /**
     * Implements {@link aCssMinifierFilter::filter()}.
     * 
     * @param array $tokens Array of objects of type aCssToken
     * @return integer Count of added, changed or removed tokens; a return value larger than 0 will rebuild the array
     */
    public function apply(array &$tokens)
        {
        $r = 0;
        $transformations = array("-moz-keyframes", "-webkit-keyframes");
        for ($i = 0, $l = count($tokens); $i < $l; $i++)
            {
            if (get_class($tokens[$i]) === "CssAtKeyframesStartToken")
                {
                for ($ii = $i; $ii < $l; $ii++)
                    {
                    if (get_class($tokens[$ii]) === "CssAtKeyframesEndToken")
                        {
                        break;
                        }
                    }
                if (get_class($tokens[$ii]) === "CssAtKeyframesEndToken")
                    {
                    $add    = array();
                    $source = array();
                    for ($iii = $i; $iii <= $ii; $iii++)
                        {
                        $source[] = clone($tokens[$iii]);
                        }
                    foreach ($transformations as $transformation)
                        {
                        $t = array();
                        foreach ($source as $token)
                            {
                            $t[] = clone($token);
                            }
                        $t[0]->AtRuleName = $transformation;
                        $add = array_merge($add, $t);
                        }
                    if (isset($this->configuration["RemoveSource"]) && $this->configuration["RemoveSource"] === true)
                        {
                        array_splice($tokens, $i, $ii - $i + 1, $add);
                        }
                    else
                        {
                        array_splice($tokens, $ii + 1, 0, $add);
                        }
                    $l = count($tokens);
                    $i = $ii + count($add);
                    $r += count($add);
                    }
                }
            }
        return $r;
        }
    }

/**
 * This {@link aCssMinifierPlugin} will convert a color value in hsl notation to hexadecimal notation.
 * 
 * Example:
 * <code>
 * color: hsl(232,36%,48%);
 * </code>
 * 
 * Will get converted to:
 * <code>
 * color:#4e5aa7;
 * </code>
 * 
 * @package     CssMin/Minifier/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssConvertHslColorsMinifierPlugin extends aCssMinifierPlugin
    {
    /**
     * Regular expression matching the value.
     * 
     * @var string
     */
    private $reMatch = "/^hsl\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*%\s*,\s*([0-9]+)\s*%\s*\)/iS";
    /**
     * Implements {@link aCssMinifierPlugin::minify()}.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    public function apply(aCssToken &$token)
        {
        if (stripos($token->Value, "hsl") !== false && preg_match($this->reMatch, $token->Value, $m))
            {
            $token->Value = str_replace($m[0], $this->hsl2hex($m[1], $m[2], $m[3]), $token->Value);
            }
        return false;
        }
    /**
     * Implements {@link aMinifierPlugin::getTriggerTokens()}
     * 
     * @return array
     */
    public function getTriggerTokens()
        {
        return array
            (
            "CssAtFontFaceDeclarationToken",
            "CssAtPageDeclarationToken",
            "CssRulesetDeclarationToken"
            );
        }
    /**
     * Convert a HSL value to hexadecimal notation.
     * 
     * Based on: {@link http://www.easyrgb.com/index.php?X=MATH&H=19#text19}.
     * 
     * @param integer $hue Hue
     * @param integer $saturation Saturation
     * @param integer $lightness Lightnesss
     * @return string
     */
    private function hsl2hex($hue, $saturation, $lightness)
        {
        $hue        = $hue / 360;
        $saturation = $saturation / 100;
        $lightness  = $lightness / 100;
        if ($saturation == 0)
            {
            $red    = $lightness * 255;
            $green  = $lightness * 255;
            $blue   = $lightness * 255;
            }
        else
            {
            if ($lightness < 0.5 )
                {
                $v2 = $lightness * (1 + $saturation);
                }
            else
                {
                $v2 = ($lightness + $saturation) - ($saturation * $lightness);
                }
            $v1     = 2 * $lightness - $v2;
            $red    = 255 * self::hue2rgb($v1, $v2, $hue + (1 / 3));
            $green  = 255 * self::hue2rgb($v1, $v2, $hue);
            $blue   = 255 * self::hue2rgb($v1, $v2, $hue - (1 / 3));
            }
        return "#" . str_pad(dechex(round($red)), 2, "0", STR_PAD_LEFT) . str_pad(dechex(round($green)), 2, "0", STR_PAD_LEFT) . str_pad(dechex(round($blue)), 2, "0", STR_PAD_LEFT);
        }
    /**
     * Apply hue to a rgb color value.
     * 
     * @param integer $v1 Value 1
     * @param integer $v2 Value 2
     * @param integer $hue Hue
     * @return integer
     */
    private function hue2rgb($v1, $v2, $hue)
        {
        if ($hue < 0)
            {
            $hue += 1;
            }
        if ($hue > 1)
            {
            $hue -= 1;
            }
        if ((6 * $hue) < 1)
            {
            return ($v1 + ($v2 - $v1) * 6 * $hue);
            }
        if ((2 * $hue) < 1)
            {
            return ($v2);
            }
        if ((3 * $hue) < 2)
            {
            return ($v1 + ($v2 - $v1) * (( 2 / 3) - $hue) * 6);
            }
        return $v1;
        }
    }

/**
 * This {@link aCssMinifierPlugin} will convert the font-weight values normal and bold to their numeric notation.
 * 
 * Example:
 * <code>
 * font-weight: normal;
 * font: bold 11px monospace;
 * </code>
 * 
 * Will get converted to:
 * <code>
 * font-weight:400;
 * font:700 11px monospace;
 * </code>
 *
 * @package     CssMin/Minifier/Pluginsn
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssConvertFontWeightMinifierPlugin extends aCssMinifierPlugin
    {
    /**
     * Array of included declaration properties this plugin will process; others declaration properties will get
     * ignored. 
     * 
     * @var array
     */
    private $include = array
        (
        "font",
        "font-weight"
        );
    /**
     * Regular expression matching the value.
     * 
     * @var string
     */
    private $reMatch = null;
    /**
     * Regular expression replace the value.
     * 
     * @var string
     */
    private $reReplace = "\"\${1}\" . \$this->transformation[\"\${2}\"] . \"\${3}\"";
    /**
     * Transformation table used by the {@link CssConvertFontWeightMinifierPlugin::$reReplace replace regular expression}.
     * 
     * @var array
     */
    private $transformation = array
        (
        "normal"    => "400",
        "bold"      => "700"
        );
    /**
     * Overwrites {@link aCssMinifierPlugin::__construct()}.
     * 
     * The constructor will create the {@link CssConvertFontWeightMinifierPlugin::$reReplace replace regular expression}
     * based on the {@link CssConvertFontWeightMinifierPlugin::$transformation transformation table}.
     * 
     * @param CssMinifier $minifier The CssMinifier object of this plugin.
     * @return void
     */
    public function __construct(CssMinifier $minifier)
        {
        $this->reMatch = "/(^|\s)+(" . implode("|", array_keys($this->transformation)). ")(\s|$)+/eiS";
        parent::__construct($minifier);
        }
    /**
     * Implements {@link aCssMinifierPlugin::minify()}.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    public function apply(aCssToken &$token)
        {
        if (in_array($token->Property, $this->include) && preg_match($this->reMatch, $token->Value, $m))
            {
            $token->Value = preg_replace($this->reMatch, $this->reReplace, $token->Value);
            }
        return false;
        }
    /**
     * Implements {@link aMinifierPlugin::getTriggerTokens()}
     * 
     * @return array
     */
    public function getTriggerTokens()
        {
        return array
            (
            "CssAtFontFaceDeclarationToken",
            "CssAtPageDeclarationToken",
            "CssRulesetDeclarationToken"
            );
        }
    }

/**
 * This {@link aCssMinifierPlugin} will compress several unit values to their short notations. Examples:
 * 
 * <code>
 * padding: 0.5em;
 * border: 0px;
 * margin: 0 0 0 0;
 * </code>
 * 
 * Will get compressed to:
 * 
 * <code>
 * padding:.5px;
 * border:0;
 * margin:0;
 * </code>
 * 
 * --
 *
 * @package     CssMin/Minifier/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssCompressUnitValuesMinifierPlugin extends aCssMinifierPlugin
    {
    /**
     * Regular expression used for matching and replacing unit values.
     * 
     * @var array
     */
    private $re = array
        (
        "/(^| |-)0\.([0-9]+?)(0+)?(%|em|ex|px|in|cm|mm|pt|pc)/iS" => "\${1}.\${2}\${4}",
        "/(^| )-?(\.?)0(%|em|ex|px|in|cm|mm|pt|pc)/iS" => "\${1}0",
        "/(^0\s0\s0\s0)|(^0\s0\s0$)|(^0\s0$)/iS" => "0"
        );
    /**
     * Regular expression matching the value.
     * 
     * @var string
     */
    private $reMatch = "/(^| |-)0\.([0-9]+?)(0+)?(%|em|ex|px|in|cm|mm|pt|pc)|(^| )-?(\.?)0(%|em|ex|px|in|cm|mm|pt|pc)|(^0\s0\s0\s0$)|(^0\s0\s0$)|(^0\s0$)/iS";
    /**
     * Implements {@link aCssMinifierPlugin::minify()}.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    public function apply(aCssToken &$token)
        {
        if (preg_match($this->reMatch, $token->Value))
            {
            foreach ($this->re as $reMatch => $reReplace)
                {
                $token->Value = preg_replace($reMatch, $reReplace, $token->Value);
                }
            }
        return false;
        }
    /**
     * Implements {@link aMinifierPlugin::getTriggerTokens()}
     * 
     * @return array
     */
    public function getTriggerTokens()
        {
        return array
            (
            "CssAtFontFaceDeclarationToken",
            "CssAtPageDeclarationToken",
            "CssRulesetDeclarationToken"
            );
        }
    }

/**
 * This {@link aCssMinifierPlugin} compress the content of expresssion() declaration values.
 * 
 * For compression of expressions {@link https://github.com/rgrove/jsmin-php/ JSMin} will get used. JSMin have to be 
 * already included or loadable via {@link http://goo.gl/JrW54 PHP autoloading}. 
 * 
 * @package     CssMin/Minifier/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssCompressExpressionValuesMinifierPlugin extends aCssMinifierPlugin
    {
    /**
     * Implements {@link aCssMinifierPlugin::minify()}.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    public function apply(aCssToken &$token)
        {
        if (class_exists("JSMin") && stripos($token->Value, "expression(") !== false)
            {
            $value  = $token->Value;
            $value  = substr($token->Value, stripos($token->Value, "expression(") + 10);
            $value  = trim(JSMin::minify($value));
            $token->Value = "expression(" . $value . ")";
            }
        return false;
        }
    /**
     * Implements {@link aMinifierPlugin::getTriggerTokens()}
     * 
     * @return array
     */
    public function getTriggerTokens()
        {
        return array
            (
            "CssAtFontFaceDeclarationToken",
            "CssAtPageDeclarationToken",
            "CssRulesetDeclarationToken"
            );
        }
    }

/**
 * This {@link aCssMinifierPlugin} will convert hexadecimal color value with 6 chars to their 3 char hexadecimal 
 * notation (if possible). 
 * 
 * Example:
 * <code>
 * color: #aabbcc;
 * </code>
 * 
 * Will get converted to:
 * <code>
 * color:#abc;
 * </code>
 * 
 * @package     CssMin/Minifier/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssCompressColorValuesMinifierPlugin extends aCssMinifierPlugin
    {
    /**
     * Regular expression matching 6 char hexadecimal color values.
     * 
     * @var string
     */
    private $reMatch = "/\#([0-9a-f]{6})/iS";
    /**
     * Implements {@link aCssMinifierPlugin::minify()}.
     * 
     * @param aCssToken $token Token to process
     * @return boolean Return TRUE to break the processing of this token; FALSE to continue
     */
    public function apply(aCssToken &$token)
        {
        if (strpos($token->Value, "#") !== false && preg_match($this->reMatch, $token->Value, $m))
            {
            $value = strtolower($m[1]);
            if ($value[0] == $value[1] && $value[2] == $value[3] && $value[4] == $value[5])
                {
                $token->Value = str_replace($m[0], "#" . $value[0] . $value[2] . $value[4], $token->Value);
                }
            }
        return false;
        }
    /**
     * Implements {@link aMinifierPlugin::getTriggerTokens()}
     * 
     * @return array
     */
    public function getTriggerTokens()
        {
        return array
            (
            "CssAtFontFaceDeclarationToken",
            "CssAtPageDeclarationToken",
            "CssRulesetDeclarationToken"
            );
        }
    }

/**
 * This {@link aCssToken CSS token} represents a CSS comment.
 * 
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssCommentToken extends aCssToken
    {
    /**
     * Comment as Text.
     * 
     * @var string
     */
    public $Comment = "";
    /**
     * Set the properties of a comment token.
     * 
     * @param string $comment Comment including comment delimiters 
     * @return void
     */
    public function __construct($comment)
        {
        $this->Comment = $comment;
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return $this->Comment;
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing comments.
 * 
 * Adds a {@link CssCommentToken} to the parser if a comment was found.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssCommentParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("*", "/");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return false;
        }
    /**
     * Stored buffer for restore.
     * 
     * @var string
     */
    private $restoreBuffer = "";
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        if ($char === "*" && $previousChar === "/" && $state !== "T_COMMENT")
            {
            $this->parser->pushState("T_COMMENT");
            $this->parser->setExclusive(__CLASS__);
            $this->restoreBuffer = substr($this->parser->getAndClearBuffer(), 0, -2);
            }
        elseif ($char === "/" && $previousChar === "*" && $state === "T_COMMENT")
            {
            $this->parser->popState();
            $this->parser->unsetExclusive();
            $this->parser->appendToken(new CssCommentToken("/*" . $this->parser->getAndClearBuffer()));
            $this->parser->setBuffer($this->restoreBuffer);
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * This {@link aCssToken CSS token} represents the start of a @variables at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtVariablesStartToken extends aCssAtBlockStartToken
    {
    /**
     * Media types of the @variables at-rule block.
     * 
     * @var array
     */
    public $MediaTypes = array();
    /**
     * Set the properties of a @variables at-rule token.
     * 
     * @param array $mediaTypes Media types
     * @return void
     */
    public function __construct($mediaTypes = null)
        {
        $this->MediaTypes = $mediaTypes ? $mediaTypes : array("all");
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "";
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @variables at-rule block with including declarations.
 * 
 * Found @variables at-rule blocks will add a {@link CssAtVariablesStartToken} and {@link CssAtVariablesEndToken} to the 
 * parser; including declarations as {@link CssAtVariablesDeclarationToken}.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtVariablesParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("@", "{", "}", ":", ";");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return array("T_DOCUMENT", "T_AT_VARIABLES::PREPARE", "T_AT_VARIABLES", "T_AT_VARIABLES_DECLARATION");
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        // Start of @variables at-rule block
        if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 10)) === "@variables")
            {
            $this->parser->pushState("T_AT_VARIABLES::PREPARE");
            $this->parser->clearBuffer();
            return $index + 10;
            }
        // Start of @variables declarations
        elseif ($char === "{" && $state === "T_AT_VARIABLES::PREPARE")
            {
            $this->parser->setState("T_AT_VARIABLES");
            $mediaTypes = array_filter(array_map("trim", explode(",", $this->parser->getAndClearBuffer("{"))));
            $this->parser->appendToken(new CssAtVariablesStartToken($mediaTypes));
            }
        // Start of @variables declaration
        if ($char === ":" && $state === "T_AT_VARIABLES")
            {
            $this->buffer = $this->parser->getAndClearBuffer(":");
            $this->parser->pushState("T_AT_VARIABLES_DECLARATION");
            }
        // Unterminated @variables declaration
        elseif ($char === ":" && $state === "T_AT_VARIABLES_DECLARATION")
            {
            // Ignore Internet Explorer filter declarations
            if ($this->buffer === "filter")
                {
                return false;
                }
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated @variables declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
            }
        // End of @variables declaration
        elseif (($char === ";" || $char === "}") && $state === "T_AT_VARIABLES_DECLARATION")
            {
            $value = $this->parser->getAndClearBuffer(";}");
            if (strtolower(substr($value, -10, 10)) === "!important")
                {
                $value = trim(substr($value, 0, -10));
                $isImportant = true;
                }
            else
                {
                $isImportant = false;
                }
            $this->parser->popState();
            $this->parser->appendToken(new CssAtVariablesDeclarationToken($this->buffer, $value, $isImportant));
            $this->buffer = "";
            }
        // End of @variables at-rule block
        elseif ($char === "}" && $state === "T_AT_VARIABLES")
            {
            $this->parser->popState();
            $this->parser->clearBuffer();
            $this->parser->appendToken(new CssAtVariablesEndToken());
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * This {@link aCssToken CSS token} represents the end of a @variables at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtVariablesEndToken extends aCssAtBlockEndToken
    {
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "";
        }
    }

/**
 * This {@link aCssToken CSS token} represents a declaration of a @variables at-rule block.
 * 
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtVariablesDeclarationToken extends aCssDeclarationToken
    {
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "";
        }
    }

/**
* This {@link aCssToken CSS token} represents the start of a @page at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtPageStartToken extends aCssAtBlockStartToken
    {
    /**
     * Selector.
     * 
     * @var string
     */
    public $Selector = "";
    /**
     * Sets the properties of the @page at-rule.
     * 
     * @param string $selector Selector
     * @return void
     */
    public function __construct($selector = "")
        {
        $this->Selector = $selector;
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "@page" . ($this->Selector ? " " . $this->Selector : "") . "{";
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @page at-rule block with including declarations.
 * 
 * Found @page at-rule blocks will add a {@link CssAtPageStartToken} and {@link CssAtPageEndToken} to the 
 * parser; including declarations as {@link CssAtPageDeclarationToken}.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtPageParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("@", "{", "}", ":", ";");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return array("T_DOCUMENT", "T_AT_PAGE::SELECTOR", "T_AT_PAGE", "T_AT_PAGE_DECLARATION");
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        // Start of @page at-rule block
        if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 5)) === "@page")
            {
            $this->parser->pushState("T_AT_PAGE::SELECTOR");
            $this->parser->clearBuffer();
            return $index + 5;
            }
        // Start of @page declarations
        elseif ($char === "{" && $state === "T_AT_PAGE::SELECTOR")
            {
            $selector = $this->parser->getAndClearBuffer("{");
            $this->parser->setState("T_AT_PAGE");
            $this->parser->clearBuffer();
            $this->parser->appendToken(new CssAtPageStartToken($selector));
            }
        // Start of @page declaration
        elseif ($char === ":" && $state === "T_AT_PAGE")
            {
            $this->parser->pushState("T_AT_PAGE_DECLARATION");
            $this->buffer = $this->parser->getAndClearBuffer(":", true);
            }
        // Unterminated @font-face declaration
        elseif ($char === ":" && $state === "T_AT_PAGE_DECLARATION")
            {
            // Ignore Internet Explorer filter declarations
            if ($this->buffer === "filter")
                {
                return false;
                }
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated @page declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
            }
        // End of @page declaration
        elseif (($char === ";" || $char === "}") && $state == "T_AT_PAGE_DECLARATION")
            {
            $value = $this->parser->getAndClearBuffer(";}");
            if (strtolower(substr($value, -10, 10)) == "!important")
                {
                $value = trim(substr($value, 0, -10));
                $isImportant = true;
                }
            else
                {
                $isImportant = false;
                }
            $this->parser->popState();
            $this->parser->appendToken(new CssAtPageDeclarationToken($this->buffer, $value, $isImportant));
            // --
            if ($char === "}")
                {
                $this->parser->popState();
                $this->parser->appendToken(new CssAtPageEndToken());
                }
            $this->buffer = "";
            }
        // End of @page at-rule block
        elseif ($char === "}" && $state === "T_AT_PAGE")
            {
            $this->parser->popState();
            $this->parser->clearBuffer();
            $this->parser->appendToken(new CssAtPageEndToken());
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * This {@link aCssToken CSS token} represents the end of a @page at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtPageEndToken extends aCssAtBlockEndToken
    {
    
    }

/**
 * This {@link aCssToken CSS token} represents a declaration of a @page at-rule block.
 * 
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtPageDeclarationToken extends aCssDeclarationToken
    {
    
    }

/**
 * This {@link aCssToken CSS token} represents the start of a @media at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtMediaStartToken extends aCssAtBlockStartToken
    {
    /**
     * Sets the properties of the @media at-rule.
     * 
     * @param array $mediaTypes Media types
     * @return void
     */
    public function __construct(array $mediaTypes = array())
        {
        $this->MediaTypes = $mediaTypes;
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "@media " . implode(",", $this->MediaTypes) . "{";
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @media at-rule block.
 * 
 * Found @media at-rule blocks will add a {@link CssAtMediaStartToken} and {@link CssAtMediaEndToken} to the parser. 
 * This plugin will also set the the current media types using {@link CssParser::setMediaTypes()} and
 * {@link CssParser::unsetMediaTypes()}.
 *
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtMediaParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("@", "{", "}");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return array("T_DOCUMENT", "T_AT_MEDIA::PREPARE", "T_AT_MEDIA");
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 6)) === "@media")
            {
            $this->parser->pushState("T_AT_MEDIA::PREPARE");
            $this->parser->clearBuffer();
            return $index + 6;
            }
        elseif ($char === "{" && $state === "T_AT_MEDIA::PREPARE")
            {
            $mediaTypes = array_filter(array_map("trim", explode(",", $this->parser->getAndClearBuffer("{"))));
            $this->parser->setMediaTypes($mediaTypes);
            $this->parser->setState("T_AT_MEDIA");
            $this->parser->appendToken(new CssAtMediaStartToken($mediaTypes));
            }
        elseif ($char === "}" && $state === "T_AT_MEDIA")
            {
            $this->parser->appendToken(new CssAtMediaEndToken());
            $this->parser->clearBuffer();
            $this->parser->unsetMediaTypes();
            $this->parser->popState();
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * This {@link aCssToken CSS token} represents the end of a @media at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtMediaEndToken extends aCssAtBlockEndToken
    {
    
    }

/**
 * This {@link aCssToken CSS token} represents the start of a @keyframes at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtKeyframesStartToken extends aCssAtBlockStartToken
    {
    /**
     * Name of the at-rule.
     * 
     * @var string
     */
    public $AtRuleName = "keyframes";
    /**
     * Name
     * 
     * @var string
     */
    public $Name = "";
    /**
     * Sets the properties of the @page at-rule.
     * 
     * @param string $selector Selector
     * @return void
     */
    public function __construct($name, $atRuleName = null)
        {
        $this->Name = $name;
        if (!is_null($atRuleName))
            {
            $this->AtRuleName = $atRuleName;
            }
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "@" . $this->AtRuleName . " \"" . $this->Name . "\"{";
        }
    }

/**
 * This {@link aCssToken CSS token} represents the start of a ruleset of a @keyframes at-rule block.
 * 
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtKeyframesRulesetStartToken extends aCssRulesetStartToken
    {
    /**
     * Array of selectors.
     * 
     * @var array
     */
    public $Selectors = array();
    /**
     * Set the properties of a ruleset token.
     * 
     * @param array $selectors Selectors of the ruleset 
     * @return void
     */
    public function __construct(array $selectors = array())
        {
        $this->Selectors = $selectors;
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return implode(",", $this->Selectors) . "{";
        }
    }

/**
 * This {@link aCssToken CSS token} represents the end of a ruleset of a @keyframes at-rule block.
 * 
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtKeyframesRulesetEndToken extends aCssRulesetEndToken
    {
    
    }

/**
 * This {@link aCssToken CSS token} represents a ruleset declaration of a @keyframes at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtKeyframesRulesetDeclarationToken extends aCssDeclarationToken
    {
    
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @keyframes at-rule blocks, rulesets and declarations.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtKeyframesParserPlugin extends aCssParserPlugin
    {
    /**
     * @var string Keyword
     */
    private $atRuleName = "";
    /**
     * Selectors.
     * 
     * @var array
     */
    private $selectors = array();
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("@", "{", "}", ":", ",", ";");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return array("T_DOCUMENT", "T_AT_KEYFRAMES::NAME", "T_AT_KEYFRAMES", "T_AT_KEYFRAMES_RULESETS", "T_AT_KEYFRAMES_RULESET", "T_AT_KEYFRAMES_RULESET_DECLARATION");
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        // Start of @keyframes at-rule block
        if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 10)) === "@keyframes") 
            {
            $this->atRuleName = "keyframes";
            $this->parser->pushState("T_AT_KEYFRAMES::NAME");
            $this->parser->clearBuffer();
            return $index + 10;
            }
        // Start of @keyframes at-rule block (@-moz-keyframes)
        elseif ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 15)) === "@-moz-keyframes")
            {
            $this->atRuleName = "-moz-keyframes";
            $this->parser->pushState("T_AT_KEYFRAMES::NAME");
            $this->parser->clearBuffer();
            return $index + 15;
            }
        // Start of @keyframes at-rule block (@-webkit-keyframes)
        elseif ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 18)) === "@-webkit-keyframes")
            {
            $this->atRuleName = "-webkit-keyframes";
            $this->parser->pushState("T_AT_KEYFRAMES::NAME");
            $this->parser->clearBuffer();
            return $index + 18;
            }
        // Start of @keyframes rulesets
        elseif ($char === "{" && $state === "T_AT_KEYFRAMES::NAME")
            {
            $name = $this->parser->getAndClearBuffer("{\"'");
            $this->parser->setState("T_AT_KEYFRAMES_RULESETS");
            $this->parser->clearBuffer();
            $this->parser->appendToken(new CssAtKeyframesStartToken($name, $this->atRuleName));
            }
        // Start of @keyframe ruleset and selectors
        if ($char === "," && $state === "T_AT_KEYFRAMES_RULESETS")
            {
            $this->selectors[] = $this->parser->getAndClearBuffer(",{");
            }
        // Start of a @keyframes ruleset
        elseif ($char === "{" && $state === "T_AT_KEYFRAMES_RULESETS")
            {
            if ($this->parser->getBuffer() !== "")
                {
                $this->selectors[] = $this->parser->getAndClearBuffer(",{");
                $this->parser->pushState("T_AT_KEYFRAMES_RULESET");
                $this->parser->appendToken(new CssAtKeyframesRulesetStartToken($this->selectors));
                $this->selectors = array();
                }
            }
        // Start of @keyframes ruleset declaration
        elseif ($char === ":" && $state === "T_AT_KEYFRAMES_RULESET")
            {
            $this->parser->pushState("T_AT_KEYFRAMES_RULESET_DECLARATION");
            $this->buffer = $this->parser->getAndClearBuffer(":;", true);
            }
        // Unterminated @keyframes ruleset declaration
        elseif ($char === ":" && $state === "T_AT_KEYFRAMES_RULESET_DECLARATION")
            {
            // Ignore Internet Explorer filter declarations
            if ($this->buffer === "filter")
                {
                return false;
                }
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated @keyframes ruleset declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
            }
        // End of declaration
        elseif (($char === ";" || $char === "}") && $state === "T_AT_KEYFRAMES_RULESET_DECLARATION")
            {
            $value = $this->parser->getAndClearBuffer(";}");
            if (strtolower(substr($value, -10, 10)) === "!important")
                {
                $value = trim(substr($value, 0, -10));
                $isImportant = true;
                }
            else
                {
                $isImportant = false;
                }
            $this->parser->popState();
            $this->parser->appendToken(new CssAtKeyframesRulesetDeclarationToken($this->buffer, $value, $isImportant));
            // Declaration ends with a right curly brace; so we have to end the ruleset
            if ($char === "}")
                {
                $this->parser->appendToken(new CssAtKeyframesRulesetEndToken());
                $this->parser->popState();
                }
            $this->buffer = "";
            }
        // End of @keyframes ruleset
        elseif ($char === "}" && $state === "T_AT_KEYFRAMES_RULESET")
            {
            $this->parser->clearBuffer();
            
            $this->parser->popState();
            $this->parser->appendToken(new CssAtKeyframesRulesetEndToken());
            }
        // End of @keyframes rulesets
        elseif ($char === "}" && $state === "T_AT_KEYFRAMES_RULESETS")
            {
            $this->parser->clearBuffer();
            $this->parser->popState();
            $this->parser->appendToken(new CssAtKeyframesEndToken());
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * This {@link aCssToken CSS token} represents the end of a @keyframes at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtKeyframesEndToken extends aCssAtBlockEndToken
    {
    
    }

/**
 * This {@link aCssToken CSS token} represents a @import at-rule.
 * 
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1.b1 (2001-02-22)
 */
class CssAtImportToken extends aCssToken
    {
    /**
     * Import path of the @import at-rule.
     * 
     * @var string
     */
    public $Import = "";
    /**
     * Media types of the @import at-rule.
     * 
     * @var array
     */
    public $MediaTypes = array();
    /**
     * Set the properties of a @import at-rule token.
     * 
     * @param string $import Import path
     * @param array $mediaTypes Media types
     * @return void
     */
    public function __construct($import, $mediaTypes)
        {
        $this->Import       = $import;
        $this->MediaTypes   = $mediaTypes ? $mediaTypes : array();
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "@import \"" . $this->Import . "\"" . (count($this->MediaTypes) > 0 ? " "  . implode(",", $this->MediaTypes) : ""). ";";
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @import at-rule.
 * 
 * If a @import at-rule was found this plugin will add a {@link CssAtImportToken} to the parser.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtImportParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("@", ";", ",", "\n");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return array("T_DOCUMENT", "T_AT_IMPORT");
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 7)) === "@import")
            {
            $this->parser->pushState("T_AT_IMPORT");
            $this->parser->clearBuffer();
            return $index + 7;
            }
        elseif (($char === ";" || $char === "\n") && $state === "T_AT_IMPORT")
            {
            $this->buffer = $this->parser->getAndClearBuffer(";");
            $pos = false;
            foreach (array(")", "\"", "'") as $needle)
                {
                if (($pos = strrpos($this->buffer, $needle)) !== false)
                    {
                    break;
                    }
                }
            $import = substr($this->buffer, 0, $pos + 1);
            if (stripos($import, "url(") === 0)
                {
                $import = substr($import, 4, -1);
                }
            $import = trim($import, " \t\n\r\0\x0B'\"");
            $mediaTypes = array_filter(array_map("trim", explode(",", trim(substr($this->buffer, $pos + 1), " \t\n\r\0\x0B{"))));
            if ($pos)
                {
                $this->parser->appendToken(new CssAtImportToken($import, $mediaTypes));
                }
            else
                {
                CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Invalid @import at-rule syntax", $this->parser->buffer));
                }
            $this->parser->popState();
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * This {@link aCssToken CSS token} represents the start of a @font-face at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtFontFaceStartToken extends aCssAtBlockStartToken
    {
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "@font-face{";
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @font-face at-rule block with including declarations.
 * 
 * Found @font-face at-rule blocks will add a {@link CssAtFontFaceStartToken} and {@link CssAtFontFaceEndToken} to the 
 * parser; including declarations as {@link CssAtFontFaceDeclarationToken}.
 * 
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtFontFaceParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("@", "{", "}", ":", ";");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return array("T_DOCUMENT", "T_AT_FONT_FACE::PREPARE", "T_AT_FONT_FACE", "T_AT_FONT_FACE_DECLARATION");
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        // Start of @font-face at-rule block
        if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 10)) === "@font-face")
            {
            $this->parser->pushState("T_AT_FONT_FACE::PREPARE");
            $this->parser->clearBuffer();
            return $index + 10;
            }
        // Start of @font-face declarations
        elseif ($char === "{" && $state === "T_AT_FONT_FACE::PREPARE")
            {
            $this->parser->setState("T_AT_FONT_FACE");
            $this->parser->clearBuffer();
            $this->parser->appendToken(new CssAtFontFaceStartToken());
            }
        // Start of @font-face declaration
        elseif ($char === ":" && $state === "T_AT_FONT_FACE")
            {
            $this->parser->pushState("T_AT_FONT_FACE_DECLARATION");
            $this->buffer = $this->parser->getAndClearBuffer(":", true);
            }
        // Unterminated @font-face declaration
        elseif ($char === ":" && $state === "T_AT_FONT_FACE_DECLARATION")
            {
            // Ignore Internet Explorer filter declarations
            if ($this->buffer === "filter")
                {
                return false;
                }
            CssMin::triggerError(new CssError(__FILE__, __LINE__, __METHOD__ . ": Unterminated @font-face declaration", $this->buffer . ":" . $this->parser->getBuffer() . "_"));
            }
        // End of @font-face declaration
        elseif (($char === ";" || $char === "}") && $state === "T_AT_FONT_FACE_DECLARATION")
            {
            $value = $this->parser->getAndClearBuffer(";}");
            if (strtolower(substr($value, -10, 10)) === "!important")
                {
                $value = trim(substr($value, 0, -10));
                $isImportant = true;
                }
            else
                {
                $isImportant = false;
                }
            $this->parser->popState();
            $this->parser->appendToken(new CssAtFontFaceDeclarationToken($this->buffer, $value, $isImportant));
            $this->buffer = "";
            // --
            if ($char === "}")
                {
                $this->parser->appendToken(new CssAtFontFaceEndToken());
                $this->parser->popState();
                }
            }
        // End of @font-face at-rule block
        elseif ($char === "}" && $state === "T_AT_FONT_FACE")
            {
            $this->parser->appendToken(new CssAtFontFaceEndToken());
            $this->parser->clearBuffer();
            $this->parser->popState();
            }
        else
            {
            return false;
            }
        return true;
        }
    }

/**
 * This {@link aCssToken CSS token} represents the end of a @font-face at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtFontFaceEndToken extends aCssAtBlockEndToken
    {
    
    }

/**
 * This {@link aCssToken CSS token} represents a declaration of a @font-face at-rule block.
 *
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtFontFaceDeclarationToken extends aCssDeclarationToken
    {
    
    }

/**
 * This {@link aCssToken CSS token} represents a @charset at-rule.
 * 
 * @package     CssMin/Tokens
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtCharsetToken extends aCssToken
    {
    /**
     * Charset of the @charset at-rule.
     * 
     * @var string
     */
    public $Charset = "";
    /**
     * Set the properties of @charset at-rule token. 
     * 
     * @param string $charset Charset of the @charset at-rule token
     * @return void
     */
    public function __construct($charset)
        {
        $this->Charset = $charset;
        }
    /**
     * Implements {@link aCssToken::__toString()}.
     * 
     * @return string
     */
    public function __toString()
        {
        return "@charset " . $this->Charset . ";";
        }
    }

/**
 * {@link aCssParserPlugin Parser plugin} for parsing @charset at-rule.
 * 
 * If a @charset at-rule was found this plugin will add a {@link CssAtCharsetToken} to the parser.
 *
 * @package     CssMin/Parser/Plugins
 * @link        http://code.google.com/p/cssmin/
 * @author      Joe Scylla <joe.scylla@gmail.com>
 * @copyright   2008 - 2011 Joe Scylla <joe.scylla@gmail.com>
 * @license     http://opensource.org/licenses/mit-license.php MIT License
 * @version     3.0.1
 */
class CssAtCharsetParserPlugin extends aCssParserPlugin
    {
    /**
     * Implements {@link aCssParserPlugin::getTriggerChars()}.
     * 
     * @return array
     */
    public function getTriggerChars()
        {
        return array("@", ";", "\n");
        }
    /**
     * Implements {@link aCssParserPlugin::getTriggerStates()}.
     * 
     * @return array
     */
    public function getTriggerStates()
        {
        return array("T_DOCUMENT", "T_AT_CHARSET");
        }
    /**
     * Implements {@link aCssParserPlugin::parse()}.
     * 
     * @param integer $index Current index
     * @param string $char Current char
     * @param string $previousChar Previous char
     * @return mixed TRUE will break the processing; FALSE continue with the next plugin; integer set a new index and break the processing
     */
    public function parse($index, $char, $previousChar, $state)
        {
        if ($char === "@" && $state === "T_DOCUMENT" && strtolower(substr($this->parser->getSource(), $index, 8)) === "@charset")
            {
            $this->parser->pushState("T_AT_CHARSET");
            $this->parser->clearBuffer();
            return $index + 8;
            }
        elseif (($char === ";" || $char === "\n") && $state === "T_AT_CHARSET")
            {
            $charset = $this->parser->getAndClearBuffer(";");
            $this->parser->popState();
            $this->parser->appendToken(new CssAtCharsetToken($charset));
            }
        else
            {
            return false;
            }
        return true;
        }
    }
}
<?php
namespace AssetKit;
use AssetKit\FileUtil;

// should only run this when requiring.
// this is for 5.3 compatibility
if( ! defined('JSON_PRETTY_PRINT') )
    define('JSON_PRETTY_PRINT',0);

class Data
{
    const FORMAT_JSON = 1;
    const FORMAT_PHP  = 2;
    const FORMAT_YAML = 3;
    const FORMAT_UNKNOWN = 0;

    static function detect_format_from_extension($path)
    {
        $ext = pathinfo($path, PATHINFO_EXTENSION);

        switch($ext) {
        case 'php':
            return self::FORMAT_PHP;
        case 'json':
            return self::FORMAT_JSON;
        case 'yml':
        case 'yaml':
            return self::FORMAT_YAML;
        }
        return self::FORMAT_UNKNOWN;
    }

    static function compile_manifest_to_php($path, $format = 0)
    {
        if( $format ) {
            $data = self::decode_file($path, $format);
        } else {
            $data = self::detect_format_and_decode($path);
        }

        // $newpath = FileUtil::replace_extension($path,"php");
        $newpath = \futil_replace_extension($path,"php");
        $ret = self::encode_file( $newpath , $data , self::FORMAT_PHP );
        if( $ret !== false )
            return $newpath;
    }

    static function detect_format_and_decode($path)
    {
        if($format = self::detect_format_from_extension($path)) {
            return self::decode_file($path,$format);
        }
    }

    static function decode_file($file, $format = self::FORMAT_PHP)
    {
        if($format === self::FORMAT_PHP ) {
            return require($file);
        } elseif ($format === self::FORMAT_JSON ) {
            return json_decode(file_get_contents($file),true);
        } elseif ($format === self::FORMAT_YAML ) {
            return yaml_parse_file($file);
        }
    }

    static function encode_file($path, $data, $format = self::FORMAT_PHP) 
    {
        if( $format === self::FORMAT_JSON ) {
            return file_put_contents($path, json_encode($data, JSON_PRETTY_PRINT));
        } else if ($format === self::FORMAT_PHP ) {
            $php = '<?php return ' .  var_export($data,true) . ';';
            return file_put_contents($path, $php);
        } else if ($format === self::FORMAT_YAML ) {
            return file_put_contents($path, yaml_emit($data));
        }
    }
}

<?php
namespace AssetKit\Exception;
use Exception;
class UndefinedCompressorException extends Exception { }
<?php
namespace AssetKit\Exception;
use Exception;
class UndefinedFilterException extends Exception { }
<?php
namespace AssetKit\Exception;
use InvalidArgumentException;

class UnknownCollectionKeyException extends InvalidArgumentException
{
    protected $stash;

    public function __construct($message, array $stash = array()) {
        parent::__construct($message);
        $this->stash = $stash;
    }

    public function getStash()
    {
        return $this->stash;
    }

    public function __toString()
    {
        return parent::__toString() . ':' . var_export($this->stash, true);
    }
}




<?php
namespace AssetKit\Exception;
use Exception;

class UnknownFragmentException extends Exception {

    public $fragment;

    public function __construct($message, $fragment) {
        $this->fragment = $fragment;
        parent::__construct($message);
    }
}
<?php
namespace AssetKit\Exception;
use Exception;
class UnwritableFileException extends Exception {}
<?php
namespace AssetKit\Extension\Twig;
use Twig_Extension;
use AssetKit\AssetConfig;
use AssetKit\AssetLoader;
use AssetKit\AssetRender;
use AssetKit\AssetCompiler;

class AssetExtension extends Twig_Extension
{
    protected $assetConfig;

    protected $assetLoader;

    protected $render;

    /**
     * Set AssetKit\AssetConfig
     */
    public function setAssetConfig(AssetConfig $config)
    {
        $this->assetConfig = $config;
    }


    public function getAssetConfig()
    {
        return $this->assetConfig;
    }

    /**
     * Set AssetKit\AssetLoader
     */
    public function setAssetLoader(AssetLoader $loader)
    {
        $this->assetLoader = $loader;
    }

    public function getAssetLoader()
    {
        return $this->assetLoader;
    }


    public function setAssetRender(AssetRender $render)
    {
        $this->render = $render;
    }

    public function getAssetRender()
    {
        if ($this->render) {
            return $this->render;
        }
        return $this->render = new AssetRender($this->assetConfig,$this->assetLoader);
    }

    public function setAssetCompiler(AssetCompiler $compiler)
    {
        $this->getAssetRender()->setCompiler($compiler);
    }

    public function getAssetCompiler()
    {
        return $this->getAssetRender()->getCompiler();
    }


    /**
     * Returns the token parser instances to add to the existing list.
     *
     * @return array An array of Twig_TokenParserInterface or Twig_TokenParserBrokerInterface instances
     */
    public function getTokenParsers()
    {
        return array( new AssetTokenParser() );
    }

    /**
     * Returns the name of the extension.
     *
     * @return string The extension name
     */
    public function getName() {
        return 'AssetKit';
    }
}

<?php
namespace AssetKit\Extension\Twig;
use Twig_Node;
use Twig_Compiler;
use Twig_Node_Expression;
use Twig_Node_Expression_Array;
use Twig_Node_Expression_Constant;
use Twig_Node_Expression_Name;
use Twig_Node_Expression_GetAttr;

class AssetNode extends Twig_Node
{

    public function __construct($attributes, $lineno, $tag = null)
    {
        parent::__construct(array(), $attributes, $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->addDebugInfo($this);

        $assets = $this->getAttribute('assets');
        $target = $this->getAttribute('target');
        $compiler->raw("\$extension = \$this->env->getExtension('AssetKit');\n");
        $compiler->raw("\$assetloader = \$extension->getAssetLoader();\n");
        $compiler->raw("\$assetrender = \$extension->getAssetRender();\n");
        $compiler->raw("\$assets = array();\n");
        foreach($assets as $asset) {
            if (is_string($asset)) {

                $compiler->raw("\$assets[] = \$a = \$assetloader->load('$asset');\n");

            } else if ($asset instanceof Twig_Node_Expression_Constant) {

                $compiler->raw("\$assets[] = \$a = \$assetloader->load(");
                $compiler->subcompile($asset);
                $compiler->raw(");\n");

            } else if ($asset instanceof Twig_Node_Expression_Array) {

                $pairs = $asset->getKeyValuePairs();
                foreach ($pairs as $pair) {
                    $compiler->raw('$assets[] = $a = $assetloader->load(');
                    $compiler->subcompile($pair['value']);
                    $compiler->raw(");\n");
                }
            } else if ($asset instanceof Twig_Node_Expression_Name || $asset instanceof Twig_Node_Expression_GetAttr) {
                $compiler->addDebugInfo($asset);

                $compiler->raw("\$var = ")
                    ->subcompile($asset)
                    ->raw(";\n")
                    ;

                $compiler->raw("if (is_array(\$var)){\n")
                    ->indent()
                    ->raw("foreach (\$var as \$asset){\n")
                        ->indent()
                        ->raw("\$assets[] = \$assetloader->load(\$asset);\n")
                        ->outdent()
                    ->raw("}\n")
                    ->outdent()
                    ;

                $compiler->raw("} else if (is_string(\$var)) {\n");

                $compiler->indent()
                    ->raw("\$assets[] = \$assetloader->load(\$var);\n")
                    ->outdent()
                    ->raw("}\n")
                ;
            }
        }
        $compiler->raw('$assetrender->renderAssets($assets');
        if ($target) {
            $compiler->raw(', ');
            $compiler->subcompile($target);
        }
        $compiler->raw(");\n");
    }

    /*
    public function __construct($assetNames, $lineno, $tag = null)
    {
        parent::__construct(array('assetNames' => $assetNames), array( ), $lineno, $tag);
    }

    public function compile(Twig_Compiler $compiler)
    {
        $compiler->addDebugInfo($this)
            ->write('// what the fuck');
            ->write('$context[\''.$this->getAttribute('name').'\'] = ')
            ->subcompile($this->getNode('value'))
            ->raw(";\n")
        ;
    }
    */
}




<?php
namespace AssetKit\Extension\Twig;
use Twig_TokenParser;
use Twig_Token;
use Twig_Node_Expression_Constant;
use Twig_Node_Expression_Array;
use Twig_Node_Expression_Name;

class AssetTokenParser extends Twig_TokenParser
{
    public function parse(Twig_Token $token)
    {
        $lineno = $token->getLine();
        $stream = $this->parser->getStream();

        $attributes = array(
            'assets' => array(),
            'target' => null,
        );

        // take asset names
        while (!$stream->test(Twig_Token::BLOCK_END_TYPE) && !$stream->test(Twig_Token::NAME_TYPE, 'as')) {

            if ($stream->test(Twig_Token::STRING_TYPE)) {

                $token = $stream->next();

                $strNode = new Twig_Node_Expression_Constant($token->getValue(), $token->getLine());

                $attributes['assets'][] = $strNode;

                if ($stream->test(Twig_Token::PUNCTUATION_TYPE, ',')) {
                    $stream->next();
                } else {
                    break;
                }
            } else if($stream->test(Twig_Token::NAME_TYPE, 'as')) {
                break;
            } else if ($expr = $this->parser->getExpressionParser()->parsePrimaryExpression()) {

                $attributes['assets'][] = $expr;

            } else if ($stream->test(Twig_Token::BLOCK_END_TYPE)) {

                break;

            } else {

                break;

            }
        }

        // skip "as" keyword
        if ($stream->test(Twig_Token::NAME_TYPE, 'as')) {
            $stream->next();
            $targetVar = $this->parser->getExpressionParser()->parseExpression();
            $attributes['target'] = $targetVar;
        }

        if ($stream->test(Twig_Token::NAME_TYPE, 'with')) {
            $stream->next();
            $configVar = $this->parser->getExpressionParser()->parseExpression();
            $attributes['config'] = $configVar;
        }


        $stream->expect(Twig_Token::BLOCK_END_TYPE);
        return new AssetNode($attributes, $lineno, $this->getTag());
    }

    public function getTag()
    {
        return 'assets';
    }
}

<?php
namespace AssetKit;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use AssetKit\Data;

class FileUtil
{

    static function find_non_php_manifest_file_from_directory($dir) 
    {
        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.json') )
            return $dir . DIRECTORY_SEPARATOR . 'manifest.json';
        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.yml') )
            return $dir . DIRECTORY_SEPARATOR . 'manifest.yml';
    }

    static function find_and_update_manifest_file_from_directory($dir)
    {
        // find cache
        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.php') ) {
            $cache = $dir . DIRECTORY_SEPARATOR . 'manifest.php';
            $source = self::find_non_php_manifest_file_from_directory($dir);
            if( filemtime($cache) >= filemtime($source) ) {
                return $cache;
            }
        }

        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.json') )
            return $dir . DIRECTORY_SEPARATOR . 'manifest.json';
        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.yml') )
            return $dir . DIRECTORY_SEPARATOR . 'manifest.yml';

    }

    static function find_manifest_file_from_directory($dir) 
    {
        // find cache
        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.php') )
            return $dir . DIRECTORY_SEPARATOR . 'manifest.php';
        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.json') )
            return $dir . DIRECTORY_SEPARATOR . 'manifest.json';
        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.yml') )
            return $dir . DIRECTORY_SEPARATOR . 'manifest.yml';
    }


    static function compile_manifest_file_from_directory($dir)
    {
        if( file_exists($dir . DIRECTORY_SEPARATOR . 'manifest.php') )
            unlink( $dir . DIRECTORY_SEPARATOR . 'manifest.php' );
        $path = self::find_manifest_file_from_directory($dir);
        Data::compile_manifest_to_php($path);
    }


    /**
     * Expand glob with the absolute path of asset source dir.
     * Returns relative path to the manifest.
     *
     * @param string $dir
     * @param string $glob
     *
     * @return array
     */
    static function expand_glob_from_dir($dir, $glob)
    {
        $files = glob($dir . DIRECTORY_SEPARATOR . $glob);
        return \futil_paths_remove_basepath($files, $dir . DIRECTORY_SEPARATOR );
        // return self::remove_basedir_from_paths($files, $dir);
    }



    /**
     * Remove base directory path from paths
     *
     * @param array $paths paths
     * @param string $basedir
     * @return array paths
     */
    static function remove_basedir_from_paths($paths,$basedir)
    {
        // return \futil_paths_remove_basepath($paths, $basedir . DIRECTORY_SEPARATOR );
        return array_map(function($item) use ($basedir) {
            return substr($item,strlen($basedir) + 1);
        }, $paths );
    }


    /**
     * Expand a directory by traverse it recursively.
     *
     * @param string $dir
     *
     * @return array
     */
    static function expand_dir_recursively($dir)
    {
        // expand files from dir
        $ite = new RecursiveDirectoryIterator($dir);
        $expanded = array();
        foreach (new RecursiveIteratorIterator($ite) as $path => $info) {
            if ( $info->getFilename() === '.' || $info->getFilename() === '..' )
                continue;
            $expanded[] = $path;
        }
        return $expanded;
    }

    static function mkdir_for_file($file, $mask = 0755)
    {
        $dir = dirname($file);
        if( ! file_exists($dir) ) {
            return mkdir($dir, $mask , true);
        }
        return true;
    }

    static function rmtree( $paths )
    {
        $paths = (array) $paths;
        foreach( $paths as $path ) {
            \futil_rmtree($path);
        }
        return true;
    }


}

<?php
namespace AssetKit\Filter;
use AssetKit\AssetUrlBuilder;
use AssetKit\AssetConfig;
use AssetKit\Asset;
use AssetKit\Collection;

abstract class BaseFilter
{
    protected $config;

    public function __construct(AssetConfig $config) { 
        $this->config = $config;
    }

    abstract public function filter(Collection $collection);
}

<?php
namespace AssetKit\Filter;
use RuntimeException;
use AssetKit\Process;
use AssetKit\Utils;
use AssetKit\AssetConfig;
use AssetKit\Collection;

class CoffeeScriptFilter extends BaseFilter
{
    public $coffeescript;
    public $nodejs;

    public function __construct(AssetConfig $config, $bin = null, $nodejs = null )
    {
        if ( $bin ) {
            $this->coffeescript = $bin;
        } else {
            $this->coffeescript = Utils::findbin('coffee');
        }
        if ( $nodejs ) {
            $this->nodejs = $nodejs;
        } else {
            $this->nodejs = Utils::findbin('node');
        }
        parent::__construct($config);
    }

    public function filter(Collection $collection)
    {
        if( $collection->filetype !== Collection::FileTypeCoffee ) {
            return;
        }

        $input = $collection->getContent();
        $proc = null;
        if( $this->nodejs ) {
            $proc = new Process(array( $this->nodejs, $this->coffeescript ));
        }
        else {
            $proc = new Process(array( $this->coffeescript ));
        }

        // compile and print to stdout
        $proc->arg( '-cp' )->arg('--stdio')->input($input);

        $code = $proc->run();

        if ( $code != 0 ) {
            throw new RuntimeException("CoffeeScriptFilter failure: $code");
        }

        $content = $proc->getOutput();
        $collection->setContent($content);
    }
}


<?php
namespace AssetKit\Filter;
use AssetKit\AssetUrlBuilder;
use AssetKit\AssetConfig;
use AssetKit\Asset;
use AssetKit\Collection;

class CssImportFilter extends BaseFilter
{
    const DEBUG = 0;

    public $assetBaseUrl;

    public function __construct(AssetConfig $config, $assetBaseUrl) {
        $this->assetBaseUrl = $assetBaseUrl;
        parent::__construct($config);
    }

    public function importCss($content, $fullpath, $assetSourceDir, $dirname, $dirnameUrl, $assetBaseUrl)
    {
        if (CssImportFilter::DEBUG) {
            echo "Importing from $fullpath\n";
        }

        // we should rewrite url( ) paths first, before we import css contents
        $rewrite = new CssRewriteFilter($this->config, $assetBaseUrl);
        $content = $rewrite->rewrite($content, $dirnameUrl);

        $self = $this;

        /**
         * Look for things like:
         *    @import url("jquery.ui.core.css");
         *    @import "jquery.ui.core.css";
         */
        $content = preg_replace_callback('#
            @import
            \s+
                (?:
                    url\(
                        (\'|"|)
                            (?<url>.*?)
                        \1
                    \)
                |
                    ([\'"])
                        (?<url2>.*?)
                    \3
                )
                \s*;
            #xs',

            /**
             * @param string $fullpath Current CSS file to parse import statement.
             * @param string $dirname The directory path of current CSS file.
             */
            function($matches) use ($fullpath, $assetSourceDir, $dirname, $dirnameUrl, $assetBaseUrl, $self) {
                if(CssImportFilter::DEBUG)
                    echo "--> Found {$matches[0]}\n";

                // echo "CSS File $file <br/>";
                // var_dump( $matches );

                $url = $matches['url'] ?: $matches['url2'];


                if(CssImportFilter::DEBUG)
                    echo "--> Importing css from $url\n";

                $content = "/* IMPORT FROM $url */" . PHP_EOL;
                if( preg_match( '#^https?://#' , $url ) ) {
                    // TODO: recursivly import from remote paths
                    $content .= file_get_contents( $url );
                } else {
                    // For css import filter, we need absolute absolute dirname path to import.
                    // For css rewrite filter, we need a relative dirname path to rewrite.
                    $fullDirname = $assetSourceDir . DIRECTORY_SEPARATOR . $dirname;

                    // resolve the relative url
                    $pathParts = explode( DIRECTORY_SEPARATOR, $dirname);
                    $newUrl = $url;
                    while ( 0 === strpos($newUrl, '../') ) {
                        // 2 <= substr_count($dirname, '/'))
                        array_pop($pathParts);
                        $newUrl = substr($newUrl, 3);
                    }
                    $newPath = join( DIRECTORY_SEPARATOR, $pathParts ) . '/' . $newUrl;
                    $newDirname = dirname($newPath);
                    $newDirnameUrl = $assetBaseUrl . '/' . $newDirname;
                    $newFullpath = $assetSourceDir . DIRECTORY_SEPARATOR . $newPath;

                    if(CssImportFilter::DEBUG) {
                        echo $url , " => " , $newPath , "\n";
                    }

                    $newContent = file_get_contents($newFullpath);

                    /* Import recursively */
                    $content .= $self->importCss($newContent, $newFullpath, $assetSourceDir, $newDirname , $newDirnameUrl, $assetBaseUrl);
                }
                return $content;
        }, $content );

        return $content;
    }

    public function filter(Collection $collection)
    {
        if ( ! $collection->isStylesheet ) {
            return;
        }


        // get css files and find @import statement to import related content
        $assetSourceDir = $collection->sourceDir;
        $chunks = $collection->getChunks();
        foreach( $chunks as &$chunk ) {
            $fullpath = $chunk['fullpath'];

            // the dirname of the file (absolute)
            $dirname = dirname($chunk['path']);

            // url to the directory of the asset.
            $dirnameUrl = $this->assetBaseUrl . '/' . $dirname;

            $chunk['content'] = $this->importCss(
                $chunk['content'],
                $fullpath, 
                $assetSourceDir, 
                $dirname, 
                $dirnameUrl, 
                $this->assetBaseUrl);
        }
        $collection->setChunks($chunks);
    }

}

<?php
namespace AssetKit\Filter;
use AssetKit\AssetConfig;
use AssetKit\AssetUrlBuilder;
use AssetKit\Collection;

/**
 * Rewrite css url to absolute url (from root path)
 *
 * 1. read css files from asset source dir.
 * 2. parse url(s).
 * 3. rewrite assets.
 * 4. set content.
 *
 * To use CssRewriteFilter with your own content:
 *
 *    $rewrite = new CssRewriteFilter($config, '/assets/jquery');
 *    $rewrite->rewrite( $yourContent, '/url/to/your/asset/file' );
 *
 * To use CssRewriteFilter with collection object:
 *
 *    $rewrite = new CssRewriteFilter($config, '/assets/jquery');
 *    $rewrite->filter( $collection );
 *    $css = $collection->getContent();
 *
 */
class CssRewriteFilter extends BaseFilter
{
    const DEBUG = 0;

    public $rewriteBaseUrl = '/';

    /**
     * @param string $rewriteBaseUrl path:  /assets/{asset name}
     */
    public function __construct(AssetConfig $config, $rewriteBaseUrl = '/') {
        $this->rewriteBaseUrl = $rewriteBaseUrl;
        parent::__construct($config);
    }


    /**
     * Rewrite css url paths from css content.
     *
     * This method parses css content ($content), finds url(..) by patterns,
     * Resolve the relative URL to the absolute URL based on the dirnameUrl 
     * we've provided, e.g.,
     *
     * In the css file assets/product/css/product.css.
     *
     * If the below css rule is found:
     *
     *     background: url(../images/bg.png);
     *
     * Then we resolve the "../images/bg.png" path to got the parent 
     * url path:
     *
     *    /product/css => /product
     *
     * Then we concat the url path with the base url that we just found:
     *
     *    /product       + "/images/bg.png"
     *
     * @param string $content  stylesheet content.
     * @param string $dirnameUrl the url of the diretory
     */
    public function rewrite($content, $dirnameUrl)
    {
        return preg_replace_callback('#
            url\(
                (\'|"|)
                (?<url>.*?)
                \1
            \)
            #xs',
            function($matches) use($dirnameUrl)
            {
                $url = $matches['url'];

                // do not rewrite @import css syntax
                if ( preg_match('/\.css$/',$url) ) {
                    return $matches[0];
                }

                // do not rewrite
                // if it's already an absolute path.
                if ( '/' === $url[0] ) {
                    return $matches[0];
                }


                $origUrl = $url;

                // rewrite with public asset baseurl
                $urlParts = explode('/',$dirnameUrl);
                while (0 === strpos($url, '../') ) {
                    array_pop($urlParts);
                    $url = substr($url, 3);
                }
                $dirnameUrl = join('/', $urlParts );
                $url = $dirnameUrl . '/' . $url;

                if (CssRewriteFilter::DEBUG) {
                    echo "Rewriting " , $origUrl , " to " , $url , "\n";
                }

                // replace the found string with the new absolute url.
                return str_replace( $matches['url'], $url , $matches[0]);
            }, $content );
    }



    /**
     * To retrieve file contents, because we need the base dir path 
     * to resolve paths.
     *
     * @param Collection $collection
     */
    public function filter(Collection $collection)
    {
        if ( ! $collection->isStylesheet )
            return;

        $chunks = $collection->getChunks();
        foreach( $chunks as &$chunk ) {
            $chunk['content'] = $this->rewrite( 
                $chunk['content'],
                // url to the directory of the asset.
                $this->rewriteBaseUrl . '/' . dirname($chunk['path'])
            );
        }
        $collection->setChunks($chunks);
    }

}


<?php
namespace AssetKit\Filter;
use AssetKit\Collection;
use AssetKit\Process;
use AssetKit\AssetConfig;
use AssetKit\AssetUrlBuilder;
use RuntimeException;
use AssetKit\Utils;

use Symfony\Component\Process\ProcessBuilder;

class SassFilter extends BaseFilter
{
    public $bin;

    public $fromFile = true;

    public $loadPaths = array();

    public $enableCompass = true;

    public $style;

    public $rewrite = true;

    public $debug = false;

    /**
     * $assetBaseUrl
     */
    public $rewriteBaseUrl;

    public function __construct(AssetConfig $config, $rewriteBaseUrl, $bin = null)
    {
        if ( $bin ) {
            $this->bin = $bin;
        } else {
            $this->bin = Utils::findbin('sass');
        }

        $this->rewriteBaseUrl = $rewriteBaseUrl;

        parent::__construct($config);
    }

    public function setDebug($bool)
    {
        $this->debug = $bool;
    }

    public function setCompass($bool)
    {
        $this->enableCompass = $bool;
    }

    public function addLoadPath($path)
    {
        $this->loadPaths[] = $path;
    }


    /**
     * Set SASS output style
     *
     * @param string $style compact, compressed, or expanded.
     */
    public function setStyle($style)
    {
        $this->style = $style;
    }

    public function createProcess()
    {
        $proc = new Process(array( $this->bin ));

        if ($this->enableCompass) {
            $proc->arg('--compass');
        }

        foreach( $this->loadPaths as $path ) {
            $proc->arg('--load-path');
            $proc->arg($path);
        }

        if ( $this->debug ) {
            $proc->arg('--debug-info');
        }

        if ( $this->style ) {
            $proc->arg('--style')->arg($this->style);
        }
        return $proc;
    }

    public function filter(Collection $collection)
    {
        if ($collection->filetype !== Collection::FileTypeSass) {
            return;
        }

        $chunks = $collection->getChunks();
        foreach( $chunks as &$chunk ) {
            $proc = $this->createProcess();
            $proc->arg('--load-path');
            $proc->arg( dirname($chunk['fullpath']) );
            $proc->arg('-s'); // use stdin
            $proc->input($chunk['content']);

            // echo $proc->getCommand();
            $code = $proc->run();
            if ( $code != 0 ) {
                throw new RuntimeException("SassFilter failure: $code. Command: " . $proc->getCommand() . " Output:" . $proc->getOutput());
            }
            $output = $proc->getOutput();

            if ( $this->rewrite ) {
                $rewrite = new CssRewriteFilter($this->config, $this->rewriteBaseUrl);
                $output = $rewrite->rewrite( $output, $this->rewriteBaseUrl . '/' . dirname($chunk['path']) );
            }

            $chunk['content'] = $output;
        }
        $collection->setChunks($chunks);
    }

}

<?php
namespace AssetKit\Filter;
use AssetKit\Process;
use AssetKit\Utils;
use RuntimeException;

class ScssFilter extends SassFilter
{
    public function __construct($bin = null)
    {
        if ( $bin ) {
            $this->bin = $bin;
        } else {
            $this->bin = Utils::findbin('scss');
        }
    }
}
<?php
namespace AssetKit;
use AssetKit\FileUtil;

class Installer
{
    public $enableLog = false;
    public $logger;
    public $config;

    public function __construct(AssetConfig $config) {
        $this->config = $config;
    }

    /**
     * Get target installation dir (the target directory of public)
     */
    public function getAssetInstallDir(Asset $asset, $absolute = false) {
        return $this->config->getBaseDir(true) . DIRECTORY_SEPARATOR . $asset->name;
    }



    public function setLogger($logger) 
    {
        $this->logger = $logger;
    }

    protected function debug($msg)
    {
        if ($this->logger) {
            $this->logger->debug( $msg );
        } else {
            echo $msg , "\n";
        }
    }

    protected function info($msg)
    {
        if( $this->logger ) {
            $this->logger->info( $msg );
        } else {
            echo $msg , "\n";
        }
    }


    public function uninstall(Asset $asset)
    {
        // get asset files and copy them into 
        $fromDir = $asset->sourceDir;
        $n       = $asset->name;

        // install into public asset root.
        foreach( $asset->getCollections() as $collection ) {
            foreach( $collection->getFilePaths() as $path ) {
                $subpath = $path;
                $srcFile = $fromDir . DIRECTORY_SEPARATOR . $subpath;
                $targetFile = $this->getAssetInstallDir($asset, true) . DIRECTORY_SEPARATOR . $subpath;

                $this->info("x $targetFile");
                if( file_exists($targetFile) ) {
                    unlink( $targetFile );
                }
            }
        }
    }

    public function install(Asset $asset)
    {
        // get asset files and copy them into 
        $fromDir = $asset->sourceDir;
        $n       = $asset->name;

        // install into public asset root.
        foreach( $asset->getCollections() as $collection ) {
            foreach( $collection->getFilePaths() as $path ) {
                $subpath = $path;
                $srcFile = $fromDir . DIRECTORY_SEPARATOR . $subpath;

                if( ! file_exists($srcFile) ) {
                    $this->info("$srcFile not found.");
                    continue;
                }

                $targetFile = $this->getAssetInstallDir($asset, true) . DIRECTORY_SEPARATOR . $subpath;

                $content = file_get_contents($srcFile);
                if( file_exists($targetFile) ) {
                    $contentOrig = file_get_contents($targetFile);
                    if( ($chk1 = md5($content)) !== ($chk2 = md5($contentOrig)) ) {
                        echo "Checksum mismatch: \n";
                        echo "$chk2: $targetFile (original)\n";
                        echo "$chk1: $targetFile\n";
                        echo ">> Overwrite ? (Y/n) ";
                        $line = trim(fgets(STDIN));
                        if( $line == "n" ) {
                            echo "Skip\n";
                            continue;
                        }
                    }
                    else {
                        // skip existing files
                        $this->info("- $targetFile");
                        continue;
                    }
                }
                FileUtil::mkdir_for_file( $targetFile );
                $this->info("x $targetFile");
                file_put_contents( $targetFile , $content ) or die("$targetFile write failed.");
            }
        }
    }
}


<?php
namespace AssetKit;
use Exception;

/**
 * jsmin.php - PHP implementation of Douglas Crockford's JSMin.
 *
 * This is pretty much a direct port of jsmin.c to PHP with just a few
 * PHP-specific performance tweaks. Also, whereas jsmin.c reads from stdin and
 * outputs to stdout, this library accepts a string as input and returns another
 * string as output.
 *
 * PHP 5 or higher is required.
 *
 * Permission is hereby granted to use this version of the library under the
 * same terms as jsmin.c, which has the following license:
 *
 * --
 * Copyright (c) 2002 Douglas Crockford  (www.crockford.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * The Software shall be used for Good, not Evil.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * --
 *
 * @package JSMin
 * @author Ryan Grove <ryan@wonko.com>
 * @copyright 2002 Douglas Crockford <douglas@crockford.com> (jsmin.c)
 * @copyright 2008 Ryan Grove <ryan@wonko.com> (PHP port)
 * @license http://opensource.org/licenses/mit-license.php MIT License
 * @version 1.1.1 (2008-03-02)
 * @link https://github.com/rgrove/jsmin-php/
 */

class JSMin {
  const ORD_LF            = 10;
  const ORD_SPACE         = 32;
  const ACTION_KEEP_A     = 1;
  const ACTION_DELETE_A   = 2;
  const ACTION_DELETE_A_B = 3;

  protected $a           = '';
  protected $b           = '';
  protected $input       = '';
  protected $inputIndex  = 0;
  protected $inputLength = 0;
  protected $lookAhead   = null;
  protected $output      = '';

  // -- Public Static Methods --------------------------------------------------

  /**
   * Minify Javascript
   *
   * @uses __construct()
   * @uses min()
   * @param string $js Javascript to be minified
   * @return string
   */
  public static function minify($js) {
    $jsmin = new JSMin($js);
    return $jsmin->min();
  }

  // -- Public Instance Methods ------------------------------------------------

  /**
   * Constructor
   *
   * @param string $input Javascript to be minified
   */
  public function __construct($input) {
    $this->input       = str_replace("\r\n", "\n", $input);
    $this->inputLength = strlen($this->input);
  }

  // -- Protected Instance Methods ---------------------------------------------

  /**
   * Action -- do something! What to do is determined by the $command argument.
   *
   * action treats a string as a single character. Wow!
   * action recognizes a regular expression if it is preceded by ( or , or =.
   *
   * @uses next()
   * @uses get()
   * @throws JSMinException If parser errors are found:
   *         - Unterminated string literal
   *         - Unterminated regular expression set in regex literal
   *         - Unterminated regular expression literal
   * @param int $command One of class constants:
   *      ACTION_KEEP_A      Output A. Copy B to A. Get the next B.
   *      ACTION_DELETE_A    Copy B to A. Get the next B. (Delete A).
   *      ACTION_DELETE_A_B  Get the next B. (Delete B).
  */
  protected function action($command) {
    switch($command) {
      case self::ACTION_KEEP_A:
        $this->output .= $this->a;

      case self::ACTION_DELETE_A:
        $this->a = $this->b;

        if ($this->a === "'" || $this->a === '"') {
          for (;;) {
            $this->output .= $this->a;
            $this->a       = $this->get();

            if ($this->a === $this->b) {
              break;
            }

            if (ord($this->a) <= self::ORD_LF) {
              throw new JSMinException('Unterminated string literal.');
            }

            if ($this->a === '\\') {
              $this->output .= $this->a;
              $this->a       = $this->get();
            }
          }
        }

      case self::ACTION_DELETE_A_B:
        $this->b = $this->next();

        if ($this->b === '/' && (
            $this->a === '(' || $this->a === ',' || $this->a === '=' ||
            $this->a === ':' || $this->a === '[' || $this->a === '!' ||
            $this->a === '&' || $this->a === '|' || $this->a === '?' ||
            $this->a === '{' || $this->a === '}' || $this->a === ';' ||
            $this->a === "\n" )) {

          $this->output .= $this->a . $this->b;

          for (;;) {
            $this->a = $this->get();

            if ($this->a === '[') {
              /*
                inside a regex [...] set, which MAY contain a '/' itself. Example: mootools Form.Validator near line 460:
                  return Form.Validator.getValidator('IsEmpty').test(element) || (/^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]\.?){0,63}[a-z0-9!#$%&'*+/=?^_`{|}~-]@(?:(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)*[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\])$/i).test(element.get('value'));
              */
              for (;;) {
                $this->output .= $this->a;
                $this->a = $this->get();

                if ($this->a === ']') {
                    break;
                } elseif ($this->a === '\\') {
                  $this->output .= $this->a;
                  $this->a       = $this->get();
                } elseif (ord($this->a) <= self::ORD_LF) {
                  throw new JSMinException('Unterminated regular expression set in regex literal.');
                }
              }
            } elseif ($this->a === '/') {
              break;
            } elseif ($this->a === '\\') {
              $this->output .= $this->a;
              $this->a       = $this->get();
            } elseif (ord($this->a) <= self::ORD_LF) {
              throw new JSMinException('Unterminated regular expression literal.');
            }

            $this->output .= $this->a;
          }

          $this->b = $this->next();
        }
    }
  }

  /**
   * Get next char. Convert ctrl char to space.
   *
   * @return string|null
   */
  protected function get() {
    $c = $this->lookAhead;
    $this->lookAhead = null;

    if ($c === null) {
      if ($this->inputIndex < $this->inputLength) {
        $c = substr($this->input, $this->inputIndex, 1);
        $this->inputIndex += 1;
      } else {
        $c = null;
      }
    }

    if ($c === "\r") {
      return "\n";
    }

    if ($c === null || $c === "\n" || ord($c) >= self::ORD_SPACE) {
      return $c;
    }

    return ' ';
  }

  /**
   * Is $c a letter, digit, underscore, dollar sign, or non-ASCII character.
   *
   * @return bool
   */
  protected function isAlphaNum($c) {
    return ord($c) > 126 || $c === '\\' || preg_match('/^[\w\$]$/', $c) === 1;
  }

  /**
   * Perform minification, return result
   *
   * @uses action()
   * @uses isAlphaNum()
   * @return string
   */
  protected function min() {
    $this->a = "\n";
    $this->action(self::ACTION_DELETE_A_B);

    while ($this->a !== null) {
      switch ($this->a) {
        case ' ':
          if ($this->isAlphaNum($this->b)) {
            $this->action(self::ACTION_KEEP_A);
          } else {
            $this->action(self::ACTION_DELETE_A);
          }
          break;

        case "\n":
          switch ($this->b) {
            case '{':
            case '[':
            case '(':
            case '+':
            case '-':
              $this->action(self::ACTION_KEEP_A);
              break;

            case ' ':
              $this->action(self::ACTION_DELETE_A_B);
              break;

            default:
              if ($this->isAlphaNum($this->b)) {
                $this->action(self::ACTION_KEEP_A);
              }
              else {
                $this->action(self::ACTION_DELETE_A);
              }
          }
          break;

        default:
          switch ($this->b) {
            case ' ':
              if ($this->isAlphaNum($this->a)) {
                $this->action(self::ACTION_KEEP_A);
                break;
              }

              $this->action(self::ACTION_DELETE_A_B);
              break;

            case "\n":
              switch ($this->a) {
                case '}':
                case ']':
                case ')':
                case '+':
                case '-':
                case '"':
                case "'":
                  $this->action(self::ACTION_KEEP_A);
                  break;

                default:
                  if ($this->isAlphaNum($this->a)) {
                    $this->action(self::ACTION_KEEP_A);
                  }
                  else {
                    $this->action(self::ACTION_DELETE_A_B);
                  }
              }
              break;

            default:
              $this->action(self::ACTION_KEEP_A);
              break;
          }
      }
    }

    return $this->output;
  }

  /**
   * Get the next character, skipping over comments. peek() is used to see
   *  if a '/' is followed by a '/' or '*'.
   *
   * @uses get()
   * @uses peek()
   * @throws JSMinException On unterminated comment.
   * @return string
   */
  protected function next() {
    $c = $this->get();

    if ($c === '/') {
      switch($this->peek()) {
        case '/':
          for (;;) {
            $c = $this->get();

            if (ord($c) <= self::ORD_LF) {
              return $c;
            }
          }

        case '*':
          $this->get();

          for (;;) {
            switch($this->get()) {
              case '*':
                if ($this->peek() === '/') {
                  $this->get();
                  return ' ';
                }
                break;

              case null:
                throw new JSMinException('Unterminated comment.');
            }
          }

        default:
          return $c;
      }
    }

    return $c;
  }

  /**
   * Get next char. If is ctrl character, translate to a space or newline.
   *
   * @uses get()
   * @return string|null
   */
  protected function peek() {
    $this->lookAhead = $this->get();
    return $this->lookAhead;
  }
}

// -- Exceptions ---------------------------------------------------------------
class JSMinException extends Exception {}
<?php
namespace AssetKit;
use AssetKit\FileUtil;

class LinkInstaller extends Installer
{
    public function uninstall(Asset $asset)
    {
        $name       = $asset->name;
        $targetDir = $this->getAssetInstallDir($asset, true);
        if (file_exists($targetDir)) {
            $this->info("Removing $targetDir");
            if (is_link($targetDir) ) {
                unlink($targetDir);
            } else {
                return \futil_rmtree($targetDir);
            }
        }
    }

    public function install(Asset $asset)
    {
        // asset name
        $name       = $asset->name;
        $targetDir = $this->getAssetInstallDir($asset, true);
        $sourceDir  = $asset->getSourceDir(true);

        // simply use symbol link
        FileUtil::mkdir_for_file($targetDir);

        // Remove the previously created symlink files
        if (is_link($targetDir)) {
            unlink($targetDir);
        } else if (is_dir($targetDir)) {
            \futil_rmtree($targetDir);
            if (file_exists($targetDir)) {
                rmdir($targetDir);
            }
        }

        $this->info('Creating symlink at ' . $targetDir . ' for ' . realpath($sourceDir) );
        // echo realpath($sourceDir) , " => " , $targetDir , "\n";
        symlink(realpath($sourceDir),$targetDir) or die("$targetDir link failed.");
        return array(
            'src' => $sourceDir,
            'dst' => $targetDir,
        );
    }

}



<?php
namespace AssetKit;
use RuntimeException;

/**
 * althrough Symfony'Process is pretty good,
 * but don't like to depend on composer and pear (for both)
 *
 * so this is a simple/lightweight class for proc_open function.
 */
class Process
{
    public $args = array();

    public $input;

    public $output;

    public $error;

    public $cwd;

    public $env = array();

    public function __construct($args) 
    {
        $this->args = $args;
        $this->cwd = getcwd();
    }

    public function arg($arg)
    {
        $this->args[] = $arg;
        return $this;
    }

    public function input($input)
    {
        $this->input = $input;
        return $this;
    }

    public function env($name,$value)
    {
        $this->env[ $name ] = $value;
        return $this;
    }

    public function cwd($cwd)
    {
        $this->cwd = $cwd;
        return $this;
    }

    public function getError()
    {
        return $this->error;
    }

    public function getOutput()
    {
        return $this->output;
    }

    public function getCommand()
    {
        return join(' ', array_map(function($arg) { 
                return escapeshellarg($arg);
                    } ,$this->args));
    }

    public function run()
    {
        $descriptorspec = array(
            0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
            1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
            // 2 => array("file", "/tmp/error-output.txt", "a") // stderr is a file to write to
            2 => array('pipe', 'w')
        );

        $command = $this->getCommand();
        $pipes = array();
        // $process = proc_open($command, $descriptorspec, $pipes, $this->cwd, $this->env);
        $process = proc_open($command, $descriptorspec, $pipes, $this->cwd);

        if (is_resource($process)) {
            // $pipes now looks like this:
            // 0 => writeable handle connected to child stdin
            // 1 => readable handle connected to child stdout
            // Any error output will be appended to /tmp/error-output.txt
            fwrite($pipes[0], $this->input );
            fclose($pipes[0]); // close input

            $this->output = stream_get_contents($pipes[1]);
            $this->error = stream_get_contents($pipes[2]);
            fclose($pipes[1]);
            fclose($pipes[2]); // close stderr

            // It is important that you close any pipes before calling
            // proc_close in order to avoid a deadlock
            $returnValue = proc_close($process);
        }
        else {
            throw new RuntimeException;
        }
        return $returnValue;
    }

}


<?php
namespace AssetKit;
use ConfigKit\ConfigCompiler;
use AssetKit\FileUtil;
use AssetKit\AssetUrlBuilder;
use AssetKit\Collection;
use AssetKit\AssetCollection;
use AssetKit\Asset;

// Filters
use AssetKit\Filter\SassFilter;
use AssetKit\Filter\ScssFilter;
use AssetKit\Filter\CoffeeScriptFilter;
use AssetKit\Filter\CssImportFilter;

// Compressors
use AssetKit\Compressor\Yui\JsCompressor as YuiJsCompressor;
use AssetKit\Compressor\Yui\CssCompressor as YuiCssCompressor;

// Exceptions
use AssetKit\Exception\UndefinedFilterException;
use AssetKit\Exception\UndefinedCompressorException;
use AssetKit\Exception\UnwritableFileException;
use Exception;
use RuntimeException;
use InvalidArgumentException;

function str_format($format, $args) {
    return str_replace(array_keys($args), array_values($args), $format);
}

class ProductionAssetCompiler extends AssetCompiler
{

    /**
     * @var string checksum algorithm, used for squashed css/js content.
     */
    public $checksumAlgo = 'md5';


    /**
     * @var boolean Create compiled directory if it does not exist.
     */
    public $autoPrepareCompiledDir = true;

    /**
     * @var boolean Change the permission mode of compiled directory everytime 
     *              when preparing compiled directory. this is useful for debugging.
     */
    public $chmodCompiledDir = true;

    public $defaultCompiledDirMod = 0777;

    public $targetMinFilenameFormat = '%target%-%checksum%.min.%ext%';

    public function __construct(AssetConfig $config, AssetLoader $loader) {
        parent::__construct($config, $loader);

        if ($this->autoPrepareCompiledDir) {
            $this->prepareCompiledDir();
        }
    }


    /**
     * Set checksum algorithm for generating content checksum
     *
     * @param string $algo
     */
    public function setChecksumAlgorithm($algo)
    {
        $this->checksumAlgo = $algo;
    }




    /**
     * @var boolean enable fstat check in production mode.
     *
     * You can simply restart your fpm or apache server to reset 
     * the APC cache. or enable this option to check fstat in 
     * every request.
     *
     * We prefer clean up manifest cache manually, because fstat checking
     * might consume a lot of I/O.
     */
    public $checkFstat = false;


    /**
     * Cache mode: Use simple PHP config 
     */
    const CACHE_METAFILE = 1;

    /**
     * Cache mode: Use UniversalCache\UniversalCache to caceh the compilation result.
     */
    const CACHE_UNIVERSAL = 2;

    /**
     * @var integer define the cache type
     */
    public $cacheType = self::CACHE_METAFILE;

    public function enableFstatCheck()
    {
        $this->checkFstat = true;
    }

    public function fstatCheckEnabled() {
        return $this->checkFstat;
    }


    public function assetsAreOutOfDate(array $assets, $mtime) {
        foreach( $assets as $asset ) {
            if ( $asset->isOutOfDate($mtime) ) {
                return true;
            }
        }
        return false;
    }



    /**
     * Return the meta filename for target
     *
     * @param string $target
     */
    public function buildTargetMetaFilename($target) {
        return '.target-' . $target . '.meta.php';
    }


    /**
     * Return the meta filename for asset
     *
     * @param Asset $asset
     */
    public function buildAssetMetaFilename(Asset $asset) {
        return ".asset-" . $asset->name . '.meta.php';
    }

    /**
     * Build the filename for minified content.
     *
     * @param string $target
     * @param string $checksum
     * @param string $ext     content type: js, css
     */
    public function buildTargetMinFilename($target, $checksum, $ext) {
        return str_format($this->targetMinFilenameFormat, array(
            '%target%' => $target,
            '%checksum%' => $checksum,
            '%ext%' => $ext,
        ));
    }


    /**
     * Compile multiple assets into the target path.
     *
     * For example, compiling:
     *
     *    - jquery
     *    - jquery-ui
     *    - blueprint
     *
     * Which generates
     *
     *   /assets/{target}/{md5}.min.css
     *   /assets/{target}/{md5}.min.js
     *
     * The compiled manifest is stored in APC or in the file cache.
     * So that if the touch time stamp is updated. AssetCompiler 
     * will re-compile these stuff.
     *
     * @param Asset[] $assets
     * @param string $target target name
     * @param boolean $force force compilation
     */
    public function compileAssets(array $assets, $target = null, $force = false)
    {
        $targetDefined = $target ? true : false;
        if (! $target ) {
            $target = $this->generateTargetNameFromAssets($assets);
        }

        $compiledDir = $this->config->getCompiledDir();
        $compiledUrl = $this->config->getCompiledUrl();
        $metaFile = $compiledDir . DIRECTORY_SEPARATOR . $this->buildTargetMetaFilename($target);
        $cacheKey = $this->config->getNamespace() . ':target:' . $target;

        if (!$force) {
            $cached = NULL;
            if ($this->cacheType === self::CACHE_METAFILE && file_exists($metaFile)) {
                $cached = require $metaFile;
            } else if ($this->cacheType === self::CACHE_UNIVERSAL) { 
                if ($cache = $this->config->getCache()) {
                    $cached = $cache->get($cacheKey);
                }
            }

            if ($cached) {
                if (! $this->checkFstat || ! isset($cached['mtime'])) {
                    return $cached;
                }
                if (! $this->assetsAreOutOfDate($assets, $cached['mtime'])) {
                    return $cached;
                }
            }

        }

        $contents = array( 'js' => '', 'css' => '' );
        $assetNames = array();
        foreach( $assets as $asset ) {
            $assetNames[] = $asset->name;

            // get manifest after compiling
            $m = $this->compile($asset, $force);

            // concat results from manifest
            if (isset($m['js_file']) ) {
                $contents['js'] .= file_get_contents($m['js_file']) . ";\n";
            }
            if (isset($m['css_file']) ) {
                $contents['css'] .= file_get_contents($m['css_file']) . "\n";
            }
        }

        // register target (assets) to the config, if it's not defaultTarget and the config file name is defined.
        if ($this->autoAddUnknownTarget && $targetDefined && ! $this->loader->entries->hasTarget($target)) {
            $this->loader->entries->addTarget($target, $assetNames);
            $this->loader->saveEntries();
        }

        $entry = array();

        // write minified results to file
        if ($contents['js']) {
            $entry['js_checksum'] = hash($this->checksumAlgo, $contents['js']);
            $filename = $this->buildTargetMinFilename($target, $entry['js_checksum'], 'js');
            $entry['js_file'] = $compiledDir . DIRECTORY_SEPARATOR . $filename;
            $entry['js_url']  = "$compiledUrl/" . $filename;
            if (false === file_put_contents($entry['js_file'], $contents['js'], LOCK_EX)) {
                throw new Exception("Can't write file '{$entry['js_file']}'");
            }
        }

        if ($contents['css']) {
            $entry['css_checksum'] = hash($this->checksumAlgo, $contents['css']);
            $filename = $this->buildTargetMinFilename($target, $entry['css_checksum'], 'css');
            $entry['css_file'] = $compiledDir . DIRECTORY_SEPARATOR . $filename;
            $entry['css_url'] = "$compiledUrl/" . $filename;
            if (false === file_put_contents($entry['css_file'], $contents['css'], LOCK_EX) ) {
                throw new Exception("Can't write file '{$entry['css_file']}'");
            }
        }


        $entry['assets']  = $assetNames;
        $entry['mtime']   = time();
        $entry['cache_key'] = $cacheKey;
        $entry['target'] = $target;
        $entry['metafile'] = $metaFile;

        // include entries
        $entries = array($entry);

        if ($this->cacheType === self::CACHE_UNIVERSAL) {
            if ( $cache = $this->config->getCache() ) {
                $cache->set($cacheKey, $entries);
            }
        }
        // always write the meta file
        ConfigCompiler::write($entry['metafile'], $entries);
        return $entries;
    }




    /**
     * Compile single asset
     * This is for production mode.
     *
     * For example:
     *
     * baseDir: public/assets
     * baseUrl: /assets
     *
     * And the asset directory:
     *
     * assets/jquery
     * assets/jquery/manifest.yml
     * assets/jquery/jquery-1.8.2.js
     *
     * Will be compiled into:
     *
     * public/assets/jquery/jquery.min.js
     *
     * @return array
     *
     *    {
     *      css: [string] minified css content.
     *      js:  [string] minified js content.
     *      css_file: [string] minified css file.
     *      js_file:  [string] minified js file.
     *      css_url: [string] minified css url.
     *      js_url:  [string] minified js url.
     *      mtime: [integer] the last modification time.
     *    }
     *
     */
    public function compile(Asset $asset, $force = false) 
    {
        $compiledDir = $this->config->getCompiledDir();
        $compiledUrl = $this->config->getCompiledUrl();
        $metaFile = $compiledDir . DIRECTORY_SEPARATOR . $this->buildAssetMetaFilename($asset);

        if (! $force && file_exists($metaFile)) {
            $cached = require $metaFile;
            if ( ! $this->checkFstat || ! isset($cached['mtime']) ) {
                return $cached;
            }
            if ( ! $asset->isOutOfDate($cached['mtime']) ) {
                return $cached;
            }
        }

        $prefixName = $asset->name . '.min';
        $jsFile = $compiledDir . DIRECTORY_SEPARATOR . $prefixName . '.js';
        $cssFile = $compiledDir . DIRECTORY_SEPARATOR . $prefixName . '.css';
        $jsUrl = $compiledUrl . "/$prefixName.js";
        $cssUrl = $compiledUrl . "/$prefixName.css";

        /*
        $fp = fopen($jsFile, "w");
        if (flock($fp, LOCK_EX, $wouldBlock)) {  }
        */

        $out = $this->squash($asset);
        if ($out['js']) {
            $out['js_file'] = $jsFile;
            $out['js_url'] = $jsUrl;
            if (false === file_put_contents($jsFile, $out['js'], LOCK_EX)) {
                throw new Exception("Can't write file '$jsFile'");
            }
            unset($out['js']);
        }
        if ($out['css']) {
            $out['css_file'] = $cssFile;
            $out['css_url'] = $cssUrl;
            if (false === file_put_contents($cssFile , $out['css'], LOCK_EX)) {
                throw new Exception("Can't write file '$cssFile'");
            }
            unset($out['css']);
        }

        // store cache
        ConfigCompiler::write($metaFile, $out);
        return $out;
    }


    public function generateTargetNameFromAssets(array $assets)
    {
        $names = array();
        foreach($assets as $a) {
            $names[] = $a->name;
        }
        sort($names);
        $key = join('-',$names);

        if ( strlen($key) < 64 ) {
            return 'autogenerated-' . $key;
        }
        // we don't need so much accuracy here, 
        // simply use crc32 is faster than md5
        return 'autogenerated-' . crc32($key);
    }


    /**
     * Prepare directory for compiled assets.
     */
    public function prepareCompiledDir()
    {
        $compiledDir = $this->config->getCompiledDir();

        if (! file_exists($compiledDir)) {
            mkdir($compiledDir,$this->defaultCompiledDirMod, true);
        }

        if (!is_dir($compiledDir)) {
            throw new RuntimeException("The $compiledDir is not a directory.");
        }

        if (!is_writable($compiledDir)) {
            if ($this->chmodCompiledDir) {
                chmod($compiledDir,$this->defaultCompiledDirMod);
            } else {
                throw new UnwritableFileException("The $compiledDir is not writable for asset compilation.");
            }
        }

    }

    /**
     * Squash asset contents,
     *
     * pipe file contents through filters, compressors ...
     *
     * @param  AssetKit\Asset $asset
     * @return array [ css: string, js: string ]
     */
    public function squash(Asset $asset)
    {
        $out = array(
            'js' => '',
            'css' => '',
            'mtime' => 0,
        );
        $collections = $asset->getCollections();
        $assetBaseUrl = $this->urlBuilder->buildBaseUrl($asset);
        foreach( $collections as $collection ) {
            // skip unknown collection type
            if ( ! $collection->isScript && ! $collection->isStylesheet )
                continue;

            if ( $lastm = $collection->getLastModifiedTime() ) {
                if ( $lastm > $out['mtime'] ) {
                    $out['mtime'] = $lastm;
                }
            }

            // If we are in development mode, we don't need to compress them all,
            // we just filter them
            if ( $this->enableCompressor ) 
            {
                // Run user-defined filters, user-defined filters can override 
                // default filters.
                // NOTE: users must define css_import filter for production mode.
                if ( $collection->getFilters() ) {
                    $this->runUserDefinedFilters($collection);
                }
                // for stylesheets, before compress it, we should import the css contents
                elseif ( $collection->isStylesheet && $collection->filetype === Collection::FileTypeCss ) {
                    // css import filter implies css rewrite
                    $import = new CssImportFilter($this->config, $assetBaseUrl);
                    $import->filter( $collection );
                } else {
                    $this->runDefaultFilters($asset, $collection);
                }
                $this->runCollectionCompressors($collection);
            }
            else {
                if ( $collection->getFilters() ) {
                    $this->runUserDefinedFilters($collection);
                } else {
                    $this->runDefaultFilters($asset, $collection);
                }
            }

            // concat js and css
            if ( $collection->isScript ) {
                $out['js'] .=  $collection->getContent() . ";\n";
            } elseif ( $collection->isStylesheet ) {
                $out['css'] .= $collection->getContent() . "\n";
            }
        }
        return $out;
    }

    public function setDefaultJsCompressor($compressorId, $compressor = NULL) {
        $this->defaultJsCompressor = $compressorId;
        if ($compressor) {
            $this->registerCompressor($compressorId, $compressor);
        }
    }

    public function setDefaultCssCompressor($compressorId, $compressor = NULL) {
        $this->defaultCssCompressor = $compressorId;
        if ($compressor) {
            $this->registerCompressor($compressorId, $compressor);
        }
    }

    public function runDefaultCompressors(Collection $collection)
    {
        if ( $this->defaultJsCompressor 
            && ($collection->isScript) ) 
        {
            if ( $com = $this->getCompressor($this->defaultJsCompressor) ) {
                $com->compress($collection);
            }
        } elseif ( $collection->isStylesheet && $this->defaultCssCompressor ) {
            if ( $com = $this->getCompressor($this->defaultCssCompressor) ) {
                $com->compress($collection);
            }
        }
    }

    /**
     * Run compressors at the end
     *
     */
    public function runCollectionCompressors(Collection $collection)
    {
        // if custom compresor is not define, use default compressors
        if ( empty($collection->compressors) ) {
            $this->runDefaultCompressors($collection);
        } else {
            if ( $collection->hasCompressor('no') ) {
                return;
            }
            foreach( $collection->compressors as $n ) {
                $compressor = $this->getCompressor( $n );
                $compressor->compress($collection);
            }
        }
    }

}




<?php
namespace AssetKit;
use AssetKit\Asset;
use ZipArchive;
use Exception;

class ResourceUpdater
{
    public function __construct()
    {
        // check zip extension and ZipArchive class (which might be pure php version)
        if( ! extension_loaded('zip') && ! class_exists('ZipArchive') ) {
            throw new Exception('zip extension or ZipArchive class is required.');
        }
    }

    public function update(Asset $asset, $update = false)
    {
        if( ! isset($asset->stash['resource']) ) {
            return false;
        }

        // if we have the source files , we 
        // should skip initializing resource from remotes.
        if( ! $update && $asset->hasSourceFiles() ) {
            return;
        }

        $resDir = null;
        $r = $asset->stash['resource'];
        if( isset($r['url']) ) {
            $url = $r['url'];

            $info = parse_url($url);
            $path = $info['path'];
            $filename = basename($info['path']);
            $targetFile = $asset->sourceDir . DIRECTORY_SEPARATOR . $filename;

            echo "Downloading file...\n";
            $cmd = "curl -# --location " . escapeshellarg($url) . " > " . escapeshellarg($targetFile);
            system($cmd);

            echo "Stored at $targetFile\n";

            if( isset($r['zip']) ) {
                $zip = new ZipArchive;
                if( $zip->open( $targetFile ) === TRUE ) {
                    echo "Extracting to {$asset->sourceDir}\n";
                    $zip->extractTo( $asset->sourceDir );
                    $zip->close();
                    $resDir = $asset->sourceDir;
                    unlink( $targetFile );
                }
                else {
                    throw new Exception('Zip fail');
                }
            }
        }
        elseif( isset($r['github']) ) 
        {

            // read-only
            $url = 'git://github.com/' . $r['github'] . '.git';
            $resDir = $asset->sourceDir . DIRECTORY_SEPARATOR . basename($url,'.git');
            if( file_exists($resDir) && $update ) {
                $dir = getcwd();
                chdir($resDir);
                system("git remote update --prune");
                $current = system('git rev-parse --abbrev-ref HEAD');
                system("git pull --quiet origin $current");
                chdir($dir);
            } else {
                system("git clone --quiet $url $resDir");
            }

        }
        elseif( isset($r['git']) ) 
        {
            $url = $r['git'];
            $resDir = $asset->sourceDir . DIRECTORY_SEPARATOR . basename($url,'.git');
            if( file_exists($resDir) && $update ) {
                $dir = getcwd();
                chdir($resDir);
                system("git remote update --prune");
                system("git pull --quiet origin HEAD");
                chdir($dir);
            } else {
                system("git clone --quiet $url $resDir");
            }
        }
        elseif( isset($r['svn']) ) 
        {
            $url = $r['svn'];
            $resDir = $asset->sourceDir . DIRECTORY_SEPARATOR . basename($url);
            if( file_exists($resDir) && $update ) {
                $dir = getcwd();
                chdir($resDir);
                system("svn update");
                chdir($dir);
            } else {
                system("svn checkout $url $resDir");
            }
        }
        elseif( isset($r['hg']) ) {
            $url = $r['hg'];
            $resDir = $asset->sourceDir . DIRECTORY_SEPARATOR . basename($url);
            if( file_exists($resDir) && $update ) {
                $dir = getcwd();
                chdir($resDir);
                system("hg pull -u");
                chdir($dir);
            } else {
                system("hg clone $url $resDir");
            }
        }

        // run commands for resources to initialize
        if( isset($r['commands']) ) {
            $cwd = getcwd();
            chdir( $resDir );
            foreach( $r['commands'] as $command ) {
                system($command);
            }
            chdir($cwd);
        }

    }


}



<?php
namespace AssetKit;

class Target
{
    public $id;

    public function __construct($id) {
        $this->id = $id;
    }

    public function getMetaFilename() {
        return $this->id . '.meta.php';
    }
}



<?php
namespace AssetKit;
use PHPUnit\Framework\TestCase;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;

abstract class TestCase extends \PHPUnit\Framework\TestCase
{

    public $config;

    public $configFile;

    public $loader;

    public function getConfigFile()
    {
        if ($this->configFile) {
            return $this->configFile;
        }
        return $this->configFile = $this->createConfigFilename();
    }

    public function createConfigFilename()
    {
        $filename = str_replace('\\', '_', get_class($this)) . '_' . md5(microtime());
        return "tests/$filename.yml";
    }

    public function getConfig()
    {
        if ($this->config) {
            return $this->config;
        }

        $configFile = $this->getConfigFile();
        $this->config = new \AssetKit\AssetConfig($configFile);
        $this->config->setBaseDir("tests/public");
        $this->config->setBaseUrl("/assets");
        $this->config->setNamespace("assetkit-testing");
        $this->config->setCacheDir("cache");
        $this->config->addAssetDirectory("tests/assets");
        $this->config->setRoot(getcwd());
        return $this->config;
    }

    public function getLoader()
    {
        if ($this->loader)
            return $this->loader;
        return $this->loader =  new \AssetKit\AssetLoader($this->getConfig());
    }

    public function getCompiler()
    {
        $config = $this->getConfig();
        $loader = $this->getLoader();
        return AssetCompilerFactory::create($config, $loader);
    }


    public function getInstaller()
    {
        static $installer;
        if($installer)
            return $installer;
        $installer = new \AssetKit\Installer($this->getConfig());
        $installer->enableLog = false;
        return $installer;
    }

    public function installAssets($assets)
    {
        $assets = (array) $assets;
        $installer = $this->getInstaller();
        foreach($assets as $asset) {
            $installer->install($asset);
        }
    }


    public function uninstallAssets($assets)
    {
        $assets = (array) $assets;
        $installer = $this->getInstaller();
        foreach($assets as $asset) {
            $installer->uninstall($asset);
        }
    }


    public function getLinkInstaller()
    {
        $installer = new \AssetKit\LinkInstaller;
        $installer->enableLog = false;
        return $installer;
    }

    public function setUp()
    {
        if (extension_loaded('apc') ) {
            apc_clear_cache();
        }
        $config = $this->getConfig();

        // Clean up compiled directory
        $dir = $config->getCompiledDir();
        if (is_dir($dir)) {
            $files = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($dir, RecursiveDirectoryIterator::SKIP_DOTS),
                RecursiveIteratorIterator::CHILD_FIRST
            );
            foreach ($files as $fileinfo) {
                $action = ($fileinfo->isDir() ? 'rmdir' : 'unlink');
                $action($fileinfo->getRealPath());
            }
            rmdir($dir);
        }
    }


    public function tearDown()
    {
        $configFile = $this->getConfigFile();
        if (file_exists($configFile)) {
            // fwrite(STDERR,"Cleaning up config file $configFile...\n");
            unlink($configFile);
        }
        if (extension_loaded('apc') ) {
            apc_clear_cache();
        }
    }

}

<?php
namespace AssetKit;
use Exception;

class Utils
{

    static function findbin($bin)
    {
        $path = getenv('PATH') . ':/usr/local/bin:/opt/local/bin:/usr/bin';
        $paths = explode(':',$path);
        foreach( $paths as $path ) {
            if ( file_exists($path . DIRECTORY_SEPARATOR . $bin ) ) {
                return $path . DIRECTORY_SEPARATOR . $bin;
            }
        }
        return false;
    }

    static function write_file($path,$content, $message = 'Write failed' ) {
        if( false === file_put_contents( $path , $content) ) {
            throw new Exception( $message . ' Path: ' . $path );
        }
    }

}



Õ<Şbd!ŞÇÜà‚gêAÅ%}   GBMB